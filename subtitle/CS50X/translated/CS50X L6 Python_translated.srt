1
00:00:00,000 --> 00:00:02,988
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,320 --> 00:01:02,670
DAVID MALAN: All right.
大卫·马兰：好的。

3
00:01:02,670 --> 00:01:06,240
This is CS50, and this is finally week 6.
这是 CS50，终于到了第 6 周。

4
00:01:06,240 --> 00:01:08,460
And this is that week we promised, wherein we finally
而这正是我们承诺的那一周，我们将最终

5
00:01:08,460 --> 00:01:13,705
transition from C, this lower-level older language via which we explored
从 C 语言过渡，这种低级、古老的语言，我们通过它来探索

6
00:01:13,705 --> 00:01:16,080
memory and how really computers work underneath the hood,
内存以及计算机在底层是如何工作的，

7
00:01:16,080 --> 00:01:19,590
to what's now called Python, which is a more modern, higher-level language,
到如今被称为 Python 的语言，它是一种更现代、更高级的语言，

8
00:01:19,590 --> 00:01:22,632
whereby we're still going to be able to solve the same types of problems.
我们将仍然能够解决相同类型的问题。

9
00:01:22,632 --> 00:01:25,560
But it's going to suddenly start to get much, much easier because what
但是它会突然变得容易得多，因为 Python

10
00:01:25,560 --> 00:01:29,190
Python offers, as do higher-level languages more generally,
提供的，正如更高级的语言所提供的一样，

11
00:01:29,190 --> 00:01:31,680
are what we might describe as abstractions
就是我们可能描述的抽象

12
00:01:31,680 --> 00:01:35,850
over the very low-level ideas that you've been implementing in sections
在你们一直在各个部分中实现的非常低级的概念之上

13
00:01:35,850 --> 00:01:37,780
and problem sets and so much more.
以及习题集等等。

14
00:01:37,780 --> 00:01:39,838
But recall from week 0, where we began.
但是回忆一下第 0 周，我们开始的地方。

15
00:01:39,838 --> 00:01:42,630
This was our simplest of programs that just printed "hello, world."
这是我们最简单的程序，它只打印了“hello, world”。

16
00:01:42,630 --> 00:01:44,820
Things escalated quickly thereafter in week 1,
随后，在第 1 周，事情迅速升级，

17
00:01:44,820 --> 00:01:46,860
where, suddenly, we had all of this new syntax.
突然间，我们有了所有这些新的语法。

18
00:01:46,860 --> 00:01:50,790
But the idea was still the same of just printing out "hello, world."
但想法仍然是一样的，就是打印出“hello, world”。

19
00:01:50,790 --> 00:01:53,670
Well, as of today, a lot of that distraction,
嗯，从今天开始，很多这种干扰，

20
00:01:53,670 --> 00:01:56,490
a lot of the visual distraction, goes away entirely
很多视觉上的干扰，完全消失了

21
00:01:56,490 --> 00:02:02,410
such that what used to be this in C will now be quite simply this in Python.
这样，在 C 语言中曾经是这样的，现在在 Python 中就变成了这样。

22
00:02:02,410 --> 00:02:04,480
And that's a bit of a head fake in that we're
这有点像是障眼法，因为我们

23
00:02:04,480 --> 00:02:06,850
going to see some other fancier features of Python.
将会看到 Python 语言中的一些更花哨的功能。

24
00:02:06,850 --> 00:02:09,910
But you'll find that Python's popularity in large part
但你会发现，Python 的流行程度在很大程度上

25
00:02:09,910 --> 00:02:13,300
derives from just how relatively readable it is
源于它相对容易读懂

26
00:02:13,300 --> 00:02:16,750
and also, as we'll ultimately see, just how exciting
以及，正如我们最终将会看到的那样，它有多么令人兴奋

27
00:02:16,750 --> 00:02:19,930
and filled the ecosystem among Python programmers.
并且在 Python 程序员之间充满活力。

28
00:02:19,930 --> 00:02:22,068
That is to say there's a lot more libraries.
也就是说，有更多的库。

29
00:02:22,068 --> 00:02:24,610
There's a lot more problems that people have solved in Python
人们用 Python 解决了很多问题

30
00:02:24,610 --> 00:02:26,980
that you can now incorporate into your own programs
你现在可以将它们整合到你的程序中

31
00:02:26,980 --> 00:02:30,640
in order to stand on their shoulders and get real work done faster.
以便站在他们的肩膀上，更快地完成实际工作。

32
00:02:30,640 --> 00:02:33,430
But recall, though, from C that we had a few steps via which
但请记住，在 C 语言中，我们有几个步骤可以

33
00:02:33,430 --> 00:02:35,360
to actually compile that kind of code.
真正地编译这种代码。

34
00:02:35,360 --> 00:02:38,470
So we got into the habit of make to make our program called hello.
因此我们养成了使用 make 来创建名为 hello 的程序的习惯。

35
00:02:38,470 --> 00:02:41,560
And then we've been in the habit of running it with ./hello,
然后我们习惯了用 ./hello 来运行它，

36
00:02:41,560 --> 00:02:45,070
the effect of which, of course, is to feed all of the zeros and ones that
这样做的效果是，当然，将组成 hello 程序的所有 0 和 1 传递到计算机的内存中，进而

37
00:02:45,070 --> 00:02:48,610
compose the hello program into the computer's memory and, in turn,
进入 CPU。

38
00:02:48,610 --> 00:02:49,510
the CPU.
CPU。

39
00:02:49,510 --> 00:02:52,270
We revealed that what make is really doing
我们发现 make 实际上是在做

40
00:02:52,270 --> 00:02:56,410
is something a little more specific, namely running clang, the C language
一些更具体的事情，即运行 clang，C 语言

41
00:02:56,410 --> 00:03:00,610
compiler specifically, with some automatic command line arguments so as
编译器，使用一些自动的命令行参数，以便

42
00:03:00,610 --> 00:03:04,250
to output the name that you want, link in the library that you want,
输出你想要的名字，链接你想要链接的库，

43
00:03:04,250 --> 00:03:05,030
and so forth.
等等。

44
00:03:05,030 --> 00:03:08,590
But with Python, wonderfully, we're going to get rid of those steps,
但用 Python，美妙的是，我们将摆脱这些步骤，

45
00:03:08,590 --> 00:03:11,650
too, and quite simply run it as follows.
同样，只需按如下方式运行它。

46
00:03:11,650 --> 00:03:15,100
Henceforth, our programs will no longer be in files ending in .c,
从现在开始，我们的程序将不再是扩展名为 .c 的文件，

47
00:03:15,100 --> 00:03:16,090
suffice it to say.
就足以说明问题了。

48
00:03:16,090 --> 00:03:18,970
Our files starting today are going to start ending with .py,
从今天开始，我们的文件将会以“.py”结尾，

49
00:03:18,970 --> 00:03:22,280
which is an indication to the computer-- macOS, Windows,
这会向计算机——macOS、Windows，

50
00:03:22,280 --> 00:03:25,450
or Linux or anything else-- that this is a Python program.
或者Linux，或者其他任何操作系统——表明这是一个Python程序。

51
00:03:25,450 --> 00:03:30,310
But unlike C, wherein we've been in the habit of compiling our code
但与C语言不同的是，我们一直习惯于编译我们的代码，

52
00:03:30,310 --> 00:03:33,580
and running it, compiling our code and running it, any time you make
然后运行它，编译代码并运行它，每次你做出

53
00:03:33,580 --> 00:03:37,590
a change, with Python, those two steps get reduced into one, such
更改时，使用Python，这两个步骤会合并成一个，这样

54
00:03:37,590 --> 00:03:40,090
that any time you make a change and want to rerun your code,
只要你做出更改并想要重新运行你的代码，

55
00:03:40,090 --> 00:03:42,310
you don't explicitly compile it anymore.
你就不用再显式地编译它了。

56
00:03:42,310 --> 00:03:46,930
You instead just run a program called python, similar in spirit to clang.
相反，你只需运行一个叫做“python”的程序，它在精神上与clang类似。

57
00:03:46,930 --> 00:03:49,780
But whereas clang is a compiler, python will
但clang是一个编译器，而python会

58
00:03:49,780 --> 00:03:53,050
see as not only the name of the language, but the name of a program.
被视为不仅是语言的名字，也是程序的名字。

59
00:03:53,050 --> 00:03:56,110
And the type of that program is that of interpreter.
这种程序的类型是解释器。

60
00:03:56,110 --> 00:03:59,710
An interpreter is a program that reads your code top to bottom, left to right,
解释器是一个程序，它从上到下、从左到右读取你的代码，

61
00:03:59,710 --> 00:04:04,300
and really does what it says without having this intermediate step of first
并且真正地执行它所说的内容，而不需要像编译器那样首先经历一个中间步骤，

62
00:04:04,300 --> 00:04:06,860
having to compile it in zeros and ones.
将代码编译成0和1。

63
00:04:06,860 --> 00:04:08,570
So with that said, let me do this.
所以，让我做这件事吧。

64
00:04:08,570 --> 00:04:10,690
Let me flip over here to VS Code.
让我切换到VS Code这边。

65
00:04:10,690 --> 00:04:13,600
And within VS Code, let me write my first Python program.
在VS Code中，让我写第一个Python程序。

66
00:04:13,600 --> 00:04:17,200
And as always, I can create a new file with the code command within VS Code.
和以往一样，我可以在VS Code中使用“code”命令创建一个新文件。

67
00:04:17,200 --> 00:04:20,500
I'm going to create this file called hello.py, for instance.
例如，我将创建一个名为“hello.py”的文件。

68
00:04:20,500 --> 00:04:25,345
And quite, quite simply, I'm going to go ahead and simply do print("Hello,
非常简单，我将直接执行print("Hello,

69
00:04:25,345 --> 00:04:27,560
world").
world").

70
00:04:27,560 --> 00:04:30,430
And if I go down to my terminal window, instead of compiling this,
如果我切换到终端窗口，我不会编译这个程序，

71
00:04:30,430 --> 00:04:34,600
I'm instead going to interpret this program by running python, space,
而是通过运行python、空格，来解释这个程序，

72
00:04:34,600 --> 00:04:37,600
and the name of the file I want Python to interpret, hitting Enter.
然后输入要解释的文件名，最后按下回车键。

73
00:04:37,600 --> 00:04:38,650
And voila.
瞧！

74
00:04:38,650 --> 00:04:40,970
Now you see "hello, world."
现在你看到了“hello, world”。

75
00:04:40,970 --> 00:04:43,300
But let me go ahead and compare this at left.
但是，让我将它与左侧的代码进行比较。

76
00:04:43,300 --> 00:04:47,740
Let me also go ahead and bring back briefly a file called hello.c.
让我再将一个名为“hello.c”的文件调回来。

77
00:04:47,740 --> 00:04:51,250
And I'm going to do this as we did in the very first day of C,
我要像在C语言的第一天那样做，

78
00:04:51,250 --> 00:04:53,740
where I included standard io.h.
我包含了“stdio.h”。

79
00:04:53,740 --> 00:04:55,540
I did int main(void).
我写了“int main(void)”。

80
00:04:55,540 --> 00:04:59,770
I did inside of there printf(), quote unquote, "hello, world," backslash n,
我在里面写了“printf()”，引号、“hello, world”，反斜杠“n”，

81
00:04:59,770 --> 00:05:01,508
close quote, semicolon.
关闭引号，分号。

82
00:05:01,508 --> 00:05:02,800
And let me go ahead in VS Code.
然后让我在VS Code中继续。

83
00:05:02,800 --> 00:05:05,390
And if you drag your file over to the right or the left,
如果你将文件拖到右侧或左侧，

84
00:05:05,390 --> 00:05:08,072
you can actually split-screen things if of help.
你可以实际使用分屏功能，如果这有帮助的话。

85
00:05:08,072 --> 00:05:10,780
And what I've done here is-- and let me hide my terminal window--
我在这里做的是——让我隐藏一下终端窗口——

86
00:05:10,780 --> 00:05:12,940
I've now compared these two files left and right.
我现在比较了这两个文件，一个在左侧，一个在右侧。

87
00:05:12,940 --> 00:05:15,280
So here's hello.c from, say, week 1.
所以，这是来自第一周的“hello.c”。

88
00:05:15,280 --> 00:05:18,100
Here's hello.py from week 6 now.
现在，这是来自第六周的“hello.py”。

89
00:05:18,100 --> 00:05:20,680
And the obvious-- the differences are perhaps obvious.
显而易见——差异可能是显而易见的。

90
00:05:20,680 --> 00:05:23,890
But there's still some-- there's a subtlety, at least one subtlety.
但仍然存在一些——至少存在一个微妙之处。

91
00:05:23,890 --> 00:05:26,530
Beyond getting rid of lots of syntax, what
除了摆脱了许多语法之外，我

92
00:05:26,530 --> 00:05:29,020
did I apparently omit from my Python version,
在Python版本中明显遗漏了什么，

93
00:05:29,020 --> 00:05:32,680
even though it didn't appear to behave in any buggy way?
即使它似乎没有出现任何错误？

94
00:05:32,680 --> 00:05:34,180
Yeah?
是啊？

95
00:05:34,180 --> 00:05:35,380
Sorry?
抱歉？

96
00:05:35,380 --> 00:05:36,180
Say one more time?
再说一遍？

97
00:05:36,180 --> 00:05:36,620
AUDIENCE: The library.
观众：库。

98
00:05:36,620 --> 00:05:37,700
DAVID MALAN: The library.
戴维·马兰：库。

99
00:05:37,700 --> 00:05:41,570
So I didn't have to include any kind of library like the standard I/O library.
所以，我不用包含任何像标准 I/O 库这样的库。

100
00:05:41,570 --> 00:05:44,123
print(), apparently, in Python, just works.
显然，在 Python 中，print() 可以直接使用。

101
00:05:44,123 --> 00:05:45,290
AUDIENCE: main() [INAUDIBLE]
观众：main() [听不清]

102
00:05:45,290 --> 00:05:47,790
DAVID MALAN: So I don't need to use main() anymore.
戴维·马兰：所以我不用再使用 main() 了。

103
00:05:47,790 --> 00:05:51,350
So this main() function, to be clear, was required in C because that's what
为了说清楚，这个 main() 函数在 C 中是必需的，因为这就是

104
00:05:51,350 --> 00:05:54,050
told the compiler what the main part of your program is.
告诉编译器你程序的主要部分是什么。

105
00:05:54,050 --> 00:05:56,060
And you can't just start writing code otherwise.
否则你就不能直接开始写代码。

106
00:05:56,060 --> 00:05:56,935
What else do you see?
你还有什么发现？

107
00:05:56,935 --> 00:05:57,893
AUDIENCE: No semicolon.
观众：没有分号。

108
00:05:57,893 --> 00:06:00,560
DAVID MALAN: So there's no more semicolon, wonderfully enough,
戴维·马兰：所以，没有分号了，真是太好了，

109
00:06:00,560 --> 00:06:03,090
at the end of this line, even though there was here.
这行的末尾没有分号，即使这里有。

110
00:06:03,090 --> 00:06:05,090
And things are getting a little more subtle now.
事情现在变得越来越微妙了。

111
00:06:05,090 --> 00:06:06,300
What else?
还有呢？

112
00:06:06,300 --> 00:06:07,460
So the new line.
还有新行。

113
00:06:07,460 --> 00:06:10,520
So recall that in printf(), if you wanted to move the cursor to the next
请记住，在 printf() 中，如果你想将光标移到下一行

114
00:06:10,520 --> 00:06:13,470
line when you're done printing, you had to do it yourself.
你必须自己动手。

115
00:06:13,470 --> 00:06:15,500
So it seems as though Python--
所以，似乎 Python--

116
00:06:15,500 --> 00:06:17,810
because when I interpreted this program a moment ago,
因为我刚才解释这个程序的时候，

117
00:06:17,810 --> 00:06:21,150
the cursor did move to the next line on its own.
光标自动移到了下一行。

118
00:06:21,150 --> 00:06:23,340
They sort of reversed the default behavior.
他们有点颠倒了默认行为。

119
00:06:23,340 --> 00:06:25,680
So those are just some of the salient differences here.
所以，这些只是这里的一些主要区别。

120
00:06:25,680 --> 00:06:29,540
One, you don't have to explicitly include standard library, so to speak,
第一，你不用显式地包含标准库，可以说，

121
00:06:29,540 --> 00:06:33,728
like standard I/O. You don't need to define a main() function anymore.
像标准 I/O。你不用再定义 main() 函数了。

122
00:06:33,728 --> 00:06:35,270
You can just start writing your code.
你可以直接开始写代码。

123
00:06:35,270 --> 00:06:37,790
You don't need these parentheses, these curly braces.
你不需要这些圆括号、这些花括号。

124
00:06:37,790 --> 00:06:40,280
printf() is now called print(), it would seem.
printf() 现在似乎被称为 print()。

125
00:06:40,280 --> 00:06:43,100
And you don't need the backslash n.
而且你不需要反斜杠 n。

126
00:06:43,100 --> 00:06:46,250
Now, there is one thing that's also a little looser,
现在，还有一件事也比较宽松，

127
00:06:46,250 --> 00:06:47,700
even though I didn't do it here.
虽然我在这里没有做。

128
00:06:47,700 --> 00:06:51,710
Even though in C, it was required to use double quotes any times you--
即使在 C 中，每次你使用--

129
00:06:51,710 --> 00:06:56,240
any time you want to use a string, a.k.a., char*, in Python,
无论何时你想在 Python 中使用字符串，也就是 char*，

130
00:06:56,240 --> 00:07:00,210
as with a lot of languages nowadays, you can actually get away with just using
就像现在很多语言一样，你可以实际上使用

131
00:07:00,210 --> 00:07:03,780
single quotes so long as you are consistent.
单引号，只要你保持一致。

132
00:07:03,780 --> 00:07:05,730
Generally speaking, some people like this
一般来说，有些人喜欢这样

133
00:07:05,730 --> 00:07:07,650
because you don't have to hold Shift, and therefore, you just
因为你不用按住 Shift，因此，你只需要

134
00:07:07,650 --> 00:07:08,970
hit one key instead of two.
按一个键而不是两个键。

135
00:07:08,970 --> 00:07:11,290
So there's an argument in terms of efficiency.
所以，在效率方面存在争议。

136
00:07:11,290 --> 00:07:14,220
However, if you want to use an apostrophe in your string,
但是，如果你想在你的字符串中使用撇号，

137
00:07:14,220 --> 00:07:15,580
then you have to escape it.
那么你必须转义它。

138
00:07:15,580 --> 00:07:19,020
And so in general, stylistically, I'll use double quotes in this way.
所以，一般来说，从风格上来说，我会这样使用双引号。

139
00:07:19,020 --> 00:07:21,570
But things are getting a little looser now with Python,
但 Python 现在变得越来越宽松了，

140
00:07:21,570 --> 00:07:24,390
whereby that's not actually a requirement.
这实际上不是一项要求。

141
00:07:24,390 --> 00:07:27,240
But what's especially exciting with Python,
但 Python 特别令人兴奋的地方是，

142
00:07:27,240 --> 00:07:30,960
and, really, a lot of higher-level languages, is just how much real work
而且，实际上，很多高级语言，就是你能完成多少实际工作

143
00:07:30,960 --> 00:07:32,642
you can get done relatively quickly.
能够在相对较短的时间内完成。

144
00:07:32,642 --> 00:07:34,350
So you've just spent quite a bit of time,
所以你刚刚花了不少时间，

145
00:07:34,350 --> 00:07:37,050
daresay, implementing your spell checker and implementing
可以说，实现了你的拼写检查器，并实现了

146
00:07:37,050 --> 00:07:39,360
your own dictionary of sorts.
你自己的字典。

147
00:07:39,360 --> 00:07:42,420
Well, let me propose that maybe we should have asked you
好吧，我想建议，也许我们应该让你

148
00:07:42,420 --> 00:07:45,513
to do that in Python instead of C. Why?
用 Python 而不是 C 来做。为什么呢？

149
00:07:45,513 --> 00:07:46,930
Well, let me go ahead and do this.
好吧，让我来做这件事。

150
00:07:46,930 --> 00:07:50,170
Let me close these two tabs and reopen my terminal window.
让我关闭这两个标签，重新打开我的终端窗口。

151
00:07:50,170 --> 00:07:52,440
Let me go into a directory called speller
让我进入一个名为 speller 的目录

152
00:07:52,440 --> 00:07:55,020
that I downloaded in advance for class.
我之前为课程下载的。

153
00:07:55,020 --> 00:07:57,150
And if I type ls in here, you'll notice that it's
如果我在里面输入 ls，你会注意到它

154
00:07:57,150 --> 00:08:00,660
very similar to what you spent time on with problem set 5.
与你在问题集 5 中花费时间的内容非常相似。

155
00:08:00,660 --> 00:08:02,670
But the file extensions are different.
但是文件扩展名不同。

156
00:08:02,670 --> 00:08:05,040
There's a dictionary.py instead of dictionary.c.
有一个 dictionary.py 而不是 dictionary.c。

157
00:08:05,040 --> 00:08:07,620
There's a speller.py instead of a speller.c.
有一个 speller.py 而不是 speller.c。

158
00:08:07,620 --> 00:08:10,980
And there's the exact same directories, dictionaries, and texts
而且有完全相同的目录、字典和文本

159
00:08:10,980 --> 00:08:13,110
that we gave you for problem set 5.
我们给你的问题集 5。

160
00:08:13,110 --> 00:08:18,660
So let me just stipulate that I spent time implementing speller.c in Python.
所以，我想说，我花时间用 Python 实现 speller.c。

161
00:08:18,660 --> 00:08:20,580
And so I gave it a name of speller.py.
因此我把它命名为 speller.py。

162
00:08:20,580 --> 00:08:25,090
But I didn't go about really implementing dictionary.py yet.
但我还没有真正实现 dictionary.py。

163
00:08:25,090 --> 00:08:29,250
And so why don't we go ahead and actually implement dictionary.py
所以，为什么我们不继续实现 dictionary.py 呢？

164
00:08:29,250 --> 00:08:30,900
together by doing this?
一起做这件事？

165
00:08:30,900 --> 00:08:34,530
Let me clear my terminal, do code dictionary.py.
让我清除终端，执行代码 dictionary.py。

166
00:08:34,530 --> 00:08:38,309
And let me propose that we implement, ultimately, four functions.
我想建议，我们最终实现四个函数。

167
00:08:38,309 --> 00:08:40,120
And what are those functions going to be?
这些函数将是什么？

168
00:08:40,120 --> 00:08:42,960
Well, they're going to be the check() function, the load() function,
它们将是 check() 函数、load() 函数，

169
00:08:42,960 --> 00:08:45,420
the size() function, and the unload() function.
size() 函数和 unload() 函数。

170
00:08:45,420 --> 00:08:50,140
But recall that in problem set 5, you implemented your own hash table.
但请记住，在问题集 5 中，你实现了你自己的哈希表。

171
00:08:50,140 --> 00:08:54,333
And so while there isn't a hash table data type in Python,
所以，虽然 Python 中没有哈希表数据类型，

172
00:08:54,333 --> 00:08:55,750
I'm going to go ahead and do this.
我将继续这样做。

173
00:08:55,750 --> 00:08:58,860
I'm going to create a variable, a global variable in dictionary.py,
我将在 dictionary.py 中创建一个变量，一个全局变量，

174
00:08:58,860 --> 00:09:01,620
called words, and I'm going to make it a set.
名为 words，我将把它设为一个集合。

175
00:09:01,620 --> 00:09:03,960
In the mathematical sense, a set is a collection
从数学意义上讲，集合是集合

176
00:09:03,960 --> 00:09:05,970
of things that won't contain duplicates.
不会包含重复项的事物。

177
00:09:05,970 --> 00:09:07,588
Any duplicates will be filtered out.
任何重复项都将被过滤掉。

178
00:09:07,588 --> 00:09:10,380
So I'm going to now, after that, creating that one global variable,
所以，现在，在那之后，创建那个全局变量，

179
00:09:10,380 --> 00:09:13,410
I'm going to create a function called check(), just as you did.
我将创建一个名为 check() 的函数，就像你之前做的那样。

180
00:09:13,410 --> 00:09:15,730
And check() takes as input a word.
而 check() 函数将一个单词作为输入。

181
00:09:15,730 --> 00:09:19,200
And if I want to check if a word is in that set of words,
如果我想检查一个单词是否在这个单词集合中，

182
00:09:19,200 --> 00:09:25,080
I can simply do word.lower in words.
我可以简单地用 words 中的 word.lower 来做。

183
00:09:25,080 --> 00:09:26,070
And that's it.
就是这样。

184
00:09:26,070 --> 00:09:28,740
Let me now define another function called load(), which, recall,
现在，让我定义另一个名为 load() 的函数，回想一下，

185
00:09:28,740 --> 00:09:32,310
took an argument, which was the name of the dictionary you want to load
它接受一个参数，即你想要加载的字典的名称

186
00:09:32,310 --> 00:09:33,060
into memory.
到内存中。

187
00:09:33,060 --> 00:09:35,352
Inside of my load() function, I'm now going to do this.
在我的 load() 函数内部，我将要这样做。

188
00:09:35,352 --> 00:09:39,525
I'm going to say with open(dictionary) as a variable called file.
我将使用 with open(dictionary) 作为名为 file 的变量。

189
00:09:39,525 --> 00:09:42,150
And in there, I'm going to go ahead and update the set of words
在那里，我将继续更新单词集

190
00:09:42,150 --> 00:09:47,670
to be the updated version of whatever's in this file as a result of reading
成为这个文件中读取结果的更新版本。

191
00:09:47,670 --> 00:09:50,580
it and then splitting its lines, whereby this file has
它然后将它的行分割，这样这个文件就有

192
00:09:50,580 --> 00:09:54,090
a big, long column of words, each of which is separated by a new line,
一大长列的单词，每个单词都用新行分隔，

193
00:09:54,090 --> 00:09:57,930
splitline is going to split all of those into one big collection.
splitline 将把所有这些分割成一个大的集合。

194
00:09:57,930 --> 00:10:00,270
And then I'm just going to go ahead and return True.
然后我将继续返回 True。

195
00:10:00,270 --> 00:10:03,643
I'm now going to go ahead and define a size function, just as you did.
我现在将继续定义一个大小函数，就像你做的那样。

196
00:10:03,643 --> 00:10:06,810
But in Python, I'm going to go ahead and just go ahead and return the length
但在 Python 中，我将继续返回长度

197
00:10:06,810 --> 00:10:12,120
of that set of words, where length, or len(), is a function itself in Python.
的那组单词，其中 length 或 len() 本身就是 Python 中的一个函数。

198
00:10:12,120 --> 00:10:14,170
And I'm going to do one last function.
我将做最后一个函数。

199
00:10:14,170 --> 00:10:17,560
It turns out that in Python, even though, for this program,
事实证明，在 Python 中，尽管对于这个程序，

200
00:10:17,560 --> 00:10:20,040
I'm going to go and implement a function called unload,
我将实现一个名为 unload 的函数，

201
00:10:20,040 --> 00:10:22,500
there's not actually anything to unload in Python,
实际上在 Python 中没有要卸载的东西，

202
00:10:22,500 --> 00:10:25,410
because Python will manage your memory for you.
因为 Python 会为你管理内存。

203
00:10:25,410 --> 00:10:27,750
malloc() is gone. free() is gone.
malloc() 不见了。free() 不见了。

204
00:10:27,750 --> 00:10:29,340
Pointers are gone.
指针不见了。

205
00:10:29,340 --> 00:10:33,280
It handles all of that, seemingly magically for now, for you.
它处理了所有这些，现在看起来像是魔法一样，为你。

206
00:10:33,280 --> 00:10:37,080
So here then is, I claim, what you could have done with problem set 5
所以，我认为，这是你用问题集 5 可以做的

207
00:10:37,080 --> 00:10:39,090
if implementing it in Python instead.
如果用 Python 实现。

208
00:10:39,090 --> 00:10:41,470
Let me go ahead and open my terminal window.
让我打开我的终端窗口。

209
00:10:41,470 --> 00:10:42,690
Let me increase its size.
让我增加它的尺寸。

210
00:10:42,690 --> 00:10:46,380
Let me run Python of speller.py, which is the name of the actual program, not
让我运行 speller.py 的 Python，这是实际程序的名称，而不是

211
00:10:46,380 --> 00:10:48,360
the dictionary per se that I implemented.
我实现的字典本身。

212
00:10:48,360 --> 00:10:51,300
Let's run it on a file called holmes.txt because that
让我们在一个名为 holmes.txt 的文件上运行它，因为

213
00:10:51,300 --> 00:10:53,140
was a particularly big file.
是一个特别大的文件。

214
00:10:53,140 --> 00:10:55,680
And if I hit Enter now, we'll see, hopefully,
如果我现在按下回车键，我们将会看到，希望是

215
00:10:55,680 --> 00:10:59,630
the same output that you saw in C flying across the screen.
你在 C 中看到的相同输出，在屏幕上飞过。

216
00:10:59,630 --> 00:11:02,870
And eventually, we should see that same summary at the bottom
最终，我们应该在底部看到相同的摘要

217
00:11:02,870 --> 00:11:04,820
as to how many words seem to be misspelled,
关于有多少个单词似乎拼错了，

218
00:11:04,820 --> 00:11:09,170
how many words were in the dictionary, and, ultimately, how
字典中有多少个单词，最终，以及整个过程是多么

219
00:11:09,170 --> 00:11:11,510
fast this whole process was.
快。

220
00:11:11,510 --> 00:11:15,500
Now, the total amount of time required was 1.93 seconds, which was actually
现在，总共花费的时间是 1.93 秒，实际上

221
00:11:15,500 --> 00:11:16,940
longer than it seemed to take.
比看起来的时间要长。

222
00:11:16,940 --> 00:11:18,590
That's because we're doing this in the cloud,
那是因为我们是在云端进行的，

223
00:11:18,590 --> 00:11:21,715
and it was taking some amount of time to send all of the text to my screen.
并且把所有文本发送到我的屏幕上花了些时间。

224
00:11:21,715 --> 00:11:26,120
But the code was only taking 1.93 seconds total on the actual server.
但代码在实际服务器上只花了 1.93 秒。

225
00:11:26,120 --> 00:11:29,300
And hopefully, these same kinds of numbers line up with your own,
希望这些数字与你自己的数字一致，

226
00:11:29,300 --> 00:11:33,500
the difference being what I did not have to implement for this spell checker is
不同之处在于，对于这个拼写检查器，我不必实现的是

227
00:11:33,500 --> 00:11:36,500
your own hash table, is your own dictionary, literally,
你自己的哈希表，是你自己的字典，字面意义上，

228
00:11:36,500 --> 00:11:41,780
beyond what I've done using Python here with some of these built-in features.
除了我在这里使用 Python 使用一些内置功能所做的之外。

229
00:11:41,780 --> 00:11:45,440
So why, you see, why not always use Python,
所以，你看，为什么不总是使用 Python，

230
00:11:45,440 --> 00:11:48,140
assuming that you prefer the idea of being
假设你更喜欢能够

231
00:11:48,140 --> 00:11:53,540
able to whip up within seconds the entirety of problem set 5?
在几秒钟内完成整个问题集 5？

232
00:11:53,540 --> 00:11:57,940
How might you choose now between languages?
你现在如何在两种语言之间选择？

233
00:11:57,940 --> 00:11:59,940
And I apologize if you're harboring resentment
我如果让你心存怨恨，我表示歉意

234
00:11:59,940 --> 00:12:02,790
that this wasn't a week earlier.
这没有早一个星期出现。

235
00:12:02,790 --> 00:12:05,850
Why Python or why C?
为什么是 Python 还是为什么是 C？

236
00:12:05,850 --> 00:12:08,790
Any instincts?
有任何直觉吗？

237
00:12:08,790 --> 00:12:09,615
Any thoughts?
有什么想法吗？

238
00:12:09,615 --> 00:12:11,190
There's hopefully a reason?
希望是有原因的？

239
00:12:11,190 --> 00:12:13,390
Yeah, over here?
对，这边？

240
00:12:13,390 --> 00:12:15,286
Yeah?
对？

241
00:12:15,286 --> 00:12:20,813
AUDIENCE: I always thought that Python was a little slower than C [INAUDIBLE]
观众：我一直认为 Python 比 C 慢一点 [听不清]

242
00:12:20,813 --> 00:12:22,480
DAVID MALAN: Ah, really good conjecture.
大卫·马兰：啊，非常好的猜想。

243
00:12:22,480 --> 00:12:24,730
So you always thought that Python was slower than C
所以你一直认为 Python 比 C 慢

244
00:12:24,730 --> 00:12:27,950
and takes up more space than C. Odds are that's, in fact, correct.
并且占用的空间比 C 大。很有可能，实际上是正确的。

245
00:12:27,950 --> 00:12:32,050
So even though, ultimately, this 1.93 seconds is still pretty darn fast,
所以即使最终，这 1.93 秒仍然非常快，

246
00:12:32,050 --> 00:12:35,230
odds are it's a little slower than the C version would have been.
但它可能比 C 版本要慢一些。

247
00:12:35,230 --> 00:12:38,110
It's possible, too, that my version in Python
我的 Python 版本也有可能

248
00:12:38,110 --> 00:12:41,050
actually does take up more RAM or memory underneath the hood.
实际上会占用更多 RAM 或内存。

249
00:12:41,050 --> 00:12:41,560
Why?
为什么？

250
00:12:41,560 --> 00:12:44,950
Well, because Python itself is managing memory for you.
因为 Python 本身正在为你管理内存。

251
00:12:44,950 --> 00:12:49,420
And it doesn't necessarily know a priori how much memory you're going to need.
而且它不一定事先知道你需要多少内存。

252
00:12:49,420 --> 00:12:52,840
You, the programmer might, and you, the programmer writing in C,
你，程序员可能知道，而你，用 C 语言编程的程序员，

253
00:12:52,840 --> 00:12:55,540
allocated presumably exactly as much memory
可能分配了正好和你上周在第 5 题中所需要的内存一样多。

254
00:12:55,540 --> 00:12:58,660
as you might have needed last week with problem set 5.
但是 Python 必须尽力为你做到最好

255
00:12:58,660 --> 00:13:01,630
But Python's got to maybe do its best effort for you
并尝试为你管理内存，这会产生一些开销。

256
00:13:01,630 --> 00:13:05,260
and try to manage memory for you, and there's going to be some overhead.
我的代码行数少得多，

257
00:13:05,260 --> 00:13:08,170
The fact that I have so many fewer lines of code,
这些代码行帮我解决了第 5 题，

258
00:13:08,170 --> 00:13:11,560
the fact that these lines of code solve problem set 5 for me,
意味着 Python 或发明 Python 的人写了一些代码

259
00:13:11,560 --> 00:13:17,050
means that Python, or whoever invented Python, they wrote lines of code
来给我提供这种功能。

260
00:13:17,050 --> 00:13:19,190
to of give me this functionality.
所以如果你把 Python 想象成一个中间人，

261
00:13:19,190 --> 00:13:21,440
And so if you think of Python as a middleman of sorts,
它正在为我做更多的事情。

262
00:13:21,440 --> 00:13:23,420
it's doing more work for me.
它正在做更多繁重的工作。

263
00:13:23,420 --> 00:13:24,960
It's doing more of the heavy lift.
所以它可能需要更长时间。

264
00:13:24,960 --> 00:13:26,540
So it might take me a bit more time.
但是，我的天哪，看看它在编写代码方面节省了多少时间。

265
00:13:26,540 --> 00:13:30,050
But, my gosh, look how much time it has saved in terms
而且可以说，这段代码更容易阅读，

266
00:13:30,050 --> 00:13:31,820
of writing this code more quickly.
或者至少在今天，第 6 周之后，当你对 Python 的语法有所了解后就会变得更容易阅读

267
00:13:31,820 --> 00:13:34,220
And arguably, this code is even more readable,
以及 Python 本身的特性。

268
00:13:34,220 --> 00:13:38,660
or at least will be after today, week 6, once you have an eye for the syntax
除此之外，你还可以非常轻松地做其他事情。

269
00:13:38,660 --> 00:13:41,430
and features of Python itself.
让我回到我的终端窗口。

270
00:13:41,430 --> 00:13:45,030
So beyond that, it turns out you can do other things pretty easily as well.
让我关闭这个 dictionary.py。

271
00:13:45,030 --> 00:13:47,490
Let me go back into my terminal window.
让我进入一个名为 filter 的文件夹，其中

272
00:13:47,490 --> 00:13:49,400
Let me close this dictionary.py.
我存放着我们之前见过的跨越河面的那座桥。

273
00:13:49,400 --> 00:13:52,220
Let me go into a folder called filter, in which
这是一座桥。

274
00:13:52,220 --> 00:13:56,520
I have this same bridge that we've seen in the past across the river there.
这是这张照片的原始版本。

275
00:13:56,520 --> 00:13:57,352
So here's a bridge.
假设我实际上想编写一个模糊它的程序。

276
00:13:57,352 --> 00:13:59,810
This is the original version of this particular photograph.
你可能还记得，在第 4 题中，你可以用 C 语言编写同样的代码

277
00:13:59,810 --> 00:14:02,640
Suppose I actually want to write a program that blurs this.
通过操作构成该文件的红色、绿色和蓝色像素。

278
00:14:02,640 --> 00:14:06,590
Well, you might recall from problem set 4 you could write that same code in C
但让我试着提出这个建议。

279
00:14:06,590 --> 00:14:10,760
by manipulating all of the red, the green, the blue pixels that
让我创建一个名为 blur.py 的文件。

280
00:14:10,760 --> 00:14:12,770
are ultimately composing that file.
在这个文件中，让我尝试导入一个库。

281
00:14:12,770 --> 00:14:14,940
But let me go ahead and propose this instead.
所以，从 Python 图像库 PIL 中，让我尝试

282
00:14:14,940 --> 00:14:17,540
Let me create a file called blur.py.
让我创建一个名为 blur.py 的文件。

283
00:14:17,540 --> 00:14:23,840
And in this file, let me go ahead and just go ahead and import a library.
在这个文件中，让我继续前进，并导入一个库。

284
00:14:23,840 --> 00:14:27,950
So from the Python image library, PIL, let me go ahead
所以从 Python 图像库 PIL 开始，让我继续

285
00:14:27,950 --> 00:14:31,790
and import something called Image, capital I, and Image Filter, capital
导入名为 Image 的内容，大写 I，以及 Image Filter，大写

286
00:14:31,790 --> 00:14:32,810
I, capital F.
我，大写的 F。

287
00:14:32,810 --> 00:14:35,570
So I'm going to do before = Image.open("bridge.bmp").
所以我要在之前做 = Image.open("bridge.bmp")。

288
00:14:38,480 --> 00:14:41,300
Then let me go ahead and create another variable called after
然后，我将创建一个名为“after”的变量

289
00:14:41,300 --> 00:14:46,220
and set that equal to before.filter, and then, in parentheses,
并将其设置为等于“before.filter”，然后，在括号内

290
00:14:46,220 --> 00:14:50,328
ImageFilter, spelled as before, dot BoxBlur,
是“ImageFilter”，拼写与之前相同，然后是“dot BoxBlur”

291
00:14:50,328 --> 00:14:51,870
and then we'll give it a value of 10.
然后我们会给它赋予 10 的值。

292
00:14:51,870 --> 00:14:53,900
How much do I want to blur it, for instance?
例如，我想把它模糊多少？

293
00:14:53,900 --> 00:14:57,710
After that, I'm going to literally call after.save, and let's
在那之后，我会直接调用 after.save，然后我们

294
00:14:57,710 --> 00:15:00,320
save it as a file called out.bmp.
把它保存为名为 out.bmp 的文件。

295
00:15:00,320 --> 00:15:01,520
And that's it.
就是这样。

296
00:15:01,520 --> 00:15:05,640
I propose that this is how you can now write code in Python to blur an image,
我认为这就是你现在可以用 Python 编写代码模糊图像的方式，

297
00:15:05,640 --> 00:15:07,640
much like you might have for problem set 4.
就像你可能在问题集 4 中做过的那样。

298
00:15:07,640 --> 00:15:12,200
Now let me go ahead in my terminal window and run python of blur.py.
现在让我在终端窗口中运行 blur.py 的 python 代码。

299
00:15:12,200 --> 00:15:14,403
When I hit Enter, those four lines of code will run.
当我按下回车键时，这四行代码就会运行。

300
00:15:14,403 --> 00:15:16,070
It seems to have happened quite quickly.
似乎很快完成了。

301
00:15:16,070 --> 00:15:19,460
Let me go ahead and open now out.bmp.
现在让我打开 out.bmp。

302
00:15:19,460 --> 00:15:24,020
And whereas the previous image looked like this a moment ago, let me go ahead
而之前那张图片看起来是这样的，让我继续

303
00:15:24,020 --> 00:15:26,030
and open out.bmp.
打开 out.bmp。

304
00:15:26,030 --> 00:15:28,430
And hopefully, you can indeed see that it blurred it
希望你能看到它确实模糊了

305
00:15:28,430 --> 00:15:30,597
for me using that same code.
用同样的代码为我。

306
00:15:30,597 --> 00:15:32,930
And if we want things to escalate a little more quickly,
如果我们想让事情更快一点，

307
00:15:32,930 --> 00:15:35,220
let me go ahead and do this instead.
让我继续做这个。

308
00:15:35,220 --> 00:15:36,650
Let me close blur.bmp.
让我关闭 blur.bmp。

309
00:15:36,650 --> 00:15:39,440
Let me go ahead and open a file called edges.py.
让我继续打开一个名为 edges.py 的文件。

310
00:15:39,440 --> 00:15:41,990
And maybe, in edges.py, we can use this same library.
也许，在 edges.py 中，我们可以使用同一个库。

311
00:15:41,990 --> 00:15:47,913
So from the Python Image Library, import Image and import ImageFilter.
所以从 Python 图像库中，导入 Image 和导入 ImageFilter。

312
00:15:47,913 --> 00:15:50,330
Let me go ahead and create another variable called before,
让我继续创建另一个名为 before 的变量，

313
00:15:50,330 --> 00:15:53,900
set it equal to Image.open("bridge.bmp"),
将其赋值为 Image.open("bridge.bmp")，

314
00:15:53,900 --> 00:15:54,980
just like before.
就像之前一样。

315
00:15:54,980 --> 00:15:57,560
Let me create another variable called after,
让我继续创建另一个名为 after 的变量，

316
00:15:57,560 --> 00:16:03,200
set that equal to before.filter(ImageFilter.FIND_EDGES),
将其赋值为 before.filter(ImageFilter.FIND_EDGES)，

317
00:16:03,200 --> 00:16:06,500
which comes with this library automatically, and lastly,
这是这个库自动提供的，最后

318
00:16:06,500 --> 00:16:10,370
the same thing-- save this as a file called out.bmp.
同样的事情-- 把它保存为一个名为 out.bmp 的文件。

319
00:16:10,370 --> 00:16:12,470
So if you struggled perhaps with this one
所以如果你之前可能在这方面遇到了一些困难

320
00:16:12,470 --> 00:16:16,310
previously, whereby you wrote for the more comfortable version of problem
之前，当你为更舒适版本的题目编写代码时

321
00:16:16,310 --> 00:16:19,580
set 4, edge detection, so to speak, well, you
集 4，可以这么说，边缘检测，那么你

322
00:16:19,580 --> 00:16:23,270
might have then created a file that given an input like this,
可能就创建了一个文件，给定像这样的输入，

323
00:16:23,270 --> 00:16:28,340
the original bridge.bmp, this new version, out.bmp, with just four
原始的 bridge.bmp，这个新版本，out.bmp，只有四

324
00:16:28,340 --> 00:16:31,050
lines of code, now looks like this.
行代码，现在看起来像这样。

325
00:16:31,050 --> 00:16:32,840
So, again, if this is a little frustrating
所以，再说一次，如果这有点令人沮丧

326
00:16:32,840 --> 00:16:36,110
that we had to do all of this in C, that was exactly
我们不得不把所有这些都用 C 语言来实现，这正是

327
00:16:36,110 --> 00:16:39,140
the point to motivate that you now understand nonetheless
想要让你理解的重点，尽管如此

328
00:16:39,140 --> 00:16:40,850
what's going on underneath the hood.
了解引擎盖下的运作机制。

329
00:16:40,850 --> 00:16:43,580
But with Python, you can express the solutions
但是用 Python，你可以表达解决方案

330
00:16:43,580 --> 00:16:46,880
to problems all the more efficiently, all the more readily.
用更有效率的方式，更轻松地解决问题。

331
00:16:46,880 --> 00:16:50,060
And just one last one, too-- it's very common nowadays
还有一个，现在很常见

332
00:16:50,060 --> 00:16:52,910
in the world of photography and social media and the like to do face
在摄影、社交媒体等领域做人脸

333
00:16:52,910 --> 00:16:54,830
detection, for better or for worse.
检测，无论好坏。

334
00:16:54,830 --> 00:16:56,990
And it turns out that face detection, even
事实证明，人脸检测，即使

335
00:16:56,990 --> 00:16:59,240
if you want to integrate it into your own application,
如果你想将它集成到你的应用程序中，

336
00:16:59,240 --> 00:17:02,660
is something that lots of other people have integrated into their applications
也是许多其他人已经将其集成到他们的应用程序中的功能

337
00:17:02,660 --> 00:17:03,360
as well.
。

338
00:17:03,360 --> 00:17:07,880
So Python, to my point earlier of having this very rich ecosystem of libraries
所以 Python，就像我之前提到的，拥有一个非常丰富的库生态系统

339
00:17:07,880 --> 00:17:12,349
that other people wrote, you can literally run a command like pip
是由其他人编写的，你实际上可以运行一个像 pip 这样的命令

340
00:17:12,349 --> 00:17:19,680
install face_recognition if you want to add support to your code space,
安装 face_recognition，如果你想在你的代码空间中添加支持，

341
00:17:19,680 --> 00:17:21,930
or to your programming and environment more generally,
或者更普遍地说，添加到你的编程和环境中，

342
00:17:21,930 --> 00:17:24,532
for the notion of face recognition.
用于人脸识别的概念。

343
00:17:24,532 --> 00:17:26,490
In fact, this is going to automatically install
事实上，这将自动安装

344
00:17:26,490 --> 00:17:29,340
from some server elsewhere a library that someone else wrote
来自其他服务器上的一个由其他人编写的库

345
00:17:29,340 --> 00:17:30,870
called face_recognition.
名为 face_recognition。

346
00:17:30,870 --> 00:17:34,000
And with this library, you can do something like this.
使用这个库，你可以做这样的事情。

347
00:17:34,000 --> 00:17:37,290
Let me go into a directory that I came with in advance.
让我进入一个我事先准备好的目录。

348
00:17:37,290 --> 00:17:40,350
Let me go ahead and ls in there, and you'll see four files--
让我继续在那里 ls，你会看到四个文件——

349
00:17:40,350 --> 00:17:43,710
detect.py and recognize.py, which are going to detect
detect.py 和 recognize.py，它们将分别检测

350
00:17:43,710 --> 00:17:48,150
faces and then recognize specific faces, respectively, and then two files
人脸，然后识别特定人脸，以及两个文件

351
00:17:48,150 --> 00:17:50,260
I brought from a popular TV show, for instance.
例如，我从一个受欢迎的电视剧中获得。

352
00:17:50,260 --> 00:17:55,350
So if I open office.jpg, here is one of the early cast photos from the hit TV
所以如果我打开 office.jpg，这里就是热门电视剧《办公室》的早期演员照片之一。

353
00:17:55,350 --> 00:17:56,580
series The Office.
《办公室》。

354
00:17:56,580 --> 00:18:03,060
And here is a photograph of someone specific from the show, Toby.
这里是一张电视剧中某位特定人物的照片，托比。

355
00:18:03,060 --> 00:18:05,970
Now, this is, of course, Toby's face.
当然，这是托比的脸。

356
00:18:05,970 --> 00:18:10,830
But what is it that makes Toby's face a face?
但是什么让托比的脸成为一张脸？

357
00:18:10,830 --> 00:18:15,450
More generally, if I open up office.jpg, and I asked you, the human,
更一般地说，如果我打开 office.jpg，我问你，人类，

358
00:18:15,450 --> 00:18:17,917
to identify all of the faces in this picture,
识别这幅图片中所有的人脸，

359
00:18:17,917 --> 00:18:21,000
it wouldn't be that hard with a marker to sort of circle all of the faces.
用标记圈出所有的人脸并不难。

360
00:18:21,000 --> 00:18:21,510
But how?
但是怎样？

361
00:18:21,510 --> 00:18:22,410
Why?
为什么？

362
00:18:22,410 --> 00:18:26,460
How do you as humans detect faces, might you think?
你作为人类是如何检测人脸的，你可能会想？

363
00:18:26,460 --> 00:18:27,030
Yeah?
是吧？

364
00:18:27,030 --> 00:18:28,380
AUDIENCE: You have eyes, nose.
观众：你有眼睛，鼻子。

365
00:18:28,380 --> 00:18:30,360
DAVID MALAN: Features, yeah, like eyes, nose,
大卫·马兰：特征，是的，比如眼睛，鼻子，

366
00:18:30,360 --> 00:18:32,610
generally in a similar orientation, even though we all
通常以类似的方向，即使我们所有人

367
00:18:32,610 --> 00:18:34,140
have different faces, ultimately.
最终都有不同的脸。

368
00:18:34,140 --> 00:18:38,140
But there's a pattern to the shapes that you're seeing on the screen.
但你在屏幕上看到的形状存在一个模式。

369
00:18:38,140 --> 00:18:40,140
Well, it turns out this face_recognition library
事实证明，这个 face_recognition 库

370
00:18:40,140 --> 00:18:43,590
has been trained, perhaps via artificial intelligence over time,
已经过训练，也许是通过人工智能随着时间的推移，

371
00:18:43,590 --> 00:18:46,830
to recognize faces, but any number of different faces,
来识别面孔，但任何数量的不同面孔，

372
00:18:46,830 --> 00:18:48,430
perhaps among these folks here.
也许就在这些人中。

373
00:18:48,430 --> 00:18:51,250
So if I go back into my terminal window here,
所以如果我回到我的终端窗口，

374
00:18:51,250 --> 00:18:56,970
let me go ahead and run, say, python of detect.py, which I wrote
让我继续运行，比如 python detect.py，我之前写的

375
00:18:56,970 --> 00:18:59,190
in advance, which uses that library.
提前准备好的，它使用了那个库。

376
00:18:59,190 --> 00:19:03,240
And what that program is going to do-- it's going to think, do some thinking.
而那个程序将会做的是——它会思考，做一些思考。

377
00:19:03,240 --> 00:19:04,830
It's just found some face.
它刚刚发现了一些面孔。

378
00:19:04,830 --> 00:19:08,100
And let me go ahead now and open a file it just created
让我现在继续打开一个它刚刚创建的文件

379
00:19:08,100 --> 00:19:12,370
called detected.jpg, which I didn't have in my folder a moment ago.
名为 detected.jpg，我之前在我的文件夹中没有它。

380
00:19:12,370 --> 00:19:16,650
But when I open this here file, you'll now see all of the faces
但是当我打开这个文件时，你就会看到所有的人脸。

381
00:19:16,650 --> 00:19:19,290
based on this library's detection thereof.
基于此库的检测结果。

382
00:19:19,290 --> 00:19:22,500
But suppose that we're looking for a very specific face among them,
但假设我们要在其中寻找一张非常特定的脸，

383
00:19:22,500 --> 00:19:23,435
maybe Toby's.
可能是托比的。

384
00:19:23,435 --> 00:19:25,560
Well, maybe if we write a program that doesn't just
好吧，也许如果我们编写一个程序，它不仅仅是

385
00:19:25,560 --> 00:19:30,030
take as input the office.jpg, but a second input, toby.jpg,
将 office.jpg 作为输入，而是第二个输入，toby.jpg，

386
00:19:30,030 --> 00:19:32,910
maybe this library, and code more generally,
也许这个库，以及更一般的代码，

387
00:19:32,910 --> 00:19:37,320
can distinguish Toby's face from Jim's, from Pam's, from everyone else
可以区分托比的脸，吉姆的脸，帕姆的脸，以及所有其他人

388
00:19:37,320 --> 00:19:41,880
in the show, just based on this one piece of training data, so to speak.
在节目中，仅仅基于这一个训练数据，可以说。

389
00:19:41,880 --> 00:19:47,580
Well let me instead run python of recognize.py and hit Enter.
好吧，让我运行 recognize.py 的 python 脚本并按回车键。

390
00:19:47,580 --> 00:19:50,370
It's going to do some thinking, some thinking, some thinking.
它会思考，思考，思考。

391
00:19:50,370 --> 00:19:52,800
And it is going to output now a file called
它现在将输出一个名为

392
00:19:52,800 --> 00:19:59,740
recognized.jpg, which should show me his face, ideally, specifically.
recognized.jpg 的文件，它应该理想地、具体地显示他的脸。

393
00:19:59,740 --> 00:20:01,200
And so what has it done?
那么它做了什么？

394
00:20:01,200 --> 00:20:05,670
Well, with sort of a green marker, there is Toby among all of these faces.
好吧，用一种绿色的标记，在所有这些脸上，有托比。

395
00:20:05,670 --> 00:20:07,800
That's maybe a dozen or so lines of code,
这可能只有十来行代码，

396
00:20:07,800 --> 00:20:10,860
but it's built on top of this ecosystem of libraries.
但它是建立在这个库生态系统之上的。

397
00:20:10,860 --> 00:20:14,295
And this is, again, just one of the reasons why Python is so popular.
而这，再一次，只是 Python 如此受欢迎的原因之一。

398
00:20:14,295 --> 00:20:16,920
Undoubtedly, some number of years from now, Python will be out,
毫无疑问，从现在算起几年后，Python 会过时，

399
00:20:16,920 --> 00:20:18,378
and something else will be back in.
而其他一些东西将重新流行起来。

400
00:20:18,378 --> 00:20:21,600
But that's indeed among the goals of CS50, too, is not to teach you C,
但这确实是 CS50 的目标之一，不是教你 C 语言，

401
00:20:21,600 --> 00:20:23,820
not to teach you Python, not in a couple of weeks
不是教你 Python，不是在几周内

402
00:20:23,820 --> 00:20:26,280
to teach you JavaScript and other languages, too,
教你 JavaScript 和其他语言，

403
00:20:26,280 --> 00:20:28,200
but to teach you how to program.
而是教你如何编程。

404
00:20:28,200 --> 00:20:30,900
And indeed, all of the ideas we have explored and will now
事实上，我们已经探索过的，现在将要探索的，

405
00:20:30,900 --> 00:20:36,000
explore more today, you'll see recurring for languages in the years to come.
今天将要深入探索的，你将会看到在未来的几年里，它们会在不同的语言中反复出现。

406
00:20:36,000 --> 00:20:40,530
Any questions before we now dive into how it is this code is working
在我们深入研究这段代码是如何工作的之前，有什么问题吗？

407
00:20:40,530 --> 00:20:45,150
and why I type the things that I did before we forge ahead?
以及为什么我之前打出这些内容，在我们继续前进之前？

408
00:20:45,150 --> 00:20:48,890
Any questions along these lines?
这方面还有什么问题吗？

409
00:20:48,890 --> 00:20:50,720
Anything at all?
任何问题都可以提出来吗？

410
00:20:50,720 --> 00:20:51,270
No?
没有吗？

411
00:20:51,270 --> 00:20:51,770
All right.
好的。

412
00:20:51,770 --> 00:20:54,887
So how does Python itself work?
那么 Python 本身是如何工作的呢？

413
00:20:54,887 --> 00:20:56,720
Well, let's do a quick review as we did when
好吧，让我们做一个快速回顾，就像我们在

414
00:20:56,720 --> 00:20:58,730
we transitioned from Scratch to C, this time,
从 Scratch 过渡到 C 语言时所做的那样，这一次，

415
00:20:58,730 --> 00:21:00,470
though, from Scratch, say, to Python.
不过，是从 Scratch 到 Python。

416
00:21:00,470 --> 00:21:02,507
So in Python, as with many languages, there
所以在 Python 中，就像在许多其他语言中一样，有

417
00:21:02,507 --> 00:21:05,090
are these things called functions-- the actions and verbs that
这些被称为函数的东西——实际完成动作的动词。

418
00:21:05,090 --> 00:21:06,330
actually get things done.
实际上完成动作的动词。

419
00:21:06,330 --> 00:21:09,590
So here on the left, recall from week 0, was the simplest of functions.
所以左边这里，回忆一下第 0 周，是最简单的函数。

420
00:21:09,590 --> 00:21:12,320
We played with, first, the say block, which just literally has
我们首先玩了 say 代码块，它只是简单地让

421
00:21:12,320 --> 00:21:13,880
the cat say something on the screen.
猫在屏幕上说出一些东西。

422
00:21:13,880 --> 00:21:18,980
We've seen in C, for instance, the equivalent line of code is arguably
例如，我们在 C 语言中看到的等效代码行可以算是

423
00:21:18,980 --> 00:21:22,130
this here, with printf(), with the parentheses, the quotation marks,
这里，使用了 printf()，带括号，引号，

424
00:21:22,130 --> 00:21:23,810
the backslash n, the semicolon.
反斜杠 n，分号。

425
00:21:23,810 --> 00:21:27,330
In Python now, it's going to indeed be a little simpler than that.
现在在 Python 中，它确实比那更简单一些。

426
00:21:27,330 --> 00:21:30,590
But the idea is the same as it was back in week 0.
但这个想法和第 0 周时一样。

427
00:21:30,590 --> 00:21:33,800
Libraries-- so we've seen already in C, and now we've
库——所以在 C 语言中我们已经看到了，现在我们已经

428
00:21:33,800 --> 00:21:36,170
already seen in Python that these things exist, too.
我们已经在 Python 中看到过这些东西的存在了。

429
00:21:36,170 --> 00:21:40,460
In the world of C, recall that besides the standard ones, like standard io.h,
在 C 语言的世界里，回想一下，除了像 standard io.h 这样的标准库之外，

430
00:21:40,460 --> 00:21:43,978
that header file, we could very quickly introduce cs50.h,
那个头文件，我们可以很快地引入 cs50.h，

431
00:21:43,978 --> 00:21:45,770
which was like your entry point, the header
它就像你的入口点，头文件

432
00:21:45,770 --> 00:21:49,342
file for the CS50 library, which gave you a bunch of functions as well.
用于 CS50 库，它也为你提供了一堆函数。

433
00:21:49,342 --> 00:21:51,300
Well, we're going to give you a similar library
好吧，我们将为你提供一个类似的库

434
00:21:51,300 --> 00:21:54,145
for at least the next week or two, training wheels for Python
至少在接下来的一两周内，用于 Python 的辅助工具

435
00:21:54,145 --> 00:21:57,270
specifically, that, again, will take off so that you can stand on your own,
具体来说，它会再次帮助你起飞，这样你就可以独立了，

436
00:21:57,270 --> 00:21:59,160
even with CS50 behind you.
即使有了 CS50 的支持。

437
00:21:59,160 --> 00:22:03,130
But the syntax for using a library in Python is a little different.
但是在 Python 中使用库的语法有点不同。

438
00:22:03,130 --> 00:22:05,250
You don't include a .h file.
你不需要包含 .h 文件。

439
00:22:05,250 --> 00:22:09,550
You just import, instead, the name of the library.
相反，你只需导入库的名称。

440
00:22:09,550 --> 00:22:10,050
All right.
好的。

441
00:22:10,050 --> 00:22:11,258
What does that actually mean?
这到底意味着什么呢？

442
00:22:11,258 --> 00:22:14,280
Well, if there are specific functions in that library you want to use,
好吧，如果库中有一些你想要使用的特定函数，

443
00:22:14,280 --> 00:22:16,050
in Python, you can be more precise.
在 Python 中，你可以更加精确。

444
00:22:16,050 --> 00:22:18,750
You don't just have to say, give me the whole library.
你不需要说，给我整个库。

445
00:22:18,750 --> 00:22:23,580
For efficiency purposes, you can say, let me import the get_string() function
为了效率，你可以说，让我导入 get_string() 函数

446
00:22:23,580 --> 00:22:25,800
from the CS50 library.
来自 CS50 库。

447
00:22:25,800 --> 00:22:29,610
So you have finer-grained control in Python, which can actually speed things
所以在 Python 中，你拥有更细粒度的控制，这实际上可以加快速度

448
00:22:29,610 --> 00:22:31,590
up if you're not loading things unnecessarily
如果你没有不必要地加载东西

449
00:22:31,590 --> 00:22:35,040
into memory, if all you want is, say, one feature therein.
到内存中，如果你只需要其中一个功能。

450
00:22:35,040 --> 00:22:40,230
So here, for instance, in Scratch, was an example of how we might use not only
所以，例如，在 Scratch 中，就是一个例子，说明了我们如何不仅

451
00:22:40,230 --> 00:22:45,120
a built-in function, like the say block, or, in C, in the printf(),
可以使用内置函数，比如 say 块，或者，在 C 语言中，使用 printf()，

452
00:22:45,120 --> 00:22:50,250
but how we might similarly now do the same but achieve this in Python.
但我们现在如何以类似的方式做到这一点，并在 Python 中实现这一点。

453
00:22:50,250 --> 00:22:51,610
So how might we do this?
那么我们该怎么做呢？

454
00:22:51,610 --> 00:22:54,672
Well, in Python, or rather, in C, this code
好吧，在 Python 中，或者更确切地说，在 C 语言中，这段代码

455
00:22:54,672 --> 00:22:56,130
looks a little something like this.
看起来像这样。

456
00:22:56,130 --> 00:22:59,070
Back in week 1, we declared a variable of type string,
在第一周，我们声明了一个字符串类型的变量，

457
00:22:59,070 --> 00:23:01,530
even though later we revealed that to be char*.
尽管我们后来发现它实际上是 char*。

458
00:23:01,530 --> 00:23:04,980
I gave this a variable name of answer for parity with Scratch.
为了与 Scratch 保持一致，我给它起了个变量名叫做 answer。

459
00:23:04,980 --> 00:23:08,140
Then we use CS50's own get_string() function and asked, for instance,
然后，我们使用 CS50 自带的 get_string() 函数，并问道，例如，

460
00:23:08,140 --> 00:23:10,290
the same question as in the white oval here.
与这里白色椭圆形中的问题相同。

461
00:23:10,290 --> 00:23:14,430
And then, using this placeholder syntax, these format codes,
然后，使用这种占位符语法，这些格式代码，

462
00:23:14,430 --> 00:23:18,870
which was printf()-specific, we could plug in that answer to this premade
这对于 printf() 是特定的，我们可以将答案插入这个预先做好的字符串中

463
00:23:18,870 --> 00:23:21,120
string where the %s is.
其中 %s 的位置。

464
00:23:21,120 --> 00:23:24,370
And we saw %i and %f and a bunch of others as well.
我们也看到了 %i 和 %f 以及其他一些。

465
00:23:24,370 --> 00:23:27,450
So this is sort of how, in C, you approximate
所以，这就是你在 C 语言中模拟

466
00:23:27,450 --> 00:23:31,080
the idea of concatenating two things together, joining two things,
将两个东西连接在一起，组合两个东西的想法，

467
00:23:31,080 --> 00:23:33,330
just as we did here in Scratch.
就像我们在这里在 Scratch 中所做的那样。

468
00:23:33,330 --> 00:23:36,360
So in Python, it turns out it's not only going to be a little easier,
所以，在 Python 中，事实证明它不仅会更简单一些，

469
00:23:36,360 --> 00:23:39,070
but there's going to be even more ways to do this.
而且会有更多的方法来做到这一点。

470
00:23:39,070 --> 00:23:42,690
And so even what might seem today like a lot of different syntax,
因此，即使今天看起来有很多不同的语法，

471
00:23:42,690 --> 00:23:45,300
it really is just different ways, stylistically,
它实际上只是风格上不同的方法，

472
00:23:45,300 --> 00:23:46,392
to achieve the same goals.
来实现相同的目标。

473
00:23:46,392 --> 00:23:48,600
And over time, as you get more comfortable with this,
随着时间的推移，当你对此越来越熟悉，

474
00:23:48,600 --> 00:23:51,900
you too will develop your own style, or, if working for a company
你也会发展出自己的风格，或者，如果你在公司工作

475
00:23:51,900 --> 00:23:54,120
or working with a team, you might collectively
或者与团队合作，你们可能会共同

476
00:23:54,120 --> 00:23:56,950
decide which conventions you want to use.
决定你想使用哪些约定。

477
00:23:56,950 --> 00:24:01,290
But here, for instance, is one way you could implement this same idea
但是，例如，以下是一种实现相同想法的方法

478
00:24:01,290 --> 00:24:04,120
in Scratch but in Python instead.
在 Scratch 中，但用 Python 代替。

479
00:24:04,120 --> 00:24:06,690
So notice I'm going to still use a variable called answer.
所以注意，我仍然要使用一个名为 answer 的变量。

480
00:24:06,690 --> 00:24:08,910
I'm going to use CS50's function called get_string().
我将使用 CS50 的名为 get_string() 的函数。

481
00:24:08,910 --> 00:24:11,370
I'm still going to use, quote unquote, "What's your name?"
我仍然要使用，引号中的，“What's your name？”

482
00:24:11,370 --> 00:24:14,408
But down here is where we see the most difference.
但在这里，我们看到了最大的区别。

483
00:24:14,408 --> 00:24:16,200
It's, again, not called printf() in Python.
它，再次强调，在 Python 中不叫 printf()。

484
00:24:16,200 --> 00:24:18,060
It's now called just print().
它现在直接叫 print()。

485
00:24:18,060 --> 00:24:22,350
And what might you infer the plus operator is doing here?
你能推断出加号运算符在这里的作用吗？

486
00:24:22,350 --> 00:24:26,063
It's not addition, obviously, in a mathematical sense.
它不是加法，显然，在数学意义上。

487
00:24:26,063 --> 00:24:28,230
But those of you who have perhaps programmed before,
但是你们中那些可能以前编程过的人，

488
00:24:28,230 --> 00:24:30,195
what does the plus represent in this context?
在这个上下文中，加号代表什么？

489
00:24:30,195 --> 00:24:32,340
AUDIENCE: It's joining the two strings together.
观众：它将两个字符串连接在一起。

490
00:24:32,340 --> 00:24:34,757
DAVID MALAN: It's indeed joining the two strings together.
大卫·马兰：它确实将两个字符串连接在一起。

491
00:24:34,757 --> 00:24:36,630
So this is indeed concatenating the thing
所以这实际上是将左边的东西

492
00:24:36,630 --> 00:24:38,830
on the left with the thing on the right.
与右边的东西连接在一起。

493
00:24:38,830 --> 00:24:42,160
So you don't use the placeholder in this particular scenario.
因此，你不会在这种情况下使用占位符。

494
00:24:42,160 --> 00:24:44,490
You can instead, a little more simply, just use plus.
你可以改为，更简单一点，直接使用加号。

495
00:24:44,490 --> 00:24:46,120
But you want your grammar to line up.
但你想要你的语法对齐。

496
00:24:46,120 --> 00:24:50,430
So I still have "hello," and then close quote
所以我还保留着“hello”，然后关闭引号

497
00:24:50,430 --> 00:24:52,950
because I want to form a full phrase.
因为我想构成一个完整的短语。

498
00:24:52,950 --> 00:24:55,410
Notice, too, there's also one other slightly more
注意，还有另外一个稍微更

499
00:24:55,410 --> 00:24:58,200
subtle difference on the first line.
细微的差异在第一行。

500
00:24:58,200 --> 00:25:01,482
Besides the fact that we don't have a semicolon, what else is different?
除了我们没有分号之外，还有什么不同？

501
00:25:01,482 --> 00:25:03,690
AUDIENCE: You don't declare the type of the variable.
观众：你没有声明变量的类型。

502
00:25:03,690 --> 00:25:05,982
DAVID MALAN: I didn't declare the type of the variable.
大卫·马兰：我没有声明变量的类型。

503
00:25:05,982 --> 00:25:08,340
So Python still has strings, as we'll see.
所以 Python 仍然有字符串，正如我们将会看到的那样。

504
00:25:08,340 --> 00:25:12,290
But you don't have to tell the interpreter what type of variable
但你不需要告诉解释器变量的类型

505
00:25:12,290 --> 00:25:12,790
it is.
是什么。

506
00:25:12,790 --> 00:25:14,490
And this is going to save us some keystrokes,
这将为我们节省一些按键，

507
00:25:14,490 --> 00:25:17,230
and it's just going to be a little more user-friendly over time.
而且随着时间的推移，它会更友好一些。

508
00:25:17,230 --> 00:25:21,130
Meanwhile, you can do this also a little bit differently if you prefer.
同时，如果你愿意，也可以用稍微不同的方式来做。

509
00:25:21,130 --> 00:25:25,620
You can instead trust that the print() function in Python can actually do even
你可以改为信任 Python 中的 print() 函数实际上可以做更多

510
00:25:25,620 --> 00:25:27,210
more for you automatically.
更多事情，自动地为你。

511
00:25:27,210 --> 00:25:32,160
The print() function in Python can take multiple arguments separated by commas
Python 中的 print() 函数可以接受多个用逗号分隔的参数

512
00:25:32,160 --> 00:25:33,240
in the usual way.
以通常的方式。

513
00:25:33,240 --> 00:25:35,340
And by default, Python is going to insert
默认情况下，Python 将插入

514
00:25:35,340 --> 00:25:39,767
for you a single space between its first argument and its second argument.
一个空格，在它的第一个参数和第二个参数之间。

515
00:25:39,767 --> 00:25:41,850
So notice what I've done here is my first argument
所以注意，我在这里做的，是我的第一个参数

516
00:25:41,850 --> 00:25:45,090
is, quote unquote, "hello," with a comma but no space.
是，引号中的，“hello”，带一个逗号，但没有空格。

517
00:25:45,090 --> 00:25:48,150
Then, outside of the quotes, I'm putting a comma because that just means,
然后，在引号外面，我加了一个逗号，因为这意味着，

518
00:25:48,150 --> 00:25:49,550
here comes my second argument.
我的第二个参数来了。

519
00:25:49,550 --> 00:25:52,098
And then I put the same variable as before.
然后，我放上了和之前一样的变量。

520
00:25:52,098 --> 00:25:53,890
And I'm just going to let Python figure out
我只要让 Python 弄明白

521
00:25:53,890 --> 00:25:56,860
that it should, by default, per its documentation,
它应该按照文档，默认情况下

522
00:25:56,860 --> 00:26:02,050
can join these two variables, putting a single space in between them.
可以将这两个变量连接起来，并在它们之间添加一个空格。

523
00:26:02,050 --> 00:26:03,610
You can do this yet another way.
你还可以用另一种方式来做到这一点。

524
00:26:03,610 --> 00:26:06,850
And this way looks a little weirder, but this is actually
这种方式看起来有点奇怪，但实际上

525
00:26:06,850 --> 00:26:09,910
probably the most common way nowadays in Python
现在在 Python 中，这可能是最常见的做法。

526
00:26:09,910 --> 00:26:14,450
is to use what's called a format string, or f string, for short.
就是使用所谓的格式字符串，简称 f 字符串。

527
00:26:14,450 --> 00:26:16,390
And this looks weird to me still.
对我来说，这仍然看起来很奇怪。

528
00:26:16,390 --> 00:26:17,170
It looks weird.
看起来很奇怪。

529
00:26:17,170 --> 00:26:21,010
But if you prefix a string in Python with an f,
但是，如果你在 Python 中用 f 作为字符串的前缀，

530
00:26:21,010 --> 00:26:26,020
literally, you can then use curly braces inside of that string in Python.
你就可以在 Python 的字符串中使用花括号。

531
00:26:26,020 --> 00:26:29,930
And Python will not print out literally a curly brace and a closed curly brace.
Python 不会直接打印出一个花括号和一个闭合的花括号。

532
00:26:29,930 --> 00:26:34,330
It will instead interpolate whatever is inside of those curly braces.
相反，它会将花括号中的内容进行插值。

533
00:26:34,330 --> 00:26:36,400
That is to say if answer is a variable that
也就是说，如果 answer 是一个变量，它

534
00:26:36,400 --> 00:26:39,190
has some value, like "David" or something like that,
具有某个值，比如 "David" 之类的，

535
00:26:39,190 --> 00:26:42,400
saying f before the first quotation mark,
在第一个引号之前加上 f，

536
00:26:42,400 --> 00:26:44,530
and then using these curly braces therein,
然后使用花括号，

537
00:26:44,530 --> 00:26:48,430
is going to do the exact same thing of creating a string that says "Hello,"
将生成一个包含 "Hello" 的字符串，

538
00:26:48,430 --> 00:26:50,440
comma, space, "David."
逗号，空格，"David"。

539
00:26:50,440 --> 00:26:52,390
So it's going to plug in the value for you.
所以它会为你插入值。

540
00:26:52,390 --> 00:26:56,350
So you can think of this as %s but without that second step of having
所以你可以把它想象成 %s，但不需要第二步，也就是

541
00:26:56,350 --> 00:26:59,635
to keep track of what you want to plug back in for %s.
跟踪你想插入到 %s 中的内容。

542
00:26:59,635 --> 00:27:02,330
Instead of %s, you literally put in curly braces,
而不是 %s，你直接插入花括号，

543
00:27:02,330 --> 00:27:04,060
what do you want to put right there?
你想在那里放什么？

544
00:27:04,060 --> 00:27:06,610
You format the string yourself.
你自己格式化字符串。

545
00:27:06,610 --> 00:27:10,570
So given all of those ways, how might we actually
鉴于所有这些方法，我们实际上该如何

546
00:27:10,570 --> 00:27:14,410
go about implementing this or using this ourselves?
去实现它或自己使用它呢？

547
00:27:14,410 --> 00:27:18,040
Well, let me propose that we do this here.
好吧，我建议我们在这里做这个。

548
00:27:18,040 --> 00:27:21,070
Let me propose that I go back to VS Code.
我建议我回到 VS Code。

549
00:27:21,070 --> 00:27:24,640
Let me go ahead and open up hello.py again.
让我打开 hello.py 文件。

550
00:27:24,640 --> 00:27:28,730
And as before, instead of just printing out something like,
和之前一样，而不是打印类似这样的东西，

551
00:27:28,730 --> 00:27:31,330
quote unquote, "hello, world," let me actually print out
"hello, world" ，让我真正打印出来

552
00:27:31,330 --> 00:27:33,260
something a little more interesting.
一些更有趣的东西。

553
00:27:33,260 --> 00:27:36,850
So let me go ahead and, from the CS50 library,
所以，我从 CS50 库中

554
00:27:36,850 --> 00:27:39,310
import the function called get_string().
导入名为 get_string() 的函数。

555
00:27:39,310 --> 00:27:42,010
Then let me go ahead and create a variable called answer.
然后我创建一个名为 answer 的变量。

556
00:27:42,010 --> 00:27:45,700
Let me set that equal to the return value of get_string() with,
我将其设置为 get_string() 的返回值，

557
00:27:45,700 --> 00:27:50,590
as an argument, quote unquote, "What's your name?"
作为参数，"What's your name?"

558
00:27:50,590 --> 00:27:54,610
And then no semicolon at the end of that line, but on the next line, frankly
然后在那一行的末尾不要加分号，但在下一行，坦率地说

559
00:27:54,610 --> 00:27:57,650
here, I can pick any one of those potential solutions.
在这里，我可以选择其中任何一个潜在的解决方案。

560
00:27:57,650 --> 00:27:59,090
So let me start with the first.
所以，我从第一个开始。

561
00:27:59,090 --> 00:28:00,415
So "hello, " + answer.
所以 "hello, " + answer。

562
00:28:03,640 --> 00:28:07,840
And now, if I go down to my terminal window and run python of hello.py,
现在，如果我进入终端窗口并运行 hello.py 的 python，

563
00:28:07,840 --> 00:28:08,950
I'm prompted for my name.
我会被提示输入我的名字。

564
00:28:08,950 --> 00:28:12,280
I can type in D-A-V-I-D, and voila, that there then works.
我可以输入 D-A-V-I-D，瞧，它就运行了。

565
00:28:12,280 --> 00:28:13,870
Or I can tweak this a little bit.
或者我可以稍微调整一下。

566
00:28:13,870 --> 00:28:19,120
I can trust that Python will concatenate its first and second argument for me.
我可以相信 Python 会为我连接它的第一个和第二个参数。

567
00:28:19,120 --> 00:28:21,010
But this isn't quite right.
但这不太对。

568
00:28:21,010 --> 00:28:24,820
Let me go ahead and rerun python of hello.py, hit Enter, and type
让我重新运行 hello.py 的 python，按 Enter，然后输入

569
00:28:24,820 --> 00:28:25,420
in "David."
在 "David" 中。

570
00:28:25,420 --> 00:28:28,840
It's going to be ever-so-slightly buggy, sort of grammatically
它将略微有点错误，从语法上来说

571
00:28:28,840 --> 00:28:29,980
or visually, if you will.
或者从视觉上来说，如果你愿意。

572
00:28:29,980 --> 00:28:31,880
What did I do wrong here?
我这里做错了什么？

573
00:28:31,880 --> 00:28:32,380
Yeah.
是的。

574
00:28:32,380 --> 00:28:35,900
So I left the space in there, even though I'm getting one for free from
所以我留下了这个空格，即使我从

575
00:28:35,900 --> 00:28:36,400
print().
print() 中免费得到了一个。

576
00:28:36,400 --> 00:28:38,260
So that's an easy solution here.
所以这里有一个简单的解决方案。

577
00:28:38,260 --> 00:28:41,560
But let's do it one other way after running this to be sure--
但是让我们在运行完这个后尝试另一种方法，以确保--

578
00:28:41,560 --> 00:28:42,250
D-A-V-I-D.
D-A-V-I-D。

579
00:28:42,250 --> 00:28:44,620
And OK, now it looks like I intended.
好了，现在看起来就像我想要的那样了。

580
00:28:44,620 --> 00:28:47,780
Well, let's go ahead and use that placeholder syntax.
好吧，让我们继续使用占位符语法。

581
00:28:47,780 --> 00:28:52,240
So let's just pass in one bigger string as our argument, do "hello,"
所以我们只需将一个更大的字符串作为我们的参数传递，输入 "hello,"

582
00:28:52,240 --> 00:28:55,930
and then, in curly braces, [? answer ?],, like this.
然后在花括号中，[? answer ?]，像这样。

583
00:28:55,930 --> 00:28:58,390
Well, let me go down to my terminal window and clear it.
好吧，让我到我的终端窗口并清除它。

584
00:28:58,390 --> 00:29:03,700
Let me run python of hello.py and enter, type in D-A-V-I-D, and voila.
让我运行 python hello.py 并输入，输入 D-A-V-I-D，然后瞧！

585
00:29:03,700 --> 00:29:05,650
OK, I made a mistake.
好的，我犯了一个错误。

586
00:29:05,650 --> 00:29:08,150
What did I do wrong here, minor though it seems to be?
我这里做错了什么，尽管看起来很小？

587
00:29:08,150 --> 00:29:08,650
Yeah?
是的？

588
00:29:08,650 --> 00:29:09,525
AUDIENCE: [INAUDIBLE]
观众：[听不清]

589
00:29:09,525 --> 00:29:11,410
DAVID MALAN: So the stupid little f that you
DAVID MALAN：所以你必须在字符串之前加的这个愚蠢的小 f

590
00:29:11,410 --> 00:29:13,690
have to put before the string to tell Python
要告诉 Python

591
00:29:13,690 --> 00:29:16,570
that this is a special string-- it's a format string, or f
这是一个特殊字符串--它是一个格式字符串，或者 f

592
00:29:16,570 --> 00:29:20,450
string-- that it should additionally format for you.
字符串--它应该另外为你格式化。

593
00:29:20,450 --> 00:29:24,272
So if I rerun this after adding that f, I can do python of hello.py.
所以如果我在添加那个 f 后重新运行它，我可以运行 python hello.py。

594
00:29:24,272 --> 00:29:24,980
What's your name?
你叫什么名字？

595
00:29:24,980 --> 00:29:25,480
David.
David。

596
00:29:25,480 --> 00:29:28,690
And now it looks the way I might intend.
现在看起来就像我想要的那样了。

597
00:29:28,690 --> 00:29:33,160
But it turns out in Python, you don't actually need to use get_string().
但事实证明在 Python 中，你实际上不需要使用 get_string()。

598
00:29:33,160 --> 00:29:35,770
In C, recall that we introduced that because it's actually
在 C 中，回想一下我们引入了它，因为它实际上

599
00:29:35,770 --> 00:29:40,840
pretty annoying in C to get strings, in particular to get strings safely.
在 C 中获取字符串相当令人厌烦，特别是安全地获取字符串。

600
00:29:40,840 --> 00:29:44,950
Recall those short examples we did with scanf not too long ago.
回想一下我们不久前使用 scanf 做的那些简短的例子。

601
00:29:44,950 --> 00:29:47,530
And scanf kind of scans what the user types at the keyboard
而 scanf 扫描用户在键盘上输入的内容

602
00:29:47,530 --> 00:29:49,150
and loads it into memory.
并将其加载到内存中。

603
00:29:49,150 --> 00:29:53,890
But the fundamental danger with scanf when it comes to strings was what?
但是 scanf 在处理字符串时最根本的危险是什么？

604
00:29:53,890 --> 00:30:00,580
Why was it dangerous to use scanf to get strings from a user?
为什么使用 scanf 从用户那里获取字符串很危险？

605
00:30:00,580 --> 00:30:01,080
Why?
为什么？

606
00:30:01,080 --> 00:30:02,058
Yeah?
是的？

607
00:30:02,058 --> 00:30:04,690
AUDIENCE: What if they give you a really long string you don't have space for?
观众：如果他们给你的字符串太长，你没有空间怎么办？

608
00:30:04,690 --> 00:30:05,260
DAVID MALAN: Exactly.
DAVID MALAN：正是。

609
00:30:05,260 --> 00:30:07,010
What if they give you a really long string
如果他们给你的字符串太长

610
00:30:07,010 --> 00:30:08,598
that you didn't allocate space for?
而你没有为它分配空间呢？

611
00:30:08,598 --> 00:30:11,140
Because you're not going to know as the programmer in advance
因为作为程序员，你事先并不知道

612
00:30:11,140 --> 00:30:13,750
how long of a string the human is going to type in.
用户要输入多长的字符串。

613
00:30:13,750 --> 00:30:15,130
So you might under--
所以你可能会低估它，因此内存不足，或者

614
00:30:15,130 --> 00:30:19,895
you might undercut it and therefore have too much memory, or too many
太多字符被放入了内存，从而导致

615
00:30:19,895 --> 00:30:22,270
characters being put into that memory, thereby giving you
某种缓冲区溢出，可能会导致电脑崩溃，或者至少

616
00:30:22,270 --> 00:30:26,260
some kind of buffer overflow, which might crash the computer or, minimally,
你的程序崩溃。

617
00:30:26,260 --> 00:30:27,130
your program.
你的程序。

618
00:30:27,130 --> 00:30:31,570
So it turns out in C, get_string() was especially useful.
所以事实证明在 C 中，get_string() 非常有用。

619
00:30:31,570 --> 00:30:33,700
In Python, it's not really that useful.
在 Python 中，它并没有那么有用。

620
00:30:33,700 --> 00:30:39,640
All it does is use a function that does come with Python called input().
它所做的就是使用一个 Python 自带的函数，叫做 input()。

621
00:30:39,640 --> 00:30:43,370
And, in fact, the input() function in Python, for all intents and purposes,
事实上，Python 中的 input() 函数，就其目的而言，

622
00:30:43,370 --> 00:30:47,270
is the same as the get_string() function that we give to you.
与我们提供的 get_string() 函数相同。

623
00:30:47,270 --> 00:30:50,140
But just to ease the transition from C to Python,
但为了便于从 C 语言过渡到 Python，

624
00:30:50,140 --> 00:30:52,780
we implemented a Python version of get_string() nonetheless.
我们还是实现了 Python 版本的 get_string() 函数。

625
00:30:52,780 --> 00:30:55,120
But this is to say if I go to VS Code here,
但我想说的是，如果我在这里进入 VS Code，

626
00:30:55,120 --> 00:30:59,030
and I just change get_string() to input(), and, in fact,
并将 get_string() 更改为 input()，事实上，

627
00:30:59,030 --> 00:31:03,680
I even get rid of the CS50 library at the top, this too should work fine.
我甚至可以去掉顶部的 CS50 库，这应该也能正常工作。

628
00:31:03,680 --> 00:31:07,940
If I rerun python of hello.py, type in my name, David, and voila,
如果我重新运行 hello.py 的 Python 程序，输入我的名字，David，瞧，

629
00:31:07,940 --> 00:31:10,710
I have that now working as well.
现在它也能正常工作了。

630
00:31:10,710 --> 00:31:11,210
All right.
好的。

631
00:31:11,210 --> 00:31:19,020
Questions about this use of get_string() or input() or any of our syntax thus
关于使用 get_string() 或 input() 或我们到目前为止的任何语法，

632
00:31:19,020 --> 00:31:19,520
far?
有疑问吗？

633
00:31:21,990 --> 00:31:22,490
All right.
好的。

634
00:31:22,490 --> 00:31:24,470
Well, what about variables?
那么，变量呢？

635
00:31:24,470 --> 00:31:26,480
We've used variables already, and we already
我们已经使用过变量了，并且已经

636
00:31:26,480 --> 00:31:29,960
identified the fact that you don't have to specify the type of your variables
确定了这样一个事实：你不需要主动指定变量的类型

637
00:31:29,960 --> 00:31:33,710
proactively, even though, clearly, Python supports strings thus far,
尽管 Python 到目前为止支持字符串，

638
00:31:33,710 --> 00:31:37,010
well, in Python, here's how you might declare
那么，在 Python 中，你可以这样声明

639
00:31:37,010 --> 00:31:40,130
a variable that not necessarily is assigned like a string,
一个不一定被赋值为字符串的变量，

640
00:31:40,130 --> 00:31:41,440
but maybe an integer instead.
而是可能是一个整数。

641
00:31:41,440 --> 00:31:43,190
So in Scratch, here's how you could create
所以在 Scratch 中，你可以这样创建一个

642
00:31:43,190 --> 00:31:47,030
a variable called counter if you want to count things and set it equal to 0.
名为 counter 的变量，如果你想统计事物并将其设置为 0。

643
00:31:47,030 --> 00:31:50,180
In C, what we would have done is this--
在 C 语言中，我们会这样做：

644
00:31:50,180 --> 00:31:55,040
int counter = 0; that's the exact same thing as in Scratch.
int counter = 0; 这与 Scratch 中完全相同。

645
00:31:55,040 --> 00:31:59,570
But in Python, as you might imagine, we can chip away at this and type
但在 Python 中，正如你所想，我们可以简化它并输入

646
00:31:59,570 --> 00:32:01,760
out this same idea little more easily.
这个相同的想法，只是更容易一点。

647
00:32:01,760 --> 00:32:03,920
One, we don't need to say int anymore.
首先，我们不再需要说 int。

648
00:32:03,920 --> 00:32:06,240
Two, we don't need the semicolon anymore.
其次，我们不再需要分号。

649
00:32:06,240 --> 00:32:07,850
And so you just do what you intend.
所以你只需要做你想做的事情。

650
00:32:07,850 --> 00:32:09,770
If you want a variable, just write it out.
如果你想要一个变量，就写出来。

651
00:32:09,770 --> 00:32:12,352
If you want to assign it a value, you use the equals sign.
如果你想为它赋值，就使用等号。

652
00:32:12,352 --> 00:32:14,810
If you want to specify that value, you put it on the right.
如果你想指定那个值，就将其放在右边。

653
00:32:14,810 --> 00:32:17,570
And just as in C, this is not the equality operator.
就像 C 语言一样，这不是相等运算符。

654
00:32:17,570 --> 00:32:20,420
It's the assignment operator from right to left.
它是从右到左的赋值运算符。

655
00:32:20,420 --> 00:32:25,460
Recall that in Scratch, if you wanted to increment a variable by 1 or any value,
回想一下，在 Scratch 中，如果你想将一个变量加 1 或任何值，

656
00:32:25,460 --> 00:32:27,260
you could use this puzzle piece here.
你可以使用这里的这个拼图块。

657
00:32:27,260 --> 00:32:32,310
Well, in C, you could do syntax like this, which, again, is not equality.
那么，在 C 语言中，你可以使用这样的语法，它同样不是相等运算。

658
00:32:32,310 --> 00:32:38,600
It's saying add 1 to counter and then assign it back to the counter variable.
它是说将 1 加到 counter 上，然后将它赋值回 counter 变量。

659
00:32:38,600 --> 00:32:42,750
In Python, you can do exactly the same thing minus the semicolon.
在 Python 中，你可以做完全相同的事情，只是没有分号。

660
00:32:42,750 --> 00:32:44,690
So you don't need to use the semicolon here.
所以你不需要在这里使用分号。

661
00:32:44,690 --> 00:32:48,380
But you might recall that in C, there was some syntactic sugar for this idea
但你可能还记得，在 C 语言中，有一些语法糖来表达这个想法

662
00:32:48,380 --> 00:32:49,640
because it was pretty popular.
因为它很流行。

663
00:32:49,640 --> 00:32:53,810
And so you could shorten this in C, as you can in Python,
所以你可以在 C 语言中缩写它，就像在 Python 中一样，

664
00:32:53,810 --> 00:32:59,270
to actually just this. += 1 will add to the counter variable whatever that
实际上就是这个。+= 1 会将任何值加到 counter 变量上，这个值就是

665
00:32:59,270 --> 00:33:00,560
value is.
值的。

666
00:33:00,560 --> 00:33:03,740
But it's not all steps forward.
但并非所有都是进步。

667
00:33:03,740 --> 00:33:07,250
You might be in the habit of using ++ or --.
你可能习惯使用 ++ 或 -- 。

668
00:33:07,250 --> 00:33:09,870
Sorry, those are not available in Python.
抱歉，这些在 Python 中不可用。

669
00:33:09,870 --> 00:33:10,370
Why?
为什么？

670
00:33:10,370 --> 00:33:12,590
It's because the designers of Python decided that you
这是因为 Python 的设计者决定你

671
00:33:12,590 --> 00:33:14,360
don't need them because this is--
不需要它们，因为这...

672
00:33:14,360 --> 00:33:16,230
gets the job done anyway.
无论如何都能完成工作。

673
00:33:16,230 --> 00:33:19,290
But there's a question down here in front, unless it was about the same.
但这里面有一个问题，除非是关于相同的问题。

674
00:33:19,290 --> 00:33:19,790
All right.
好的。

675
00:33:19,790 --> 00:33:22,070
So that's one feature we're taking away.
所以，我们拿走了一个功能。

676
00:33:22,070 --> 00:33:25,130
But it's not such a big deal to do += in this case.
但在这种情况下，做 += 并不算什么大问题。

677
00:33:25,130 --> 00:33:28,520
Well, what about the actual types involved here
那么，这里涉及的实际类型呢？

678
00:33:28,520 --> 00:33:31,970
beyond actually being able to define variables?
除了能够定义变量之外呢？

679
00:33:31,970 --> 00:33:36,620
Well, recall that in the world of C, we had at least these data
回想一下，在 C 的世界里，我们至少有这些数据

680
00:33:36,620 --> 00:33:39,020
types, those that came with the language in particular.
类型，那些与语言本身相关的类型。

681
00:33:39,020 --> 00:33:41,570
And we played with quite a few of these over time.
随着时间的推移，我们使用了其中相当一部分。

682
00:33:41,570 --> 00:33:45,110
In Python, we're going to take a bunch of those away.
在 Python 中，我们将拿走其中很多。

683
00:33:45,110 --> 00:33:51,650
In Python, you're only going to have access to a bool, true or false,
在 Python 中，你将只能访问 bool、true 或 false，

684
00:33:51,650 --> 00:33:54,110
a float, which is a real number with a decimal point,
float，它是一个带有小数点的实数，

685
00:33:54,110 --> 00:33:58,430
typically, an int, or an integer, and a string, now known as str.
通常，int 或整数，以及字符串，现在称为 str。

686
00:33:58,430 --> 00:34:00,533
So Python here sort of cuts some corners,
所以 Python 在这里某种程度上偷了一些懒，

687
00:34:00,533 --> 00:34:02,450
feels like it's too long to write out strings.
感觉写出字符串太长了。

688
00:34:02,450 --> 00:34:08,750
So a string in Python is called str, S-T-R, but it's the exact same idea.
所以在 Python 中，字符串被称为 str，S-T-R，但它完全是一样的概念。

689
00:34:08,750 --> 00:34:11,870
Notice, though, that missing from this now, in particular,
注意，现在，尤其是，这里缺少

690
00:34:11,870 --> 00:34:16,639
are double and long, which, recall, actually used more bits in order
double 和 long，回想一下，它们实际上使用了更多的位来

691
00:34:16,639 --> 00:34:17,929
to store information.
存储信息。

692
00:34:17,929 --> 00:34:20,781
We'll see that that might not necessarily be a bad thing.
我们会看到，这可能不一定是坏事。

693
00:34:20,781 --> 00:34:22,489
In fact, Python just simplifies the world
事实上，Python 只是简化了世界

694
00:34:22,489 --> 00:34:24,590
into two different types of variables but gets
分成两种不同类型的变量，但它

695
00:34:24,590 --> 00:34:26,460
out of the business of you having to decide,
让你不必再决定，

696
00:34:26,460 --> 00:34:30,923
do you want a small int or a large int or something along those lines?
你想要一个小的 int 还是一个大的 int，或者类似的东西？

697
00:34:30,923 --> 00:34:32,340
Well, let me go ahead and do this.
好吧，让我继续做这个。

698
00:34:32,340 --> 00:34:34,670
Let me switch back over to VS Code here.
让我切换回 VS Code。

699
00:34:34,670 --> 00:34:37,940
And why don't we actually try to play around with some calculations using
我们为什么不尝试用一些计算来玩玩

700
00:34:37,940 --> 00:34:39,590
these data types and more?
这些数据类型以及更多？

701
00:34:39,590 --> 00:34:42,500
Let me go ahead and propose that we implement,
让我提议我们实现，

702
00:34:42,500 --> 00:34:48,690
like we did way back in week 1, a simple calculator.
就像我们在第一周做的那样，一个简单的计算器。

703
00:34:48,690 --> 00:34:51,889
So let me do this-- code of calculator.c.
所以让我这样做——calculator.c 的代码。

704
00:34:51,889 --> 00:34:55,670
So I'm indeed going to do this in C first, just so
所以，我确实要先用 C 做这个，这样

705
00:34:55,670 --> 00:34:58,470
that we have a similar example at hand.
我们手边就有一个类似的例子。

706
00:34:58,470 --> 00:35:02,940
So I'm going to include standard io.h here at the top.
所以，我要在顶部包含 standard io.h。

707
00:35:02,940 --> 00:35:06,370
I'm going to go ahead and do int main(void).
我将继续执行 int main(void)。

708
00:35:06,370 --> 00:35:10,270
Inside of main(), I'm going to go ahead and declare a variable called x and set
在 main() 内部，我将继续声明一个名为 x 的变量并设置

709
00:35:10,270 --> 00:35:15,190
that equal to get_int(), and I'm going to prompt the user for that value x.
它等于 get_int()，我将提示用户输入该值 x。

710
00:35:15,190 --> 00:35:18,550
But if I'm using get_int(), recall that actually is from the CS50 library.
但如果我使用 get_int()，请记住，它实际上来自 CS50 库。

711
00:35:18,550 --> 00:35:22,000
So in C, I'm going to need cs50.h, still, for this example.
所以在 C 中，对于这个例子，我仍然需要 cs50.h。

712
00:35:22,000 --> 00:35:24,290
But back in week 1, I then did something else.
但是，回到第一周，我做了另一件事。

713
00:35:24,290 --> 00:35:28,240
I then said, give me another variable called y, set that equal to get_int(),
然后我说，再给我一个名为 y 的变量，将其设置为 get_int()，

714
00:35:28,240 --> 00:35:31,960
and set that equal to that-- pass in that prompt there.
并将其设置为那个 - 将提示传递进去。

715
00:35:31,960 --> 00:35:34,210
And then, lastly, let's just do something super simple
最后，让我们做一些非常简单的事情

716
00:35:34,210 --> 00:35:35,900
like add two numbers together.
比如将两个数字加在一起。

717
00:35:35,900 --> 00:35:37,480
So in C, I'll use printf().
所以在 C 中，我会使用 printf()。

718
00:35:37,480 --> 00:35:41,860
I'm going to go ahead and do %i backslash n as a placeholder.
我会用 %i 反斜杠 n 作为占位符。

719
00:35:41,860 --> 00:35:44,380
And then I'm just going to plug in x + y.
然后，我只需要将 x + y 插入进去。

720
00:35:44,380 --> 00:35:48,460
So all of that was in C. So it was a decent number of lines of code
所以所有这些都在 C 中。所以它有相当多的代码行

721
00:35:48,460 --> 00:35:50,650
to accomplish that task, only three of which
来完成这项任务，其中只有三行

722
00:35:50,650 --> 00:35:53,200
are really the logical part of my program.
才是程序的逻辑部分。

723
00:35:53,200 --> 00:35:55,640
These are the three that we're really interested in.
这三行才是我们真正感兴趣的。

724
00:35:55,640 --> 00:35:59,980
So let me instead now do this, code of calculator.py,
所以现在让我做这件事，calculator.py 的代码，

725
00:35:59,980 --> 00:36:01,510
which is going to give me a new tab.
这将给我一个新标签。

726
00:36:01,510 --> 00:36:05,540
Let me just drag it over to the right so I can view these side by side.
让我把它拖到右边，这样我就可以并排查看它们。

727
00:36:05,540 --> 00:36:07,790
And in calculator.py, let's do this.
在 calculator.py 中，让我们这样做。

728
00:36:07,790 --> 00:36:11,910
From the CS50 library, import the get_int() function,
从 CS50 库中导入 get_int() 函数，

729
00:36:11,910 --> 00:36:13,430
which is also available.
它也是可用的。

730
00:36:13,430 --> 00:36:16,670
Then let's go ahead and create a variable called x and set it equal
然后，让我们创建一个名为 x 的变量并将其设置为

731
00:36:16,670 --> 00:36:20,180
to the return value of get_int(), passing in the same prompt--
get_int() 的返回值，传入相同的提示 -

732
00:36:20,180 --> 00:36:22,220
no semicolon, no mention of int.
没有分号，没有提到 int。

733
00:36:22,220 --> 00:36:25,040
Let's then create a second variable y, set it equal to get_int(),
然后让我们创建一个第二个变量 y，将其设置为 get_int()，

734
00:36:25,040 --> 00:36:29,970
prompt the user for y, as before, no int, explicitly, no semicolon.
提示用户输入 y，如前所述，没有 int，明确地，没有分号。

735
00:36:29,970 --> 00:36:33,620
And now let's just go ahead and print out x + y.
现在让我们直接打印出 x + y。

736
00:36:33,620 --> 00:36:37,070
So it turns out that the print() function in Python is further flexible,
事实证明，Python 中的 print() 函数更加灵活，

737
00:36:37,070 --> 00:36:39,050
that you don't need these format strings.
你不需要这些格式字符串。

738
00:36:39,050 --> 00:36:42,470
If you want to print out an integer, just pass it an integer,
如果你想打印一个整数，只需传入一个整数，

739
00:36:42,470 --> 00:36:45,750
even if that integer is the sum of two other integers.
即使该整数是另外两个整数的和。

740
00:36:45,750 --> 00:36:48,180
So it just sort of works as you might expect.
所以它就像你预期的那样工作。

741
00:36:48,180 --> 00:36:50,060
So let me go down into my terminal here.
所以让我进入我的终端。

742
00:36:50,060 --> 00:36:52,580
Let me run python of calculator.py.
让我运行 calculator.py 的 python。

743
00:36:52,580 --> 00:36:54,830
And when I hit Enter, I'm prompted for x.
当我按下 Enter 键时，它会提示我输入 x。

744
00:36:54,830 --> 00:36:55,730
Let's do 1.
让我们输入 1。

745
00:36:55,730 --> 00:36:56,630
I'm prompted for y.
它会提示我输入 y。

746
00:36:56,630 --> 00:36:57,530
Let's do 2.
让我们输入 2。

747
00:36:57,530 --> 00:37:02,070
And voila, I should see 3 as the result--
瞧，我应该看到结果是 3 -

748
00:37:02,070 --> 00:37:04,800
so no actual surprises there.
所以没有真正的意外。

749
00:37:04,800 --> 00:37:07,948
But let me go ahead and, you know what?
但是让我继续，你知道吗？

750
00:37:07,948 --> 00:37:09,740
Let's take away this training wheel, right?
让我们去掉这个训练轮，对吧？

751
00:37:09,740 --> 00:37:12,210
We don't want to keep introducing CS50-specific things.
我们不想一直介绍 CS50 特定的东西。

752
00:37:12,210 --> 00:37:14,960
So suppose we didn't give you get_int().
假设我们没有给你 get_int()。

753
00:37:14,960 --> 00:37:18,505
Well, it turns out that get_int() is still doing a bit of help for you,
好吧，事实证明 get_int() 仍然在帮助你，

754
00:37:18,505 --> 00:37:21,380
even though get_string() was kind of a throwaway and we could replace
即使 get_string() 是一种一次性的，我们可以用

755
00:37:21,380 --> 00:37:22,590
get_string() with input().
input() 替换 get_string()。

756
00:37:22,590 --> 00:37:24,530
So let's try this same idea.
所以让我们尝试一下这个想法。

757
00:37:24,530 --> 00:37:28,880
Let's go ahead and prompt the user for input for both x and y using
让我们使用

758
00:37:28,880 --> 00:37:33,410
the input() function in Python instead of get_int() from CS50.
Python 中的 input() 函数而不是 CS50 中的 get_int()，来提示用户输入 x 和 y。

759
00:37:33,410 --> 00:37:37,280
Let me go ahead and rerun Python of calculator.py and hit Enter.
让我继续重新运行 calculator.py 的 Python 并按下 Enter。

760
00:37:37,280 --> 00:37:38,330
So far, so good.
到目前为止，一切顺利。

761
00:37:38,330 --> 00:37:39,470
Let me type in 1.
让我输入 1。

762
00:37:39,470 --> 00:37:40,490
Let me type in 2.
让我输入 2。

763
00:37:40,490 --> 00:37:43,230
And what answer should we see?
我们应该看到什么答案？

764
00:37:43,230 --> 00:37:46,260
Hopefully still 3, but nope.
希望仍然是 3，但不是。

765
00:37:46,260 --> 00:37:51,570
Now the answer is 12, or is it?
现在答案是 12，还是？

766
00:37:51,570 --> 00:37:54,233
Why am I seeing 12 and not 3?
为什么我看到的是 12 而不是 3？

767
00:37:54,233 --> 00:37:55,650
AUDIENCE: [INAUDIBLE] two strings.
观众：[听不清] 两个字符串。

768
00:37:55,650 --> 00:37:56,400
DAVID MALAN: Yeah.
大卫·马兰：是的。

769
00:37:56,400 --> 00:37:59,230
So it's actually concatenating what seem to be two strings.
所以它实际上是连接了两个看似是字符串的东西。

770
00:37:59,230 --> 00:38:01,980
So if we actually read the documentation for the input() function,
所以如果我们实际阅读 input() 函数的文档，

771
00:38:01,980 --> 00:38:04,530
it's behaving exactly as it's supposed to.
它的行为完全符合预期。

772
00:38:04,530 --> 00:38:06,810
It is getting input from the user from their keyboard.
它正在从用户的键盘获取输入。

773
00:38:06,810 --> 00:38:09,840
But anything you type at the keyboard is effectively a string.
但是你在键盘上输入的任何东西实际上都是一个字符串。

774
00:38:09,840 --> 00:38:12,390
Even if some of the symbols happen to look like or actually
即使某些符号碰巧看起来像或实际上

775
00:38:12,390 --> 00:38:15,780
be decimal numbers, they're still going to come to you as strings.
是十进制数，它们仍然会作为字符串传递给你。

776
00:38:15,780 --> 00:38:20,130
And so x is a string, a.k.a., str, y is a str,
所以 x 是一个字符串，也就是 str，y 也是一个 str，

777
00:38:20,130 --> 00:38:24,660
and we've already seen that if you use plus in between two strings, or strs,
我们已经看到，如果你在两个字符串或 strs 之间使用加号，

778
00:38:24,660 --> 00:38:27,390
you're going to get concatenation, not addition.
你将得到连接，而不是加法。

779
00:38:27,390 --> 00:38:32,590
So you're not seeing 12 as much as you're seeing 1 2, not 12.
所以你看到的不是 12，而是 1 2，而不是 12。

780
00:38:32,590 --> 00:38:33,820
So how can we fix this?
那么我们该如何解决这个问题？

781
00:38:33,820 --> 00:38:38,040
Well, in C, we had this technique where we could cast one thing to another
好吧，在 C 中，我们有这种技术，我们可以将一个东西转换为另一个东西

782
00:38:38,040 --> 00:38:40,710
by just putting int in parentheses, for instance.
例如，只需将 int 放入括号中。

783
00:38:40,710 --> 00:38:42,880
In Python, things are a little higher-level such
在 Python 中，事物级别更高一些

784
00:38:42,880 --> 00:38:46,060
that you can't quite get away with just casting
以至于你不能仅仅通过强制转换就解决问题

785
00:38:46,060 --> 00:38:51,280
one thing to another because a string, recall, is not
一个东西到另一个东西，因为一个字符串，回忆一下，不是

786
00:38:51,280 --> 00:38:53,080
the same thing as a char.
与 char 相同。

787
00:38:53,080 --> 00:38:55,450
A string has zero or more characters.
一个字符串有零个或多个字符。

788
00:38:55,450 --> 00:38:56,890
A char always has one.
一个 char 始终只有一个。

789
00:38:56,890 --> 00:39:00,490
And in C, there was a perfect mapping between single characters
而在 C 中，单个字符之间存在完美的映射

790
00:39:00,490 --> 00:39:05,230
and single numbers in decimal, like 65 for capital A.
以及十进制的单个数字，例如 65 代表大写字母 A。

791
00:39:05,230 --> 00:39:09,430
But in Python, we can do something somewhat similar and not so much cast
但在 Python 中，我们可以做一些类似的事情，而不是强制转换

792
00:39:09,430 --> 00:39:15,510
but convert this input() to an int and convert this input() to an int.
而是将这个 input() 转换为 int，并将这个 input() 转换为 int。

793
00:39:15,510 --> 00:39:17,260
So just like in C, you can nest functions.
所以就像在 C 中一样，你可以嵌套函数。

794
00:39:17,260 --> 00:39:19,750
You can call one function and pass its output
你可以调用一个函数，并将它的输出

795
00:39:19,750 --> 00:39:21,700
as the input to another function.
作为另一个函数的输入。

796
00:39:21,700 --> 00:39:25,390
And this now will convert x and y to integers.
现在这将把 x 和 y 转换为整数。

797
00:39:25,390 --> 00:39:28,780
And so now plus is going to behave as you should-- as you would expect.
所以现在加号将按照你应该的方式，也就是你期望的方式工作。

798
00:39:28,780 --> 00:39:33,010
Let me rerun python of calculator.py, type in 1, type in 2, and now
让我重新运行 calculator.py 的 python，输入 1，输入 2，现在

799
00:39:33,010 --> 00:39:37,150
we're back to seeing 3 as the result. If this is a little unclear,
我们又看到结果是 3 了。如果这一点不太清楚，

800
00:39:37,150 --> 00:39:39,190
this nesting, let me do this one other way.
这种嵌套，让我用另一种方式来做。

801
00:39:39,190 --> 00:39:43,360
Instead of just passing input() output into int,
而不是简单地将 input() 的输出传递给 int，

802
00:39:43,360 --> 00:39:45,760
I could also more pedantically do this.
我也可以更严格地这样做。

803
00:39:45,760 --> 00:39:52,000
x should actually equal int(x), y should actually equal int(y).
x 实际上应该等于 int(x)，y 实际上应该等于 int(y)。

804
00:39:52,000 --> 00:39:54,200
This would be the exact same effect.
这将产生完全相同的效果。

805
00:39:54,200 --> 00:39:57,340
It's just two extra lines where it's not really necessary.
它只是两行额外的代码，实际上并不必要。

806
00:39:57,340 --> 00:39:58,540
But that would work fine.
但这样也能正常工作。

807
00:39:58,540 --> 00:40:01,270
If you don't like that approach, we could even do it inline.
如果你不喜欢这种方法，我们甚至可以在一行代码中完成。

808
00:40:01,270 --> 00:40:05,420
We could actually convert x to an int and y to an int.
我们实际上可以将 x 转换为 int，并将 y 转换为 int。

809
00:40:05,420 --> 00:40:05,920
Why?
为什么？

810
00:40:05,920 --> 00:40:10,180
Well, int, I-N-T, in the context of Python itself, is a function.
嗯，int，I-N-T，在 Python 本身中，是一个函数。

811
00:40:10,180 --> 00:40:13,570
And it takes as input here a string, or str,
它将字符串（或str）作为输入，

812
00:40:13,570 --> 00:40:19,550
and returns to you the numeric, the integral equivalent-- so similar idea,
并返回给您数值，即整数等价物——所以概念类似，

813
00:40:19,550 --> 00:40:20,870
but it's actually a function.
但它实际上是一个函数。

814
00:40:20,870 --> 00:40:23,320
So all of the syntax that I've been tinkering with here
所以，我一直在这里调试的语法

815
00:40:23,320 --> 00:40:27,800
is sort of fundamentally the same as it would be in C. But in this case,
从根本上来说与C语言中的语法相同。但在这种情况下，

816
00:40:27,800 --> 00:40:31,120
we're not casting but converting more specifically.
我们不是类型转换，而是更确切地说是转换。

817
00:40:31,120 --> 00:40:33,830
Well, let me go back to these data types.
好吧，让我回到这些数据类型。

818
00:40:33,830 --> 00:40:37,423
These are some of the data types that are available to us in Python.
这些是Python中可用的数据类型。

819
00:40:37,423 --> 00:40:39,340
It turns out there's a bunch of others as well
事实证明还有很多其他的类型

820
00:40:39,340 --> 00:40:40,923
that we'll start to dabble with today.
我们今天会开始尝试。

821
00:40:40,923 --> 00:40:43,490
You can get a range of values, a list of values,
您可以获得一系列值、一组值，

822
00:40:43,490 --> 00:40:46,960
which is going to be like an array, but better, tuples, which
这就像数组，但更好；元组，它

823
00:40:46,960 --> 00:40:50,920
are kind of like x, comma, y, often, combinations of values that
就像x、逗号、y一样，通常是值的组合，

824
00:40:50,920 --> 00:40:51,940
don't change.
不会改变。

825
00:40:51,940 --> 00:40:57,580
dict for dictionary-- it turns out that in Python, you get dictionaries.
dict代表字典——事实证明，在Python中，您可以获得字典。

826
00:40:57,580 --> 00:40:58,917
You get hash tables for free.
您免费获得哈希表。

827
00:40:58,917 --> 00:41:00,250
They're built into the language.
它们是语言的一部分。

828
00:41:00,250 --> 00:41:02,125
And we already saw that Python also gives you
我们已经看到，Python也为您提供了

829
00:41:02,125 --> 00:41:04,060
a data type known as a set, which is just
一种称为集合的数据类型，它只是一个

830
00:41:04,060 --> 00:41:06,400
a collection of values that gives you--
值的集合，它为您提供——

831
00:41:06,400 --> 00:41:08,090
gets rid of any duplicates for you.
为您清除所有重复项。

832
00:41:08,090 --> 00:41:11,830
And as we saw briefly in speller-- and we'll play more with these ideas soon--
我们在拼写器中简单地看到了这一点——我们很快就会更多地尝试这些概念——

833
00:41:11,830 --> 00:41:15,340
it's going to actually be pretty darn easy to get values or check
实际上，获取或检查这些数据类型中的值会非常容易。

834
00:41:15,340 --> 00:41:17,960
for values in those there data types.
在这些数据类型中检查值。

835
00:41:17,960 --> 00:41:22,510
So that in C, we were able to get input easily, we had all of these functions.
所以在C语言中，我们可以轻松地获取输入，我们拥有所有这些函数。

836
00:41:22,510 --> 00:41:26,253
In the CS50 library for Python, we're only going to give you these instead.
在Python的CS50库中，我们将只提供这些函数。

837
00:41:26,253 --> 00:41:27,670
They're going to be the same name.
它们将具有相同的名称。

838
00:41:27,670 --> 00:41:30,670
So it's still get_string(), not get_str, because we wanted the functions
所以仍然是get_string()，而不是get_str，因为我们希望函数

839
00:41:30,670 --> 00:41:31,840
to remain named the same.
保持相同的名称。

840
00:41:31,840 --> 00:41:34,690
But get_float(), get_int(), get_string() all exist.
但get_float()、get_int()、get_string()都存在。

841
00:41:34,690 --> 00:41:37,280
But, again, get_string() is not all that useful.
但是，再次强调，get_string()并不是那么有用。

842
00:41:37,280 --> 00:41:41,980
But get_int() and get_float() actually are.
但get_int()和get_float()实际上很有用。

843
00:41:41,980 --> 00:41:42,580
Why?
为什么？

844
00:41:42,580 --> 00:41:44,830
Well, let me go back to VS Code here.
好吧，让我回到VS Code这里。

845
00:41:44,830 --> 00:41:47,920
And let me go back to the second version of this program,
让我回到这个程序的第二个版本，

846
00:41:47,920 --> 00:41:54,980
whereby I proactively converted each of these return values to integers.
在这个版本中，我主动地将这些返回值都转换为整数。

847
00:41:54,980 --> 00:41:59,020
So recall that this is the solution to the 1 2 problem.
所以，回想一下，这是1 2问题的解决方案。

848
00:41:59,020 --> 00:42:03,550
And to be clear, if I run python of calculator.py and input 1 and 2,
明确地说，如果我运行calculator.py并输入1和2，

849
00:42:03,550 --> 00:42:06,100
I get back now 3 as expected.
现在我会得到3，如预期。

850
00:42:06,100 --> 00:42:09,850
But what I'm not showing you is that there's still potentially a bug here.
但我没有告诉您的是，这里仍然存在潜在的错误。

851
00:42:09,850 --> 00:42:13,480
Let me run python of calculator.py, and let me just not cooperate.
让我运行calculator.py，并且不配合。

852
00:42:13,480 --> 00:42:15,400
Instead of typing what looks like a number,
而不是输入看起来像数字的东西，

853
00:42:15,400 --> 00:42:19,180
let me actually type something that's clearly a string, like cat.
让我输入明显是字符串的东西，比如“cat”。

854
00:42:19,180 --> 00:42:22,570
And unfortunately, we're going to see the first of our errors,
不幸的是，我们将看到我们的第一个错误，

855
00:42:22,570 --> 00:42:23,938
the first of our runtime errors.
第一个运行时错误。

856
00:42:23,938 --> 00:42:26,230
And this, like in C, is going to look cryptic at first.
就像C语言一样，一开始看起来很神秘。

857
00:42:26,230 --> 00:42:28,330
But this is generally known as a traceback, where
但它通常被称为回溯，它

858
00:42:28,330 --> 00:42:31,523
it's going to trace back for you everything your program just did,
它将为你跟踪回溯程序刚刚执行的所有操作，

859
00:42:31,523 --> 00:42:33,190
even though this one's relatively short.
即使这段代码相对较短。

860
00:42:33,190 --> 00:42:36,915
And you'll see that calculator.py, line 1--
你会看到 calculator.py 文件，第一行——

861
00:42:36,915 --> 00:42:39,040
I didn't even get very far before there's an error.
我还没有执行多远就出现了错误。

862
00:42:39,040 --> 00:42:42,300
And then, with all of these carrot symbols here, this is a problem.
然后，这里所有这些尖括号符号都表示存在问题。

863
00:42:42,300 --> 00:42:42,810
Why?
为什么？

864
00:42:42,810 --> 00:42:47,370
invalid literal for int() function with base 10, quote unquote, 'cat.'
“使用基数 10 为 int() 函数提供的无效文字，引号内的文字是 'cat'。”

865
00:42:47,370 --> 00:42:49,147
Again, just like in C, It's very arcane.
同样，就像在 C 语言中一样，这很深奥。

866
00:42:49,147 --> 00:42:51,480
It's hard to understand this the first time you read it.
第一次读到它时很难理解。

867
00:42:51,480 --> 00:42:55,920
But what it's trying to tell me is that cat is not an integer.
但它试图告诉我的是，“cat”不是一个整数。

868
00:42:55,920 --> 00:42:59,850
And therefore, the int() function cannot convert it to an integer for you.
因此，int() 函数无法将其转换为整数。

869
00:42:59,850 --> 00:43:01,920
We're going to leave this problem alone for now.
我们现在先放着这个问题。

870
00:43:01,920 --> 00:43:04,950
But this is why, again, get_int()'s looking kind of good,
但这就是为什么，get_int() 看起来还不错，

871
00:43:04,950 --> 00:43:07,980
and get_float()'s looking kind of good because those functions from
get_float() 也看起来还不错，因为来自

872
00:43:07,980 --> 00:43:12,970
CS50's library will deal with these kinds of problems for you.
CS50 库的这些函数将为你处理这些问题。

873
00:43:12,970 --> 00:43:14,970
Now, just so you've seen it, there's another way
现在，为了让你了解，还有另一种方法

874
00:43:14,970 --> 00:43:17,370
to import functions from these things.
从这些文件中导入函数。

875
00:43:17,370 --> 00:43:20,430
If you were to use, for instance, in a program, get_float(), get_int(),
例如，如果你要在程序中使用 get_float()，get_int()，

876
00:43:20,430 --> 00:43:24,180
and get_string(), you don't need to do three separate lines like this.
和 get_string()，你不需要像这样写三行单独的代码。

877
00:43:24,180 --> 00:43:27,420
You can actually separate them a little more cleanly with commas.
实际上，你可以用逗号更简洁地将它们分开。

878
00:43:27,420 --> 00:43:33,240
And, in fact, if I go back to a version of this program here in VS Code whereby
事实上，如果我回到这个程序在 VS Code 中的一个版本，在这里

879
00:43:33,240 --> 00:43:35,710
I actually do use the get_int() function--
我确实使用了 get_int() 函数——

880
00:43:35,710 --> 00:43:39,810
so let me actually get rid of all this and use get_int() as before.
所以让我实际上去掉所有这些代码，就像以前一样使用 get_int()。

881
00:43:39,810 --> 00:43:43,000
Let me get rid of all this and use get_int() as before.
让我去掉所有这些代码，就像以前一样使用 get_int()。

882
00:43:43,000 --> 00:43:48,640
Previously, the way I did this was by saying from cs50 import get_int()
以前，我使用的方式是说 from cs50 import get_int()

883
00:43:48,640 --> 00:43:51,200
if you know in advance what function you want to use.
如果你事先知道要使用哪个函数。

884
00:43:51,200 --> 00:43:54,400
But suppose, for whatever reason, you already have your own function named
但假设，由于某种原因，你已经有了自己的名为

885
00:43:54,400 --> 00:43:57,940
get_int(), and therefore, it would collide with CS50's own,
get_int() 的函数，因此，它将与 CS50 的函数冲突，

886
00:43:57,940 --> 00:44:01,400
you can avoid that issue, too, by just using that first statement we saw
你也可以通过使用我们之前看到的第一个语句来避免这个问题

887
00:44:01,400 --> 00:44:01,900
earlier.
更早。

888
00:44:01,900 --> 00:44:03,520
Just import the library itself.
只需导入库本身。

889
00:44:03,520 --> 00:44:06,520
Don't specify explicitly which functions you're going to use.
不要明确指定要使用的函数。

890
00:44:06,520 --> 00:44:09,850
But thereafter-- and you could not do this in C--
但是之后——你不能在 C 语言中这样做——

891
00:44:09,850 --> 00:44:14,950
you could specify cs50.get_int(), cs50.get_int(),
你可以指定 cs50.get_int()，cs50.get_int()，

892
00:44:14,950 --> 00:44:19,450
in order to go into the library, access its get_int() function, and therefore,
以便进入库，访问它的 get_int() 函数，因此，

893
00:44:19,450 --> 00:44:22,630
it doesn't matter if you or any number of other people wrote
无论你或其他任何人是否写了

894
00:44:22,630 --> 00:44:25,360
an identically-named function called get_int().
一个名为 get_int() 的同名函数。

895
00:44:25,360 --> 00:44:28,660
You're using here, clearly, CS50's own.
你在这里使用的是 CS50 自己的函数。

896
00:44:28,660 --> 00:44:34,180
So this is, again, just more ways to achieve the same solution
所以，这又是另一种实现相同解决方案的方法

897
00:44:34,180 --> 00:44:36,410
but with different syntax.
但使用了不同的语法。

898
00:44:36,410 --> 00:44:36,910
All right.
好的。

899
00:44:36,910 --> 00:44:44,030
Any questions about any of this syntax or features thus far?
到目前为止，对任何语法或功能有任何疑问吗？

900
00:44:44,030 --> 00:44:44,530
No?
没有吗？

901
00:44:44,530 --> 00:44:45,030
All right.
好的。

902
00:44:45,030 --> 00:44:48,010
Well, how about maybe another example here,
那么，这里再举个例子，

903
00:44:48,010 --> 00:44:52,450
whereby we revisit conditionals, which was the way of implementing
我们重新回顾一下条件语句，这是实现的一种方式。

904
00:44:52,450 --> 00:44:55,510
do this thing or this thing, sort of proverbial forks in the road.
做这件事或那件事，就像谚语中说的岔路口。

905
00:44:55,510 --> 00:44:58,420
In Scratch, recall, we might use building blocks like these
还记得 Scratch 中，我们可以使用这样的积木

906
00:44:58,420 --> 00:45:01,990
to just check, is x less than y, and if so, say so.
来检查，x 是否小于 y，如果是，就说出来。

907
00:45:01,990 --> 00:45:04,400
In C, this code looked like this.
在 C 中，这段代码看起来是这样的。

908
00:45:04,400 --> 00:45:07,210
And notice that we had parentheses around the x and the y.
请注意，我们在 x 和 y 周围加了括号。

909
00:45:07,210 --> 00:45:11,380
We had curly braces, even though I did disclaim that for single lines of code,
我们有花括号，即使我确实声明了，对于单行代码，

910
00:45:11,380 --> 00:45:13,160
you can actually omit the curly braces.
实际上可以省略花括号。

911
00:45:13,160 --> 00:45:15,790
But stylistically, we always include them in CS50's code.
但从风格上来说，我们始终在 CS50 的代码中包含它们。

912
00:45:15,790 --> 00:45:18,250
But you have the backslash n and the semicolon.
但你有反斜杠 n 和分号。

913
00:45:18,250 --> 00:45:21,770
In a moment, you're about to see the Python equivalent of this,
一会儿，你将看到这段代码的 Python 等价物，

914
00:45:21,770 --> 00:45:23,270
which is almost the same.
它几乎一样。

915
00:45:23,270 --> 00:45:24,760
It's just a little nicer.
只是它稍微好一点。

916
00:45:24,760 --> 00:45:28,160
This, then, is the Python equivalent thereof.
然后，这就是它的 Python 等价物。

917
00:45:28,160 --> 00:45:32,840
So what's different at a glance here, just to be clear?
那么，一目了然，这里有什么不同，为了更清楚起见？

918
00:45:32,840 --> 00:45:33,620
What's different?
有什么不同？

919
00:45:33,620 --> 00:45:34,475
Yeah?
是吗？

920
00:45:34,475 --> 00:45:35,350
AUDIENCE: [INAUDIBLE]
观众：[听不清]

921
00:45:35,350 --> 00:45:38,440
DAVID MALAN: So the conditional is not in parentheses.
所以条件语句不在括号里。

922
00:45:38,440 --> 00:45:42,230
You can use parentheses, especially if, logically, you need to group things.
你可以使用括号，尤其是在逻辑上，你需要将某些东西分组的时候。

923
00:45:42,230 --> 00:45:45,160
But if you don't need them, don't use them is Python's mindset.
但如果你不需要它们，就不要用它们，这是 Python 的理念。

924
00:45:45,160 --> 00:45:46,780
What else has changed here?
这里还有什么变化？

925
00:45:46,780 --> 00:45:47,500
Yeah?
是吗？

926
00:45:47,500 --> 00:45:48,700
AUDIENCE: No curly brackets.
观众：没有花括号。

927
00:45:48,700 --> 00:45:51,620
DAVID MALAN: No curly braces, yeah, so no curly braces around this.
没有花括号，是的，所以这里没有花括号。

928
00:45:51,620 --> 00:45:55,250
And even though it's one line of code, you just don't use curly braces at all.
即使它只有一行代码，你也根本不用花括号。

929
00:45:55,250 --> 00:45:55,750
Why?
为什么？

930
00:45:55,750 --> 00:46:00,230
Because in Python, indentation is actually really, really important.
因为在 Python 中，缩进实际上非常非常重要。

931
00:46:00,230 --> 00:46:02,410
And we know from office hours and problem sets
我们从办公室时间和作业集中知道

932
00:46:02,410 --> 00:46:05,200
occasionally that if you forgot to run style50
有时，如果你忘记运行 style50

933
00:46:05,200 --> 00:46:07,870
or you didn't manually format your code beautifully,
或者你没有手动格式化你的代码使其美观，

934
00:46:07,870 --> 00:46:10,960
C is not actually going to care if everything is aligned on the left.
C 实际上并不关心所有内容是否都左对齐。

935
00:46:10,960 --> 00:46:14,830
If you never once hit the Tab character or the space bar,
如果你从未按下过 Tab 键或空格键，

936
00:46:14,830 --> 00:46:17,770
C, or specifically, clang, isn't really going to care.
C，或者更确切地说，clang，实际上并不关心。

937
00:46:17,770 --> 00:46:19,722
But your teaching fellow, your TA, is going
但你的助教，你的助教，将要

938
00:46:19,722 --> 00:46:22,930
to care, or your colleague in the real world, because your code's just a mess
关心，或者你现实世界中的同事，因为你的代码只是一团糟

939
00:46:22,930 --> 00:46:23,920
and hard to read.
而且难以阅读。

940
00:46:23,920 --> 00:46:29,380
Python, though-- because you are not the only ones in the world that might have
不过，Python-- 因为你并不是世界上唯一一个可能会有

941
00:46:29,380 --> 00:46:31,450
bad habits when it comes to style--
关于风格的坏习惯的人--

942
00:46:31,450 --> 00:46:34,490
Python as a language decided, that's it.
Python 作为一门语言决定了，就这样。

943
00:46:34,490 --> 00:46:37,890
Everyone has to indent in order for their code to even work.
每个人都必须缩进才能让他们的代码正常工作。

944
00:46:37,890 --> 00:46:40,470
So the convention as Python is to use for spaces--
所以 Python 的惯例是使用 4 个空格--

945
00:46:40,470 --> 00:46:43,850
so 1, 2, 3, 4, or hit Tab and let it automatically convert to the same,
所以 1、2、3、4，或者按下 Tab 键，让它自动转换为相同的值，

946
00:46:43,850 --> 00:46:47,960
and use a colon instead of the curly braces,
并使用冒号代替花括号，

947
00:46:47,960 --> 00:46:50,480
for instance, to make clear what is associated
例如，为了清楚地表明什么与

948
00:46:50,480 --> 00:46:53,000
with this particular conditional.
这个特定的条件语句相关。

949
00:46:53,000 --> 00:46:55,310
We can omit, though, the backslash n per before.
不过，我们可以像之前一样省略反斜杠 n。

950
00:46:55,310 --> 00:46:56,630
We can omit the semicolon.
我们可以省略分号。

951
00:46:56,630 --> 00:46:59,750
But this is essentially the Python version thereof.
但这本质上是它的 Python 版本。

952
00:46:59,750 --> 00:47:03,560
Here in C-- in Scratch, if you wanted to do an if-else,
在 C 中-- 在 Scratch 中，如果你想做一个 if-else 语句，

953
00:47:03,560 --> 00:47:08,000
like we did back in week 0, in C, It's very similar to the if, except you add
就像我们在第 0 周做的那样，在 C 中，它与 if 非常相似，除了你需要添加

954
00:47:08,000 --> 00:47:11,810
the else clause and write out an additional printf() like this.
else 子句并像这样写出另一个 printf()。

955
00:47:11,810 --> 00:47:13,760
In Python, we can tighten this up.
在 Python 中，我们可以简化它。

956
00:47:13,760 --> 00:47:16,730
if x less than y, colon, that's exactly the same.
如果 x 小于 y，冒号，这完全一样。

957
00:47:16,730 --> 00:47:17,810
First line's the same.
第一行相同。

958
00:47:17,810 --> 00:47:21,680
All we're doing now is adding an else and the second print line here.
我们现在所做的只是在这里添加一个 else 和第二行打印语句。

959
00:47:21,680 --> 00:47:22,640
How about in Scratch?
在 Scratch 中呢？

960
00:47:22,640 --> 00:47:26,060
If we had a three-way fork in the road-- if, else, if, else.
如果我们有一条三岔路口 - if、else、if、else。

961
00:47:26,060 --> 00:47:29,750
In C, it looked pretty much like that-- if, else, if, else.
在 C 中，它看起来很像这样 - if、else、if、else。

962
00:47:29,750 --> 00:47:31,820
In Python, we can tighten this up.
在 Python 中，我们可以简化它。

963
00:47:31,820 --> 00:47:34,170
And this is not a typo.
这不是打字错误。

964
00:47:34,170 --> 00:47:38,300
What jumps out at you as weird but you got to just get used to it?
有什么让你觉得奇怪但你必须习惯的东西吗？

965
00:47:38,300 --> 00:47:39,020
Yeah?
是吗？

966
00:47:39,020 --> 00:47:39,820
AUDIENCE: elif.
观众：elif。

967
00:47:39,820 --> 00:47:40,570
DAVID MALAN: elif.
大卫·马兰：elif。

968
00:47:40,570 --> 00:47:44,750
And honestly, years later, I still can't remember if it's elif or elsif
说实话，几年过去了，我仍然记不住是 elif 还是 elsif

969
00:47:44,750 --> 00:47:49,332
because other languages actually do E-L-S-I-F.
因为其他语言实际上使用的是 E-L-S-I-F。

970
00:47:49,332 --> 00:47:52,040
and now I probably now biased all of you to now questioning this.
现在我可能让你们所有人都开始质疑这个问题了。

971
00:47:52,040 --> 00:47:53,390
But it's elif in Python.
但在 Python 中是 elif。

972
00:47:53,390 --> 00:47:55,200
E-L-I-F is not a typo.
E-L-I-F 不是打字错误。

973
00:47:55,200 --> 00:47:58,520
It's in the spirit of let's just save ourselves some keystrokes.
这是为了节省按键次数。

974
00:47:58,520 --> 00:48:03,950
So elif is identical to elsif, but it's a little tighter to type it this way.
所以 elif 与 elsif 相同，但这样打起来更紧凑。

975
00:48:03,950 --> 00:48:04,670
All right.
好的。

976
00:48:04,670 --> 00:48:09,080
So if we now have this ability to express conditionals,
所以，如果我们现在有了表达条件语句的能力，

977
00:48:09,080 --> 00:48:11,250
what can we actually do with them?
我们实际上可以用它们做什么？

978
00:48:11,250 --> 00:48:13,530
Well, let me go over to VS Code here.
好吧，让我到 VS Code 中去看看。

979
00:48:13,530 --> 00:48:18,320
And let me propose that we revisit maybe another program from before,
我建议我们再看一个之前的程序，

980
00:48:18,320 --> 00:48:21,600
where we just compare two integers in particular.
我们只是比较两个特定的整数。

981
00:48:21,600 --> 00:48:22,580
So I'm in VS Code.
所以我在 VS Code 中。

982
00:48:22,580 --> 00:48:25,670
Let me open up a file called, say, compare.py.
让我打开一个文件，例如，compare.py。

983
00:48:25,670 --> 00:48:28,460
And in compare.py, we'll use the CS50 library just
在 compare.py 中，我们将使用 CS50 库，

984
00:48:28,460 --> 00:48:32,220
so we don't risk any errors, like if the human doesn't type an integer.
这样我们就不会冒任何错误的风险，例如，如果用户没有输入一个整数。

985
00:48:32,220 --> 00:48:35,450
So we're going to go ahead and say from cs50 import get_int().
所以，我们将使用 from cs50 import get_int()。

986
00:48:35,450 --> 00:48:39,350
And in compare.py, let's get two variables-- x = get_int(),
在 compare.py 中，让我们获取两个变量 - x = get_int()，

987
00:48:39,350 --> 00:48:41,390
and prompt the user for x.
并提示用户输入 x。

988
00:48:41,390 --> 00:48:42,830
So "What's x?"
所以，“x 是多少？”

989
00:48:42,830 --> 00:48:47,840
To be a bit more verbose, y = get+int("What's y? ")
为了更详细一些，y = get+int("y 是多少？")

990
00:48:47,840 --> 00:48:50,490
And then let's go ahead and just compare these two values.
然后，让我们比较一下这两个值。

991
00:48:50,490 --> 00:48:55,196
So if x is less than y, then go ahead and print out with print("x is less
所以，如果 x 小于 y，那么使用 print("x 小于

992
00:48:55,196 --> 00:49:01,160
than y"), close quote, elif x is greater than y,
y")，关闭引号，如果 x 大于 y，

993
00:49:01,160 --> 00:49:07,220
go ahead and print out "x is greater than y," close quote, else,
那么使用 "x 大于 y"，关闭引号，否则，

994
00:49:07,220 --> 00:49:12,830
go ahead and print out "x is equal to y"-- so the exact same program,
使用 "x 等于 y" - 所以是完全相同的程序，

995
00:49:12,830 --> 00:49:16,400
but I've added to the mix getting a value of x and y.
但我添加了获取 x 和 y 值的功能。

996
00:49:16,400 --> 00:49:18,650
Let me run python of compare.py.
让我运行 compare.py 的 Python 脚本。

997
00:49:18,650 --> 00:49:19,430
Enter.
输入。

998
00:49:19,430 --> 00:49:23,060
Let's type in 1 for x, 2 for y. x is less than y.
让我们输入 1 作为 x，2 作为 y。x 小于 y。

999
00:49:23,060 --> 00:49:24,500
Let's run it once more.
让我们再运行一次。

1000
00:49:24,500 --> 00:49:26,240
x is 2. y is 1.
x 是 2，y 是 1。

1001
00:49:26,240 --> 00:49:27,440
x is greater than y.
x 大于 y。

1002
00:49:27,440 --> 00:49:30,230
And just for good measure, let's run it a third time. x is 1.
为了确保，让我们再运行一次。x 是 1。

1003
00:49:30,230 --> 00:49:31,400
y is 1.
y 等于 1。

1004
00:49:31,400 --> 00:49:32,690
x is equal to y.
x 等于 y。

1005
00:49:32,690 --> 00:49:37,430
So the code, daresay, works exactly as you would expect, as you would hope.
所以这段代码，我可以肯定地说，它完全按照你预期的那样工作，就像你希望的那样。

1006
00:49:37,430 --> 00:49:40,430
But it turns out that in the world of Python,
但事实证明，在 Python 的世界里，

1007
00:49:40,430 --> 00:49:44,210
we're actually going to get some other behavior that might actually
我们实际上会得到一些其他的行为，这些行为可能实际上

1008
00:49:44,210 --> 00:49:48,620
have been what you expected weeks ago, even though C did not behave this way.
是你几周前所期待的，即使 C 的行为并非如此。

1009
00:49:48,620 --> 00:49:52,610
In the world of Python and in the world of strings, a.k.a.
在 Python 的世界里，以及在字符串的世界里，也就是

1010
00:49:52,610 --> 00:49:57,090
strs, strings actually behave more like you would expect.
strs，字符串实际上更符合你的预期。

1011
00:49:57,090 --> 00:49:58,070
So by that I mean this.
我的意思是这个。

1012
00:49:58,070 --> 00:49:59,780
Let me actually go back to this code.
让我回到这段代码。

1013
00:49:59,780 --> 00:50:05,420
And instead of using integers, let me go ahead and get rid of--
而不是使用整数，让我继续去掉 -

1014
00:50:05,420 --> 00:50:08,670
I could do get_string(), but we said that that's not really necessary.
我可以使用 get_string()，但我们说过那不是真的必要。

1015
00:50:08,670 --> 00:50:11,030
So let's just go ahead and change this to input().
所以让我们直接把这个改成 input()。

1016
00:50:11,030 --> 00:50:11,720
And actually, you know what?
实际上，你知道吗？

1017
00:50:11,720 --> 00:50:12,678
Let's just start fresh.
让我们从头开始。

1018
00:50:12,678 --> 00:50:16,370
Let's give myself a string called s and use the input() function and ask
让我们给自己一个叫做 s 的字符串，并使用 input() 函数，然后询问

1019
00:50:16,370 --> 00:50:17,920
the user for s.
用户输入 s。

1020
00:50:17,920 --> 00:50:21,800
Let's use another variable called t just because it comes after s and use
让我们使用另一个叫做 t 的变量，因为它在 s 之后，并使用

1021
00:50:21,800 --> 00:50:23,870
the input() function to get t.
input() 函数来获取 t。

1022
00:50:23,870 --> 00:50:26,698
Then let's compare if s and t are the same.
然后让我们比较 s 和 t 是否相同。

1023
00:50:26,698 --> 00:50:28,490
Now, a couple of weeks ago, this backfired.
现在，几周前，这反倒起了作用。

1024
00:50:28,490 --> 00:50:32,670
And if I tried to compare two strings for equality, it did not work.
如果我尝试比较两个字符串是否相等，它没有奏效。

1025
00:50:32,670 --> 00:50:38,100
But if I do if s == t, print("Same"), else,
但如果我执行 if s == t，print("Same")，否则，

1026
00:50:38,100 --> 00:50:40,590
let's go ahead and print("Different").
让我们继续打印 "Different"。

1027
00:50:40,590 --> 00:50:44,410
I daresay, in Python, I think this is going to work as you would expect.
我可以肯定地说，在 Python 中，我认为这将按照你预期的那样工作。

1028
00:50:44,410 --> 00:50:48,480
So python of compare.py, let's type in cat and cat.
所以 python 的 compare.py，让我们输入 cat 和 cat。

1029
00:50:48,480 --> 00:50:49,920
And indeed those are the same.
确实它们是相同的。

1030
00:50:49,920 --> 00:50:53,190
Let me run it again and type in cat and dog, respectively.
让我再次运行它，并分别输入 cat 和 dog。

1031
00:50:53,190 --> 00:50:55,140
And those are now different.
现在它们不同了。

1032
00:50:55,140 --> 00:51:00,240
But in C, we always got "Different," "Different," "Different,"
但在 C 中，我们总是得到 "Different"，"Different"，"Different"，

1033
00:51:00,240 --> 00:51:04,500
even if I typed the exact same word, be it cat or dog or high or anything else.
即使我输入完全相同的词，无论是 cat 还是 dog 还是 high，或者其他任何东西。

1034
00:51:04,500 --> 00:51:08,820
Why, in C, were s and t always different a couple of weeks ago?
为什么，在 C 中，几周前 s 和 t 总是不同的？

1035
00:51:08,820 --> 00:51:09,904
Yeah?
对吧？

1036
00:51:09,904 --> 00:51:12,946
AUDIENCE: Because it was comparing the value of the char* with the memory
观众：因为它是比较 char* 的值和内存

1037
00:51:12,946 --> 00:51:13,515
address.
地址。

1038
00:51:13,515 --> 00:51:14,390
DAVID MALAN: Exactly.
DAVID MALAN：没错。

1039
00:51:14,390 --> 00:51:18,570
In C, string is the same thing as char*, which is a memory address.
在 C 中，字符串与 char* 是同一个东西，它是一个内存地址。

1040
00:51:18,570 --> 00:51:20,780
And because we had called get_string() twice,
因为我们两次调用了 get_string()，

1041
00:51:20,780 --> 00:51:24,290
even if the human typed the same things, that was two different chunks of memory
即使人输入了相同的东西，那也是两块不同的内存

1042
00:51:24,290 --> 00:51:25,790
at two different addresses.
在两个不同的地址。

1043
00:51:25,790 --> 00:51:29,090
So those two char*s were just naturally always different,
所以这两个 char* 自然总是不同的，

1044
00:51:29,090 --> 00:51:31,880
even if the characters at those addresses were the same.
即使这些地址上的字符是相同的。

1045
00:51:31,880 --> 00:51:33,802
Python is meant to be higher-level.
Python 旨在成为更高级别的语言。

1046
00:51:33,802 --> 00:51:35,510
It's meant to be a little more intuitive.
它旨在更直观一些。

1047
00:51:35,510 --> 00:51:38,720
It's meant to be more accessible to folks who might not necessarily
它旨在更容易被那些可能不一定

1048
00:51:38,720 --> 00:51:41,310
know or want to understand those lower-level details.
了解或想要了解这些低级细节的人所使用。

1049
00:51:41,310 --> 00:51:48,080
So in Python, ==, even for strings just works the way that you might expect.
所以在 Python 中，==，即使对于字符串，也按照你预期的那样工作。

1050
00:51:48,080 --> 00:51:50,450
But in Python, we can do some other things,
但在 Python 中，我们可以做一些其他的事情，

1051
00:51:50,450 --> 00:51:55,230
too, even more easily than we could in C. Let me go back to VS Code here.
而且比我们在 C 中更容易。让我回到 VS Code 这里。

1052
00:51:55,230 --> 00:51:56,660
Let me close compare.py.
让我关闭 compare.py。

1053
00:51:56,660 --> 00:51:59,720
And let's reimplement a program from C called agree,
让我们重新实现一个来自 C 的名为 agree 的程序，

1054
00:51:59,720 --> 00:52:02,980
which allowed us to prompt the user for a yes/no question, like,
它允许我们提示用户一个是/否问题，例如，

1055
00:52:02,980 --> 00:52:05,730
do you agree to these terms and conditions or something like that.
你是否同意这些条款和条件或类似的东西。

1056
00:52:05,730 --> 00:52:08,660
So let's do code of agree.py.
所以让我们编写 agree.py 的代码。

1057
00:52:08,660 --> 00:52:12,410
And with agree.py, let me go ahead and--
在 agree.py 中，让我继续，

1058
00:52:12,410 --> 00:52:14,680
actually, let's go ahead and do this.
实际上，让我们继续这样做。

1059
00:52:14,680 --> 00:52:18,220
Let me also open up a file that I came with in advance.
让我打开一个我事先准备好的文件。

1060
00:52:18,220 --> 00:52:20,310
And this is called agree.c.
它叫做 agree.c。

1061
00:52:20,310 --> 00:52:23,340
And this is what we did some weeks ago when
几周前我们就是这样做的，

1062
00:52:23,340 --> 00:52:26,860
we wanted to check whether or not the user had agreed to something or not.
我们想要检查用户是否同意某件事。

1063
00:52:26,860 --> 00:52:29,310
So we used the CS50 library, the standard I/O library,
所以我们使用了 CS50 库，标准 I/O 库，

1064
00:52:29,310 --> 00:52:31,290
we had a main() function, we used get_char().
我们有一个 main() 函数，我们使用了 get_char()。

1065
00:52:31,290 --> 00:52:35,460
And then we used == a lot, and we used the two vertical bars,
然后我们使用了 == 很多次，也使用了两个竖线，

1066
00:52:35,460 --> 00:52:36,990
which meant logical or.
这意味着逻辑或。

1067
00:52:36,990 --> 00:52:39,100
Is this thing true or is this thing true?
这东西是真的还是这东西是真的？

1068
00:52:39,100 --> 00:52:42,120
And if so, printf() "Agreed" or "Not agreed."
如果是，则打印 "Agreed" 或 "Not agreed."

1069
00:52:42,120 --> 00:52:42,900
So this worked.
所以这有效。

1070
00:52:42,900 --> 00:52:44,160
And this is relatively simple.
这相对简单。

1071
00:52:44,160 --> 00:52:47,670
That's the right way to do it in C. But notice
这是在 C 中做这件事的正确方法。但请注意

1072
00:52:47,670 --> 00:52:50,400
it was a little verbose because we wanted
它有点冗长，因为我们想要

1073
00:52:50,400 --> 00:52:53,820
to handle uppercase and lowercase, uppercase and lowercase.
处理大小写，大小写。

1074
00:52:53,820 --> 00:52:56,640
So that did start to bloat the code, admittedly.
所以不可否认，这确实让代码膨胀了。

1075
00:52:56,640 --> 00:52:58,770
So let's try to do the same thing in Python
所以让我们尝试在 Python 中做同样的事情

1076
00:52:58,770 --> 00:53:02,530
and see what we can do the same or different-- no pun intended.
看看我们可以做哪些相同或不同的事情——没有双关语。

1077
00:53:02,530 --> 00:53:03,330
So let me do this.
所以让我这样做。

1078
00:53:03,330 --> 00:53:08,160
In agree.py, why don't we try to get input from the user as before?
在 agree.py 中，我们为什么不尝试像以前一样从用户获取输入？

1079
00:53:08,160 --> 00:53:09,450
And I will use--
我会使用——

1080
00:53:09,450 --> 00:53:12,060
I could use get_string(), but I'll go ahead and use input().
我可以使用 get_string()，但我将继续使用 input()。

1081
00:53:12,060 --> 00:53:17,940
So s = input("Do you agree? ") in double quotes.
所以 s = input("Do you agree? ") 用双引号。

1082
00:53:17,940 --> 00:53:21,090
And then let's go ahead and check if s == "Y"--
然后让我们继续检查 s 是否等于 "Y"——

1083
00:53:24,240 --> 00:53:26,980
and it's not vertical bar now, it's actually more readable,
现在不是竖线了，实际上更易读了，

1084
00:53:26,980 --> 00:53:34,830
more English-like-- or s == "y," then go ahead and print out "Agreed" as before,
更像英语——或者 s == "y"，然后继续打印 "Agreed" 就像以前一样，

1085
00:53:34,830 --> 00:53:36,270
elsif--
否则——

1086
00:53:36,270 --> 00:53:43,710
see, I did it there-- elif s == "N" or s == "n,"
看，我在那里做了——elif s == "N" 或者 s == "n"，

1087
00:53:43,710 --> 00:53:47,040
go ahead and print out "Not agreed."
继续打印 "Not agreed."

1088
00:53:47,040 --> 00:53:51,720
So it's almost the same as the C version, except that I'm using,
所以它几乎与 C 版本相同，除了我正在使用，

1089
00:53:51,720 --> 00:53:53,980
literally, O-R instead of two vertical bars.
实际上，O-R 而不是两个竖线。

1090
00:53:53,980 --> 00:53:56,430
So let's run this-- so python of agree.py.
所以让我们运行这个——所以 python agree.py。

1091
00:53:56,430 --> 00:53:57,030
Enter.
输入。

1092
00:53:57,030 --> 00:53:58,110
Do I agree?
我同意吗？

1093
00:53:58,110 --> 00:53:59,610
Yes, for little y.
是的，是小写 y。

1094
00:53:59,610 --> 00:54:02,970
Let's do it again. python of agree.py, capital Y. Yes.
让我们再做一次。python agree.py，大写 Y。是的。

1095
00:54:02,970 --> 00:54:03,910
That works there.
在那里有效。

1096
00:54:03,910 --> 00:54:06,630
And if I do it again with lowercase n, and if I do it
如果我再用小写 n 做一遍，如果我做

1097
00:54:06,630 --> 00:54:10,240
with capital N, this program, too, seems to work.
用大写 N，这个程序也似乎有效。

1098
00:54:10,240 --> 00:54:12,160
But what if I do this?
但如果我这样做呢？

1099
00:54:12,160 --> 00:54:13,980
Let me rerun python of agree.py.
让我重新运行 python agree.py。

1100
00:54:13,980 --> 00:54:16,140
Let me type in Yes.
让我输入“Yes”。

1101
00:54:16,140 --> 00:54:17,227
OK, it just ignores me.
好的，它直接忽略了我。

1102
00:54:17,227 --> 00:54:18,060
Let me run it again.
让我重新运行它。

1103
00:54:18,060 --> 00:54:18,915
Let me type in no.
让我输入“no”。

1104
00:54:18,915 --> 00:54:20,130
It just ignores me.
它直接忽略了我。

1105
00:54:20,130 --> 00:54:22,230
Let me try it very emphatically, YES in all caps.
让我尝试一下，非常肯定地，用全大写字母输入“YES”。

1106
00:54:22,230 --> 00:54:23,370
It just ignores me.
它直接忽略了我。

1107
00:54:23,370 --> 00:54:26,100
So there's some explosion of possibilities
所以存在着大量的可能性

1108
00:54:26,100 --> 00:54:27,930
that ideally we should handle, right?
理想情况下，我们应该处理这些可能性，对吧？

1109
00:54:27,930 --> 00:54:32,790
This is bad user interface design if I have-- the user has to type Y or N,
如果我必须让用户输入“Y”或“N”，这将是糟糕的用户界面设计，

1110
00:54:32,790 --> 00:54:37,260
even if yes and no in English are perfectly reasonable and logical, too.
即使英语中的“yes”和“no”也很合理，也很逻辑。

1111
00:54:37,260 --> 00:54:39,250
So how could we handle that?
我们该如何处理这种情况呢？

1112
00:54:39,250 --> 00:54:43,950
Well, it turns out in Python, we can use something like an array,
事实证明，在 Python 中，我们可以使用类似数组的东西，

1113
00:54:43,950 --> 00:54:47,740
technically called a list, to maybe check a bunch of things at once.
在技术上称为列表，用来同时检查很多东西。

1114
00:54:47,740 --> 00:54:49,120
So let me do this.
让我来做这个。

1115
00:54:49,120 --> 00:54:54,330
Let me instead say not equality, but let me use the in keyword in Python
与其说是不等，不如让我在 Python 中使用“in”关键字

1116
00:54:54,330 --> 00:54:56,880
and check if it's in a collection of possible values.
并检查它是否在一个可能的取值集合中。

1117
00:54:56,880 --> 00:54:59,940
Let me say if s is in--
让我说如果 s 在...

1118
00:54:59,940 --> 00:55:03,930
and here comes, in square brackets, just like--
这里出现了，在方括号中，就像...

1119
00:55:03,930 --> 00:55:09,630
in square brackets, quote unquote, "y", quote unquote, "yes,"
在方括号中，引号引起来，"y"，引号引起来，"yes"，

1120
00:55:09,630 --> 00:55:13,770
then we can go ahead and print out "Agreed,"
那么我们可以继续打印出“Agreed”，

1121
00:55:13,770 --> 00:55:20,100
elif s in this list of values, lowercase "n" or lowercase "no,"
或者如果 s 在这个取值列表中，小写字母 "n" 或小写字母 "no"，

1122
00:55:20,100 --> 00:55:23,190
then we can print out, for instance, "Not agreed."
那么我们可以打印出，例如，“Not agreed”。

1123
00:55:23,190 --> 00:55:25,890
But this is a bit of a step backwards because now
但这有点倒退，因为现在

1124
00:55:25,890 --> 00:55:29,010
I'm only handling lowercase.
我只处理小写字母。

1125
00:55:29,010 --> 00:55:32,520
So let me go into the mix and maybe add capital "Y"--
所以让我来混合一下，可能还要添加大写字母“Y”...

1126
00:55:32,520 --> 00:55:36,780
wait a minute, then maybe capital "YES," then maybe "YeS," also--
等等，然后是大写字母“YES”，然后是“YeS”，还有...

1127
00:55:36,780 --> 00:55:41,310
I mean, weird, but we should probably support this and "YEs."
我的意思是，很奇怪，但我们应该支持这个和“YEs”。

1128
00:55:41,310 --> 00:55:43,480
I mean, there's a lot of combinations.
我的意思是，有很多组合。

1129
00:55:43,480 --> 00:55:45,360
So this is not going to end well.
所以结局不会很好。

1130
00:55:45,360 --> 00:55:47,760
Or it's just going to bloat my code unnecessarily.
或者它会不必要地膨胀我的代码。

1131
00:55:47,760 --> 00:55:51,840
And eventually, for longer words, I'm surely going to miss capitalization.
最终，对于更长的单词，我肯定会忽略大小写。

1132
00:55:51,840 --> 00:55:54,990
So logically, whether it's in Python or C or any language,
所以从逻辑上讲，无论是在 Python、C 还是任何语言中，

1133
00:55:54,990 --> 00:56:00,900
what might be a better design for this problem of handling Y and Yes,
对于处理“Y”和“Yes”这个问题，一个更好的设计是什么？

1134
00:56:00,900 --> 00:56:03,090
but who cares about the capitalization?
但谁在乎大小写呢？

1135
00:56:03,090 --> 00:56:07,500
AUDIENCE: Don't use capitals or [INAUDIBLE]
观众：不要使用大写字母或...（听不清）

1136
00:56:07,500 --> 00:56:10,260
DAVID MALAN: So OK, so don't use capitals.
大卫·马兰：好的，所以不要使用大写字母。

1137
00:56:10,260 --> 00:56:12,280
You could only support lowercase.
你只能支持小写字母。

1138
00:56:12,280 --> 00:56:12,780
That's fine.
这样可以。

1139
00:56:12,780 --> 00:56:14,072
That's kind of a copout, right?
这有点像逃避责任，对吧？

1140
00:56:14,072 --> 00:56:16,225
Because now the program's usability is worse.
因为现在程序的可使用性变差了。

1141
00:56:16,225 --> 00:56:17,100
AUDIENCE: Convert it.
观众：转换它。

1142
00:56:17,100 --> 00:56:19,590
DAVID MALAN: Oh, we could convert it to lowercase, yeah.
大卫·马兰：哦，我们可以把它转换成小写字母，是的。

1143
00:56:19,590 --> 00:56:22,440
Though I did hear you say we could just check the first letter,
虽然我听到你说我们可以只检查第一个字母，

1144
00:56:22,440 --> 00:56:24,460
I bet that's going to get us into trouble.
我打赌那会让我们陷入麻烦。

1145
00:56:24,460 --> 00:56:26,700
And we probably don't want to allow any word starting
我们可能不想允许任何以...开头的单词

1146
00:56:26,700 --> 00:56:31,320
with Y, any word starting with N, just because it logically-- especially you
以 Y 开头的单词，任何以 N 开头的单词，仅仅是因为它在逻辑上...尤其是你

1147
00:56:31,320 --> 00:56:33,150
want the lawyers happy, presumably.
希望律师开心，可以理解。

1148
00:56:33,150 --> 00:56:36,960
You should probably get an explicit semantically correct word like Y or N
你应该获得一个语义上正确的明确单词，比如 Y 或 N

1149
00:56:36,960 --> 00:56:37,890
or yes or no.
或者 yes 或者 no。

1150
00:56:37,890 --> 00:56:41,580
But, yeah, we can actually go about converting this to something
但是，是的，我们实际上可以将它转换成一些东西

1151
00:56:41,580 --> 00:56:42,295
maybe smaller.
可能更小。

1152
00:56:42,295 --> 00:56:43,920
But how do we go about converting this?
但是我们如何进行转换呢？

1153
00:56:43,920 --> 00:56:48,450
In C, that alone was going to be pretty darn annoying because we'd have to use
在 C 语言中，仅此一项就相当令人厌烦，因为我们必须使用

1154
00:56:48,450 --> 00:56:53,770
the tolower() function on every character and compare it for equality.
tolower() 函数对每个字符进行比较，以检查是否相等。

1155
00:56:53,770 --> 00:56:55,440
It just feels like that's a bit of work.
感觉这有点工作量。

1156
00:56:55,440 --> 00:56:58,840
But in Python, you're going to get more functionality for free.
但在 Python 中，你会免费获得更多功能。

1157
00:56:58,840 --> 00:57:01,680
So there might very well be a function, like in C,
所以，可能会有一个函数，就像在 C 语言中一样，

1158
00:57:01,680 --> 00:57:03,600
called tolower() or toupper().
叫做 tolower() 或 toupper()。

1159
00:57:03,600 --> 00:57:06,300
But the weird thing about C, perhaps in retrospect,
但是 C 语言的奇怪之处，也许是事后看来，

1160
00:57:06,300 --> 00:57:10,090
is that those functions just kind of worked on the honor system.
就是这些函数只是在荣誉制度下运行。

1161
00:57:10,090 --> 00:57:15,010
tolower() and toupper() just trusted that you would pass them an input,
tolower() 和 toupper() 只相信你会传递给他们一个输入，

1162
00:57:15,010 --> 00:57:18,400
an argument, that is, in fact, a char.
一个参数，即一个 char。

1163
00:57:18,400 --> 00:57:22,300
In Python, and in a lot of other higher-level languages,
在 Python 以及许多其他高级语言中，

1164
00:57:22,300 --> 00:57:26,120
they introduced this notion of Object-Oriented Programming,
他们引入了面向对象编程的概念，

1165
00:57:26,120 --> 00:57:28,270
which is commonly described as OOP.
通常被描述为 OOP。

1166
00:57:28,270 --> 00:57:31,120
And in the world of Object-Oriented Programming,
在面向对象编程的世界中，

1167
00:57:31,120 --> 00:57:34,510
your values can not only-- your variables,
你的值不仅可以，你的变量，

1168
00:57:34,510 --> 00:57:37,450
for instance, and your data types can not only have values.
例如，你的数据类型不仅可以拥有值。

1169
00:57:37,450 --> 00:57:40,940
They can also have functionality built into them.
它们还可以具有内置的功能。

1170
00:57:40,940 --> 00:57:43,270
So if you have a data type like a string,
所以，如果你有一个像字符串这样的数据类型，

1171
00:57:43,270 --> 00:57:45,370
frankly, it just makes good sense that strings
坦白地说，字符串应该可以转换为大写、小写、首字母大写，

1172
00:57:45,370 --> 00:57:48,490
should be uppercaseable, lowercaseable, capitalizable,
这是合理的。

1173
00:57:48,490 --> 00:57:50,990
and any number of other operations on strings.
以及字符串上的许多其他操作。

1174
00:57:50,990 --> 00:57:54,040
So in the world of object-oriented programming functions,
所以在面向对象编程的世界中，函数

1175
00:57:54,040 --> 00:57:58,150
like toupper() and tolower() and isupper() and islower() are not just
比如 toupper() 和 tolower() 以及 isupper() 和 islower()，不仅仅是

1176
00:57:58,150 --> 00:57:59,980
in some random library that you can use.
你在某个随机库中可以使用。

1177
00:57:59,980 --> 00:58:02,560
They're built into the strings themselves.
它们内置在字符串本身。

1178
00:58:02,560 --> 00:58:06,400
And what this means is that in the world of strings in Python,
这意味着在 Python 中的字符串世界中，

1179
00:58:06,400 --> 00:58:10,360
here, for instance, is the URL of the documentation for all of the functions,
例如，这里就是所有函数的文档的 URL，

1180
00:58:10,360 --> 00:58:13,810
otherwise known as methods, that come with strings.
也称为方法，它们与字符串一起出现。

1181
00:58:13,810 --> 00:58:16,150
So you don't go check for a C-type library
所以，你不用去检查 C 语言库

1182
00:58:16,150 --> 00:58:18,790
like we did in C. You check the actual data
就像我们在 C 语言中那样。你检查实际数据

1183
00:58:18,790 --> 00:58:20,770
type, the documentation, therefore, and you
类型，因此，文档，然后你

1184
00:58:20,770 --> 00:58:24,580
will see in Python's own documentation what functions, a.k.a.
会看到 Python 自己的文档中有哪些函数，又称

1185
00:58:24,580 --> 00:58:26,680
methods, come with strings.
方法，与字符串一起出现。

1186
00:58:26,680 --> 00:58:28,420
So a method is just a function.
所以，方法只是一个函数。

1187
00:58:28,420 --> 00:58:32,540
But it's a function that comes with some data type, like a string.
但它是一个与某种数据类型（比如字符串）一起出现的函数。

1188
00:58:32,540 --> 00:58:35,830
So let me propose that we do this.
所以，我建议我们这样做。

1189
00:58:35,830 --> 00:58:38,980
In the world of object-oriented programming,
在面向对象编程的世界中，

1190
00:58:38,980 --> 00:58:41,720
we can come back to agree.py.
我们可以回到 agree.py 文件。

1191
00:58:41,720 --> 00:58:44,620
And we can actually improve the program by getting
我们实际上可以通过消除

1192
00:58:44,620 --> 00:58:47,440
rid of this crazy long list, which I wasn't even done with,
这个疯狂的长列表（我甚至还没写完），

1193
00:58:47,440 --> 00:58:50,260
and just canonicalize everything as lowercase.
来改进程序，并将所有内容规范化为小写。

1194
00:58:50,260 --> 00:58:53,470
So let's just check for lowercase y and lowercase yes, lowercase
所以，我们只需要检查小写 y 和小写 yes，小写

1195
00:58:53,470 --> 00:58:55,630
n, lowercase no, and that's it.
n，小写 no，就这些。

1196
00:58:55,630 --> 00:58:58,000
But to your suggestion, let's force everything
但是根据你的建议，我们来强制所有内容

1197
00:58:58,000 --> 00:59:01,600
that the user types into lowercase, not because we want
用户输入的内容变成小写，不是因为我们想要

1198
00:59:01,600 --> 00:59:03,160
to permanently change their input--
永久地改变他们的输入 -

1199
00:59:03,160 --> 00:59:05,980
we can throw the value away thereafter-- but
我们可以在之后丢弃这个值 - 但是

1200
00:59:05,980 --> 00:59:09,520
because we want to more easily logically compare it
因为我们想更轻松地逻辑比较它

1201
00:59:09,520 --> 00:59:12,350
for membership in this list of values.
在这些值的列表中是否包含它。

1202
00:59:12,350 --> 00:59:18,200
So one way to do this would be to literally do s = s.lower().
所以一种方法是直接执行 s = s.lower()。

1203
00:59:18,200 --> 00:59:19,480
So here's the difference.
所以这就是区别。

1204
00:59:19,480 --> 00:59:22,360
In the world of C, we would have done this--
在 C 语言的世界里，我们会这样做 -

1205
00:59:22,360 --> 00:59:25,990
tolower and pass in the value s.
tolower 并传入值 s。

1206
00:59:25,990 --> 00:59:30,010
But in the world of Python, and, in general, object-oriented programming--
但是在 Python 的世界里，总的来说，在面向对象编程中 -

1207
00:59:30,010 --> 00:59:32,530
Java is another language that does this--
Java 也是另一门这样做的语言 -

1208
00:59:32,530 --> 00:59:36,460
if s is a string, a.k.a. str, therefore, s is actually
如果 s 是一个字符串，也称为 str，因此，s 实际上

1209
00:59:36,460 --> 00:59:38,290
what's known in Python as an object.
在 Python 中被称为一个对象。

1210
00:59:38,290 --> 00:59:41,560
An object can not only have values or attributes inside of them,
一个对象不仅可以在内部包含值或属性，

1211
00:59:41,560 --> 00:59:43,300
but also functionality built in.
还包含内置的功能。

1212
00:59:43,300 --> 00:59:47,260
And just like in C, with a struct, if you want to go inside of something,
就像在 C 中，使用结构体，如果你想进入某个东西的内部，

1213
00:59:47,260 --> 00:59:49,030
you use the dot operator.
你需要使用点运算符。

1214
00:59:49,030 --> 00:59:54,250
And inside of this string, I claim, is a function, a.k.a., method,
我声称在这个字符串内部，存在一个函数，也称为方法，

1215
00:59:54,250 --> 00:59:55,330
called lower().
叫做 lower()。

1216
00:59:55,330 --> 00:59:58,510
Long story short, the only takeaway, if this is a bit abstract,
长话短说，唯一需要记住的是，如果这有点抽象，

1217
00:59:58,510 --> 01:00:01,185
is that instead of doing lower and then, in parentheses,
就是，与其执行 lower 然后在括号里

1218
01:00:01,185 --> 01:00:04,060
s, in the world of object-oriented programming, you kind of flip that
是 s，在面向对象编程的世界里，你需要反过来

1219
01:00:04,060 --> 01:00:08,950
and you do s dot name of the method, and then open paren and close paren if you
并且你执行 s 点 方法名称，然后打开括号并关闭括号，如果你

1220
01:00:08,950 --> 01:00:10,940
don't need to pass in any arguments.
不需要传入任何参数。

1221
01:00:10,940 --> 01:00:12,650
So this actually achieves the same.
所以这实际上实现了相同的功能。

1222
01:00:12,650 --> 01:00:17,680
So let me go ahead and rerun agree.py, and let me type in lowercase y.
所以让我继续重新运行 agree.py，并且让我输入小写 y。

1223
01:00:17,680 --> 01:00:18,460
That works.
这可以。

1224
01:00:18,460 --> 01:00:20,680
Let me run it again, type in lowercase yes.
让我再次运行，输入小写 yes。

1225
01:00:20,680 --> 01:00:24,820
That works let me run it again, type in capital Y. That works.
这可以，让我再次运行，输入大写 Y，这可以。

1226
01:00:24,820 --> 01:00:27,070
Let me type in capital YES, all capital--
让我输入大写 YES，全部大写 -

1227
01:00:27,070 --> 01:00:28,360
all uppercase YES.
所有大写的 YES。

1228
01:00:28,360 --> 01:00:29,410
That too works.
这也行。

1229
01:00:29,410 --> 01:00:31,450
Let me try no.
让我尝试 no。

1230
01:00:31,450 --> 01:00:33,640
Let me try no in lowercase.
让我尝试小写 no。

1231
01:00:33,640 --> 01:00:37,180
And all of these permutations now actually work
现在这些排列组合都行

1232
01:00:37,180 --> 01:00:38,830
because I'm forcing it to lowercase.
因为我把它强制转换为小写。

1233
01:00:38,830 --> 01:00:42,460
But even more interestingly, in Python, if you're sort of becoming a languages
但更有趣的是，在 Python 中，如果你正在成为一个语言

1234
01:00:42,460 --> 01:00:48,850
person, if you have a variable s that is being set the return value of input()
人员，如果你有一个变量 s，它被设置为 input() 函数的返回值

1235
01:00:48,850 --> 01:00:52,420
function, and then you're immediately going about changing it to lowercase,
函数，然后你立即将其更改为小写，

1236
01:00:52,420 --> 01:00:57,800
you can also chain method calls together in something like Python by doing this.
你也可以在像 Python 这样的东西中将方法调用链接在一起，通过这样做。

1237
01:00:57,800 --> 01:01:02,720
We can get rid of this line altogether, and then I can just do this, .lower.
我们可以完全去掉这一行，然后我就可以这样做，.lower。

1238
01:01:02,720 --> 01:01:05,950
And so whatever the return value of input() is, it's going to be a str.
所以，无论 input() 的返回值是什么，它都会是一个 str。

1239
01:01:05,950 --> 01:01:08,350
Whatever the human types in, you can then immediately
无论人类输入什么，你都可以立即

1240
01:01:08,350 --> 01:01:12,490
force it to lowercase and then assign the whole value to this variable
将其强制转换为小写，然后将整个值分配给这个变量

1241
01:01:12,490 --> 01:01:13,120
called s.
叫做 s。

1242
01:01:13,120 --> 01:01:17,260
You don't actually have to wait around and do it on a separate line
你实际上不必等待并在单独的一行上执行它。

1243
01:01:17,260 --> 01:01:20,220
altogether.
总而言之。

1244
01:01:20,220 --> 01:01:23,235
Questions, then, on any of this?
那么，对此有任何问题吗？

1245
01:01:26,250 --> 01:01:26,750
No?
没有？

1246
01:01:26,750 --> 01:01:27,250
All right.
好的。

1247
01:01:27,250 --> 01:01:30,260
Let me do one other that's reminiscent of something we did in the past.
让我做另一个，它让人想起我们过去做过的事情。

1248
01:01:30,260 --> 01:01:32,900
Let me go into VS Code here, clear my terminal.
让我进入 VS Code，清除我的终端。

1249
01:01:32,900 --> 01:01:35,960
Let's close both the C and the Python version of agree.
让我们关闭 C 和 Python 版本的 agree。

1250
01:01:35,960 --> 01:01:39,500
And let's create a program called uppercase.py, whose purpose in life
让我们创建一个名为 uppercase.py 的程序，它的目的是

1251
01:01:39,500 --> 01:01:41,390
is to actually uppercase a whole string.
将整个字符串转换成大写。

1252
01:01:41,390 --> 01:01:45,440
In the world of C, we had to do this character by character by character.
在 C 的世界里，我们必须逐个字符地执行此操作。

1253
01:01:45,440 --> 01:01:46,200
And that's fine.
这很好。

1254
01:01:46,200 --> 01:01:48,380
I'm going to go ahead and do it similarly here
我将继续在这里以类似的方式进行操作

1255
01:01:48,380 --> 01:01:53,540
in Python, whereby I want to convert it character by character.
在 Python 中，我想要逐个字符地转换它。

1256
01:01:53,540 --> 01:01:56,510
But unfortunately, before I can do that, I actually
但不幸的是，在我能够做到之前，我实际上

1257
01:01:56,510 --> 01:02:00,320
need some way of looping in Python, which we actually haven't seen yet.
需要一些在 Python 中循环的方法，而我们实际上还没有见过。

1258
01:02:00,320 --> 01:02:02,420
So we need one more set of building blocks.
所以我们需要另一组构建块。

1259
01:02:02,420 --> 01:02:05,120
And, in fact, if we were to consult the Python documentation,
事实上，如果我们要查阅 Python 文档，

1260
01:02:05,120 --> 01:02:06,530
we'd see this and much more.
我们会看到这些以及更多内容。

1261
01:02:06,530 --> 01:02:10,240
So, in fact, here's a list of all of the functions that come with Python.
所以，实际上，这里列出了 Python 附带的所有函数。

1262
01:02:10,240 --> 01:02:11,990
And it's actually not that long of a list,
而且实际上这并不是一个很长的列表，

1263
01:02:11,990 --> 01:02:15,680
because so much of the functionality of Python is built into data types,
因为 Python 的很多功能都内置在数据类型中，

1264
01:02:15,680 --> 01:02:18,950
like strings and integers and floats and more.
比如字符串、整数、浮点数等等。

1265
01:02:18,950 --> 01:02:22,790
Here is the canonical source of truth for Python documentation.
这里是对 Python 文档的权威来源。

1266
01:02:22,790 --> 01:02:25,950
So as opposed to using the CS50 manual for C,
所以与使用 C 的 CS50 手册相反，

1267
01:02:25,950 --> 01:02:29,700
which is meant to be a simplified version of publicly
它旨在成为公开的简化版本

1268
01:02:29,700 --> 01:02:32,520
available documentation, we'll generally, for Python,
提供的文档，对于 Python，我们通常会

1269
01:02:32,520 --> 01:02:33,870
point you to the official docs.
把你指向官方文档。

1270
01:02:33,870 --> 01:02:39,000
I will disclaim they're not really written for introductory students.
我得说，它们并不是专门为入门学生编写的。

1271
01:02:39,000 --> 01:02:42,150
And they'll generally leave some detail off and use arcane language.
而且它们通常会省略一些细节，并使用晦涩难懂的语言。

1272
01:02:42,150 --> 01:02:43,947
But at this point in the term, even if it
但在本学期这个阶段，即使它

1273
01:02:43,947 --> 01:02:45,780
might be a little frustrating at first, it's
可能一开始会有点令人沮丧，但是

1274
01:02:45,780 --> 01:02:47,873
good to see documentation in the real world
看到现实世界中的文档是件好事

1275
01:02:47,873 --> 01:02:50,290
because that's what you're going to have after the course.
因为这是你在课程结束后会接触到的东西。

1276
01:02:50,290 --> 01:02:52,860
And so you'll get used to it through practice over time.
所以，随着时间的推移，你会通过实践逐渐习惯它。

1277
01:02:52,860 --> 01:02:55,408
But with loops, let's introduce one other feature
但对于循环，让我们介绍另一个特性

1278
01:02:55,408 --> 01:02:56,700
that we can compare to Scratch.
我们可以把它与 Scratch 相比较。

1279
01:02:56,700 --> 01:03:00,270
Here, for instance, in Scratch, is how we might have repeated something three
例如，在 Scratch 中，我们可以像这样重复某件事三次

1280
01:03:00,270 --> 01:03:01,980
times, like meowing on the screen.
比如在屏幕上喵喵叫。

1281
01:03:01,980 --> 01:03:04,330
In C, there were a bunch of ways to do this.
在 C 中，有很多方法可以做到这一点。

1282
01:03:04,330 --> 01:03:07,080
And the clunkiest was maybe to do it with a while loop
也许最笨拙的方法是用 while 循环

1283
01:03:07,080 --> 01:03:10,080
where we declare a variable called i, set it equal to 0,
我们声明一个名为 i 的变量，并将其设置为 0，

1284
01:03:10,080 --> 01:03:14,580
and then, iteratively, increment i again and again until it exceeds--
然后，反复增加 i 直到它超过--

1285
01:03:14,580 --> 01:03:17,970
until it equals 3, each time printing out "meow."
直到它等于 3，每次都打印 "meow"。

1286
01:03:17,970 --> 01:03:22,620
In Python, we can do this in a few different ways as well.
在 Python 中，我们也可以通过几种不同的方式来实现这一点。

1287
01:03:22,620 --> 01:03:26,850
The nearest translation of C into Python is perhaps this.
C 语言翻译成 Python 语言最接近的可能是这样。

1288
01:03:26,850 --> 01:03:29,850
It's almost the same, and logically, it really is the same,
它几乎相同，从逻辑上讲，它确实相同，

1289
01:03:29,850 --> 01:03:32,730
but you don't specify int, and you don't have a semicolon.
但你不需要指定 int，也不需要分号。

1290
01:03:32,730 --> 01:03:34,270
You don't have curly braces.
你没有大括号。

1291
01:03:34,270 --> 01:03:35,520
But you do have a colon.
但你有一个冒号。

1292
01:03:35,520 --> 01:03:36,690
You don't use printf().
你不使用 printf()。

1293
01:03:36,690 --> 01:03:37,800
You use print().
你使用 print()。

1294
01:03:37,800 --> 01:03:42,240
And you can't use i++, but you still can use i += 1.
你不能使用 i++，但你仍然可以使用 i += 1。

1295
01:03:42,240 --> 01:03:45,360
So logically, exactly the same idea as in C--
所以逻辑上，这和 C 语言中完全相同——

1296
01:03:45,360 --> 01:03:46,660
It's just a little tighter.
它只是更简洁一点。

1297
01:03:46,660 --> 01:03:49,920
I mean, it's a little easier to read, even though it's very mechanical,
我的意思是，它更容易阅读，即使它非常机械化，

1298
01:03:49,920 --> 01:03:50,490
if you will.
如果你愿意的话。

1299
01:03:50,490 --> 01:03:51,900
You're defining all of these.
你定义了所有这些。

1300
01:03:51,900 --> 01:03:54,600
You're defining this variable and changing it incrementally.
你正在定义这个变量并对其进行增量更改。

1301
01:03:54,600 --> 01:03:58,317
Well, recall that in C, we could also use a for loop, which at first glance
好吧，回想一下，在 C 语言中，我们也可以使用 for 循环，乍一看

1302
01:03:58,317 --> 01:04:00,150
was probably more cryptic than a while loop.
可能比 while 循环更难以理解。

1303
01:04:00,150 --> 01:04:02,670
But odds are by now, you're more comfortable or more
但到目前为止，你可能对使用循环更熟悉或更有

1304
01:04:02,670 --> 01:04:04,950
in the habit of using loops-- same exact idea.
使用循环的习惯——完全相同的概念。

1305
01:04:04,950 --> 01:04:08,160
In Python, though, we might do it like this.
但在 Python 中，我们可能会这样做。

1306
01:04:08,160 --> 01:04:13,530
We've seen how, in square brackets, you can have lists of values, like y, yes,
我们已经看到了，在方括号中，你可以有值的列表，例如 y，yes，

1307
01:04:13,530 --> 01:04:14,690
and so forth.
等等。

1308
01:04:14,690 --> 01:04:16,690
Well, let's just do the same thing with numbers.
好吧，我们用数字做同样的事情。

1309
01:04:16,690 --> 01:04:19,380
So if you want Python to do something three times, give it
所以，如果你想让 Python 做某事三次，就给它

1310
01:04:19,380 --> 01:04:24,390
a list of three values, like 0, 1, 2, and then print out "hello, world"
一个包含三个值的列表，例如 0、1、2，然后打印出 “hello, world”

1311
01:04:24,390 --> 01:04:26,100
that many times.
那么多次。

1312
01:04:26,100 --> 01:04:29,550
Now, this is correct, but it's bad design.
现在，这是正确的，但设计不好。

1313
01:04:29,550 --> 01:04:33,720
Even if you've never seen Python before, extrapolate mentally from this.
即使你以前从未见过 Python，也可以从这里进行心理推断。

1314
01:04:33,720 --> 01:04:38,204
Why is this probably not the right way or the best way to do this looping?
为什么这可能不是正确的方法或最好的方法来进行循环？

1315
01:04:38,204 --> 01:04:40,329
AUDIENCE: Because if you wanted to do it more than,
观众：因为如果你想做超过，

1316
01:04:40,329 --> 01:04:42,360
like, three times, you have to [INAUDIBLE]..
比如，三次，你必须 [听不清]。

1317
01:04:42,360 --> 01:04:43,110
DAVID MALAN: Yeah.
大卫·马兰：是的。

1318
01:04:43,110 --> 01:04:46,830
If you want to do it four times, five times, 50 times, 100 times,
如果你想做四次、五次、五十次、一百次，

1319
01:04:46,830 --> 01:04:50,250
I mean, surely, there's a better way than enumerating all of these values.
我的意思是，肯定有比枚举所有这些值更好的方法。

1320
01:04:50,250 --> 01:04:51,060
And there is.
并且确实有。

1321
01:04:51,060 --> 01:04:55,620
In fact, in Python, there's a function called range() that actually returns
事实上，在 Python 中，有一个名为 range() 的函数，它实际上返回

1322
01:04:55,620 --> 01:04:58,170
to you very efficiently a range of values.
给你一个值的范围，非常高效。

1323
01:04:58,170 --> 01:05:02,040
And by default, it hands you the number 0 and then 1 and then 2.
默认情况下，它会给你数字 0，然后是 1，然后是 2。

1324
01:05:02,040 --> 01:05:05,430
And if you want more than that, you just change the argument to range() to be
如果你想要更多，你只需要更改 range() 的参数为

1325
01:05:05,430 --> 01:05:07,060
how many values do you want.
你想要多少个值。

1326
01:05:07,060 --> 01:05:10,560
So if you passed in range of 50, you would get back 0
所以，如果你传入范围为 50，你将得到 0

1327
01:05:10,560 --> 01:05:15,430
through 49, which effectively allows you to do something 50 times in total.
到 49，这实际上允许你总共做某事 50 次。

1328
01:05:15,430 --> 01:05:18,430
So this is perhaps the most Pythonic way, so to speak.
所以这也许是最 Pythonic 的方式，这么说吧。

1329
01:05:18,430 --> 01:05:20,070
And this is actually a term of art.
这实际上是一个艺术术语。

1330
01:05:20,070 --> 01:05:23,340
Pythonic isn't necessarily the only way to do something.
Pythonic 不一定只是做某事的唯一方法。

1331
01:05:23,340 --> 01:05:28,230
But it's the way to do something based on consensus in the Python community.
但它是根据 Python 社区的共识来做某事的方式。

1332
01:05:28,230 --> 01:05:30,090
So it's pretty common to do this.
所以这样做很常见。

1333
01:05:30,090 --> 01:05:32,100
But there's some curiosity here.
但这里有一些好奇的地方。

1334
01:05:32,100 --> 01:05:36,720
Notice I'm declaring a variable i, but I'm never actually using it.
请注意，我声明了一个变量 i，但我实际上从未使用过它。

1335
01:05:36,720 --> 01:05:39,137
In fact, I don't even increment it because that's
事实上，我甚至没有对其进行增量操作，因为那是

1336
01:05:39,137 --> 01:05:40,470
sort of happening automatically.
自动发生的。

1337
01:05:40,470 --> 01:05:43,690
Well, what's really happening here is automatically in Python,
好吧，这里真正发生的事情是，在 Python 中，它会自动

1338
01:05:43,690 --> 01:05:50,000
on every iteration of this loop, Python is assigning i to the next value.
在循环的每次迭代中，Python 将 i 赋值为下一个值。

1339
01:05:50,000 --> 01:05:51,393
So initially, i is 0.
因此，最初，i 为 0。

1340
01:05:51,393 --> 01:05:52,810
Then it goes through an iteration.
然后它经历一次迭代。

1341
01:05:52,810 --> 01:05:53,920
Then i is 1.
然后 i 为 1。

1342
01:05:53,920 --> 01:05:55,210
Then i is 2.
然后 i 为 2。

1343
01:05:55,210 --> 01:05:58,210
And then that's it if you only asked for three values.
如果你只要求三个值，那就到此为止。

1344
01:05:58,210 --> 01:06:00,940
But there's this other technique in Python, just so you know,
但是，您需要了解 Python 中的另一种技巧，

1345
01:06:00,940 --> 01:06:03,850
whereby if you're the programmer, and you know you don't actually
如果您是程序员，并且知道您实际上

1346
01:06:03,850 --> 01:06:06,100
care about the name of this variable, you
不关心这个变量的名称，那么您

1347
01:06:06,100 --> 01:06:10,600
can actually change it to an underscore, which has no functional effect per se.
可以将它更改为下划线，它本身没有功能上的影响。

1348
01:06:10,600 --> 01:06:14,020
It just signals to the reader, your colleague, your teaching fellow,
它只是向读者、您的同事、您的助教传达信号，

1349
01:06:14,020 --> 01:06:17,738
that it's a variable, and you need it in order to achieve a for loop.
这是一个变量，您需要它才能实现 for 循环。

1350
01:06:17,738 --> 01:06:19,780
But you don't care about the name of the variable
但是您不关心变量的名称

1351
01:06:19,780 --> 01:06:22,150
because you're not going to use it explicitly anywhere.
因为您不会在任何地方显式地使用它。

1352
01:06:22,150 --> 01:06:25,310
So that might be an even more Pythonic way of doing things.
所以这可能是一种更 Pythonic 的做事方式。

1353
01:06:25,310 --> 01:06:27,580
But if you're more comfortable seeing the i
但如果您更习惯看到 i

1354
01:06:27,580 --> 01:06:30,010
and using the variable more explicitly, that's fine.
并且更习惯显式地使用变量，那就没问题。

1355
01:06:30,010 --> 01:06:32,480
Underscore does not mean anything special.
下划线没有特殊含义。

1356
01:06:32,480 --> 01:06:35,720
It's just a valid character for a variable name.
它只是一个有效的变量名字符。

1357
01:06:35,720 --> 01:06:38,630
So this is convention, nothing more technical than that.
所以这只是一个约定，没有比这更技术性的内容。

1358
01:06:38,630 --> 01:06:42,430
What about a forever loop in Scratch, like literally meow forever.
Scratch 中的无限循环呢，就像真的永远喵喵叫。

1359
01:06:42,430 --> 01:06:46,840
Well, over here, we can just use in C, while(true) printf() "meow,"
好吧，在这里，我们可以在 C 中使用 while(true) printf() "meow,"

1360
01:06:46,840 --> 01:06:49,210
again and again and again.
一遍又一遍。

1361
01:06:49,210 --> 01:06:51,977
In Python, it's almost the same.
在 Python 中，几乎是一样的。

1362
01:06:51,977 --> 01:06:53,560
You still get rid of the curly braces.
您仍然需要去掉花括号。

1363
01:06:53,560 --> 01:06:54,430
You add the colon.
您需要添加冒号。

1364
01:06:54,430 --> 01:06:55,638
You get rid of the semicolon.
您需要去掉分号。

1365
01:06:55,638 --> 01:06:57,940
But there's a subtlety.
但是有一个细微之处。

1366
01:06:57,940 --> 01:07:00,040
What else is different here?
这里还有什么不同？

1367
01:07:00,040 --> 01:07:01,090
Yeah?
是吧？

1368
01:07:01,090 --> 01:07:02,620
So True is uppercase.
所以 True 是大写的。

1369
01:07:02,620 --> 01:07:03,310
Why?
为什么？

1370
01:07:03,310 --> 01:07:04,210
Who knows?
谁知道呢？

1371
01:07:04,210 --> 01:07:07,210
The world decided that in Python, True is capitalized
全世界决定在 Python 中，True 是大写的

1372
01:07:07,210 --> 01:07:08,320
and False is capitalized.
而 False 也是大写的。

1373
01:07:08,320 --> 01:07:11,030
In many other languages, daresay most, they are not.
在许多其他语言中，敢说大多数语言，它们都不是大写的。

1374
01:07:11,030 --> 01:07:15,430
It's just a difference that you have to keep in mind or remember.
这只是一个你需要记住的差异。

1375
01:07:15,430 --> 01:07:15,940
All right.
好的。

1376
01:07:15,940 --> 01:07:20,480
So now that we have looping constructs, let me go back to my code here.
现在我们有了循环结构，让我回到我的代码。

1377
01:07:20,480 --> 01:07:23,680
And recall that I proposed that we re-implement a program like uppercase,
还记得我建议我们重新实现一个像 uppercase 这样的程序，

1378
01:07:23,680 --> 01:07:25,420
force an entire string to uppercase.
强制整个字符串变为大写。

1379
01:07:25,420 --> 01:07:29,470
And in C, we would have done this with a for loop, iterating from left to right.
在 C 中，我们会用 for 循环来做，从左到右迭代。

1380
01:07:29,470 --> 01:07:32,410
But what's nice in Python frankly, is that it's a lot easier
但坦率地说，Python 中的好处是，它比 C 中更容易

1381
01:07:32,410 --> 01:07:37,510
to loop in Python than it is in C because you can loop over
在 Python 中循环，因为您可以在

1382
01:07:37,510 --> 01:07:39,460
anything that is iterable.
任何可迭代的东西上循环。

1383
01:07:39,460 --> 01:07:43,210
A string is iterable in the sense that you can iterate over it
字符串是可迭代的，因为您可以从左到右迭代它

1384
01:07:43,210 --> 01:07:44,630
from left to right.
从左到右。

1385
01:07:44,630 --> 01:07:45,740
So what do I mean by this?
我的意思是什么呢？

1386
01:07:45,740 --> 01:07:48,010
Well, let me go ahead and, in uppercase.py,
好吧，让我在 uppercase.py 中继续，

1387
01:07:48,010 --> 01:07:51,790
let's first prompt the user for a variable called before and set that
让我们首先提示用户输入一个名为 before 的变量，并设置它。

1388
01:07:51,790 --> 01:07:56,650
equal to the return value of input(), giving them a prompt of "Before,"
等于输入函数input()的返回值，并提示他们输入“Before”，

1389
01:07:56,650 --> 01:07:57,820
colon.
冒号。

1390
01:07:57,820 --> 01:08:01,720
Then let's go ahead, as we did weeks ago, and print out just the word
然后让我们继续，就像几周前一样，打印出这个词

1391
01:08:01,720 --> 01:08:08,110
"After," just to make clear to the user what is actually going to be printed.
“After”，以便让用户清楚地知道实际要打印的内容。

1392
01:08:08,110 --> 01:08:12,700
Then let me go ahead and specify the following loop--
然后让我继续指定下面的循环——

1393
01:08:12,700 --> 01:08:16,005
for-- and previously you saw me use i, but because I'm dealing with
for——之前你看到我使用了i，但因为我现在正在处理

1394
01:08:16,005 --> 01:08:18,130
characters, I'm actually going to do this instead--
字符，所以我实际上会这样做——

1395
01:08:18,130 --> 01:08:24,910
for c in before, colon, print out c.upper.
对于before中的每个字符c，打印c.upper。

1396
01:08:24,910 --> 01:08:26,290
And that's it.
就这样。

1397
01:08:26,290 --> 01:08:28,359
Now, this is a little flawed, I will concede.
现在，我承认，这有点缺陷。

1398
01:08:28,359 --> 01:08:31,540
But let me run this-- python of uppercase.py.
但是让我运行一下——python uppercase.py。

1399
01:08:31,540 --> 01:08:35,229
Let's type in something like cat, C-A-T in all lowercase.
让我们输入一些东西，比如cat，C-A-T，全部小写。

1400
01:08:35,229 --> 01:08:35,990
Enter.
回车。

1401
01:08:35,990 --> 01:08:36,490
All right.
好的。

1402
01:08:36,490 --> 01:08:39,040
Well, you see "After," and I did get it right in the sense
好吧，你看到了“After”，而且就结果而言，我确实做对了

1403
01:08:39,040 --> 01:08:43,359
that it is capital C, capital A, capital T, but it looks a little stupid.
它确实是C，A，T大写，但是看起来有点愚蠢。

1404
01:08:43,359 --> 01:08:45,189
And in order to fix this, we actually need
为了解决这个问题，我们需要

1405
01:08:45,189 --> 01:08:49,479
to introduce something that's called named parameters.
引入一个叫做命名参数的东西。

1406
01:08:49,479 --> 01:08:55,510
So let me actually go ahead and propose that we can fix this problem
所以让我提议，我们可以解决这个问题

1407
01:08:55,510 --> 01:08:59,140
by actually passing in another argument to the print() function.
通过向print()函数传递另一个参数。

1408
01:08:59,140 --> 01:09:01,540
And this is a little different syntactically from C.
这在语法上与C语言有点不同。

1409
01:09:01,540 --> 01:09:04,479
But if I go back to VS Code here, it turns out
但如果我回到VS Code这里，结果证明

1410
01:09:04,479 --> 01:09:06,319
that there's two aesthetic problems here.
这里有两个美学问题。

1411
01:09:06,319 --> 01:09:10,130
One, I did not want the new line automatically inserted after "After."
第一，我不希望在“After”后面自动插入换行符。

1412
01:09:10,130 --> 01:09:10,630
Why?
为什么？

1413
01:09:10,630 --> 01:09:13,569
Because, just like in week 1, I want them to line up nicely--
因为，就像第一周一样，我希望它们整齐地对齐——

1414
01:09:13,569 --> 01:09:15,310
or in week 2.
或者第二周。

1415
01:09:15,310 --> 01:09:18,367
And I don't want a new line after C-A-T. So even
而且我不希望在C-A-T后面出现换行符。所以即使

1416
01:09:18,367 --> 01:09:20,200
though at first glance a moment-- a bit ago,
虽然乍一看，前不久，

1417
01:09:20,200 --> 01:09:23,620
it might have seemed nice that Python just does the backslash n for you,
Python自动为你添加反斜杠n，看起来可能挺好，

1418
01:09:23,620 --> 01:09:27,649
it can backfire if you don't actually want a new line every time.
但如果你并不想每次都出现换行符，它就会适得其反。

1419
01:09:27,649 --> 01:09:29,660
So the syntax is going to look a little weird.
所以语法看起来会有点奇怪。

1420
01:09:29,660 --> 01:09:32,529
But in Python, with the print() function,
但是在Python中，使用print()函数，

1421
01:09:32,529 --> 01:09:36,819
if you want to change the character that's automatically used at the end
如果你想改变自动用在每行末尾的字符

1422
01:09:36,819 --> 01:09:43,130
of every line, you can literally pass in a second argument called end and set it
你可以直接传入一个名为end的第二个参数，并将其设置为

1423
01:09:43,130 --> 01:09:45,660
equal to something else.
其他东西。

1424
01:09:45,660 --> 01:09:48,350
So if you want to set it equal to something else,
所以如果你想将其设置为其他东西，

1425
01:09:48,350 --> 01:09:52,620
and that something else is nothing, "", then that's fine.
而这个其他东西是空字符串，""，那就没问题。

1426
01:09:52,620 --> 01:09:57,050
You can actually specify end="".
你可以指定end=""。

1427
01:09:57,050 --> 01:10:00,980
Down here, too, if you want to specify that at the end of every one of these
这里也是，如果你想指定每个字符末尾

1428
01:10:00,980 --> 01:10:05,330
characters should be nothing, I can specify end="".
都是空字符串，我可以指定end=""。

1429
01:10:05,330 --> 01:10:08,390
What this implies is that by default in Python,
这意味着在Python中，默认情况下，

1430
01:10:08,390 --> 01:10:13,280
the default value of this end parameter is actually always backslash n.
这个end参数的默认值实际上始终是反斜杠n。

1431
01:10:13,280 --> 01:10:15,800
So if you want to override it and take that away,
所以如果你想覆盖它并将其移除，

1432
01:10:15,800 --> 01:10:19,380
you just literally change it to "" instead.
你只需将其更改为空字符串""。

1433
01:10:19,380 --> 01:10:23,960
And now if I clear my-- if I rerun this program, uppercase.py,
现在，如果我清空我的——如果我重新运行这个程序，uppercase.py，

1434
01:10:23,960 --> 01:10:27,820
type in cat in all lowercase, now you'll see--
输入cat，全部小写，现在你将看到——

1435
01:10:27,820 --> 01:10:29,307
oh, two minor bugs here.
哦，这里有两个小错误。

1436
01:10:29,307 --> 01:10:30,140
One was just stupid.
其中一个很愚蠢。

1437
01:10:30,140 --> 01:10:31,940
I had one too many spaces here.
我在这里多打了一个空格。

1438
01:10:31,940 --> 01:10:35,150
But you'll notice that I didn't move the cursor to the next line
但是你会注意到我没有将光标移动到下一行

1439
01:10:35,150 --> 01:10:38,090
after CAT was printed in all uppercase.
在 CAT 全部大写打印之后。

1440
01:10:38,090 --> 01:10:40,070
And that we can fix by just printing nothing.
而我们可以通过什么都不打印来解决这个问题。

1441
01:10:40,070 --> 01:10:43,140
It turns out when you don't pass print() an argument at all,
事实证明，当你没有给 print() 传递任何参数时，

1442
01:10:43,140 --> 01:10:46,690
it automatically gives you just the line ending, nothing else.
它会自动给你一个行结束符，除此之外什么都没有。

1443
01:10:46,690 --> 01:10:49,210
So I think this will move the cursor as expected.
所以我认为这将按预期移动光标。

1444
01:10:49,210 --> 01:10:52,200
So let me clear it now, run python of uppercase.py
所以现在让我清除它，运行 uppercase.py 的 python

1445
01:10:52,200 --> 01:10:55,290
and hit Enter, type in cat in all lowercase, cross my fingers this time,
然后按回车键，输入 cat 的小写字母，这次我祈祷一切顺利，

1446
01:10:55,290 --> 01:10:59,910
and now I have indeed capitalized this, character by character
现在我确实已经逐个字符地将它大写了

1447
01:10:59,910 --> 01:11:03,360
by character, just like we did in C.
逐个字符，就像我们在 C 中做的那样。

1448
01:11:03,360 --> 01:11:06,060
But honestly, this, too, not really necessary--
但老实说，这也不太必要——

1449
01:11:06,060 --> 01:11:08,610
it turns out I don't need to loop over a whole string,
事实证明我不需要遍历整个字符串，

1450
01:11:08,610 --> 01:11:10,510
because strings themselves come with methods.
因为字符串本身就带有方法。

1451
01:11:10,510 --> 01:11:12,930
And if you were to visit the documentation for strings,
如果你要查看字符串的文档，

1452
01:11:12,930 --> 01:11:17,370
you would see that indeed, upper is a method that comes with every string,
你会发现，确实，upper 是每个字符串都带有的一个方法，

1453
01:11:17,370 --> 01:11:20,880
and you don't need to call it on every character individually.
你不需要对每个字符单独调用它。

1454
01:11:20,880 --> 01:11:25,650
I could instead get rid of all of this and just print out--
我可以用另一种方法，去掉所有这些，然后只打印出来——

1455
01:11:25,650 --> 01:11:31,860
for instance, I can just print out before.upper.
例如，我可以只打印出 before.upper。

1456
01:11:31,860 --> 01:11:35,400
And the upper() function that comes with strings will automatically apply it
字符串自带的 upper() 函数会自动将其应用

1457
01:11:35,400 --> 01:11:39,370
to every character they're in and, I think, achieve the same result.
到它们包含的每个字符中，我认为，将达到相同的结果。

1458
01:11:39,370 --> 01:11:42,990
So let me go ahead and try this again-- python of uppercase.py, type in cat,
所以让我再次尝试一下——运行 uppercase.py 的 python，输入 cat，

1459
01:11:42,990 --> 01:11:46,330
enter, and indeed, it works exactly the same way.
回车，确实，它以完全相同的方式工作。

1460
01:11:46,330 --> 01:11:48,090
Let me take this one step further.
让我更进一步。

1461
01:11:48,090 --> 01:11:51,510
Let me go ahead and combine a couple of ideas now here.
现在让我在这里将几个想法结合起来。

1462
01:11:51,510 --> 01:11:56,220
Let me go ahead and, for instance, let me get rid of this last print() line.
让我继续，例如，让我去掉最后一行 print()。

1463
01:11:56,220 --> 01:12:00,090
Let me change my logic to be after equals the return value of this.
让我将我的逻辑更改为 after 等于此的返回值。

1464
01:12:00,090 --> 01:12:04,770
And now I can use one of those f strings and plug this in maybe here, After.
现在我可以使用其中一个 f 字符串，并将它插入到这里，After。

1465
01:12:04,770 --> 01:12:06,750
And I can get rid of the new line ending.
我可以去掉换行符。

1466
01:12:06,750 --> 01:12:08,385
I can specify this is an f string.
我可以指定这是一个 f 字符串。

1467
01:12:08,385 --> 01:12:10,260
So I'm just changing this around a little bit
所以我只是稍微改变一下这个

1468
01:12:10,260 --> 01:12:13,680
logically so that now I have a variable called after that
从逻辑上来说，现在我有一个名为 after 的变量

1469
01:12:13,680 --> 01:12:15,940
is the uppercase version of before.
是 before 的大写版本。

1470
01:12:15,940 --> 01:12:21,910
And now, if I do python of uppercase.py, type in cat, that too now works.
现在，如果我运行 uppercase.py 的 python，输入 cat，它也工作了。

1471
01:12:21,910 --> 01:12:23,980
And if I-- actually let me add a space there,
如果我——实际上让我在那里加一个空格，

1472
01:12:23,980 --> 01:12:28,350
if I run python of uppercase.py, type in cat, that too now works.
如果我运行 uppercase.py 的 python，输入 cat，它也工作了。

1473
01:12:28,350 --> 01:12:31,440
And lastly here, if you don't want to bother
最后在这里，如果你不想麻烦

1474
01:12:31,440 --> 01:12:33,960
creating another variable like this, you can even
创建另一个这样的变量，你甚至可以

1475
01:12:33,960 --> 01:12:37,830
put short bits of code inside of these format strings.
在这些格式字符串中放入一小段代码。

1476
01:12:37,830 --> 01:12:40,800
So I, for instance, could go in here into these curly braces
例如，我可以进入这里，进入这些大括号

1477
01:12:40,800 --> 01:12:42,510
and not just put a variable name.
并且不仅仅放一个变量名。

1478
01:12:42,510 --> 01:12:48,120
I can actually put Python code inside of the curly braces, inside of my string.
我实际上可以将 Python 代码放入大括号中，放入我的字符串中。

1479
01:12:48,120 --> 01:12:51,600
And so now if I run Python of uppercase.py, type in cat,
所以现在如果我运行 uppercase.py 的 Python，输入 cat，

1480
01:12:51,600 --> 01:12:54,360
even that too now works.
现在，甚至那个也起作用了。

1481
01:12:54,360 --> 01:12:55,890
Now, which one is the best?
现在，哪个最好？

1482
01:12:55,890 --> 01:12:59,590
This is kind of reasonable to put the bit of code inside of the string.
把代码片段放在字符串里似乎是合理的。

1483
01:12:59,590 --> 01:13:02,793
I would not start writing long lines of code inside of curly braces
我不会在花括号里写长长的代码行

1484
01:13:02,793 --> 01:13:04,710
that start to wrap, no less, because then it's
而且还要开始换行，因为这样

1485
01:13:04,710 --> 01:13:06,420
just going to be a matter of bad style.
就只是糟糕的风格问题了。

1486
01:13:06,420 --> 01:13:09,780
But this, again, is to say that there's a bunch of different ways
但是，再说一次，这只是说有很多不同的方法

1487
01:13:09,780 --> 01:13:11,590
to solve each of these problems.
来解决这些问题。

1488
01:13:11,590 --> 01:13:15,240
And so up until now, we've generally seen not named parameters.
到目前为止，我们一般没有看到命名参数。

1489
01:13:15,240 --> 01:13:20,100
end is the first parameter we've ever seen that has a name, literally, end.
end 是我们见到的第一个有名字的参数，准确地说，是 end。

1490
01:13:20,100 --> 01:13:23,790
Up until now in C and up until a moment ago in Python,
到目前为止，在 C 语言中，以及在刚才的 Python 中，

1491
01:13:23,790 --> 01:13:27,840
we've always been assuming that our parameters are positional.
我们一直假设我们的参数是位置参数。

1492
01:13:27,840 --> 01:13:33,600
What matters is the order in which you specify them, not necessarily something
重要的是你指定它们的顺序，而不是其他的什么东西。

1493
01:13:33,600 --> 01:13:35,280
else.
其他东西。

1494
01:13:35,280 --> 01:13:35,880
Whew.
哇。

1495
01:13:35,880 --> 01:13:37,600
OK, that was a lot.
好吧，内容很多。

1496
01:13:37,600 --> 01:13:42,660
Any questions about any of this here?
关于这里的内容有任何问题吗？

1497
01:13:42,660 --> 01:13:43,230
No?
没有？

1498
01:13:43,230 --> 01:13:43,620
All right.
好吧。

1499
01:13:43,620 --> 01:13:44,290
It feels like a lot.
感觉很多。

1500
01:13:44,290 --> 01:13:45,450
Let's take our 10-minute break here.
我们在这里休息 10 分钟。

1501
01:13:45,450 --> 01:13:46,700
Fruit roll-ups are now served.
现在供应水果卷。

1502
01:13:46,700 --> 01:13:50,310
We'll be back in 10.
我们 10 分钟后回来。

1503
01:13:50,310 --> 01:13:51,690
All right.
好的。

1504
01:13:51,690 --> 01:13:52,830
We are back.
我们回来了。

1505
01:13:52,830 --> 01:13:58,440
And recall that as we left off, we had just introduced loops.
回想一下，在我们离开的时候，我们刚刚介绍了循环。

1506
01:13:58,440 --> 01:14:01,620
And we'd seen a bunch of different ways by which
我们已经看到了很多不同的方法，通过这些方法

1507
01:14:01,620 --> 01:14:03,140
we could get, say, a cat to meow.
我们可以让一只猫发出喵喵的声音。

1508
01:14:03,140 --> 01:14:04,890
Let's actually translate that to some code
让我们实际把它翻译成一些代码

1509
01:14:04,890 --> 01:14:08,490
and start to make sense of some of the programs with which we began,
并开始理解我们一开始的一些程序，

1510
01:14:08,490 --> 01:14:11,452
like creating our own functions, as we did for the speller example
比如创建我们自己的函数，就像我们在拼写程序示例中所做的那样

1511
01:14:11,452 --> 01:14:14,410
at the very beginning, and actually do this a little more methodically.
在一开始，而且实际上更加有条理地做这件事。

1512
01:14:14,410 --> 01:14:16,270
So let me go over to VS Code here.
所以让我转到这里的 VS Code。

1513
01:14:16,270 --> 01:14:20,790
Let me go ahead and create a program called meow.py, instead of meow.c
让我创建一个名为 meow.py 的程序，而不是 meow.c

1514
01:14:20,790 --> 01:14:22,140
as in the past.
像以前一样。

1515
01:14:22,140 --> 01:14:25,890
And suffice it to say if you want to implement the idea of a cat,
如果要实现猫的想法，就足够了，

1516
01:14:25,890 --> 01:14:30,270
we can do better than just saying print("meow"), print("meow"),
我们可以做得比仅仅说 print("meow")、print("meow") 更好，

1517
01:14:30,270 --> 01:14:31,260
print("meow").
print("meow")。

1518
01:14:31,260 --> 01:14:32,457
This, of course, would work.
当然，这可以工作。

1519
01:14:32,457 --> 01:14:35,290
This is correct if the goal is to get the thing to meow three times.
如果目标是让这个东西喵喵叫三次，那这是正确的。

1520
01:14:35,290 --> 01:14:40,710
But when I run python of meow.py, it's going to work as expected,
但是当我运行 meow.py 的 python 时，它将按预期工作，

1521
01:14:40,710 --> 01:14:42,650
but this is just not good design, right?
但这只是一个不好的设计，对吧？

1522
01:14:42,650 --> 01:14:44,310
We should minimally be using a loop.
我们应该至少使用一个循环。

1523
01:14:44,310 --> 01:14:47,870
So let me propose that we improve this per the building blocks we've seen.
所以让我提议我们根据我们看到的构建块来改进它。

1524
01:14:47,870 --> 01:14:51,470
And I could say something like, for i in range(3),
我可以说类似这样的东西，对于 i in range(3)，

1525
01:14:51,470 --> 01:14:54,170
go ahead and print out now, quote unquote, "meow."
继续打印出来，现在，引号中的 "meow"。

1526
01:14:54,170 --> 01:14:58,340
So this is better in the sense that it still prints meow, meow, meow.
所以，从这个意义上说，这更好，因为它仍然打印 meow、meow、meow。

1527
01:14:58,340 --> 01:15:01,490
But if I want to change this to a dog and change the meow to a woof
但是如果我想把它改成一条狗，把 meow 改成 woof

1528
01:15:01,490 --> 01:15:04,370
or something like that, I can change it in one place and not three
或类似的东西，我可以在一个地方更改它，而不是三个

1529
01:15:04,370 --> 01:15:07,290
different places-- so just, in general, better design.
不同的位置——所以总体来说，更好的设计。

1528
01:15:01,490 --> 01:15:04,370
or something like that, I can change it in one place and not three
或者类似的东西，我可以改变一个地方，而不是三个地方。

1529
01:15:04,370 --> 01:15:07,290
different places-- so just, in general, better design.
不同的位置——所以总体来说，设计更好。

1530
01:15:07,290 --> 01:15:10,460
But what if now, much like in Scratch and in C,
但是如果现在，就像在 Scratch 和 C 中一样，

1531
01:15:10,460 --> 01:15:14,270
I wanted to create my own meow() function which did not come with either
我想创建自己的 meow() 函数，它不包含在两种语言中的任何一种。

1532
01:15:14,270 --> 01:15:15,770
of those languages as well.
在这两种语言中。

1533
01:15:15,770 --> 01:15:18,170
Well, as a teaser at the start of class, we
好吧，作为课堂开始时的预告，我们

1534
01:15:18,170 --> 01:15:20,600
saw that you can define your own functions
看到了你可以定义自己的函数

1535
01:15:20,600 --> 01:15:24,410
with this keyword def, which is a little bit different from how C does it.
使用这个关键字 def，这与 C 的做法略有不同。

1536
01:15:24,410 --> 01:15:29,060
But let me go ahead and do this indeed in Python and define my own function
但是让我在 Python 中继续这样做，并定义我自己的函数

1537
01:15:29,060 --> 01:15:29,690
meow().
meow()。

1538
01:15:29,690 --> 01:15:36,950
So let me go ahead and do def meow(), and then, inside of that function,
所以让我继续做 def meow()，然后，在这个函数里面，

1539
01:15:36,950 --> 01:15:41,370
I'm just going to literally do for now, quote unquote, "meow" with print().
我现在就用 print() 来做，引号引起来的“meow”。

1540
01:15:41,370 --> 01:15:46,910
And now down here, notice, I can actually go ahead and just call meow().
现在，请注意，我可以直接调用 meow()。

1541
01:15:46,910 --> 01:15:49,880
And I can go ahead and call meow(), and I can call meow().
我可以调用 meow()，我还可以调用 meow()。

1542
01:15:49,880 --> 01:15:52,370
And this is not the best design at the moment.
目前，这不是最好的设计。

1543
01:15:52,370 --> 01:15:56,900
But Python does not constrain me to have to implement a main() function,
但是 Python 没有限制我必须实现一个 main() 函数，

1544
01:15:56,900 --> 01:15:58,200
as we've seen thus far.
正如我们迄今所见。

1545
01:15:58,200 --> 01:16:01,850
But I can define my own helper functions, if you will,
但如果愿意，我可以定义自己的辅助函数，

1546
01:16:01,850 --> 01:16:03,590
like a helper function called meow().
比如一个叫做 meow() 的辅助函数。

1547
01:16:03,590 --> 01:16:06,350
So let me go ahead and just run this for demonstration's sake
所以，让我继续执行它，为了演示的缘故，

1548
01:16:06,350 --> 01:16:08,120
and run python of meow.py.
运行 python of meow.py。

1549
01:16:08,120 --> 01:16:09,380
That does seem to work.
这似乎可以工作。

1550
01:16:09,380 --> 01:16:10,610
But this is not good design.
但这并不是好的设计。

1551
01:16:10,610 --> 01:16:15,800
And let me go ahead and actually do this-- for i in range(3),
让我继续执行它——for i in range(3)，

1552
01:16:15,800 --> 01:16:18,140
now let me call the meow() function.
现在让我调用 meow() 函数。

1553
01:16:18,140 --> 01:16:19,430
And this, too, should work.
这也应该可以工作。

1554
01:16:19,430 --> 01:16:23,480
If I do python of meow.py, there we have meow, meow, meow.
如果我执行 python of meow.py，我们有 meow、meow、meow。

1555
01:16:23,480 --> 01:16:26,840
But I very deliberately did something clever here.
但我很故意在这里做了一些聪明的事情。

1556
01:16:26,840 --> 01:16:29,060
I defined meow at the top of my file.
我在文件的顶部定义了 meow。

1557
01:16:29,060 --> 01:16:31,600
But that's not the best practice because as in C,
但这并不是最佳实践，因为就像在 C 中一样，

1558
01:16:31,600 --> 01:16:34,100
when someone opens the file for the first time, whether you,
当有人第一次打开文件时，无论是你，

1559
01:16:34,100 --> 01:16:38,510
a TF, a TA, a colleague, you'd like to see the main part of the program
一个 TF，一个 TA，一个同事，你都想看到程序的主要部分

1560
01:16:38,510 --> 01:16:42,050
at the top of the file, just because it's easier mentally to dive right in
在文件顶部，仅仅是因为在心理上更容易直接进入

1561
01:16:42,050 --> 01:16:43,610
and know what this file is doing.
并知道这个文件正在做什么。

1562
01:16:43,610 --> 01:16:47,420
So let me go ahead and practice what I'm preaching and put the main part
所以，让我继续实践我所宣扬的，并将主要部分

1563
01:16:47,420 --> 01:16:49,670
of my code, even if there's no main() function per se,
我的代码，即使没有一个真正的 main() 函数，

1564
01:16:49,670 --> 01:16:51,480
at the top of this file.
放在这个文件的顶部。

1565
01:16:51,480 --> 01:16:53,600
So now I have the loop at the top.
所以，现在我在顶部有了循环。

1566
01:16:53,600 --> 01:16:57,710
I'm calling meow() on line 2, and I'm defining meow() on lines 5 and 6.
我在第二行调用 meow()，我在第五行和第六行定义 meow()。

1567
01:16:57,710 --> 01:17:00,420
Well, instinctively, you can perhaps see where this is going.
嗯，凭直觉，你或许能看出这将走向何方。

1568
01:17:00,420 --> 01:17:02,750
If I run Python of meow.py and hit Enter,
如果我运行 Python of meow.py 并按回车键，

1569
01:17:02,750 --> 01:17:06,570
there's one of those tracebacks that's tracing my error.
就会出现一个回溯，它正在追踪我的错误。

1570
01:17:06,570 --> 01:17:11,060
And here, my error is apparently on line 2 in meow.py.
在这里，我的错误显然出现在 meow.py 的第二行。

1571
01:17:11,060 --> 01:17:15,120
And you'll notice that, huh, the name 'meow' is not defined.
你会注意到，嗯，名字'meow'没有定义。

1572
01:17:15,120 --> 01:17:18,440
And so previously, we saw a different type of error, a value error.
因此，之前我们看到了不同类型的错误，一个值错误。

1573
01:17:18,440 --> 01:17:20,870
Here we're seeing a name error in the sense
这里我们看到的是一个名字错误，从某种意义上说

1574
01:17:20,870 --> 01:17:23,690
that Python does not recognize the name of this function.
这意味着 Python 无法识别这个函数的名称。

1575
01:17:23,690 --> 01:17:27,630
And intuitively, why might that be, even if the error is a little cryptic?
直觉上，为什么会出现这种情况，即使错误信息有点难以理解？

1576
01:17:27,630 --> 01:17:28,130
Yeah?
是吧？

1577
01:17:28,130 --> 01:17:29,660
AUDIENCE: [INAUDIBLE] top to bottom.
观众：[听不清] 从上到下。

1578
01:17:29,660 --> 01:17:33,680
DAVID MALAN: Yeah, Python, too-- as fancier as it seems to be than C,
David Malan：是的，Python 也是这样，虽然它看起来比 C 更高级，

1579
01:17:33,680 --> 01:17:36,810
it still takes things pretty literally, top to bottom, left to right.
但它仍然非常直白地按顺序执行代码，从上到下，从左到右。

1580
01:17:36,810 --> 01:17:40,820
So if you define meow() on line 5, you can't use it on line 2.
因此，如果你在第 5 行定义了 meow()，就不能在第 2 行使用它。

1581
01:17:40,820 --> 01:17:43,352
OK, so I could undo this, and I could flip the order.
好的，我可以撤销这个操作，然后改变顺序。

1582
01:17:43,352 --> 01:17:46,310
But let me just stipulate that as soon as we have a bunch of functions,
但是我要说明的是，一旦我们拥有大量函数，

1583
01:17:46,310 --> 01:17:49,880
it's probably naive to assume I can just keep putting my functions above, above,
假设我可以一直把我的函数放在上面，上面，就太天真了，

1584
01:17:49,880 --> 01:17:50,510
above, above.
上面，上面。

1585
01:17:50,510 --> 01:17:53,810
And honestly, that's going to move all of my main code, so to speak,
老实说，这样一来，我的主代码（可以这样说）

1586
01:17:53,810 --> 01:17:57,360
to the bottom of the file, which is sort of counterproductive or less obvious.
就会移到文件的底部，这有点事与愿违，或者说不太直观。

1587
01:17:57,360 --> 01:18:01,400
So it turns out in Python, even though you don't need a main() function,
所以，在 Python 中，虽然你并不需要一个 main() 函数，

1588
01:18:01,400 --> 01:18:05,160
it's actually quite common to define one nonetheless.
但实际上，定义一个 main() 函数很常见。

1589
01:18:05,160 --> 01:18:08,850
So what I could do to solve this problem is this.
所以，解决这个问题的方法是：

1590
01:18:08,850 --> 01:18:12,980
Let me go ahead and define a function called main() that takes no arguments,
我可以定义一个名为 main() 的函数，它不接受任何参数，

1591
01:18:12,980 --> 01:18:14,030
in this case.
在这个例子中。

1592
01:18:14,030 --> 01:18:17,310
Let me indent that same code beneath it.
我将这段代码缩进，放在 main() 函数下面。

1593
01:18:17,310 --> 01:18:20,550
And now let me keep meow() defined at the bottom of my file.
现在，我把 meow() 函数定义放在文件的底部。

1594
01:18:20,550 --> 01:18:24,170
So if we read this literally, on line 1, I'm defining a function called main().
如果我们从字面上理解，在第 1 行，我定义了一个名为 main() 的函数。

1595
01:18:24,170 --> 01:18:27,110
And it will do what is prescribed on lines 2 and 3.
它将执行第 2 和第 3 行的代码。

1596
01:18:27,110 --> 01:18:30,050
On line 6, I'm defining a function called meow(),
在第 6 行，我定义了一个名为 meow() 的函数，

1597
01:18:30,050 --> 01:18:33,690
and it will do what's prescribed on line 7-- so fairly straightforward,
它将执行第 7 行的代码——非常简单，

1598
01:18:33,690 --> 01:18:36,260
even though the keyword def is, of course, new today.
即使关键词 def 是今天才出现的新东西。

1599
01:18:36,260 --> 01:18:38,870
If I run, though, python of meow.py, you'd
如果我运行 python meow.py，你会

1600
01:18:38,870 --> 01:18:40,370
like to think I'll see three meows.
希望看到三个 "喵"。

1601
01:18:40,370 --> 01:18:43,330
But I see nothing.
但我什么也看不到。

1602
01:18:43,330 --> 01:18:45,140
I don't see an error, but I see nothing.
我没看到错误，但我什么也看不到。

1603
01:18:45,140 --> 01:18:45,640
Why?
为什么？

1604
01:18:45,640 --> 01:18:50,240
Intuitively, what explains the lack of behavior?
直觉上，什么解释了这种行为的缺失？

1605
01:18:50,240 --> 01:18:51,310
I didn't call main().
我没有调用 main() 函数。

1606
01:18:51,310 --> 01:18:55,300
So this is the thing even though it's not required in Python to have a main()
所以，虽然 Python 不要求必须有一个 main()

1607
01:18:55,300 --> 01:18:59,840
function, but it is conventional in Python to have a main() function,
函数，但在 Python 中，使用 main() 函数是惯例，

1608
01:18:59,840 --> 01:19:02,320
you have to call the function yourself.
你必须自己调用这个函数。

1609
01:19:02,320 --> 01:19:04,840
It doesn't get magically called as it does in C.
它不像在 C 语言中那样被自动调用。

1610
01:19:04,840 --> 01:19:06,730
So this might seem a little stupid--
所以，这可能看起来有点愚蠢——

1611
01:19:06,730 --> 01:19:09,970
and that's fine-- but it is the convention in Python.
没关系——但这是 Python 中的惯例。

1612
01:19:09,970 --> 01:19:14,050
Generally, the very last line of your file might just be to literally this,
通常，你文件中的最后一行代码可能是这样：

1613
01:19:14,050 --> 01:19:18,310
call main(), because this satisfies the constraint that main() is defined
调用 main()，因为这满足了 main() 函数在

1614
01:19:18,310 --> 01:19:24,020
on line 1 meow() is defined on line 6, but we don't call anything until line
第 1 行定义，meow() 函数在第 6 行定义，但我们直到第

1615
01:19:24,020 --> 01:19:24,520
10.
10 行才调用函数。

1616
01:19:24,520 --> 01:19:26,590
So line 10 says call main().
所以，第 10 行的意思是调用 main() 函数。

1617
01:19:26,590 --> 01:19:28,420
So that means execute this code.
这意味着执行这段代码。

1618
01:19:28,420 --> 01:19:32,060
Line 3 says call meow(), which means execute this code.
第 3 行的意思是调用 meow() 函数，这意味着执行这段代码。

1619
01:19:32,060 --> 01:19:36,640
So now it all works because the last thing I'm doing is call main().
现在，所有代码都可以正常工作了，因为我最后做的就是调用 main() 函数。

1620
01:19:36,640 --> 01:19:38,920
You can think of C as just kind of secretly having
你可以将C语言视为在你不知情的情况下偷偷地拥有

1621
01:19:38,920 --> 01:19:41,380
this line there for you the whole time.
一直默默地存在那里的代码。

1622
01:19:41,380 --> 01:19:45,210
But now that we have our own functions, notice that we can enhance this
但现在我们有了自己的函数，请注意，我们可以增强

1623
01:19:45,210 --> 01:19:48,900
implementation of meow() to maybe be parameterized and take actually
meow() 的实现，使其参数化，并实际接收

1624
01:19:48,900 --> 01:19:50,080
an argument itself.
一个参数。

1625
01:19:50,080 --> 01:19:51,510
So let me make a tweak here.
所以让我在这里做一个小修改。

1626
01:19:51,510 --> 01:19:54,270
Just like in C, and just like in Scratch,
就像在 C 语言中一样，也像在 Scratch 中一样，

1627
01:19:54,270 --> 01:19:58,170
I can actually let meow() meow a specific number of times.
我实际上可以让 meow() 叫出特定的次数。

1628
01:19:58,170 --> 01:19:58,980
So let me do this.
所以让我来试试这个。

1629
01:19:58,980 --> 01:20:01,950
Wouldn't it be nice, instead of having my loop in main(),
如果我们不用在 main() 函数里写循环，而是

1630
01:20:01,950 --> 01:20:05,790
to instead just distill main() into a single line of code and just pass
将 main() 函数简化成一行代码，并且直接传入

1631
01:20:05,790 --> 01:20:08,250
in the number of times you want the thing to meow?
你想让它叫多少次呢？

1632
01:20:08,250 --> 01:20:11,640
What I could do in meow() here is I have to give it a parameter.
我可以在 meow() 函数里做的是，我必须给它一个参数。

1633
01:20:11,640 --> 01:20:13,140
And I could call it anything I want.
我可以随便给它取名字。

1634
01:20:13,140 --> 01:20:16,000
I'm going to call it n for number, which seems fine.
我打算把它叫做 n，代表数字，这样看起来还不错。

1635
01:20:16,000 --> 01:20:18,270
And then, in the meow() function, I could do this--
然后，在 meow() 函数里，我可以这样做--

1636
01:20:18,270 --> 01:20:25,290
for i in range of, not 3, but n now, I can tell range() to give me a range
for i in range of，不是 3，而是 n，现在我可以告诉 range() 函数给我一个

1637
01:20:25,290 --> 01:20:27,930
that is of variable length based on what n is.
根据 n 的值来决定长度的范围。

1638
01:20:27,930 --> 01:20:31,380
And then I indent the print() below the loop now.
然后现在我把 print() 函数缩进到循环的下面。

1639
01:20:31,380 --> 01:20:33,960
And this should now do what I expect, too.
这样应该就能得到我想要的结果了。

1640
01:20:33,960 --> 01:20:36,750
Let me run python of meow.py.
让我运行一下 meow.py 的 python 程序。

1641
01:20:36,750 --> 01:20:37,530
Enter.
回车。

1642
01:20:37,530 --> 01:20:38,730
And there's 3.
结果是 3 次。

1643
01:20:38,730 --> 01:20:43,000
But if I change the 3 to a 5 and rerun this, python of meow.py,
但如果我把 3 改成 5，然后重新运行这个程序，python of meow.py，

1644
01:20:43,000 --> 01:20:44,560
now I'm getting five meows.
现在我得到了 5 次猫叫声。

1645
01:20:44,560 --> 01:20:48,040
So we've just seen a third way how, in Python, now we
所以我们刚刚看到了第三种方法，在 Python 中，现在我们可以

1646
01:20:48,040 --> 01:20:52,780
can implement the idea of meowing as its own abstracted function.
将猫叫声的概念实现为一个独立的抽象函数。

1647
01:20:52,780 --> 01:20:54,730
And I can assume now that meow() exists.
现在我可以假设 meow() 函数已经存在了。

1648
01:20:54,730 --> 01:20:57,767
I can now treat it as out of sight, out of mind.
现在我可以把它当作眼不见心不烦的东西。

1649
01:20:57,767 --> 01:20:58,600
It's an abstraction.
这就是抽象。

1650
01:20:58,600 --> 01:21:02,530
And frankly, I could even put it into a library, import it from a file,
坦白地说，我甚至可以把它放到一个库里，从一个文件中导入它，

1651
01:21:02,530 --> 01:21:07,880
like we've done with CS50, and make it usable by other people as well.
就像我们对 CS50 做的那样，让其他人也能使用它。

1652
01:21:07,880 --> 01:21:10,720
So the takeaway here, really, though, is that in Python, you
所以，这里真正的重点是，在 Python 中，你可以

1653
01:21:10,720 --> 01:21:13,750
can, similarly to C, define your own functions.
像在 C 语言中一样，定义你自己的函数。

1654
01:21:13,750 --> 01:21:15,790
But you should understand the slight differences
但你应该理解一些细微的差异

1655
01:21:15,790 --> 01:21:19,150
as to what gets called automatically for you.
关于哪些东西会被自动调用。

1656
01:21:19,150 --> 01:21:19,900
All right.
好的。

1657
01:21:19,900 --> 01:21:22,360
Other differences or similarities with C?
与 C 语言相比，还有哪些其他差异或相似之处？

1658
01:21:22,360 --> 01:21:25,930
Well, recall that in C, truncation was an issue.
好吧，回想一下，在 C 语言中，截断是一个问题。

1659
01:21:25,930 --> 01:21:30,910
Truncation is whereby if you, for instance, divide an int by an int,
截断是指，如果你，例如，将一个 int 除以一个 int，

1660
01:21:30,910 --> 01:21:34,510
and it's a fractional answer, everything after the decimal point
而结果是一个小数，小数点后的所有内容

1661
01:21:34,510 --> 01:21:38,440
gets truncated by default because an int divided by an int in C
默认会被截断，因为在 C 语言中，一个 int 除以一个 int

1662
01:21:38,440 --> 01:21:39,560
gives you an int.
结果是一个 int。

1663
01:21:39,560 --> 01:21:43,780
And if you can't fit the remainder in that integer, everything at the decimal
如果你无法将余数放入那个整数中，小数点后的所有内容

1664
01:21:43,780 --> 01:21:44,810
gets cut off.
会被截断。

1665
01:21:44,810 --> 01:21:45,800
So what does this mean?
那这意味着什么呢？

1666
01:21:45,800 --> 01:21:48,170
Well, let me actually go back to VS Code here.
好吧，我实际上要回到 VS Code 里。

1667
01:21:48,170 --> 01:21:52,540
Let me go ahead and open, say, calculator.py again,
让我继续打开，比如，calculator.py 文件，

1668
01:21:52,540 --> 01:21:54,760
and let's change up what the calculator now does.
让我们改变一下这个计算器现在执行的操作。

1669
01:21:54,760 --> 01:21:55,610
Let me do this.
我来做这个。

1670
01:21:55,610 --> 01:22:00,010
Let me define a variable called x, set it equal to the input() function,
让我定义一个名为 x 的变量，并将其设置为等于 input() 函数，

1671
01:22:00,010 --> 01:22:01,510
prompting the user for x.
提示用户输入 x。

1672
01:22:01,510 --> 01:22:05,710
Let me ask the user for y, let me not repeat past mistakes,
让我询问用户 y，不要重蹈覆辙，

1673
01:22:05,710 --> 01:22:09,160
and let me proactively convert both of these to ints.
并让我主动将这两个值转换为整数。

1674
01:22:09,160 --> 01:22:13,720
And I'll do it in one pretty one-liner here so that I definitely get x and y.
我会在这里使用一行代码来完成，这样我就能确保获得 x 和 y。

1675
01:22:13,720 --> 01:22:15,850
And on the honor system, I just won't type cat.
而且我承诺，我不会输入“cat”。

1676
01:22:15,850 --> 01:22:17,980
I won't type dog, even though this program is not
我不会输入“dog”，即使这个程序没有

1677
01:22:17,980 --> 01:22:19,917
really complete without error checking.
没有错误检查就没有真正的完成。

1678
01:22:19,917 --> 01:22:22,000
Now, let me go ahead and declare a third variable,
现在，让我继续声明第三个变量，

1679
01:22:22,000 --> 01:22:26,230
z = x / y, and now let's just go ahead and print out z.
z = x / y，现在让我们直接打印出 z。

1680
01:22:26,230 --> 01:22:27,700
I don't need a format code.
我不需要格式代码。

1681
01:22:27,700 --> 01:22:28,810
I don't need an f string.
我不需要 f 字符串。

1682
01:22:28,810 --> 01:22:32,420
If all you want to do is print a variable, print() is very flexible.
如果你只想打印一个变量，print() 非常灵活。

1683
01:22:32,420 --> 01:22:35,200
You can just say print(z), in parentheses.
你只需在括号内写 print(z) 即可。

1684
01:22:35,200 --> 01:22:38,260
Let me run python of calculator.py, hit Enter.
让我运行 calculator.py 的 Python 代码，按 Enter 键。

1685
01:22:38,260 --> 01:22:42,040
Let's type in 1 for x, 3 for y.
让我们输入 1 作为 x，3 作为 y。

1686
01:22:42,040 --> 01:22:43,570
I left out a space there.
我漏掉了空格。

1687
01:22:43,570 --> 01:22:46,240
And oh, interesting.
哦，有趣。

1688
01:22:46,240 --> 01:22:48,170
What seems to have happened here?
这里发生了什么？

1689
01:22:48,170 --> 01:22:52,900
Let me fix my spacing and rerun this again-- python of calculator.py-- so 1,
让我修正一下空格，重新运行它——calculator.py 的 Python 代码——所以是 1，

1690
01:22:52,900 --> 01:22:53,740
3.
3。

1691
01:22:53,740 --> 01:22:55,510
What did not happen?
发生了什么？

1692
01:22:55,510 --> 01:22:56,830
AUDIENCE: It doesn't truncate.
观众：它没有截断。

1693
01:22:56,830 --> 01:22:57,370
DAVID MALAN: Yeah.
大卫·马兰：是的。

1694
01:22:57,370 --> 01:22:58,400
So it didn't truncate.
所以它没有截断。

1695
01:22:58,400 --> 01:23:00,430
So Python is a little smarter when it comes
所以 Python 在这方面更智能一些

1696
01:23:00,430 --> 01:23:02,660
to converting one value to another.
将一个值转换为另一个值。

1697
01:23:02,660 --> 01:23:05,050
So an integer divided by an integer, if it ends up
所以一个整数除以另一个整数，如果结果

1698
01:23:05,050 --> 01:23:07,780
giving you this fractional component, not to worry now,
出现了小数部分，现在不用担心，

1699
01:23:07,780 --> 01:23:11,860
you'll get back what is effectively a float in Python here.
你将在这里获得一个 Python 中的浮点数。

1700
01:23:11,860 --> 01:23:17,050
Well, what else do we want to be mindful of in, say, Python?
那么，在 Python 中，我们还需要注意什么？

1701
01:23:17,050 --> 01:23:20,920
Well, recall that in C, we had this issue of floating point and precision
在 C 语言中，我们有浮点数精度问题

1702
01:23:20,920 --> 01:23:24,760
whereby if you want to represent a number, like 1/3, and on a piece
比如，如果你想表示一个数字，比如 1/3，在一张纸上，它会是

1703
01:23:24,760 --> 01:23:27,640
of paper, it's, like, 0.3 with a line over it
0.3 上面有一条线

1704
01:23:27,640 --> 01:23:29,860
because the 3 infinitely repeats--
因为 3 无限循环——

1705
01:23:29,860 --> 01:23:33,040
but we saw a problem in C last time when we actually
但上一次，我们在 C 语言中看到了一个问题，当时我们实际上

1706
01:23:33,040 --> 01:23:34,550
played around with some value.
对一些值进行了操作。

1707
01:23:34,550 --> 01:23:37,000
So, for instance, let me go back to VS Code here.
例如，让我回到 VS Code 这里。

1708
01:23:37,000 --> 01:23:40,300
And this is going to be the ugliest syntax I do think we see today.
我认为这是我们今天见过的最难看的语法。

1709
01:23:40,300 --> 01:23:45,700
But there was a way in C, using %f, to show more than the default number
但在 C 语言中，我们可以使用 %f，显示比默认值更多的

1710
01:23:45,700 --> 01:23:49,030
of digits after the decimal point, to see more significant digits.
小数点后的数字，以查看更多有效数字。

1711
01:23:49,030 --> 01:23:50,830
In Python, there's something similar.
在 Python 中，也有类似的方法。

1712
01:23:50,830 --> 01:23:51,970
It just looks very weird.
它看起来很奇怪。

1713
01:23:51,970 --> 01:23:53,860
And the way you do it in Python is this.
你在 Python 中使用的方法是：

1714
01:23:53,860 --> 01:23:56,950
You specify that you want an f string, a format string.
你指定要使用 f 字符串，也就是格式化字符串。

1715
01:23:56,950 --> 01:23:59,440
And I'm just going to start and finish my thought first--
我首先要说明一下——

1716
01:23:59,440 --> 01:24:01,270
f before "".
f 放在 "" 之前。

1717
01:24:01,270 --> 01:24:04,910
If you want to print out z, you could literally just do this.
如果你想打印 z，你可以直接这样操作。

1718
01:24:04,910 --> 01:24:08,620
And so this is just an f string, but you're interpolating z.
所以这只是一个 f 字符串，但你正在插入 z。

1719
01:24:08,620 --> 01:24:12,040
So it doesn't do anything more than it did a moment ago when I literally just
所以它与我刚才直接输入z时的效果相同

1720
01:24:12,040 --> 01:24:13,090
passed in z.
输入z。

1721
01:24:13,090 --> 01:24:15,880
But as soon as you have an f string, you can
但只要你使用f字符串，你就可以

1722
01:24:15,880 --> 01:24:19,700
configure the variable to print out to a specific number of digits.
将变量配置为以指定位数打印出来。

1723
01:24:19,700 --> 01:24:24,910
So if you actually want to print out z to, say, 50 decimal points,
所以如果你真的想将z打印成，比如，50位小数，

1724
01:24:24,910 --> 01:24:28,210
just to see a lot, you can use crazy syntax like this.
为了看到很多位数，你可以使用这样的疯狂语法。

1725
01:24:28,210 --> 01:24:31,270
So it's just using the curly braces, as I introduced before.
所以它只是使用了花括号，就像我之前介绍的那样。

1726
01:24:31,270 --> 01:24:34,000
But you then use a dot after a colon, and then
但是你随后在冒号之后使用点，然后

1727
01:24:34,000 --> 01:24:37,270
you specify the number of digits that you want and then an f to make clear
你指定你想要的位数，然后添加一个f来明确

1728
01:24:37,270 --> 01:24:37,960
it's a float.
它是一个浮点数。

1729
01:24:37,960 --> 01:24:40,877
Honestly, I google this all the time when I don't remember the syntax.
老实说，当我记不住语法时，我总是去谷歌搜索。

1730
01:24:40,877 --> 01:24:43,470
But the point is the functionality exists.
但关键是这个功能是存在的。

1731
01:24:43,470 --> 01:24:43,970
All right.
好的。

1732
01:24:43,970 --> 01:24:48,320
Let me go down here and rerun python of calculator.py.
让我到下面重新运行calculator.py的Python程序。

1733
01:24:48,320 --> 01:24:52,640
And unfortunately, if I divide 1 by 3, not all of my problems are solved.
不幸的是，如果我将1除以3，并非所有的问题都解决了。

1734
01:24:52,640 --> 01:24:56,090
Floating point precision is still a thing.
浮点精度仍然存在。

1735
01:24:56,090 --> 01:24:59,150
So be mindful of the fact that there are these limitations
所以要注意，在Python世界中存在这些限制

1736
01:24:59,150 --> 01:25:00,860
in the world of Python.
。

1737
01:25:00,860 --> 01:25:02,240
Floating point precision remains.
浮点精度仍然存在。

1738
01:25:02,240 --> 01:25:04,490
If you want to do even better than that, though, there
如果你想做得比这更好，那么就存在

1739
01:25:04,490 --> 01:25:07,670
exist a lot more libraries, third-party libraries,
许多其他的库，第三方库，

1740
01:25:07,670 --> 01:25:11,630
that can give you much greater precision for scientific purposes,
它们可以为你提供更高的精度，以用于科学目的，

1741
01:25:11,630 --> 01:25:13,830
financial purposes, or the like.
财务目的，或类似的用途。

1742
01:25:13,830 --> 01:25:16,580
But what about another problem from C, integer overflow?
但C语言中的另一个问题，整数溢出呢？

1743
01:25:16,580 --> 01:25:19,370
If you just count to high, recall that you might accidentally
如果你只是计数到一个很大的数字，请记住，你可能会意外地

1744
01:25:19,370 --> 01:25:22,880
overflow the capacity of an integer and end up going back to 0,
超出整数的容量，最终回到0，

1745
01:25:22,880 --> 01:25:25,190
or worse, going negative altogether.
或者更糟糕的是，完全变为负数。

1746
01:25:25,190 --> 01:25:28,430
In Python, this problem does not exist.
在Python中，这个问题不存在。

1747
01:25:28,430 --> 01:25:31,610
In Python, when you have an integer, a.k.a.
在Python中，当你有一个整数，也称为

1748
01:25:31,610 --> 01:25:34,460
int, even though we haven't needed to use the keyword int,
int，即使我们不需要使用int关键字，

1749
01:25:34,460 --> 01:25:37,490
it will grow and grow and grow.
它会不断增长。

1750
01:25:37,490 --> 01:25:41,590
And Python will reserve more and more memory for that integer to fit it.
Python会为这个整数保留越来越多的内存来容纳它。

1751
01:25:41,590 --> 01:25:43,770
So it is not a fixed number of bits.
所以它不是一个固定数量的比特。

1752
01:25:43,770 --> 01:25:46,900
So floating point imprecision is still a problem.
所以浮点精度仍然是一个问题。

1753
01:25:46,900 --> 01:25:51,120
Integer overflow-- not a problem in the latest versions of Python,
整数溢出——在最新版本的Python中不是问题，

1754
01:25:51,120 --> 01:25:53,250
so a difference worth knowing.
这是一个值得注意的区别。

1755
01:25:53,250 --> 01:25:56,778
But what about other features of Python that we didn't have in C?
但Python中我们没有在C语言中拥有的其他功能呢？

1756
01:25:56,778 --> 01:25:59,820
Well, let's actually revisit one of those tracebacks, one of those errors
那么，让我们重新看看那些回溯，那些错误

1757
01:25:59,820 --> 01:26:03,130
I ran into earlier, to see how we might actually solve it.
我之前遇到过，看看我们如何实际解决它。

1758
01:26:03,130 --> 01:26:05,250
So let me go back to VS Code here.
所以让我回到这里的VS Code。

1759
01:26:05,250 --> 01:26:07,870
And just for fun, let me go ahead and do this.
为了好玩，让我继续做这个。

1760
01:26:07,870 --> 01:26:09,070
Let me clear my terminal.
让我清空我的终端。

1761
01:26:09,070 --> 01:26:12,248
And let me change my calculator to actually have a get_int() function.
让我修改我的计算器，使其拥有一个get_int()函数。

1762
01:26:12,248 --> 01:26:14,040
We've seen how to define our own functions.
我们已经了解了如何定义自己的函数。

1763
01:26:14,040 --> 01:26:15,930
Let me not bother with the CS50 library.
让我不要使用CS50库。

1764
01:26:15,930 --> 01:26:18,790
Let me just invent my own get_int() function as follows.
让我像下面这样发明自己的get_int()函数。

1765
01:26:18,790 --> 01:26:22,590
So def get_int(), and just like the CS50 function,
所以def get_int()，就像CS50函数一样，

1766
01:26:22,590 --> 01:26:26,250
I'm going to have get int take a prompt, a string to show the user to ask them
我要让 get_int 函数接收一个提示，一个字符串，用于向用户提问

1767
01:26:26,250 --> 01:26:27,150
for an integer.
以获取一个整数。

1768
01:26:27,150 --> 01:26:31,410
And now I'm going to go ahead and return the return value of input(),
现在，我将返回 input() 函数的返回值，

1769
01:26:31,410 --> 01:26:33,780
passing that same prompt to input()-- because input(),
并将相同的提示传递给 input() 函数——因为 input() 函数，

1770
01:26:33,780 --> 01:26:37,330
just like get_string(), shows the user a string of text.
就像 get_string() 函数一样，会向用户显示一个文本字符串。

1771
01:26:37,330 --> 01:26:40,930
But I do want to convert this thing here to an int.
但我想要将这里的内容转换为一个整数。

1772
01:26:40,930 --> 01:26:44,730
So this is just a one-liner, really, of an implementation of get_int().
所以这实际上只是一行代码，实现了 get_int() 函数。

1773
01:26:44,730 --> 01:26:49,050
So this is kind of like what CS50 did in its Python library, but not quite.
这有点类似于 CS50 在其 Python 库中所做的，但并不完全相同。

1774
01:26:49,050 --> 01:26:49,590
Why?
为什么？

1775
01:26:49,590 --> 01:26:51,010
Because there's a problem with it.
因为它存在一个问题。

1776
01:26:51,010 --> 01:26:51,760
So let me do this.
所以让我这样做。

1777
01:26:51,760 --> 01:26:54,030
Let me define a main() function just by convention.
让我按照惯例定义一个 main() 函数。

1778
01:26:54,030 --> 01:26:57,780
Let me use this implementation of get_int() to ask the user for x.
让我使用这个 get_int() 函数的实现来向用户询问 x 的值。

1779
01:26:57,780 --> 01:27:01,170
Let me use this get_int() function to prompt the user for y.
让我使用这个 get_int() 函数来提示用户输入 y 的值。

1780
01:27:01,170 --> 01:27:05,190
And then let me do something simple like print out x + y.
然后，让我做一些简单的操作，比如打印出 x + y 的结果。

1781
01:27:05,190 --> 01:27:08,340
And then, very last thing, I have to call main().
最后，我必须调用 main() 函数。

1782
01:27:08,340 --> 01:27:10,470
And this is a minor point, but I'm deliberately
这只是一个细微的点，但我故意

1783
01:27:10,470 --> 01:27:13,770
putting multiple blank lines between my functions.
在函数之间添加多行空白。

1784
01:27:13,770 --> 01:27:14,970
This too is Pythonic.
这也是 Python 风格的。

1785
01:27:14,970 --> 01:27:17,590
It's a matter of style. style50 will help you with this.
这是一个风格问题，style50 会帮助你解决这个问题。

1786
01:27:17,590 --> 01:27:21,630
It's just meant for larger files to really make your functions stand out
这只是为了让较大的文件中的函数更加突出，

1787
01:27:21,630 --> 01:27:24,400
and be a little more separated visually from others.
并在视觉上与其他函数保持一定的距离。

1788
01:27:24,400 --> 01:27:24,900
All right.
好的。

1789
01:27:24,900 --> 01:27:27,720
Let me go ahead and run Python of calculator.py.
让我运行 calculator.py 的 Python 代码。

1790
01:27:27,720 --> 01:27:28,710
Enter.
回车。

1791
01:27:28,710 --> 01:27:29,790
Let me type in 1.
让我输入 1。

1792
01:27:29,790 --> 01:27:31,020
Let me type in 3.
让我输入 3。

1793
01:27:31,020 --> 01:27:32,400
And that actually works.
这实际上是有效的。

1794
01:27:32,400 --> 01:27:33,840
1 plus 3 is 4.
1 加 3 等于 4。

1795
01:27:33,840 --> 01:27:35,130
Let me do the more obvious.
让我做更明显的事情。

1796
01:27:35,130 --> 01:27:37,200
1 plus 2 gives me 3.
1 加 2 等于 3。

1797
01:27:37,200 --> 01:27:41,310
So the calculator is in fact working until such time as I, the human,
所以，这个计算器确实有效，直到我，这个人类，

1798
01:27:41,310 --> 01:27:44,410
don't cooperate and type in something like cat for x.
不配合，输入像 cat 这样的东西作为 x 的值。

1799
01:27:44,410 --> 01:27:47,490
Then we get that same traceback as before,
然后，我们会得到与之前相同的跟踪信息，

1800
01:27:47,490 --> 01:27:49,390
but I'm seeing it now in this file.
但我现在在文件中看到了。

1801
01:27:49,390 --> 01:27:51,790
And let me zoom in on my terminal just to make clear.
让我放大终端，以便看得更清楚。

1802
01:27:51,790 --> 01:27:55,920
We don't need to see the old history there.
我们不需要看到那里的历史记录。

1803
01:27:55,920 --> 01:28:00,390
Let me type in cat, Enter, and you'll see the same traceback.
让我输入 cat，回车，你就会看到相同的跟踪信息。

1804
01:28:00,390 --> 01:28:03,150
And you'll see that, OK, here's where now there's
你会看到，好吧，现在这里有

1805
01:28:03,150 --> 01:28:04,450
multiple functions involved.
多个函数参与其中。

1806
01:28:04,450 --> 01:28:05,430
So what's going on?
所以发生了什么？

1807
01:28:05,430 --> 01:28:08,550
The first problem is at line 12 in main().
第一个问题出现在 main() 函数中的第 12 行。

1808
01:28:08,550 --> 01:28:12,410
But that's not actually the problem because main() calls my get_int()
但这并不是真正的問題，因為 main() 函數调用了我的 get_int()

1809
01:28:12,410 --> 01:28:12,910
function.
函数。

1810
01:28:12,910 --> 01:28:17,410
So on line 6 of calculator.py, this is really the issue--
所以，在 calculator.py 文件中的第 6 行，这才是真正的问题——

1811
01:28:17,410 --> 01:28:21,330
so, again, it's tracing everything that just happened from top to bottom here--
所以，再次说明，它正在从上到下跟踪这里刚刚发生的所有事情——

1812
01:28:21,330 --> 01:28:25,440
and value error-- invalid literal for int() with base 10,
以及值错误——对于 int() 函数来说，'cat' 是一个无效的文字，基数为 10，

1813
01:28:25,440 --> 01:28:30,780
'cat,' which is to say, like before, cat is not an integer in base 10 or any
'cat'，也就是说，就像之前一样，cat 在 10 进制或任何

1814
01:28:30,780 --> 01:28:31,350
other base.
其他进制中都不是一个整数。

1815
01:28:31,350 --> 01:28:34,090
It just cannot be converted to an integer.
它不能被转换为一个整数。

1816
01:28:34,090 --> 01:28:38,080
So how do you fix this, or, really, how does the CS50 library fix this?
那么，你该如何解决这个问题呢？或者说，CS50 库是如何解决这个问题的？

1817
01:28:38,080 --> 01:28:40,180
You won't have to write much code like this.
你将不必编写太多这样的代码。

1818
01:28:40,180 --> 01:28:44,220
But it turns out that Python supports what are called exceptions.
但事实证明，Python 支持所谓的异常。

1819
01:28:44,220 --> 01:28:47,310
And generally, an exception is a better way
通常，异常是处理某些类型的错误的更好方法

1820
01:28:47,310 --> 01:28:50,610
of handling certain types of errors because in C, recall
因为在 C 语言中，请回忆一下

1821
01:28:50,610 --> 01:28:53,160
that the only way we could really handle errors
我们真正处理错误的唯一方法

1822
01:28:53,160 --> 01:28:56,310
is by having functions return special values.
是让函数返回特殊值。

1823
01:28:56,310 --> 01:29:00,330
malloc() could return null, which means it ran out of memory.
malloc() 可以返回 null，这意味着它内存不足。

1824
01:29:00,330 --> 01:29:01,560
Something went wrong.
出问题了。

1825
01:29:01,560 --> 01:29:06,270
Some functions we wrote in C could return 1, could return 2,
我们在 C 语言中编写的一些函数可以返回 1，可以返回 2，

1826
01:29:06,270 --> 01:29:07,380
could return negative 1.
可以返回 -1。

1827
01:29:07,380 --> 01:29:10,260
Recall that we could write our own functions that return values
请回忆一下，我们可以编写返回值的自定义函数

1828
01:29:10,260 --> 01:29:12,180
to indicate something went wrong.
以指示出错。

1829
01:29:12,180 --> 01:29:15,690
But the problem in C is that if you're stealing certain values,
但在 C 语言中，问题在于如果你正在窃取某些值，

1830
01:29:15,690 --> 01:29:23,280
be it null or 1 or 2 or 3, your function can never return null or 1 or 2 or 3
无论是 null 还是 1 还是 2 还是 3，你的函数永远不能返回 null 还是 1 还是 2 还是 3

1831
01:29:23,280 --> 01:29:24,640
as actual values.
作为实际值。

1832
01:29:24,640 --> 01:29:25,140
Why?
为什么？

1833
01:29:25,140 --> 01:29:27,598
Because other people are going to interpret them as errors.
因为其他人会将它们解释为错误。

1834
01:29:27,598 --> 01:29:30,960
So you kind of have to use up some of your possible return values
因此，你必须使用一些可能的返回值

1835
01:29:30,960 --> 01:29:35,310
in a language like C and treat them specially as errors.
在像 C 这样的语言中，并将它们特殊地视为错误。

1836
01:29:35,310 --> 01:29:37,380
In Python and other languages--
在 Python 和其他语言中——

1837
01:29:37,380 --> 01:29:39,280
Java and others-- you don't have to do that.
Java 和其他语言——你无需这样做。

1838
01:29:39,280 --> 01:29:43,260
You can instead have more out of band error handling, known as exceptions.
你可以改为使用带外错误处理，称为异常。

1839
01:29:43,260 --> 01:29:44,760
And that's what's happening here.
这就是这里发生的事情。

1840
01:29:44,760 --> 01:29:49,880
When I run calculator.py and I type in cat, what I'm seeing here
当我运行 calculator.py 并输入 cat 时，我在这里看到的是

1841
01:29:49,880 --> 01:29:51,810
is actually an exception.
实际上是一个异常。

1842
01:29:51,810 --> 01:29:54,650
It's something exceptional, but not in a good way.
这是一件例外的事情，但不是好的方面。

1843
01:29:54,650 --> 01:29:57,500
This exception means this was not supposed to happen.
这个异常意味着这本不应该发生。

1844
01:29:57,500 --> 01:30:00,663
The type of exception happens to be called a value error.
这种异常恰好被称为 ValueError。

1845
01:30:00,663 --> 01:30:03,830
And within the world of Python, there's this whole taxonomy, that is to say,
在 Python 的世界里，存在着整个分类法，也就是说，

1846
01:30:03,830 --> 01:30:05,570
a whole list of possible exceptions.
存在着整个可能的异常列表。

1847
01:30:05,570 --> 01:30:07,370
ValueError is one of the most common.
ValueError 是最常见的异常之一。

1848
01:30:07,370 --> 01:30:09,980
We saw another one before, name error, when I said
我们之前见过另一个异常，NameError，当我说了

1849
01:30:09,980 --> 01:30:12,560
meow when Python didn't know what meow meant.
meow 时，Python 不知道 meow 的意思。

1850
01:30:12,560 --> 01:30:14,630
So this is just an example of an exception.
所以这只是一个异常的例子。

1851
01:30:14,630 --> 01:30:18,320
But what this means is that there is a way for me to try to handle this
但这意味着，我有一种方法可以尝试处理这种情况

1852
01:30:18,320 --> 01:30:19,130
myself.
我自己。

1853
01:30:19,130 --> 01:30:21,170
So I'm actually going to go ahead and do this.
所以，我实际上将继续执行此操作。

1854
01:30:21,170 --> 01:30:26,420
Instead of get_int() simply blindly returning the integer conversion
而不是让 get_int() 简单地盲目地返回用户提供给我的任何输入的整数转换

1855
01:30:26,420 --> 01:30:31,430
of whatever input the user gives me, I'm going to instead literally try to do
而是尝试做

1856
01:30:31,430 --> 01:30:32,880
this instead.
这个。

1857
01:30:32,880 --> 01:30:34,600
So it's kind of a aptly named phrase.
所以它是一个恰如其分的短语。

1858
01:30:34,600 --> 01:30:35,600
It literally means that.
它的意思就是那样。

1859
01:30:35,600 --> 01:30:39,710
Please try to do this, except if something goes wrong,
请尝试执行此操作，除非出现错误，

1860
01:30:39,710 --> 01:30:45,030
except if there is a ValueError, in which case
除非出现 ValueError，在这种情况下

1861
01:30:45,030 --> 01:30:47,340
I want Python to do something else, for instance,
我希望 Python 执行其他操作，例如

1862
01:30:47,340 --> 01:30:50,380
quote unquote, "Not an integer."
说白了，就是“不是整数”。

1863
01:30:50,380 --> 01:30:51,550
So what does this mean?
那么这意味着什么？

1864
01:30:51,550 --> 01:30:53,130
It's a little weird, the syntax.
语法有点奇怪。

1865
01:30:53,130 --> 01:30:57,790
But in the get_int() function, Python will first try to do the following.
但在 get_int() 函数中，Python 将首先尝试执行以下操作。

1866
01:30:57,790 --> 01:31:00,090
It will try to get an input from the user.
它将尝试从用户那里获取输入。

1867
01:31:00,090 --> 01:31:01,780
It will try to convert it to an integer.
它将尝试将其转换为整数。

1868
01:31:01,780 --> 01:31:03,240
And it will try to return it.
它将尝试将其返回。

1869
01:31:03,240 --> 01:31:07,590
But if one of those operations fails, namely the integer step in this case,
但如果其中一个操作失败，在这种情况下，特别是整数步骤，

1870
01:31:07,590 --> 01:31:09,840
then an exception could happen.
就会发生异常。

1871
01:31:09,840 --> 01:31:11,770
And you might get what's called a ValueError.
你可能会得到一个叫做 ValueError 的错误。

1872
01:31:11,770 --> 01:31:11,940
Why?
为什么？

1873
01:31:11,940 --> 01:31:14,190
Because the documentation tells you that might happen.
因为文档告诉过你可能会发生这种情况。

1874
01:31:14,190 --> 01:31:16,170
Or, in my case, I experienced it firsthand,
或者，在我的例子中，我亲身经历过，

1875
01:31:16,170 --> 01:31:20,140
and now I want to catch this kind of exception in my own code.
现在我想在我的代码中捕获这种异常。

1876
01:31:20,140 --> 01:31:22,200
So if there is a ValueError, I'm not going
所以，如果有 ValueError，我不会

1877
01:31:22,200 --> 01:31:24,030
to see that crazy traceback anymore.
再看到那个疯狂的跟踪信息。

1878
01:31:24,030 --> 01:31:28,080
I'm instead going to see, quote unquote, "Not an integer."
我反而会看到“不是整数”的提示。

1879
01:31:28,080 --> 01:31:31,080
But what the CS50 library does for you technically is it
但从技术上讲，CS50 库为你做的就是

1880
01:31:31,080 --> 01:31:33,510
lets you try again and again and again.
让你反复尝试。

1881
01:31:33,510 --> 01:31:36,178
Recall in the past, if I type in cat and dog and bird,
还记得之前，如果我输入 cat、dog 和 bird，

1882
01:31:36,178 --> 01:31:38,220
it's just going to keep asking me again and again
它会反复询问我

1883
01:31:38,220 --> 01:31:39,810
until I actually give it an int.
直到我真正输入一个整数。

1884
01:31:39,810 --> 01:31:43,620
So that kind of implies that we really need a loop inside of this function.
所以，这意味着我们真的需要在这个函数中使用循环。

1885
01:31:43,620 --> 01:31:45,810
And the easiest way to do something forever
最简单的方法是让程序永远运行

1886
01:31:45,810 --> 01:31:50,820
is to loop while true, just like in C, but a capital T in Python.
就是使用 while true 循环，就像在 C 语言中一样，但在 Python 中，T 要大写。

1887
01:31:50,820 --> 01:31:54,810
And what I'm going to do now is implement a better version of get_int()
我现在要实现一个更完善的 get_int() 版本

1888
01:31:54,810 --> 01:31:57,030
here because what's it going to do?
因为它的作用是什么？

1889
01:31:57,030 --> 01:31:59,910
It is going to try-- it's going to do this forever.
它会尝试——它会永远这样做。

1890
01:31:59,910 --> 01:32:03,840
It's going to try to get an input, convert it to an int, and return it.
它会尝试获取输入、将其转换为整数并返回。

1891
01:32:03,840 --> 01:32:07,590
And just like break breaks you out of a loop,
就像 break 可以让你跳出循环一样，

1892
01:32:07,590 --> 01:32:10,650
return also breaks you out of a loop as well, right?
return 也可以让你跳出循环，对吧？

1893
01:32:10,650 --> 01:32:14,010
Because once you've returned, there's no more need for this function to execute.
因为一旦你返回，这个函数就不再需要执行。

1894
01:32:14,010 --> 01:32:17,370
So long story short, you won't have to write much code like this yourself.
总之，你不需要自己写很多这样的代码。

1895
01:32:17,370 --> 01:32:23,100
But this is essentially what the CS50 library is doing when it implements
但这本质上是 CS50 库在实现时所做的

1896
01:32:23,100 --> 01:32:24,960
the Python version of get_int().
Python 版本的 get_int() 函数。

1897
01:32:24,960 --> 01:32:26,310
So what happens now?
现在会发生什么？

1898
01:32:26,310 --> 01:32:31,028
If I run python of calculator.py, and I type in cat, I get yelled at,
如果我运行 calculator.py 的 Python 代码，然后输入 cat，我会收到提示，

1899
01:32:31,028 --> 01:32:32,820
but I'm prompted again because of the loop.
但由于循环，我会再次被提示。

1900
01:32:32,820 --> 01:32:33,697
I type in dog.
我输入 dog。

1901
01:32:33,697 --> 01:32:35,280
I'm yelled at, but I'm prompted again.
我收到提示，但我会再次被提示。

1902
01:32:35,280 --> 01:32:38,190
I type in bird, yelled at, but I'm prompted again.
我输入 bird，收到提示，但我会再次被提示。

1903
01:32:38,190 --> 01:32:41,970
If I type in 1, then I type in 2, now it proceeds
如果我输入 1，然后输入 2，现在它会继续执行

1904
01:32:41,970 --> 01:32:46,470
because it tried and succeeded this time as opposed to trying and failing
因为它这次尝试并成功了，而上次尝试却失败了

1905
01:32:46,470 --> 01:32:47,130
last time.
上次。

1906
01:32:47,130 --> 01:32:49,770
And technically, the CS50 library doesn't actually
从技术上讲，CS50 库实际上不会

1907
01:32:49,770 --> 01:32:51,580
yell at you with "Not an integer."
用“不是整数”的提示来提醒你。

1908
01:32:51,580 --> 01:32:54,750
So technically, if you want to handle the error, that is to say,
所以从技术上讲，如果你想处理这个错误，也就是说，

1909
01:32:54,750 --> 01:32:58,440
catch the exception, you can actually just say, oh, pass,
捕获异常，你实际上只需说，哦，pass，

1910
01:32:58,440 --> 01:33:02,290
and it will just silently try again and again.
它会默默地反复尝试。

1911
01:33:02,290 --> 01:33:06,670
So let me go ahead and run this. python of calculator.py works almost the same.
所以让我运行它，calculator.py 的 Python 代码与之前的代码几乎相同。

1912
01:33:06,670 --> 01:33:09,390
But notice now it works just like the C version.
但是请注意，它现在的工作方式与 C 版本相同。

1913
01:33:09,390 --> 01:33:13,290
It doesn't yell at you, but it does prompt you again and again and again.
它不会对你大喊大叫，但它会一次又一次地提示你。

1914
01:33:13,290 --> 01:33:16,120
But I'll do 1 and 2, and that now is satisfied.
但是我会输入 1 和 2，现在就满足了。

1915
01:33:16,120 --> 01:33:18,450
So that then is exceptions which you'll encounter,
所以这些就是你会遇到的异常，

1916
01:33:18,450 --> 01:33:21,930
but you yourself won't have to write much code along those lines.
但你自身不需要写很多这方面的代码。

1917
01:33:21,930 --> 01:33:23,650
Well, what else can we now do?
那么，我们现在还能做什么？

1918
01:33:23,650 --> 01:33:25,860
Well, let's revisit something like this for Mario,
让我们重新审视一下像这样的马里奥代码，

1919
01:33:25,860 --> 01:33:29,400
recall, whereby we had this two-dimensional world with things
回想一下，我们之前有一个二维世界，其中有各种东西

1920
01:33:29,400 --> 01:33:33,030
in the way for Mario, like this column of three bricks.
挡住马里奥的路，比如这一列三块砖。

1921
01:33:33,030 --> 01:33:35,610
Let me actually play around now for a moment with some loops
让我现在花点时间来玩玩循环

1922
01:33:35,610 --> 01:33:38,040
just to see how there's different ways that might actually
看看是否有不同的方式，实际上

1923
01:33:38,040 --> 01:33:41,410
resonate with you just in terms of the simplicity of some of these things.
会让你产生共鸣，仅仅因为这些东西的简单性。

1924
01:33:41,410 --> 01:33:44,310
Let me go ahead and create a program called mario.py.
让我创建一个叫做 mario.py 的程序。

1925
01:33:44,310 --> 01:33:47,970
And suppose that I want to print a column of three bricks.
假设我想打印一列三块砖。

1926
01:33:47,970 --> 01:33:50,580
It kind of doesn't get any easier than this in Python.
在 Python 中，这几乎是最简单的做法了。

1927
01:33:50,580 --> 01:33:55,800
So for i in range(3), just go ahead and print out a single hash--
所以对于 i 在 range(3) 中，就打印一个井号——

1928
01:33:55,800 --> 01:33:57,150
done.
完成。

1929
01:33:57,150 --> 01:34:00,600
That then is what we took us more lines of code in the past.
这正是我们之前用更多代码行才能实现的功能。

1930
01:34:00,600 --> 01:34:03,755
But if I run mario.py, that there gets the job done.
但是如果我运行 mario.py，它就能完成任务。

1931
01:34:03,755 --> 01:34:05,880
I could change the i to an underscore, but it's not
我可以把 i 变成下划线，但这

1932
01:34:05,880 --> 01:34:09,660
bad to remind myself that i is what's really doing my counting.
并不好，它提醒我 i 才是真正进行计数的变量。

1933
01:34:09,660 --> 01:34:11,970
Well, what else could we do beyond this?
那么，除了这个，我们还能做什么？

1934
01:34:11,970 --> 01:34:17,310
Well, recall that in the world of Mario, we prompted the user, actually,
回想一下，在马里奥的世界里，我们实际上提示了用户

1935
01:34:17,310 --> 01:34:18,660
for a specific height.
输入一个特定的高度。

1936
01:34:18,660 --> 01:34:20,640
We didn't just always hardcode 3.
我们并不总是硬编码 3。

1937
01:34:20,640 --> 01:34:23,680
So I could actually do something like this.
所以我实际上可以这样做。

1938
01:34:23,680 --> 01:34:28,860
Let me actually open up from today's code that I came with in advance
让我从今天提前准备好的代码中打开

1939
01:34:28,860 --> 01:34:31,830
and pull up this C version of Mario.
并调出这个马里奥的 C 版本。

1940
01:34:31,830 --> 01:34:34,260
So this was from some time ago, in week 1.
这是几周前，第一周的代码。

1941
01:34:34,260 --> 01:34:38,250
And this is how we implemented a loop that
这就是我们实现的循环，它

1942
01:34:38,250 --> 01:34:43,400
ensures that we get a positive integer from the user by just doing while
通过使用 while 循环来确保我们从用户那里得到一个正整数。

1943
01:34:43,400 --> 01:34:45,890
and is not positive, and then we use this for loop
它不是正数，然后我们使用这个 for 循环

1944
01:34:45,890 --> 01:34:47,850
to actually print out that many hashes.
来打印出那么多井号。

1945
01:34:47,850 --> 01:34:50,250
Now, in Python, it's actually going to be pretty similar,
现在，在 Python 中，它实际上会非常类似，

1946
01:34:50,250 --> 01:34:53,900
except for the fact that in Python, there is no do while loop.
除了在 Python 中没有 do while 循环。

1947
01:34:53,900 --> 01:34:55,670
But recall that a do while loop was useful
但回想一下，do while 循环是有用的，因为它

1948
01:34:55,670 --> 01:34:59,215
because it means you can get the user to try something and then maybe try again,
意味着你可以让用户尝试一些东西，然后可能再尝试一次，

1949
01:34:59,215 --> 01:35:00,590
maybe try again, maybe try again.
可能再尝试一次，可能再尝试一次。

1950
01:35:00,590 --> 01:35:02,970
So it's really good for user input.
所以它非常适合用户输入。

1951
01:35:02,970 --> 01:35:04,220
So let's actually do this.
所以让我们实际操作一下。

1952
01:35:04,220 --> 01:35:07,580
Let me borrow the CS50's library get_int() function,
让我借用 CS50 库的 get_int() 函数，

1953
01:35:07,580 --> 01:35:10,940
just so we don't have to re-implement that ourselves again and again.
这样我们就不用一次又一次地自己重新实现它了。

1954
01:35:10,940 --> 01:35:14,300
Let me, in Python, do this the Pythonic way.
让我在 Python 中以 Pythonic 的方式来做这件事。

1955
01:35:14,300 --> 01:35:17,630
In Python, if you want to prompt the user to do something again and again
在 Python 中，如果你想反复提示用户做某事，

1956
01:35:17,630 --> 01:35:20,780
and again, potentially, you deliberately, by convention,
再一次，可能，你故意，通过惯例，

1957
01:35:20,780 --> 01:35:22,200
induce an infinite loop.
诱导一个无限循环。

1958
01:35:22,200 --> 01:35:24,200
You just get yourself into an infinite loop.
你只是把自己陷入无限循环。

1959
01:35:24,200 --> 01:35:27,260
But the goal is going to be try something, try something, try
但目标是要尝试一些东西，尝试一些东西，尝试

1960
01:35:27,260 --> 01:35:30,230
something, and as soon as you have what you want, break out of the loop
一些东西，一旦你得到了想要的东西，就退出循环

1961
01:35:30,230 --> 01:35:31,050
instead.
反而。

1962
01:35:31,050 --> 01:35:34,370
So we're implementing the idea of a do while loop ourselves.
所以我们自己实现了 do while 循环的思想。

1963
01:35:34,370 --> 01:35:37,940
So I'm going to do this. n, for number, equals get_int(),
所以我会这样做。n，表示数字，等于 get_int()，

1964
01:35:37,940 --> 01:35:40,220
and let's ask the user for a height.
让我们向用户询问高度。

1965
01:35:40,220 --> 01:35:42,020
Then let's just check.
然后让我们检查一下。

1966
01:35:42,020 --> 01:35:44,430
If n is greater than 0, you know what?
如果 n 大于 0，你知道吗？

1967
01:35:44,430 --> 01:35:44,930
Break.
退出。

1968
01:35:44,930 --> 01:35:46,400
We've got the value we need.
我们得到了我们需要的价值。

1969
01:35:46,400 --> 01:35:50,420
And if not, it's just going to implicitly keep looping again and again
如果没有，它就会隐式地不断循环下去

1970
01:35:50,420 --> 01:35:51,020
and again.
再循环一次。

1971
01:35:51,020 --> 01:35:53,690
So in Python, this is to say-- super common--
所以在 Python 中，这表示——非常常见——

1972
01:35:53,690 --> 01:35:57,770
to deliberately induce an infinite loop and break out of it when you have
故意诱发一个无限循环，并在你拥有想要的东西时退出循环。

1973
01:35:57,770 --> 01:35:58,740
what you want.
你想要的东西。

1974
01:35:58,740 --> 01:35:59,240
All right?
好吗？

1975
01:35:59,240 --> 01:36:03,770
Now I can just do the same kind of code as before. for i in range not of--
现在我可以像以前一样编写相同的代码。for i in range 不用——

1976
01:36:03,770 --> 01:36:07,580
rage sometimes-- for i in range, not 3, but n,
range 有时候——for i in range，不是 3，而是 n，

1977
01:36:07,580 --> 01:36:10,640
now I can go ahead and print out--
现在我可以继续打印出——

1978
01:36:10,640 --> 01:36:12,432
oops-- a hash like this.
糟糕——一个这样的哈希。

1979
01:36:12,432 --> 01:36:15,140
If I open my terminal window, it's going to work almost the same,
如果我打开终端窗口，它几乎会以相同的方式工作，

1980
01:36:15,140 --> 01:36:17,400
but now mario is going to prompt me for the height.
但现在马里奥会提示我输入高度。

1981
01:36:17,400 --> 01:36:20,690
So I could type in 3, or I could type in 4,
所以我可以输入 3，或者我可以输入 4，

1982
01:36:20,690 --> 01:36:25,910
or I could be uncooperative and type in 0 or negative 1 or even cat.
或者我可以不合作地输入 0 或负 1，甚至输入 cat。

1983
01:36:25,910 --> 01:36:29,510
And because I'm using the CS50 library, cat is ignored.
因为我使用的是 CS50 库，所以 cat 被忽略了。

1984
01:36:29,510 --> 01:36:32,420
Because I'm using my while loop and breaking out
因为我使用了 while 循环，并且只在 n 为正时才退出循环

1985
01:36:32,420 --> 01:36:37,520
of it only when n is positive, I'm also ignoring the 0 and the negative 1.
所以我也忽略了 0 和负 1。

1986
01:36:37,520 --> 01:36:43,060
So, again, this would be a Pythonic way of implementing this particular idea.
所以，再次强调，这将是实现这个特定想法的 Pythonic 方式。

1987
01:36:43,060 --> 01:36:49,630
If I want to maybe enhance this a bit further, let me propose that,
如果我想进一步增强它，我建议，

1988
01:36:49,630 --> 01:36:55,450
for instance, we consider something like the two-dimensional version--
例如，我们考虑像二维版本这样的东西——

1989
01:36:55,450 --> 01:36:58,490
or the horizontal version of this instead.
或者考虑它的水平版本。

1990
01:36:58,490 --> 01:37:00,610
So recall that some time ago, we printed out,
所以回忆一下，之前我们打印过，

1991
01:37:00,610 --> 01:37:03,340
like, four question marks in the sky that might have
比如，天空中四个问号，它们可能

1992
01:37:03,340 --> 01:37:05,090
looked a little something like this.
看起来有点像这样。

1993
01:37:05,090 --> 01:37:09,740
Now, the very mechanical way to do this would be as follows.
现在，非常机械的做法如下。

1994
01:37:09,740 --> 01:37:11,200
Let me close my C code.
让我关闭我的 C 代码。

1995
01:37:11,200 --> 01:37:12,770
Let me clear my terminal.
让我清空我的终端。

1996
01:37:12,770 --> 01:37:16,060
And let me just delete my old mario version here.
让我删除我在这里的旧版马里奥。

1997
01:37:16,060 --> 01:37:20,800
And let's just do this-- for i in range(4), let's go ahead
让我们就这样做——for i in range(4)，让我们继续

1998
01:37:20,800 --> 01:37:23,620
and print out a question mark, all right?
并打印一个问号，好吗？

1999
01:37:23,620 --> 01:37:26,140
I'm going to run python of mario.py, enter,
我将运行 mario.py 的 python，输入，

2000
01:37:26,140 --> 01:37:30,430
and, ugh, it's still a column instead of a row.
而且，呃，它仍然是一列而不是一行。

2001
01:37:30,430 --> 01:37:34,245
But what's the fix here, perhaps?
但是这里有什么解决方法吗？

2002
01:37:34,245 --> 01:37:34,870
What's the fix?
有什么解决方法吗？

2003
01:37:34,870 --> 01:37:35,770
Yeah?
是吗？

2004
01:37:35,770 --> 01:37:37,270
AUDIENCE: The end equals [INAUDIBLE]
观众：结尾等于 [听不见]

2005
01:37:37,270 --> 01:37:38,020
DAVID MALAN: Yeah.
大卫·马兰：是的。

2006
01:37:38,020 --> 01:37:41,350
We can use that named parameter and say end=""
我们可以使用这个命名参数，并说 end=""

2007
01:37:41,350 --> 01:37:43,720
to just suppress the default backslash n.
只是为了抑制默认的反斜杠 n。

2008
01:37:43,720 --> 01:37:46,660
But let's give ourselves one at the very end of the loop
但让我们在循环的最后给自己一个

2009
01:37:46,660 --> 01:37:48,500
just to move the cursor correctly.
只是为了正确移动光标。

2010
01:37:48,500 --> 01:37:50,890
So now if I run python of mario.py, now it
所以现在，如果我运行 mario.py 的 python，现在它

2011
01:37:50,890 --> 01:37:53,780
looks like what it might have in the sky here.
看起来像它可能在天空中的样子。

2012
01:37:53,780 --> 01:37:57,400
But it turns out Python has some neat features, too, more syntactic sugar,
但事实证明，Python 也有一些很酷的功能，更多的语法糖，

2013
01:37:57,400 --> 01:37:59,590
if you will, for doing things a little more easily.
如果你愿意，可以更容易地完成一些事情。

2014
01:37:59,590 --> 01:38:01,850
It turns out in Python, you could also do this.
事实证明，在 Python 中，你也可以这样做。

2015
01:38:01,850 --> 01:38:03,430
You could just say print("?" * 4).
你可以直接说 print("?" * 4)。

2016
01:38:06,490 --> 01:38:11,230
And just like + means concatenation, * here means,
就像 + 代表连接一样，* 在这里代表，

2017
01:38:11,230 --> 01:38:14,170
really, multiply the string by itself that many times, so sort
实际上，将字符串自身乘以这么多次，所以排序

2018
01:38:14,170 --> 01:38:16,610
of automatically concatenate it with itself.
自动地将它自身连接起来。

2019
01:38:16,610 --> 01:38:19,327
So if I run python of mario.py, this too works-- so,
所以如果我运行 mario.py 的 python，这也是可以的——所以，

2020
01:38:19,327 --> 01:38:21,910
again, just some features of Python that make it a little more
再次，只是一些 Python 的特性，使它更

2021
01:38:21,910 --> 01:38:25,660
pleasant to use so you don't always have to slog through implementing
使用起来更愉快，所以你不必总是费力地实现

2022
01:38:25,660 --> 01:38:27,710
a loop or something along those lines.
一个循环或类似的东西。

2023
01:38:27,710 --> 01:38:29,710
Well, what about something more two-dimensional,
那么，关于更二维的东西，

2024
01:38:29,710 --> 01:38:32,800
like in the world of this brick here?
就像在这块砖的世界里？

2025
01:38:32,800 --> 01:38:36,040
Well, in the context of this sort of grid of bricks,
那么，在这种砖块网格的背景下，

2026
01:38:36,040 --> 01:38:38,450
we might do something like this in VS Code.
我们可能会在 VS Code 中做这样的事情。

2027
01:38:38,450 --> 01:38:43,700
Let me go back to mario.py, and let me do a 3-by-3 grid for that block,
让我回到 mario.py，让我为那个块创建一个 3x3 的网格，

2028
01:38:43,700 --> 01:38:44,840
like we did in week 1.
就像我们在第一周做的那样。

2029
01:38:44,840 --> 01:38:47,870
So for i in range(3)--
所以，对于 i 在 range(3) 中——

2030
01:38:47,870 --> 01:38:52,340
I can nest loops, just like in C-- for j in range(3),
我可以嵌套循环，就像在 C 中一样——对于 j 在 range(3) 中，

2031
01:38:52,340 --> 01:38:55,190
I can then print out a hash here.
然后我可以在此处打印一个井号。

2032
01:38:55,190 --> 01:38:58,370
And then let's leave this alone even though it's not quite right yet.
然后让我们先不管它，尽管它还不完全正确。

2033
01:38:58,370 --> 01:39:00,620
Let's do python of mario.py.
让我们运行 mario.py 的 python。

2034
01:39:00,620 --> 01:39:04,700
OK, it's, like, nine bricks all in a column, which so your mind might
好的，它就像九块砖，都在一列，所以你的想法可能会

2035
01:39:04,700 --> 01:39:06,770
wander to the end parameter again.
再次想到 end 参数。

2036
01:39:06,770 --> 01:39:10,310
So, yeah, let's fix this-- end="", but at the end of that loop,
所以，是的，让我们修复它——end=""，但在那个循环的末尾，

2037
01:39:10,310 --> 01:39:11,910
let's just print out a new line.
让我们打印一个新行。

2038
01:39:11,910 --> 01:39:16,020
So this logically is the same as it was in C But in this case,
所以，这在逻辑上与它在 C 中一样，但在这种情况下，

2039
01:39:16,020 --> 01:39:19,730
I'm now doing it in Python, just a little more easily, without i++,
我现在在 Python 中做，只是更容易一些，不需要 i++，

2040
01:39:19,730 --> 01:39:26,120
without a conditional, I'm just relying on this for i in syntax using range().
不需要条件语句，我只依靠这个 for i in 语法使用 range()。

2041
01:39:26,120 --> 01:39:28,080
I can tighten this up further, frankly.
坦率地说，我可以进一步压缩它。

2042
01:39:28,080 --> 01:39:30,840
If I already have the outer loop, I could do something like this.
如果我已经有了外循环，我可以做这样的事情。

2043
01:39:30,840 --> 01:39:34,280
I could print out a single hash times 3.
我可以打印出三个井号。

2044
01:39:34,280 --> 01:39:37,610
And now if I run python of mario.py, that works, too.
现在，如果我运行 mario.py 的 python，它也起作用了。

2045
01:39:37,610 --> 01:39:40,710
So I can combine these ideas in interesting ways as well.
因此，我也可以以有趣的方式将这些想法结合起来。

2046
01:39:40,710 --> 01:39:44,550
The goal is simply to seed you with some of these building blocks.
目标只是用这些积木为你播种。

2047
01:39:44,550 --> 01:39:45,050
All right.
好的。

2048
01:39:45,050 --> 01:39:48,540
How about code that was maybe a little more logical in nature?
怎么样，也许更符合逻辑的代码？

2049
01:39:48,540 --> 01:39:52,640
Well, in Python, we indeed have some other features as well, namely lists.
那么，在 Python 中，我们确实还有一些其他特性，即列表。

2050
01:39:52,640 --> 01:39:54,950
And lists are denoted by those square brackets,
而列表由这些方括号表示，

2051
01:39:54,950 --> 01:39:56,570
reminiscent of the world of arrays.
让人想起数组的世界。

2052
01:39:56,570 --> 01:39:59,270
But in Python, what's really nice about lists
但在 Python 中，关于列表真正好的地方是，

2053
01:39:59,270 --> 01:40:02,510
is that their memory is automatically handled for you.
这意味着它们的内存会自动为你处理。

2054
01:40:02,510 --> 01:40:05,930
An array is about having values contiguously in memory.
数组指的是在内存中连续存储值。

2055
01:40:05,930 --> 01:40:09,440
In Python, a list is more like a linked list.
在 Python 中，列表更像一个链表。

2056
01:40:09,440 --> 01:40:12,770
It will allocate memory for you and grow and shrink these things.
它会为你分配内存，并可以扩展和缩减这些东西。

2057
01:40:12,770 --> 01:40:14,990
And you do not have to know about pointers.
你不需要了解指针。

2058
01:40:14,990 --> 01:40:16,520
You do not have to know about nodes.
你不需要了解节点。

2059
01:40:16,520 --> 01:40:18,830
You do not have to implement linked lists yourself.
你不需要自己实现链表。

2060
01:40:18,830 --> 01:40:22,250
You just get list as a data type in Python itself.
你直接在 Python 中获得列表作为数据类型。

2061
01:40:22,250 --> 01:40:25,490
Here, for instance, is some of the documentation for lists specifically.
例如，这里有一些关于列表的特定文档。

2062
01:40:25,490 --> 01:40:29,210
And in particular, lists also, like strings, or strs,
特别是，列表也像字符串或 strs 一样，

2063
01:40:29,210 --> 01:40:31,970
have methods, functions that come with them,
具有方法，即附带的函数，

2064
01:40:31,970 --> 01:40:34,710
that just make it easy to do certain things.
这使得做某些事情变得很容易。

2065
01:40:34,710 --> 01:40:40,100
So, for instance, if I wanted to maybe do something like taking averages
例如，如果我想做一些事情，比如计算平均值，

2066
01:40:40,100 --> 01:40:43,850
of scores, like we did some time ago, we can do that using a combination
比如我们之前做过的那样，我们可以使用列表和 len() 函数的组合

2067
01:40:43,850 --> 01:40:47,550
of lists and the function called len(), which I alluded to earlier,
我之前提到的 len() 函数，

2068
01:40:47,550 --> 01:40:49,550
which will tell you the length of a list.
它可以告诉你列表的长度。

2069
01:40:49,550 --> 01:40:50,705
Now, how might we do this?
我们现在该如何做呢？

2070
01:40:50,705 --> 01:40:52,580
Well, if we read the documentation for len(),
好吧，如果我们阅读 len() 函数的文档，

2071
01:40:52,580 --> 01:40:55,455
it turns out there's other functions there too that might be helpful.
我们会发现，那里还有其他一些可能有用的函数。

2072
01:40:55,455 --> 01:40:57,240
So let me go back to VS Code here.
所以，让我回到这里的 VS Code。

2073
01:40:57,240 --> 01:40:59,030
Let me close mario.py.
让我关闭 mario.py。

2074
01:40:59,030 --> 01:41:02,360
And let me open a file called scores.py, reminiscent of something
让我打开一个名为 scores.py 的文件，它让人想起我们之前做过的事情。

2075
01:41:02,360 --> 01:41:03,800
we did weeks ago, too.
我们几周前也做过。

2076
01:41:03,800 --> 01:41:06,090
Let me go ahead and, just for demonstration's sake,
让我继续，为了演示，

2077
01:41:06,090 --> 01:41:09,920
give myself a variable called scores that has my three test scores
给自己一个名为 scores 的变量，其中包含我的三次考试成绩

2078
01:41:09,920 --> 01:41:11,480
or whatnot from weeks ago.
或者几周前的那些成绩。

2079
01:41:11,480 --> 01:41:15,890
So I'm using square brackets, not curly braces, as in C. This is a linked list,
因此我使用方括号，而不是像在 C 中那样使用花括号。这是一个链表，

2080
01:41:15,890 --> 01:41:17,780
or a list in Python.
或者在 Python 中是列表。

2081
01:41:17,780 --> 01:41:20,460
And let me get the average of these values.
让我获取这些值的平均值。

2082
01:41:20,460 --> 01:41:24,380
Well, I could do this-- average =, and it turns out in Python,
好吧，我可以这样做 - average = ，事实证明，在 Python 中，

2083
01:41:24,380 --> 01:41:26,300
you just get a lot of functionality for free.
你得到了很多免费的功能。

2084
01:41:26,300 --> 01:41:29,600
And those functions sometimes take not single arguments,
这些函数有时不接受单个参数，

2085
01:41:29,600 --> 01:41:31,740
but lists as their arguments.
而是将列表作为参数。

2086
01:41:31,740 --> 01:41:35,330
So, for instance, I can use Python's built-in sum() function and pass
例如，我可以使用 Python 内置的 sum() 函数并传递

2087
01:41:35,330 --> 01:41:36,230
in those scores.
这些分数。

2088
01:41:36,230 --> 01:41:41,130
I can then divide that sum by the length of the scores list as well.
然后我也可以用这个和除以分数列表的长度。

2089
01:41:41,130 --> 01:41:44,670
So length of a list just tells you how many things are in it.
所以列表的长度就是告诉你它里面有多少个东西。

2090
01:41:44,670 --> 01:41:51,620
So this is like doing magically 72 plus 73 plus 33, all divided by 3 in total.
所以这就像神奇地将 72 加 73 加 33，然后除以总共 3 一样。

2091
01:41:51,620 --> 01:41:54,840
If I want to now do the math out, I can print the result.
如果我现在想进行计算，我可以打印出结果。

2092
01:41:54,840 --> 01:41:59,630
So I can print out, using an f string and maybe some prefix text here.
所以我可以使用 f 字符串和一些前缀文本打印出来。

2093
01:41:59,630 --> 01:42:02,520
Let's print out that average here.
让我们在这里打印出平均值。

2094
01:42:02,520 --> 01:42:06,170
So let me do python of scores.py, enter, and there
所以让我执行 scores.py 的 Python 脚本，回车，然后

2095
01:42:06,170 --> 01:42:08,280
is the average, slightly imprecisely.
就是平均值，稍微有点不精确。

2096
01:42:08,280 --> 01:42:10,280
But at that point, I'm not doing so well anyway.
但无论如何，我在那一点上的表现并不太好。

2097
01:42:10,280 --> 01:42:11,100
So that's fine.
所以没关系。

2098
01:42:11,100 --> 01:42:17,840
So at this point, we've seen that we have sort of more functionality than C.
所以，在这一点上，我们看到我们拥有的功能比 C 更多。

2099
01:42:17,840 --> 01:42:20,490
In C, how would we have computed the average weeks ago?
在 C 语言中，我们之前是如何计算平均值的？

2100
01:42:20,490 --> 01:42:22,170
I mean, we literally created a variable.
我的意思是，我们实际上创建了一个变量。

2101
01:42:22,170 --> 01:42:22,970
We then had a loop.
然后我们使用了一个循环。

2102
01:42:22,970 --> 01:42:24,278
We iterated over the array.
我们遍历了数组。

2103
01:42:24,278 --> 01:42:25,320
We added things together.
我们把东西加在一起。

2104
01:42:25,320 --> 01:42:26,930
It was just so much more work.
这只是多做了很多工作。

2105
01:42:26,930 --> 01:42:30,920
It's nice when you have a language that comes with functions, among them len(),
当你拥有一个包含函数的语言时，这很好，其中包括 len()，

2106
01:42:30,920 --> 01:42:34,670
among them sum(), that just does more of this for you.
其中包括 sum()，它可以为你做更多这样的事情。

2107
01:42:34,670 --> 01:42:37,690
But suppose you actually want to get the scores from the user.
但是假设你实际上想从用户那里获得分数。

2108
01:42:37,690 --> 01:42:41,020
In C, we used an array, and in C, we used get_int().
在 C 语言中，我们使用了一个数组，并且在 C 语言中，我们使用了 get_int()。

2109
01:42:41,020 --> 01:42:42,850
We can do something a little similar here.
我们在这里可以做一些类似的事情。

2110
01:42:42,850 --> 01:42:46,300
Let me propose that instead of hardcoding those three values,
让我建议，与其硬编码这三个值，

2111
01:42:46,300 --> 01:42:49,770
let me do this. from cs50 import get_int().
让我这样做。从 cs50 导入 get_int()。

2112
01:42:49,770 --> 01:42:53,710
Now let me give myself an empty list by just saying scores
现在让我通过说 scores 来给自己一个空列表

2113
01:42:53,710 --> 01:42:55,570
equals open bracket, closed bracket.
等于开括号，闭括号。

2114
01:42:55,570 --> 01:42:59,890
And unlike C, where you just can't do this-- you can't say give me an array
与 C 语言不同，你不能这样做——你不能说给我一个数组

2115
01:42:59,890 --> 01:43:03,100
and I'll figure out the length later, unless you resort
然后我稍后会确定长度，除非你诉诸

2116
01:43:03,100 --> 01:43:06,040
to pointers and memory management or the like, in Python
指针和内存管理等等，在 Python 中

2117
01:43:06,040 --> 01:43:09,680
you can absolutely give yourself an initially empty list.
你可以绝对给自己一个最初为空的列表。

2118
01:43:09,680 --> 01:43:12,970
Now let's do this. for i in range(3), let's
现在让我们这样做。对于 i in range(3)，让我们

2119
01:43:12,970 --> 01:43:15,320
prompt the human for three test scores.
提示用户输入三个考试分数。

2120
01:43:15,320 --> 01:43:18,400
So the first score will be the return value of get_int(),
所以第一个分数将是 get_int() 的返回值，

2121
01:43:18,400 --> 01:43:20,680
prompting the user for their score.
提示用户输入他们的分数。

2122
01:43:20,680 --> 01:43:25,000
And now, if I want to add this score to that otherwise empty list,
现在，如果我想将这个分数添加到那个原本为空的列表中，

2123
01:43:25,000 --> 01:43:27,130
here's where methods come into play, functions
这就是方法发挥作用的地方，函数

2124
01:43:27,130 --> 01:43:30,130
that come with objects, like lists.
与对象一起提供的，例如列表。

2125
01:43:30,130 --> 01:43:31,780
I can do scores, plural--
我可以做 scores，复数——

2126
01:43:31,780 --> 01:43:35,710
because that's the name of my variable from line 3-- .append,
因为这是我来自第 3 行的变量的名称——.append，

2127
01:43:35,710 --> 01:43:37,650
and I can append that score.
我可以追加那个分数。

2128
01:43:37,650 --> 01:43:40,070
So if we read the documentation for lists in Python,
所以，如果我们阅读 Python 中列表的文档，

2129
01:43:40,070 --> 01:43:43,940
you will see that lists come with a function, a method called append(),
你会看到列表带有一个函数，一个叫做 append() 的方法，

2130
01:43:43,940 --> 01:43:47,630
which literally just tacks a value onto the end, tacks a value onto the end,
它实际上只是将一个值追加到末尾，将一个值追加到末尾，

2131
01:43:47,630 --> 01:43:52,040
like all of that annoying code we would have written in C to iterate with
就像我们在 C 语言中编写的用来迭代的所有烦人的代码一样

2132
01:43:52,040 --> 01:43:55,040
pointer and pointer and pointer to the end of the list, append it,
指针和指针和指针到列表的末尾，追加它，

2133
01:43:55,040 --> 01:43:56,180
malloc() a new node.
malloc() 一个新的节点。

2134
01:43:56,180 --> 01:43:58,262
Python does all of that for us.
Python 为我们做了所有这些。

2135
01:43:58,262 --> 01:44:01,220
And so once you've done that, now I can do something similar to before.
所以一旦你做完了，我现在可以做一些类似之前的事情。

2136
01:44:01,220 --> 01:44:04,460
The average equals the sum of those scores divided
平均值等于这些分数的总和除以

2137
01:44:04,460 --> 01:44:06,740
by the length of that list of scores.
那个分数列表的长度。

2138
01:44:06,740 --> 01:44:11,660
And I can again print out, with an f string, the average value
我再次使用 f 字符串打印出平均值

2139
01:44:11,660 --> 01:44:13,667
in that variable like this.
在这个变量中，像这样。

2140
01:44:13,667 --> 01:44:16,250
So, again, you just have more building blocks at your disposal
所以，再次，你只是有更多的构建块供你使用

2141
01:44:16,250 --> 01:44:19,770
when it comes to something like this.
当涉及到像这样的事情时。

2142
01:44:19,770 --> 01:44:22,790
You can also do this, just so you've seen other syntax.
你也可以这样做，只是让你看到其他的语法。

2143
01:44:22,790 --> 01:44:28,610
It turns out that instead of doing scores.append, you could also do this.
事实证明，除了使用 scores.append，你还可以这样做。

2144
01:44:28,610 --> 01:44:36,530
You could concatenate scores with itself by adding two lists together like this.
你可以通过将两个列表加在一起的方式将 scores 与自身连接起来。

2145
01:44:36,530 --> 01:44:38,000
This looks a little weird.
这看起来有点奇怪。

2146
01:44:38,000 --> 01:44:40,910
But on the left is my variable scores.
但在左边是我的变量分数。

2147
01:44:40,910 --> 01:44:44,900
On the right here, I am taking whatever is in that list,
在右边这里，我正在获取该列表中的任何内容，

2148
01:44:44,900 --> 01:44:49,190
and I'm adding the current score by adding it to its own list.
并将当前得分添加到其自身列表中。

2149
01:44:49,190 --> 01:44:51,900
And this will update the value as we go.
这将随着我们的进行更新值。

2150
01:44:51,900 --> 01:44:54,110
But it does, in fact, change the value of score
但实际上，它确实改变了分数的值

2151
01:44:54,110 --> 01:44:58,070
as opposed to appending to the initial list.
而不是追加到初始列表。

2152
01:44:58,070 --> 01:44:58,610
All right.
好的。

2153
01:44:58,610 --> 01:45:02,120
How about some other building blocks here?
这里的一些其他构建块怎么样？

2154
01:45:02,120 --> 01:45:04,010
Let me propose this.
让我提出这个。

2155
01:45:04,010 --> 01:45:06,470
Let me close out scores.py.
让我关闭 scores.py。

2156
01:45:06,470 --> 01:45:09,800
Let me open up a file called phonebook.py,
让我打开一个名为 phonebook.py 的文件，

2157
01:45:09,800 --> 01:45:12,080
reminiscent of what we did weeks ago in C.
让人想起几周前我们在 C 语言中所做的。

2158
01:45:12,080 --> 01:45:13,747
And let me give myself a list of names.
让我给自己一个名字列表。

2159
01:45:13,747 --> 01:45:15,330
We won't bother with numbers just yet.
我们现在还不会考虑数字。

2160
01:45:15,330 --> 01:45:17,247
Let's just play with lists for another moment.
让我们再玩一下列表。

2161
01:45:17,247 --> 01:45:18,830
So here is a variable called names.
所以这里有一个名为 names 的变量。

2162
01:45:18,830 --> 01:45:22,670
It has maybe three names in it-- maybe Carter and David
它可能包含三个名字——可能是卡特和戴维

2163
01:45:22,670 --> 01:45:25,220
and John Harvard, as in past weeks.
还有约翰·哈佛，就像过去几周一样。

2164
01:45:25,220 --> 01:45:29,303
And now let me go ahead and ask the user to input a name--
现在让我继续要求用户输入一个名字——

2165
01:45:29,303 --> 01:45:31,220
because this is going to be like a phone book.
因为这将就像一本电话簿。

2166
01:45:31,220 --> 01:45:33,110
I want to ask the user for a name and then look up
我想询问用户姓名，然后查找

2167
01:45:33,110 --> 01:45:35,943
that person's name and the phone book, even though I'm not bothering
那个人的名字和电话簿，即使我没有费心

2168
01:45:35,943 --> 01:45:38,330
by having any phone numbers just yet.
暂时没有电话号码。

2169
01:45:38,330 --> 01:45:41,780
How could I search for, a la linear search, someone's name?
我怎样才能像线性搜索一样搜索某人的姓名呢？

2170
01:45:41,780 --> 01:45:45,410
Well, in Python I could do this. for name--
好吧，在 Python 中我可以这样做。 对于姓名——

2171
01:45:45,410 --> 01:45:53,210
rather, for n in names, if the current name equals what the human typed in,
更确切地说，对于 names 中的 n，如果当前姓名等于人类输入的姓名，

2172
01:45:53,210 --> 01:45:58,470
then go ahead and print out "Found," then break out of this loop.
然后继续打印“已找到”，然后退出此循环。

2173
01:45:58,470 --> 01:46:02,250
Otherwise, we'll print out "Not found" at the bottom.
否则，我们将在底部打印“未找到”。

2174
01:46:02,250 --> 01:46:02,750
All right.
好的。

2175
01:46:02,750 --> 01:46:05,360
So let's try this-- python of phonebook.py.
所以让我们尝试一下——phonebook.py 的 Python。

2176
01:46:05,360 --> 01:46:06,960
Let's search for maybe Carter.
让我们搜索一下可能存在的卡特。

2177
01:46:06,960 --> 01:46:07,460
That's easy.
这很容易。

2178
01:46:07,460 --> 01:46:08,570
He's at the beginning.
他在开头。

2179
01:46:08,570 --> 01:46:09,475
Oh, hmm.
哦，嗯。

2180
01:46:09,475 --> 01:46:11,600
Well, he was found, but then I printed "Not found."
好吧，他被找到了，但我却打印了“未找到”。

2181
01:46:11,600 --> 01:46:13,250
So that's not quite what I want.
所以这并不完全是我想要的。

2182
01:46:13,250 --> 01:46:14,240
How about David?
戴维呢？

2183
01:46:14,240 --> 01:46:16,820
D-A-V-I-D. "Found," "Not found"--
D-A-V-I-D。“已找到”，“未找到”——

2184
01:46:16,820 --> 01:46:18,260
all right, not very correct.
好吧，不太正确。

2185
01:46:18,260 --> 01:46:20,090
How about this?
这个怎么样？

2186
01:46:20,090 --> 01:46:21,900
Let's search for Eli, not in the list.
让我们搜索一下不在列表中的伊莱。

2187
01:46:21,900 --> 01:46:22,400
OK.
好的。

2188
01:46:22,400 --> 01:46:25,070
So at least someone not being in the list is working.
所以至少不在列表中的人是有效的。

2189
01:46:25,070 --> 01:46:28,310
But logically, for Carter, for David, and even John,
但从逻辑上讲，对于卡特、戴维甚至约翰，

2190
01:46:28,310 --> 01:46:31,355
why are we seeing "Found" and then "Not found?"
为什么我们会看到“已找到”，然后是“未找到”？

2191
01:46:37,030 --> 01:46:38,650
Why is it not found?
为什么找不到？

2192
01:46:38,650 --> 01:46:39,170
Yeah?
是的？

2193
01:46:39,170 --> 01:46:41,063
AUDIENCE: You need to intend the print().
观众：你需要缩进 print()。

2194
01:46:41,063 --> 01:46:41,730
DAVID MALAN: OK.
大卫·马兰：好的。

2195
01:46:41,730 --> 01:46:45,610
I don't have seem to have indented the print(), but let me try this.
我似乎没有缩进 print()，但我试试这个。

2196
01:46:45,610 --> 01:46:48,180
If I just go with the else here--
如果我直接在 else 这里使用它，

2197
01:46:48,180 --> 01:46:50,910
let me go up here and indent this and say else--
让我到这里，缩进它，然后写 else

2198
01:46:50,910 --> 01:46:53,790
I'm not sure logically this is what we want,
从逻辑上讲，我不确定这就是我们想要的，

2199
01:46:53,790 --> 01:46:57,810
because what I think this is going to do if I search for maybe Carter--
因为我认为，如果我要搜索 Carter，这将是...

2200
01:46:57,810 --> 01:46:58,660
OK, that worked.
好吧，成功了。

2201
01:46:58,660 --> 01:47:00,480
So it's partially fixed the problem.
所以它部分解决了问题。

2202
01:47:00,480 --> 01:47:03,150
But let me try searching for maybe David.
但让我试着搜索 David。

2203
01:47:03,150 --> 01:47:05,280
Oh, now we're sort of the opposite problem--
哦，现在我们遇到的是相反的问题，

2204
01:47:05,280 --> 01:47:06,420
"Not found," "Found."
“未找到”，“找到”。

2205
01:47:06,420 --> 01:47:07,020
Why?
为什么？

2206
01:47:07,020 --> 01:47:09,450
Well, I don't think we want to immediately conclude
好吧，我认为我们不想立刻得出结论，

2207
01:47:09,450 --> 01:47:12,000
that someone's not found just because they don't
某人没有找到，仅仅是因为他们没有

2208
01:47:12,000 --> 01:47:15,220
equal the current name in the list.
等于列表中当前的名称。

2209
01:47:15,220 --> 01:47:19,950
So it turns out we could fix this in a couple of different ways.
所以事实证明，我们可以通过几种不同的方式来修复它。

2210
01:47:19,950 --> 01:47:22,290
But there's kind of a neat features of Python.
但 Python 有一个很酷的功能。

2211
01:47:22,290 --> 01:47:25,980
In Python, even for loops can have an else clause.
在 Python 中，即使是 for 循环也可以有 else 语句。

2212
01:47:25,980 --> 01:47:27,150
And this is weird.
这很奇怪。

2213
01:47:27,150 --> 01:47:29,320
But the way this works is as follows.
但它的工作原理如下。

2214
01:47:29,320 --> 01:47:34,560
In Python, if you break out of a loop, that's it for the for loop.
在 Python 中，如果你从循环中跳出，就结束了 for 循环。

2215
01:47:34,560 --> 01:47:38,640
If, though, you get all the way through the list that you're looping over,
但是，如果你遍历了整个列表，

2216
01:47:38,640 --> 01:47:42,520
and you never once call line 8-- you never break out of the loop--
而且你从来没有调用过第 8 行，你从来没有跳出循环，

2217
01:47:42,520 --> 01:47:44,950
Python is smart enough to realize, OK, you just
Python 足够聪明，它意识到，好吧，你只是

2218
01:47:44,950 --> 01:47:46,510
went through lines 5 through 8.
遍历了第 5 行到第 8 行。

2219
01:47:46,510 --> 01:47:49,120
You never actually logically called break.
实际上你并没有逻辑地调用 break。

2220
01:47:49,120 --> 01:47:51,490
Here's an else clause to be associated with it.
这里有一个 else 语句与它关联。

2221
01:47:51,490 --> 01:47:52,730
Semantically, this is weird.
从语义上讲，这很奇怪。

2222
01:47:52,730 --> 01:47:55,610
We've only ever seen if and else associated with each other.
我们只见过 if 和 else 彼此关联。

2223
01:47:55,610 --> 01:47:59,330
But for loops in Python actually can have else as well.
但 Python 中的 for 循环实际上也可以有 else。

2224
01:47:59,330 --> 01:48:03,190
And in this case now, if I do python of phonebook.py, type in Carter,
在这种情况下，现在，如果我运行 phonebook.py，输入 Carter，

2225
01:48:03,190 --> 01:48:05,005
now we get only one answer.
现在我们只得到一个答案。

2226
01:48:05,005 --> 01:48:07,630
If I do it again and type in David, now we get only one answer.
如果我再次运行并输入 David，现在我们只得到一个答案。

2227
01:48:07,630 --> 01:48:08,547
Do it again with John.
再试一次，输入 John。

2228
01:48:08,547 --> 01:48:09,700
Now we get only one answer.
现在我们只得到一个答案。

2229
01:48:09,700 --> 01:48:10,480
Do it with Eli.
输入 Eli。

2230
01:48:10,480 --> 01:48:12,530
Now we get only one answer.
现在我们只得到一个答案。

2231
01:48:12,530 --> 01:48:14,998
So, again, you just get a few more tools in your toolkit
所以，再次，你只是在你的工具箱里获得了一些额外的工具，

2232
01:48:14,998 --> 01:48:18,040
when it comes to a language like Python that might very well make solving
对于像 Python 这样的语言，这可能会让解决问题变得更轻松。

2233
01:48:18,040 --> 01:48:20,890
problems a little more pleasant.
让解决问题变得更加愉快。

2234
01:48:20,890 --> 01:48:22,870
But this is kind of stupid in Python.
但在 Python 中这有点蠢。

2235
01:48:22,870 --> 01:48:25,060
This is correct, but it's not well designed,
这是正确的，但它设计得不好，

2236
01:48:25,060 --> 01:48:28,810
because I don't need to iterate over lists like this so pedantically
因为我不需要像这样那么迂腐地遍历列表，

2237
01:48:28,810 --> 01:48:30,700
like we've been doing for weeks in C.
就像我们在 C 语言中几个星期以来一直在做的那样。

2238
01:48:30,700 --> 01:48:33,880
I can actually tighten this up, and I can just do this.
我实际上可以简化它，我可以直接做这个。

2239
01:48:33,880 --> 01:48:38,440
I can get rid of the loop, and I can say if name in names, then print out,
我可以去掉循环，然后可以写 if name in names，然后打印出，

2240
01:48:38,440 --> 01:48:39,430
quote unquote, "Found."
引号，"找到”。

2241
01:48:39,430 --> 01:48:40,750
That's it in Python.
这就是 Python 中的做法。

2242
01:48:40,750 --> 01:48:44,020
If you want Python to search a whole list of values for you,
如果你想让 Python 为你搜索整个值的列表，

2243
01:48:44,020 --> 01:48:45,700
just let Python do the work.
就让 Python 做这项工作。

2244
01:48:45,700 --> 01:48:50,590
And you can literally just say if the name that the human inputted is
你可以直接说，如果人类输入的名称是

2245
01:48:50,590 --> 01:48:55,180
in names, which is this list here, Python will use linear search for you,
在名称中，也就是这里列表中，Python 会为你使用线性搜索，

2246
01:48:55,180 --> 01:48:59,240
search automatically from left to right, presumably, looking for the value.
它会自动地从左到右进行搜索，大概是在寻找这个值。

2247
01:48:59,240 --> 01:49:02,260
And if it doesn't find it then and only then will
如果它没有找到，也只有在这种情况下才会

2248
01:49:02,260 --> 01:49:04,490
this else clause execute instead.
执行这个 else 子句。

2249
01:49:04,490 --> 01:49:06,970
So, again, Python's just starting to save us
所以，同样，Python 刚刚开始为我们省时间

2250
01:49:06,970 --> 01:49:10,970
some time because this, too, will find Carter, but it will not find,
因为这个也会找到 Carter，但它不会找到

2251
01:49:10,970 --> 01:49:12,800
for instance, Eli.
例如，Eli。

2252
01:49:12,800 --> 01:49:13,300
All right?
好的吧？

2253
01:49:13,300 --> 01:49:15,350
So we get that functionality for free.
所以我们免费获得了这个功能。

2254
01:49:15,350 --> 01:49:18,470
But what more can we perhaps do here?
但是我们还可以在这里做些什么呢？

2255
01:49:18,470 --> 01:49:22,360
Well, it turns out that Python has yet other features
事实证明，Python 还有其他特性

2256
01:49:22,360 --> 01:49:25,930
we might want to explore, namely dictionaries, shortened as dict.
我们可能想要探索，也就是字典，缩写为 dict。

2257
01:49:25,930 --> 01:49:29,708
And a dictionary in Python is just like it was in C and, really,
Python 中的字典和 C 中一样，实际上，

2258
01:49:29,708 --> 01:49:31,000
in computer science in general.
在计算机科学中，通常都是这样。

2259
01:49:31,000 --> 01:49:32,625
A dictionary was an abstract data type.
字典是一种抽象数据类型。

2260
01:49:32,625 --> 01:49:36,460
And it's a collection of key value pairs it looks a little something like this.
它是一组键值对，它看起来有点像这样。

2261
01:49:36,460 --> 01:49:38,980
If in C, if in Python, if, in any language,
如果在 C 中，如果在 Python 中，如果，在任何语言中，

2262
01:49:38,980 --> 01:49:43,210
you want to associate something with something, like a name with a number,
你想将某个东西与另一个东西关联起来，比如将姓名与数字关联起来，

2263
01:49:43,210 --> 01:49:46,990
you had to, in problem set 5, implement the darn thing yourself
在问题集 5 中，你不得不自己实现这个东西

2264
01:49:46,990 --> 01:49:50,950
by implementing an entire spell checker with an array and linked list
通过使用数组和链表来实现一个完整的拼写检查器

2265
01:49:50,950 --> 01:49:53,890
to store all of those words in your dictionary.
来存储字典中的所有单词。

2266
01:49:53,890 --> 01:49:57,220
In Python, as we saw earlier, you can use a set, or you can use,
在 Python 中，正如我们之前看到的，你可以使用一个集合，或者你可以使用

2267
01:49:57,220 --> 01:50:02,080
more simply, a dictionary that implements for you all of problem
更简单地说，是一个为你实现所有问题的字典

2268
01:50:02,080 --> 01:50:03,730
set 5's ideas.
问题集 5 的想法。

2269
01:50:03,730 --> 01:50:06,370
But Python does the heavy lifting for you.
但是 Python 为你做了繁重的工作。

2270
01:50:06,370 --> 01:50:11,600
A dict in Python is essentially a hash table, a collection of key value pairs.
Python 中的 dict 本质上是一个哈希表，是一组键值对。

2271
01:50:11,600 --> 01:50:13,720
So what does this mean for me in Python?
那么这对我在 Python 中意味着什么？

2272
01:50:13,720 --> 01:50:18,050
It means that I can do some pretty handy things pretty easily.
这意味着我可以很容易地做一些非常方便的事情。

2273
01:50:18,050 --> 01:50:21,070
So, for instance, let me go back here to VS Code,
所以，例如，让我回到 VS Code，

2274
01:50:21,070 --> 01:50:25,210
and let me change my phone book altogether to be this.
让我将我的电话簿完全改为这样。

2275
01:50:25,210 --> 01:50:29,570
Let me give myself a list of dictionaries.
让我给自己一个字典列表。

2276
01:50:29,570 --> 01:50:32,830
So people is now going to be a global list.
所以 people 现在将是一个全局列表。

2277
01:50:32,830 --> 01:50:35,977
And I'm going to demarcate it here with open square bracket
我将用左方括号来标记它

2278
01:50:35,977 --> 01:50:37,060
and closed square bracket.
和右方括号。

2279
01:50:37,060 --> 01:50:39,430
And just to be nice and neat and tidy, I'm
为了整洁美观，我

2280
01:50:39,430 --> 01:50:45,160
going to have these people no longer just be Carter and David and John,
不再让这些人只是 Carter、David 和 John，

2281
01:50:45,160 --> 01:50:46,600
as in the previous example.
就像上一个例子一样。

2282
01:50:46,600 --> 01:50:52,060
But I want each of the elements of this list to be a key value
但我希望这个列表的每个元素都是一个键值

2283
01:50:52,060 --> 01:50:54,800
pair, like a name and a number.
对，比如姓名和数字。

2284
01:50:54,800 --> 01:50:56,140
So how can I do this?
我该如何做到呢？

2285
01:50:56,140 --> 01:50:58,940
In Python, you can use this syntax.
在 Python 中，你可以使用这种语法。

2286
01:50:58,940 --> 01:51:02,290
And this is, I think, the last of the weird looking syntax today.
我认为这是今天最后一种看起来很奇怪的语法。

2287
01:51:02,290 --> 01:51:06,910
You can define a dictionary that is something like this
你可以定义一个类似于这样的字典

2288
01:51:06,910 --> 01:51:10,070
by using two curly braces like this.
使用两个花括号，就像这样。

2289
01:51:10,070 --> 01:51:12,820
And inside of your curly braces, you get to invent
在你的花括号中，你可以创造

2290
01:51:12,820 --> 01:51:15,140
the name, the keys, and the values.
名称、键和值。

2291
01:51:15,140 --> 01:51:18,107
So if you want one key to be the person's name, you can do,
所以如果你想让一个键是人的姓名，你可以这样做，

2292
01:51:18,107 --> 01:51:20,440
quote unquote, "name" and then, quote unquote, "Carter."
引号引起来，"name" 然后，引号引起来，"Carter"。

2293
01:51:20,440 --> 01:51:24,850
If you want another key to be "number," you can do, quote unquote, "number,"
如果你想要另一个键是 "number"，你可以做，引号引起来，"number"，

2294
01:51:24,850 --> 01:51:29,560
and then, quote unquote, something like last time, "1-617-495-1000,"
然后，引号引起来，就像上次一样，"1-617-495-1000"，

2295
01:51:29,560 --> 01:51:31,420
for instance, for Carter's number there.
例如，这是 Carter 的电话号码。

2296
01:51:31,420 --> 01:51:35,530
And collectively, everything here on line 2 represents a dictionary.
总体而言，这里第 2 行的所有内容都代表一个字典。

2297
01:51:35,530 --> 01:51:40,680
It's as though, on a chalkboard, I wrote down "name, Carter, number,
就好像我在黑板上写下 "name, Carter, number,

2298
01:51:40,680 --> 01:51:45,790
+1-617-495-1000," row by row by row in this table.
+1-617-495-1000"，一行一行地在表格里写。

2299
01:51:45,790 --> 01:51:47,700
This is simply the code equivalent thereof.
这只是代码等价物。

2300
01:51:47,700 --> 01:51:50,340
If you want to be really nitpicky or tidy,
如果你真的想要挑剔或者整洁，

2301
01:51:50,340 --> 01:51:52,840
you could style your code to look like this,
你可以将代码样式设置为这样，

2302
01:51:52,840 --> 01:51:56,360
which makes it a little more clear, perhaps, as to what's going on.
这可能让代码更加清晰地展示正在发生的事情。

2303
01:51:56,360 --> 01:51:58,860
It's just starting to add a lot of whitespace to the screen.
只是开始在屏幕上添加很多空白。

2304
01:51:58,860 --> 01:52:01,140
But it's just a collection of key value pairs,
但它只是一个键值对集合，

2305
01:52:01,140 --> 01:52:04,573
again, akin to a two-column table like this.
再次强调，它类似于这样一个两列表格。

2306
01:52:04,573 --> 01:52:07,740
I'm going to undo the whitespace just to kind of tighten things up because I
我要撤销空白，让代码更加紧凑，因为我要

2307
01:52:07,740 --> 01:52:09,760
want to cram two other people in here.
在这里塞进另外两个人。

2308
01:52:09,760 --> 01:52:13,740
So I'm going to go ahead and do another set of curly braces with,
所以我要继续添加另一组花括号，里面包含，

2309
01:52:13,740 --> 01:52:17,370
quote unquote, "name" and "David," quote unquote, "number"--
引号引起来，"name" 和 "David"，引号引起来，"number" --

2310
01:52:17,370 --> 01:52:21,300
and we'll have the same number, so "+1-617-495-1000."
他们的电话号码相同，都是 "+1-617-495-1000"。

2311
01:52:21,300 --> 01:52:25,560
And then, lastly, let's do another set of curly braces for a name of say
最后，我们再添加一组花括号，里面包含一个叫做

2312
01:52:25,560 --> 01:52:34,140
"John," and John Harvard's number, quote unquote, "number" will be "+1"--
"John" 的人，John Harvard 的电话号码，引号引起来，"number" 将是 "+1" --

2313
01:52:34,140 --> 01:52:40,120
let's see-- "949-468-2750" is always John Harvard's number.
让我们看看 -- "949-468-2750" 永远是 John Harvard 的电话号码。

2314
01:52:40,120 --> 01:52:44,090
And then, by convention, you typically end even this element with a comma.
然后，按照惯例，你通常会用逗号结束这个元素。

2315
01:52:44,090 --> 01:52:46,150
But it's not strictly necessary syntactically.
但在语法上它并非严格必须。

2316
01:52:46,150 --> 01:52:48,410
But stylistically, that's often added for you.
但在风格上，它通常会被添加进去。

2317
01:52:48,410 --> 01:52:49,450
So what is people?
那么 people 是什么呢？

2318
01:52:49,450 --> 01:52:54,470
people is now a list of dictionaries, a list of dictionaries.
people 现在是一个字典列表，一个字典列表。

2319
01:52:54,470 --> 01:52:55,700
So what does that mean?
所以这意味着什么？

2320
01:52:55,700 --> 01:52:57,700
It means I can now do code like this.
这意味着我现在可以编写这样的代码。

2321
01:52:57,700 --> 01:53:02,200
I can prompt the user with the input() function for someone's name if the goal
我可以使用 input() 函数提示用户输入某人的姓名，如果目标

2322
01:53:02,200 --> 01:53:04,300
now is to look up that person's number.
是查找该人的电话号码。

2323
01:53:04,300 --> 01:53:05,680
How can I look up that number?
我如何查找那个号码？

2324
01:53:05,680 --> 01:53:10,720
Well, for each person in the list of people, let's go ahead and do this.
好了，对于 people 列表中的每个人，让我们继续执行以下操作。

2325
01:53:10,720 --> 01:53:16,930
If the current person's name equals equals whatever name the human
如果当前人的姓名等于用户输入的姓名，那么通过进入该人的信息并执行以下操作，获取该人的电话号码。

2326
01:53:16,930 --> 01:53:22,930
typed in, then get that person's number by going into that person and doing,
引号引起来，"number"，然后继续

2327
01:53:22,930 --> 01:53:25,870
quote unquote, "number," and then go ahead
并打印出类似于以下格式的字符串 "Found" 该人的电话号码。

2328
01:53:25,870 --> 01:53:31,270
and print out something like this f string "Found" that person's number.
然后，既然我们找到了他们，我们就一起退出。

2329
01:53:31,270 --> 01:53:34,310
And then, since we found them, let's just break out all together.
如果我们遍历了整个列表，那么就在最后打印

2330
01:53:34,310 --> 01:53:37,600
And if we get through that whole thing, let's just, at the very end, print
出 "Not found"。

2331
01:53:37,600 --> 01:53:39,310
out "Not found."
这里有什么奇怪的地方？

2332
01:53:39,310 --> 01:53:40,860
So what's weird here?
如果我关注这段代码，很明显，这种语法是新的。

2333
01:53:40,860 --> 01:53:44,370
If I focus on this code here, this syntax obviously is new.
方括号，意思是，嘿，Python，这里有一个列表。

2334
01:53:44,370 --> 01:53:47,760
The square brackets, though, just means, hey, Python, here comes a list.
嘿，Python，列表到此为止。

2335
01:53:47,760 --> 01:53:49,590
Hey, Python, that's it for the list.


2336
01:53:49,590 --> 01:53:52,320
Inside of this list are three dictionaries.
这个列表里面有三个字典。

2337
01:53:52,320 --> 01:53:55,470
The curly braces mean, hey, Python, here comes a dictionary.
花括号的意思是，嘿，Python，这里有一个字典。

2338
01:53:55,470 --> 01:53:57,300
Hey, Python, that's it for the dictionary.
嘿，Python，字典到此为止了。

2339
01:53:57,300 --> 01:53:59,970
Each of these dictionaries has two key value pairs--
每个字典都有两个键值对——

2340
01:53:59,970 --> 01:54:03,580
"name" and its value, "number" and its value.
“name”和它的值，“number”和它的值。

2341
01:54:03,580 --> 01:54:07,980
So you can think of each of these lines as being like a C struct,
所以你可以把这些行想象成一个 C 结构体，

2342
01:54:07,980 --> 01:54:09,310
like with typedef and struct.
就像使用 typedef 和 struct 一样。

2343
01:54:09,310 --> 01:54:12,060
But I don't have to decide in advance what the keys and the values
但我不用提前决定键和值

2344
01:54:12,060 --> 01:54:12,727
are going to be.
是什么。

2345
01:54:12,727 --> 01:54:15,360
I can just, on the fly, create a dictionary like this,
我可以直接，在运行时，像这样创建一个字典，

2346
01:54:15,360 --> 01:54:18,550
again, reminiscent of this kind of chalkboard design.
再次，让人想起这种黑板设计。

2347
01:54:18,550 --> 01:54:19,050
All right.
好的。

2348
01:54:19,050 --> 01:54:21,210
So what am I actually doing in code?
那么我在代码中到底做了什么？

2349
01:54:21,210 --> 01:54:26,490
A dictionary in Python lets you index into it,
Python 中的字典允许你索引它，

2350
01:54:26,490 --> 01:54:31,287
similar to an array with numbers in C. So in C, this
类似于 C 中带数字的数组。所以在 C 中，这

2351
01:54:31,287 --> 01:54:32,370
is a little bit different.
有点不同。

2352
01:54:32,370 --> 01:54:35,550
In C, you might have been in the habit of doing person.name.
在 C 中，你可能习惯于做 person.name。

2353
01:54:35,550 --> 01:54:38,220
But because it's a dictionary, the syntax in Python
但因为它是一个字典，Python 中的语法

2354
01:54:38,220 --> 01:54:41,590
is you actually use square brackets with strings
是你实际上使用方括号，里面是字符串

2355
01:54:41,590 --> 01:54:45,620
as being inside the square brackets rather than numbers.
而不是数字。

2356
01:54:45,620 --> 01:54:49,750
But all this is now doing is it's creating a variable on line 11,
但现在它所做的一切只是在第 11 行创建一个变量，

2357
01:54:49,750 --> 01:54:53,060
setting that number equal to that same person's number.
将该数字设置为与该人的数字相同。

2358
01:54:53,060 --> 01:54:53,560
Why?
为什么？

2359
01:54:53,560 --> 01:54:56,140
Because we're inside of this loop, I'm iterating
因为我们在循环中，我正在迭代

2360
01:54:56,140 --> 01:54:58,340
over each person one at a time.
每个人的时间。

2361
01:54:58,340 --> 01:54:59,260
And that's what for--
那就是 for——

2362
01:54:59,260 --> 01:55:00,430
that's what n does.
那就是 n 所做的。

2363
01:55:00,430 --> 01:55:06,280
It assigns the person variable to this dictionary, then this dictionary,
它将 person 变量分配给这个字典，然后分配给这个字典，

2364
01:55:06,280 --> 01:55:08,860
then this dictionary automatically for me--
然后自动分配给这个字典——

2365
01:55:08,860 --> 01:55:11,480
no need for i and i++ and all of that.
不需要 i 和 i++ 以及所有这些。

2366
01:55:11,480 --> 01:55:14,020
So this is just saying, if the current person's name
所以这只是说，如果当前人的名字

2367
01:55:14,020 --> 01:55:17,560
equals the name we're looking for, get a variable called number and assign it
等于我们正在寻找的名字，得到一个名为 number 的变量并分配它

2368
01:55:17,560 --> 01:55:20,708
that person's number, and then print out that person's number.
该人的号码，然后打印出该人的号码。

2369
01:55:20,708 --> 01:55:23,500
So whereas last time we were just printing "Found" and "Not found,"
所以，上次我们只是打印“Found”和“Not found”，

2370
01:55:23,500 --> 01:55:25,310
now I'm going to print an actual number.
现在我要打印一个实际的数字。

2371
01:55:25,310 --> 01:55:28,270
So if I run python of phonebook.py and I search for Carter,
所以，如果我运行 phonebook.py 的 python 并搜索 Carter，

2372
01:55:28,270 --> 01:55:29,680
there then is his number.
那里就是他的号码。

2373
01:55:29,680 --> 01:55:34,550
If I run python of phonebook.py, type in John, there then is John's number.
如果我运行 phonebook.py 的 python，输入 John，那里就是 John 的号码。

2374
01:55:34,550 --> 01:55:38,840
And if I search for someone who's not there, I instead just get "Not found."
如果我搜索一个不在那里的人，我只会得到“Not found”。

2375
01:55:38,840 --> 01:55:42,010
So what's interesting and compelling about dictionaries
所以，字典有趣且引人入胜的地方在于

2376
01:55:42,010 --> 01:55:45,580
is they're kind of known as the Swiss Army knives of data structures
它们被称为数据结构的瑞士军刀

2377
01:55:45,580 --> 01:55:48,010
in programming because you can just use them
在编程中，因为你可以随意使用它们

2378
01:55:48,010 --> 01:55:49,930
in so many interesting, clever ways.
以很多有趣、巧妙的方式。

2379
01:55:49,930 --> 01:55:52,750
If you ever want to associate something with something else,
如果你想将某些东西与其他东西关联起来，

2380
01:55:52,750 --> 01:55:54,910
a dictionary is your friend.
字典就是你的朋友。

2381
01:55:54,910 --> 01:55:58,390
And you no longer have to write dozens of lines of code as in P set 5.
你不再需要像 P set 5 那样编写数十行代码。

2382
01:55:58,390 --> 01:56:01,850
You can write single lines of code to achieve this same idea.
你可以编写单行代码来实现同样的想法。

2383
01:56:01,850 --> 01:56:04,990
So, for instance, if I, too, want to tighten this up,
例如，如果我也想把这个收紧，

2384
01:56:04,990 --> 01:56:07,180
I actually don't need this loop altogether.
实际上，我根本不需要这个循环。

2385
01:56:07,180 --> 01:56:10,240
An even better version of this code would be this.
这段代码有一个更好的版本。

2386
01:56:10,240 --> 01:56:12,737
I don't need this variable, technically, even
从技术上讲，我甚至不需要这个变量，

2387
01:56:12,737 --> 01:56:14,320
though this will look a little uglier.
尽管这看起来有点丑。

2388
01:56:14,320 --> 01:56:16,870
Notice that I'm only creating a variable called number
请注意，我只创建了一个名为 number 的变量，

2389
01:56:16,870 --> 01:56:19,180
because I want to set it equal to this person's number.
因为我想把它设置为这个人的电话号码。

2390
01:56:19,180 --> 01:56:21,940
But strictly speaking, any time you've declared a variable
但严格地说，任何时候你声明一个变量，

2391
01:56:21,940 --> 01:56:25,220
and then used it in the next line, eh, you don't really need it.
然后在下一行使用它，嗯，你真的不需要它。

2392
01:56:25,220 --> 01:56:26,450
So I could do this.
所以我可以这样做。

2393
01:56:26,450 --> 01:56:27,950
I could get rid of that line.
我可以去掉那行。

2394
01:56:27,950 --> 01:56:30,430
And instead of printing "number" in my curly braces,
而不用在我的花括号中打印 "number"，

2395
01:56:30,430 --> 01:56:33,640
I could actually do person, square brackets,
我可以实际做 person，方括号，

2396
01:56:33,640 --> 01:56:35,740
and you might be inclined to do this.
你可能倾向于这样做。

2397
01:56:35,740 --> 01:56:38,740
But this is going to confuse Python because you're mixing double quotes
但这会让 Python 困惑，因为你在内部和外部混合了双引号

2398
01:56:38,740 --> 01:56:40,410
on the inside and the outside.
在内部和外部。

2399
01:56:40,410 --> 01:56:43,680
But you can use single quotes here, compellingly.
但你可以在这里使用单引号，很有说服力。

2400
01:56:43,680 --> 01:56:45,390
So you don't have to do it this way.
所以你不必这样去做。

2401
01:56:45,390 --> 01:56:47,850
But this is just to show you, syntactically,
但这只是为了从语法上向你展示，

2402
01:56:47,850 --> 01:56:51,010
you can put most anything you want in these curly braces
你可以在这些花括号中放入你想要的任何东西

2403
01:56:51,010 --> 01:56:55,350
so long as you don't confuse Python by using the same syntax.
只要你不通过使用相同的语法来混淆 Python。

2404
01:56:55,350 --> 01:56:58,240
But let me do one other thing here.
但让我在这里做另外一件事。

2405
01:56:58,240 --> 01:56:59,910
This is even more powerful.
这更强大。

2406
01:56:59,910 --> 01:57:02,400
Let me propose that if all you're storing
让我假设，如果你所存储的全部是

2407
01:57:02,400 --> 01:57:05,760
is names and numbers, names and numbers, I can actually
姓名和电话号码，姓名和电话号码，我实际上可以

2408
01:57:05,760 --> 01:57:09,090
simplify this dictionary significantly.
显著简化这个字典。

2409
01:57:09,090 --> 01:57:14,370
Let me actually redeclare this people data structure
让我重新声明这个 people 数据结构

2410
01:57:14,370 --> 01:57:19,770
to be not a list of dictionaries, but how about just one big dictionary?
不要是一个字典列表，而是只有一个大字典怎么样？

2411
01:57:19,770 --> 01:57:22,230
Because if I'm only associating names with numbers,
因为如果我只将姓名与电话号码关联起来，

2412
01:57:22,230 --> 01:57:24,780
I don't technically need to create special keys
我从技术上讲不需要创建名为 "name" 和 "number" 的特殊键

2413
01:57:24,780 --> 01:57:26,040
called "name" and "number."
名为 "name" 和 "number"。

2414
01:57:26,040 --> 01:57:32,730
Why don't I just associate Carter with his number, +1-617-495-1000?
为什么我不直接将 Carter 与他的电话号码 +1-617-495-1000 关联起来？

2415
01:57:32,730 --> 01:57:37,240
Why don't I just associate, quote unquote, "David" with his number,
为什么我不直接将 "David" 与他的电话号码

2416
01:57:37,240 --> 01:57:41,500
+1-617-495-1000?
+1-617-495-1000 关联起来？

2417
01:57:41,500 --> 01:57:51,850
And then, lastly, let's just associate John with his number, +1-949-468-2750?
然后，最后，让我们只将 John 与他的电话号码 +1-949-468-2750 关联起来？

2418
01:57:51,850 --> 01:57:54,280
And that too would work.
这样也可以。

2419
01:57:54,280 --> 01:57:57,520
But notice that I'm going to get rid of my list of people
但请注意，我要去掉我的 people 列表

2420
01:57:57,520 --> 01:58:01,120
and instead just have one dictionary of people, the downside of which
而只保留一个 people 字典，缺点是

2421
01:58:01,120 --> 01:58:04,660
is that you can only have one key, one value, one key, one value.
你只能有一个键，一个值，一个键，一个值。

2422
01:58:04,660 --> 01:58:09,013
You can't have a name key and a number key and an email key and an address key
你不能有一个 name 键，一个 number 键，一个 email 键和一个 address 键

2423
01:58:09,013 --> 01:58:11,680
and any number of other pieces of data that might be compelling.
以及其他任何可能引人注目的数据。

2424
01:58:11,680 --> 01:58:14,290
But if you've only got key value pairs like this,
但如果你只有像这样的键值对，

2425
01:58:14,290 --> 01:58:17,860
we can tighten up this code significantly so that now, down here,
我们可以显著压缩这段代码，这样现在，在这里，

2426
01:58:17,860 --> 01:58:19,360
I can actually do this.
我实际上可以这样做。

2427
01:58:19,360 --> 01:58:24,580
If the name I'm looking for is somewhere in that people dictionary,
如果我在 people 字典中找到了我要找的姓名，

2428
01:58:24,580 --> 01:58:27,640
then go ahead and get the person's number
那就继续获取这个人的电话号码

2429
01:58:27,640 --> 01:58:32,740
by going into the people dictionary, indexing into it at that person's name,
通过进入 people 字典，在该人的姓名处索引到它，

2430
01:58:32,740 --> 01:58:39,100
and then printing out "Found," for instance, that here number,
然后打印出 "Found"，例如，这里的号码，

2431
01:58:39,100 --> 01:58:42,160
making this an f string, else you can go ahead
将它改为一个 f 字符串，否则你可以继续

2432
01:58:42,160 --> 01:58:44,827
and print out "Not found" in this case here.
并在这种情况下打印出 "未找到"。

2433
01:58:44,827 --> 01:58:47,410
So, again, the difference is that the previous version created
所以，再次强调，不同之处在于之前的版本创建了

2434
01:58:47,410 --> 01:58:49,930
a list of dictionaries, and I very manually,
一个字典列表，我手动地

2435
01:58:49,930 --> 01:58:52,420
methodically, iterated over it, looking for the person.
有条理地遍历了它，寻找这个人。

2436
01:58:52,420 --> 01:58:55,030
But what's nice again about dictionaries is
但字典的好处在于

2437
01:58:55,030 --> 01:58:58,840
that Python gives you a lot of support for just looking into them easily.
Python 为你提供了很多便利的查找方式。

2438
01:58:58,840 --> 01:59:01,630
And this syntax, just like you can use it for lists,
这种语法，就像你在列表中使用它一样，

2439
01:59:01,630 --> 01:59:03,520
you can use it for dictionaries as well.
你也可以在字典中使用它。

2440
01:59:03,520 --> 01:59:08,210
And Python will look for that name among the keys in the dictionary.
Python 会在字典的键中寻找那个名字。

2441
01:59:08,210 --> 01:59:15,610
And if it finds it, you use this syntax to get at that person's number.
如果它找到了，你可以使用这种语法来获取那个人的号码。

2442
01:59:15,610 --> 01:59:16,990
Whew, OK.
哇，好吧。

2443
01:59:16,990 --> 01:59:21,250
A lot all at once, but are there any questions on this here syntax?
一下子讲了很多，但关于这种语法，大家有什么问题吗？

2444
01:59:21,250 --> 01:59:25,220
We'll then introduce a couple of final features with a final flourish.
然后我们将以最后的点睛之笔介绍几个最后的特性。

2445
01:59:25,220 --> 01:59:25,910
Yes?
有吗？

2446
01:59:25,910 --> 01:59:28,722
AUDIENCE: This way [INAUDIBLE] break [INAUDIBLE]..
观众：这样 [听不清]  break  [听不清]..

2447
01:59:28,722 --> 01:59:30,930
DAVID MALAN: In this case, I do not need to use break
大卫·马兰：在这种情况下，我不需要使用 break

2448
01:59:30,930 --> 01:59:33,030
because I don't have any loop involved.
因为我没有使用任何循环。

2449
01:59:33,030 --> 01:59:37,050
So break is only used, as we've seen it, in the context of looping
所以，正如我们所见，break 仅在循环的上下文中使用

2450
01:59:37,050 --> 01:59:39,600
over something when you want to terminate the loop early.
当你想提前终止循环时，在循环某个东西时使用它。

2451
01:59:39,600 --> 01:59:42,360
But here Python is doing the searching for you.
但这里 Python 帮你进行搜索。

2452
01:59:42,360 --> 01:59:46,500
So Python is taking care of that automatically.
所以 Python 自动处理了这件事。

2453
01:59:46,500 --> 01:59:47,000
All right.
好的。

2454
01:59:47,000 --> 01:59:50,300
Just a couple of final features so that you have a couple of more building
最后再介绍几个特性，这样你就能拥有更多构建

2455
01:59:50,300 --> 01:59:53,540
blocks-- here is the documentation for dictionaries themselves
模块 - 这里是字典本身的文档

2456
01:59:53,540 --> 01:59:56,580
in case you want to poke around as to what more you can do with them.
如果你想知道你能用它们做更多的事情，你可以查阅文档。

2457
01:59:56,580 --> 01:59:59,300
But it turns out that there are other libraries that
但事实证明，还有其他库

2458
01:59:59,300 --> 02:00:01,880
come with Python, not even third-party, and one of them
与 Python 一起提供，甚至不是第三方库，其中一个

2459
02:00:01,880 --> 02:00:07,610
is the sys library, whereby you have system-related functionality.
是 sys 库，它提供了与系统相关的功能。

2460
02:00:07,610 --> 02:00:10,230
And here's its official documentation, for instance.
例如，这是它的官方文档。

2461
02:00:10,230 --> 02:00:12,980
But what this means is that certain functionality that was just
但这意味着某些在 C 语言中可以直接使用的功能

2462
02:00:12,980 --> 02:00:17,480
immediately available in C is sometimes tucked away now into libraries
现在有时会被隐藏在 Python 的库中

2463
02:00:17,480 --> 02:00:18,080
in Python.
中。

2464
02:00:18,080 --> 02:00:19,910
So, for instance, let me go over to VS Code
例如，让我打开 VS Code

2465
02:00:19,910 --> 02:00:23,150
here, and let me just create a program called greet.py, which
这里，让我创建一个名为 greet.py 的程序，它

2466
02:00:23,150 --> 02:00:25,490
is reminiscent of an old C program that just greets
让人想起一个旧的 C 程序，它只是用

2467
02:00:25,490 --> 02:00:27,710
the user using command-line arguments.
命令行参数来问候用户。

2468
02:00:27,710 --> 02:00:31,580
But in C, recall that we got access to command-line arguments with main()
但请记住，在 C 语言中，我们使用 main() 获取命令行参数

2469
02:00:31,580 --> 02:00:34,070
and argc and argv.
以及 argc 和 argv。

2470
02:00:34,070 --> 02:00:36,870
But none of those have we seen at all today.
但我们今天还没有看到过这些。

2471
02:00:36,870 --> 02:00:39,540
And, in fact, main() itself is no longer required.
事实上，main() 本身不再是必需的。

2472
02:00:39,540 --> 02:00:43,010
So if you want to do command-line arguments in Python,
所以如果你想在 Python 中使用命令行参数，

2473
02:00:43,010 --> 02:00:44,270
you actually do this.
你需要这样做。

2474
02:00:44,270 --> 02:00:48,720
From the sys library, you can import something called argv.
从 sys 库中，你可以导入一个名为 argv 的东西。

2475
02:00:48,720 --> 02:00:50,260
So argv still exists.
所以 argv 仍然存在。

2476
02:00:50,260 --> 02:00:54,040
It's just tucked away inside of this library, otherwise known as a module.
它只是被隐藏在这个库中，也被称为模块。

2477
02:00:54,040 --> 02:00:55,630
And I can then do this.
然后我就可以这样做。

2478
02:00:55,630 --> 02:01:00,450
If the length of argv, for instance, does not equal 2,
如果 argv 的长度不等于 2，

2479
02:01:00,450 --> 02:01:02,918
well, then, we're going to go ahead and do what we did--
那么，我们将继续做我们之前做过的事情——

2480
02:01:02,918 --> 02:01:03,960
or rather, let's do this.
或者，我们这样做。

2481
02:01:03,960 --> 02:01:06,330
If the length of argv does equal 2, we're
如果 argv 的长度等于 2，我们

2482
02:01:06,330 --> 02:01:08,580
going to go ahead and do what we did a couple of weeks
将继续做我们几周前做过的事情

2483
02:01:08,580 --> 02:01:11,670
ago, whereby I'm going to print out "hello,"
之前，我将打印出“hello”，

2484
02:01:11,670 --> 02:01:15,490
comma, and then argv bracket 1, for instance,
逗号，然后是 argv 中括号 1，例如，

2485
02:01:15,490 --> 02:01:18,540
so whatever is in location 1 of that list.
也就是说列表中位置 1 的内容。

2486
02:01:18,540 --> 02:01:21,990
Else, if the length of argv is not equal to 2-- that is,
否则，如果 argv 的长度不等于 2——也就是说，

2487
02:01:21,990 --> 02:01:24,120
the human did not type two words at the prompt--
用户没有在提示符处输入两个单词——

2488
02:01:24,120 --> 02:01:27,730
let's go ahead and print out "hello, world" by default.
让我们默认打印出“hello, world”。

2489
02:01:27,730 --> 02:01:31,860
So we did the exact same thing in C. The only difference here is that this now
所以我们在 C 中做了完全相同的事情。这里唯一的区别是，现在

2490
02:01:31,860 --> 02:01:33,660
is how you get access to argv.
就是你如何访问 argv。

2491
02:01:33,660 --> 02:01:38,020
So let me run this-- python of greet.py and hit Enter. "hello, world" is all I
所以让我运行一下——python of greet.py 然后按回车。“hello, world” 就是我

2492
02:01:38,020 --> 02:01:38,520
get.
得到的。

2493
02:01:38,520 --> 02:01:40,680
And actually, I got an extra line break because out of habit,
事实上，我得到了一个额外的换行，因为习惯使然，

2494
02:01:40,680 --> 02:01:43,320
I included backslash n, but I don't need that in Python.
我包含了反斜杠 n，但在 Python 中我不需要它。

2495
02:01:43,320 --> 02:01:46,680
So let me fix that. python of greet.py-- "hello, world."
所以让我修正一下。python of greet.py——“hello, world”。

2496
02:01:46,680 --> 02:01:50,160
But if I do python of greet.py, D-A-V-I-D,
但如果我输入 python of greet.py，D-A-V-I-D，

2497
02:01:50,160 --> 02:01:53,010
now notice that argv equals 2.
现在请注意 argv 等于 2。

2498
02:01:53,010 --> 02:01:56,490
If I instead do something like Carter, argv now equals 2.
如果我改为输入类似 Carter 的内容，argv 现在等于 2。

2499
02:01:56,490 --> 02:01:57,780
But there is a difference.
但存在一个区别。

2500
02:01:57,780 --> 02:02:02,280
Technically, I'm typing three words at the prompt, three words at the prompt,
从技术上讲，我在提示符处输入了三个单词，在提示符处输入了三个单词，

2501
02:02:02,280 --> 02:02:07,380
but argv still only equals 2 because the command python is ignored from argv.
但 argv 仍然只等于 2，因为命令 python 被 argv 忽略了。

2502
02:02:07,380 --> 02:02:11,440
It's only the name of your file and the thing you type after it.
它只是你的文件名和你在它之后输入的内容。

2503
02:02:11,440 --> 02:02:16,980
So that's then how we might print out arguments in Python using argv.
所以这就是我们如何使用 argv 在 Python 中打印出参数。

2504
02:02:16,980 --> 02:02:20,490
Well, what else might we do using some of these here features?
好吧，我们还可以使用这里的一些功能做些什么？

2505
02:02:20,490 --> 02:02:25,180
Well, it turns out that you can exit from programs using this same sys
事实证明，你可以使用相同的 sys 从程序中退出

2506
02:02:25,180 --> 02:02:25,680
library.
库。

2507
02:02:25,680 --> 02:02:27,270
So let me close greet.py.
所以让我关闭 greet.py。

2508
02:02:27,270 --> 02:02:30,545
Let me open up exit.py just for demonstration's sake.
让我打开 exit.py，只是为了演示。

2509
02:02:30,545 --> 02:02:31,920
And let's do something like this.
让我们做一些类似这样的事情。

2510
02:02:31,920 --> 02:02:33,210
Let's import sys.
让我们导入 sys。

2511
02:02:33,210 --> 02:02:37,920
And if the length of sys.argv--
如果 sys.argv 的长度——

2512
02:02:37,920 --> 02:02:40,050
so here's just another way of doing this.
所以这只是另一种方法。

2513
02:02:40,050 --> 02:02:44,130
And actually, I'll do it the same first-- from sys import argv.
事实上，我将先用相同的方式做——从 sys 导入 argv。

2514
02:02:44,130 --> 02:02:49,483
If the length of argv does not equal 2--
如果 argv 的长度不等于 2——

2515
02:02:49,483 --> 02:02:51,650
well, let's actually yell at the user with something
那么，让我们实际上用一些东西吼一下用户

2516
02:02:51,650 --> 02:02:54,800
like "Missing command-line argument."
比如“缺少命令行参数”。

2517
02:02:54,800 --> 02:03:01,220
And then what we can do is exit out of the program entirely using sys.exit(),
然后我们可以使用 sys.exit() 完全退出程序，

2518
02:03:01,220 --> 02:03:02,750
which is a function therein.
这是一个其中的函数。

2519
02:03:02,750 --> 02:03:05,282
But notice that exit() is a function in sys.
但请注意 exit() 是 sys 中的一个函数。

2520
02:03:05,282 --> 02:03:05,990
So you know what?
所以你知道吗？

2521
02:03:05,990 --> 02:03:07,980
It's actually more convenient in this case.
在这种情况下，它实际上更方便。

2522
02:03:07,980 --> 02:03:09,590
Let's just import all of sys.
让我们只导入 sys 的所有内容。

2523
02:03:09,590 --> 02:03:12,800
But because that has not given me direct access to argv,
但因为这没有给我直接访问 argv 的权限，

2524
02:03:12,800 --> 02:03:16,363
let me do sys.argv here and sys.exit() here.
让我在这里做 sys.argv 以及在这里做 sys.exit()。

2525
02:03:16,363 --> 02:03:19,280
Otherwise, if all is well, let's just go ahead and print out something
否则，如果一切顺利，让我们继续打印出一些东西

2526
02:03:19,280 --> 02:03:27,140
like "hello, sys.argv," bracket 1, close quote, and that will print out "hello,
像“hello，sys.argv”，方括号1，引号结束，这将打印出“hello，

2527
02:03:27,140 --> 02:03:27,920
so-and-so."
某某”。

2528
02:03:27,920 --> 02:03:31,580
And when I'm ready to exit with a non-0--
当我准备以非0退出时--

2529
02:03:31,580 --> 02:03:35,580
with a 0 exit status, I can actually start to specify these things here.
以0退出状态，我可以真正开始在此指定这些东西。

2530
02:03:35,580 --> 02:03:38,900
So just like in C, if you want to exit from a program with 1 or 2
所以就像在C语言中一样，如果你想用1或2退出程序

2531
02:03:38,900 --> 02:03:41,330
or anything else, you can use sys.exit.
或者其他任何东西，你可以使用sys.exit。

2532
02:03:41,330 --> 02:03:45,570
And if you want to exit with a 0, you can do this here instead.
如果你想以0退出，你可以在此处这样做。

2533
02:03:45,570 --> 02:03:48,090
So we have the same capabilities as in C,
所以我们有与C语言相同的性能，

2534
02:03:48,090 --> 02:03:51,720
just accessed a little bit differently.
只是访问方式略有不同。

2535
02:03:51,720 --> 02:03:53,700
Let me propose that--
让我提议一下--

2536
02:03:53,700 --> 02:03:55,530
let's see.
让我们看看。

2537
02:03:55,530 --> 02:03:58,200
Let me propose that--
让我提议一下--

2538
02:03:58,200 --> 02:03:59,530
how about this?
这个怎么样？

2539
02:04:03,480 --> 02:04:04,590
How about this?
这个怎么样？

2540
02:04:04,590 --> 02:04:09,120
If we want to go ahead and create something a little more interactive,
如果我们想继续创建一些更交互的东西，

2541
02:04:09,120 --> 02:04:12,540
recall that there was that command a while back, namely
回想一下之前有一个命令，即

2542
02:04:12,540 --> 02:04:15,862
pip, whereby I ran pip install face_recognition.
pip，我用它运行了pip install face_recognition。

2543
02:04:15,862 --> 02:04:17,820
That's one of the examples with which we began.
这是我们开始使用的示例之一。

2544
02:04:17,820 --> 02:04:21,150
And that allows me to install more functionality from a third party
它允许我从第三方安装更多功能

2545
02:04:21,150 --> 02:04:24,207
into my own code space or my programming environment more generally.
到我自己的代码空间或更一般地我的编程环境中。

2546
02:04:24,207 --> 02:04:26,290
Well, we can have a little fun with this, in fact.
事实上，我们可以用它来玩点乐子。

2547
02:04:26,290 --> 02:04:27,780
Let me go back to VS Code here.
让我回到VS Code这里。

2548
02:04:27,780 --> 02:04:30,750
And just like there's a command in Linux called cowsay,
就像Linux中有一个叫做cowsay的命令一样，

2549
02:04:30,750 --> 02:04:32,730
whereby you can get the cow to say something,
你可以让牛说点什么，

2550
02:04:32,730 --> 02:04:35,100
you can also use this kind of thing in Python.
你也可以在Python中使用这种东西。

2551
02:04:35,100 --> 02:04:39,330
So if I do pip install cowsay, this, if it's not installed already,
所以如果我执行pip install cowsay，如果它还没有安装，

2552
02:04:39,330 --> 02:04:41,250
will install a library called cowsay.
将安装一个叫做cowsay的库。

2553
02:04:41,250 --> 02:04:44,160
And what this means is that if I actually want to code up a program
这意味着，如果我真的想编写一个程序

2554
02:04:44,160 --> 02:04:48,540
called, like, moo.py, I can import the cowsay library,
叫做 moo.py，我可以导入cowsay库，

2555
02:04:48,540 --> 02:04:52,080
and I can do something simple like cowsay.cow,
我可以做一些简单的事情，比如cowsay.cow，

2556
02:04:52,080 --> 02:04:55,620
because there's a function in this library called cow(),
因为这个库中有一个叫做cow()的函数，

2557
02:04:55,620 --> 02:04:59,970
and I can say something like "This is CS50," quote unquote.
我可以说一些类似“这是CS50”之类的话，引号结束。

2558
02:04:59,970 --> 02:05:01,330
How do I run this program?
我该如何运行这个程序？

2559
02:05:01,330 --> 02:05:05,700
I can run python of moo.py, and-- oh, underwhelming.
我可以运行python moo.py，然后--哦，太不令人满意了。

2560
02:05:05,700 --> 02:05:09,210
If I increase the size of my terminal window, run python of moo.py,
如果我增加终端窗口的大小，运行python moo.py，

2561
02:05:09,210 --> 02:05:11,460
we have that same adorable cow as before,
我们有之前那只可爱的牛，

2562
02:05:11,460 --> 02:05:15,425
but I now have programmatic capabilities with which to manipulate it.
但我现在有了可以用来操控它的编程能力。

2563
02:05:15,425 --> 02:05:18,300
And so, in fact, I could make this program a little more interesting.
所以事实上，我可以让这个程序更有趣一点。

2564
02:05:18,300 --> 02:05:22,170
I could do something like name = quote--
我可以做一些类似 name = 引号--

2565
02:05:22,170 --> 02:05:25,650
or rather, name = input("What's your name?") and combine some
或者更确切地说，name = input("你的名字是？")并结合一些

2566
02:05:25,650 --> 02:05:26,580
of today's ideas.
今天的想法。

2567
02:05:26,580 --> 02:05:29,320
And now I can say not "This is CS50," but something like,
现在我可以不说什么“这是CS50”，而是说一些类似，

2568
02:05:29,320 --> 02:05:32,520
quote unquote, "Hello," comma, person's name.
引号结束，"Hello"，逗号，人的名字。

2569
02:05:32,520 --> 02:05:36,720
And now, if I increase the size of my terminal, rerun python of moo.py,
现在，如果我增加终端的大小，重新运行python moo.py，

2570
02:05:36,720 --> 02:05:39,570
it's not going to actually moo or say "This is CS50."
它不会真的哞哞叫或说“这是CS50”。

2571
02:05:39,570 --> 02:05:42,780
It's going to say something like "hello, David," and so forth.
它会说一些类似“hello，David”之类的话，等等。

2572
02:05:42,780 --> 02:05:45,250
And suffice it to say through other functions,
而且可以这么说，通过其他函数，

2573
02:05:45,250 --> 02:05:48,730
you can do not only cows but dragons and other fancy things, too.
你可以不只画奶牛，还可以画龙和其他更奇特的东西。

2574
02:05:48,730 --> 02:05:52,000
But even in Python, too, can you generate not just ASCII art,
但是即使在 Python 中，你也不只是可以生成 ASCII 艺术，

2575
02:05:52,000 --> 02:05:54,310
but actual art and actual images.
还可以生成真实的艺术和图像。

2576
02:05:54,310 --> 02:05:57,845
And the note I thought we'd end on is doing one other library.
而我想用另一个库来结束这节课。

2577
02:05:57,845 --> 02:05:59,470
I'm going to go back into VS Code here.
我现在要回到 VS Code 中。

2578
02:05:59,470 --> 02:06:01,240
I'm going to close moo.py.
我要关闭 moo.py 文件。

2579
02:06:01,240 --> 02:06:06,220
I'm going to do pip install qrcode, which is the name of a library
我要执行 pip install qrcode 命令，qrcode 是一个库的名称

2580
02:06:06,220 --> 02:06:10,570
that I might want to install to generate QR codes automatically.
我可能想要安装它来自动生成二维码。

2581
02:06:10,570 --> 02:06:12,790
And QR codes are these two-dimensional bar codes.
二维码是二维条形码。

2582
02:06:12,790 --> 02:06:14,840
If you want to generate these things yourself,
如果你想自己生成这些东西，

2583
02:06:14,840 --> 02:06:17,080
you don't have to go to a website and type in a URL.
你不需要去网站输入一个 URL。

2584
02:06:17,080 --> 02:06:19,880
You can actually write this kind of code yourself.
你可以自己编写这种代码。

2585
02:06:19,880 --> 02:06:21,100
So how might I do this?
那么我应该怎么做呢？

2586
02:06:21,100 --> 02:06:26,890
Well, let me go into a new file called, say, qr.py.
好吧，让我创建一个新文件，比如叫 qr.py。

2587
02:06:26,890 --> 02:06:28,370
And let me do this.
让我来试试这个。

2588
02:06:28,370 --> 02:06:34,030
Let me go ahead and import this library called qrcode.
让我导入这个叫做 qrcode 的库。

2589
02:06:34,030 --> 02:06:37,360
Let me go ahead and create a variable called image, or anything else.
让我创建一个名为 image 的变量，或者任何其他名称。

2590
02:06:37,360 --> 02:06:40,720
Let me set it equal to this library's qrcodes function called
让我将其设置为该库的 qrcodes 函数，该函数叫做

2591
02:06:40,720 --> 02:06:43,090
make-- no relationship to C. It's just called make
make，与 C 无关。它就是叫做 make

2592
02:06:43,090 --> 02:06:44,650
because you want to make a QR code.
因为你想创建一个二维码。

2593
02:06:44,650 --> 02:06:48,370
Let me type in, maybe, the URL of a lecture video here on YouTube--
让我输入一个 YouTube 上的讲座视频的 URL——

2594
02:06:48,370 --> 02:07:01,990
so, like, youtu.be/xvFZjo5PgG0, quote unquote.
例如，youtu.be/xvFZjo5PgG0，引号内的内容。

2595
02:07:01,990 --> 02:07:07,490
And then I can go ahead and do img.save because inside of this image variable,
然后我可以继续执行 img.save 命令，因为在这个 image 变量中，

2596
02:07:07,490 --> 02:07:10,540
which is a different data type that this library gave me--
它是一个不同类型的变量，这个库给了我——

2597
02:07:10,540 --> 02:07:12,130
it doesn't come with Python per se--
它本身并不属于 Python——

2598
02:07:12,130 --> 02:07:18,820
I can save a file like qr.png, And I can save it in the PNG format, the Portable
我可以保存一个像 qr.png 这样的文件，而且我可以将其保存为 PNG 格式，即可移植

2599
02:07:18,820 --> 02:07:19,665
Network Graphic.
网络图形。

2600
02:07:19,665 --> 02:07:21,790
And so just to be clear, what this should hopefully
所以，为了更清楚地说明，我希望这

2601
02:07:21,790 --> 02:07:26,980
do for me is create a QR code containing that particular URL,
能为我做的是创建一个包含该特定 URL 的二维码，

2602
02:07:26,980 --> 02:07:31,540
but not as text, but rather as an actual image that I can send,
但不是文本形式，而是我可以发送的实际图像，

2603
02:07:31,540 --> 02:07:34,810
I can post online, or, in our case, generate into my code space,
我可以将其发布到网上，或者在我们的例子中，将其生成到我的代码空间中，

2604
02:07:34,810 --> 02:07:35,830
and then open.
然后打开它。

2605
02:07:35,830 --> 02:07:38,558
And so, with all that said, we've seen a bunch of new syntax
所以，综上所述，我们今天看到了很多新的语法

2606
02:07:38,558 --> 02:07:39,850
today, a bunch of new features.
以及很多新的功能。

2607
02:07:39,850 --> 02:07:45,160
But the ideas underlying Python are exactly the same as they've been in C.
但是 Python 的底层思想与 C 中的思想完全相同。

2608
02:07:45,160 --> 02:07:49,000
It's just that you don't have to do nearly as much heavy lifting yourself.
只是你不需要自己做那么多繁重的任务。

2609
02:07:49,000 --> 02:07:51,850
And here, for instance, in just three lines of code,
例如，在这里，只需要三行代码，

2610
02:07:51,850 --> 02:07:54,910
can you generate a massive QR code that people can scan,
你就可以生成一个巨大的二维码供人们扫描，

2611
02:07:54,910 --> 02:07:57,130
as you can in a moment with your phones, and actually
就像你可以在瞬间用你的手机做到一样，并且实际上

2612
02:07:57,130 --> 02:07:59,870
link to something like a CS50 class.
链接到像 CS50 这样的课程。

2613
02:07:59,870 --> 02:08:03,070
So let me go ahead and run python of qr.py.
所以让我运行 python qr.py 命令。

2614
02:08:03,070 --> 02:08:04,990
It seems to have run.
它似乎运行成功了。

2615
02:08:04,990 --> 02:08:09,760
Let me run code of qr.png, which is the file I created.
让我运行 code qr.png 命令，这是我创建的文件。

2616
02:08:09,760 --> 02:08:12,760
I'll close my terminal window, allow you an opportunity
我会关闭我的终端窗口，给你一个机会

2617
02:08:12,760 --> 02:08:17,930
to scan this here very CS50 lecture.
来扫描这个 CS50 讲座。

2618
02:08:17,930 --> 02:08:25,183
And-- and-- is someone's volume up?
还有——还有——谁的音量开着？

2619
02:08:25,183 --> 02:08:26,850
[RICK ASTLEY, "NEVER GONNA GIVE YOU UP"]
[瑞克·阿斯特利，"永远不会让你失望"]

2620
02:08:26,850 --> 02:08:27,660
There we go.
好了。

2621
02:08:27,660 --> 02:08:28,680
What a perfect ending.
多么完美的结局。

2622
02:08:28,680 --> 02:08:29,180
All right.
好的。

2623
02:08:29,180 --> 02:08:30,120
That was CS50.
这就是 CS50。

2624
02:08:30,120 --> 02:08:32,670
We'll see you next time.
我们下次再见。

2625
02:08:32,670 --> 02:08:35,720
[MUSIC PLAYING]
[音乐播放]
