1
00:00:00,000 --> 00:00:03,486
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,280 --> 00:01:02,510
DAVID MALAN: All right.
大卫·马兰：好的。

3
00:01:02,510 --> 00:01:04,580
This is CS50.
这是 CS50。

4
00:01:04,580 --> 00:01:08,390
This is week 2 wherein we will ultimately learn how to use memory,
这是第二周，我们将最终学习如何使用内存，

5
00:01:08,390 --> 00:01:11,900
but we thought we'd first begin with a bit of story time.
但我们想先从讲故事开始。

6
00:01:11,900 --> 00:01:14,570
And in fact, allow me to walk over to our brave volunteers who
事实上，请允许我走到我们勇敢的志愿者身边，他们

7
00:01:14,570 --> 00:01:15,650
have joined us already.
已经加入了我们。

8
00:01:15,650 --> 00:01:18,080
First here on my left, we have who?
首先，在我左边，我们有谁？

9
00:01:18,080 --> 00:01:19,730
AKSHAYA: Hi, I'm Akshaya.
阿克沙雅：你好，我是阿克沙雅。

10
00:01:19,730 --> 00:01:22,520
I'm a first year in Mathews, and I'm planning
我是一年级学生，在马修斯学习，我正在计划

11
00:01:22,520 --> 00:01:25,747
on concentrating in chemical and physical biology and CS.
专注于化学和物理生物学以及计算机科学。

12
00:01:25,747 --> 00:01:27,080
DAVID MALAN: Wonderful, welcome.
大卫·马兰：太棒了，欢迎。

13
00:01:27,080 --> 00:01:28,955
And let me have you hang on to the microphone
请你拿着麦克风

14
00:01:28,955 --> 00:01:31,437
first because we've asked Akshaya to tell us a short story.
先，因为我们请阿克沙雅给我们讲个短故事。

15
00:01:31,437 --> 00:01:33,770
So in your envelope, you have the beginnings of a story.
所以，你的信封里，有故事的开头。

16
00:01:33,770 --> 00:01:35,353
If you wouldn't mind reading it aloud.
如果你不介意大声朗读。

17
00:01:35,353 --> 00:01:38,630
And as she reads this, allow us to give some thought as to what
当她读的时候，让我们思考一下阿克沙雅的阅读水平，怎么说呢。

18
00:01:38,630 --> 00:01:41,922
level Akshaya reads at, so to speak.
就好像她的阅读水平一样。

19
00:01:41,922 --> 00:01:43,880
AKSHAYA: All right, it's a long one, get ready.
阿克沙雅：好的，它很长，准备好。

20
00:01:43,880 --> 00:01:48,405
One fish, two fish, red fish, blue fish.
一条鱼，两条鱼，红鱼，蓝鱼。

21
00:01:48,405 --> 00:01:50,030
DAVID MALAN: All right, very well done.
大卫·马兰：好的，做得很好。

22
00:01:50,030 --> 00:01:53,302
What grade level would you say she reads at if you think back
你认为她的阅读水平是几年级，如果你回忆一下

23
00:01:53,302 --> 00:01:55,010
to your middle school, grade school, when
你的中学，小学，当

24
00:01:55,010 --> 00:01:59,490
maybe teacher said you read at this level or maybe this level or this one
老师也许说你的阅读水平是这个级别，或者也许是这个级别，或者那个级别

25
00:01:59,490 --> 00:02:01,530
here?
在这里？

26
00:02:01,530 --> 00:02:03,817
So OK, no offense taken yet.
所以，好的，还没人冒犯。

27
00:02:03,817 --> 00:02:05,010
AUDIENCE: 1st grade.
观众：一年级。

28
00:02:05,010 --> 00:02:05,550
DAVID MALAN: I'm sorry?
大卫·马兰：你说什么？

29
00:02:05,550 --> 00:02:06,060
AUDIENCE: 1st grade.
观众：一年级。

30
00:02:06,060 --> 00:02:07,018
DAVID MALAN: 1st grade.
大卫·马兰：一年级。

31
00:02:07,018 --> 00:02:08,850
OK, so first grade is just about right.
好的，所以一年级正好合适。

32
00:02:08,850 --> 00:02:12,432
And in fact, according to one algorithm, this text here,
事实上，根据一种算法，这里这段文字，

33
00:02:12,432 --> 00:02:14,640
one fish, two fish, red fish, blue fish, would indeed
一条鱼，两条鱼，红鱼，蓝鱼，确实

34
00:02:14,640 --> 00:02:17,830
be considered to actually be 1st grade or just before first grade.
被认为是实际的一年级水平，或者刚过一年级。

35
00:02:17,830 --> 00:02:19,530
So let's-- and why is that, though?
所以，让我们，为什么这样呢？

36
00:02:19,530 --> 00:02:21,977
Why did you say 1st grade?
为什么你说是一年级？

37
00:02:21,977 --> 00:02:23,060
AUDIENCE: It's very basic.
观众：它非常基础。

38
00:02:23,060 --> 00:02:23,990
DAVID MALAN: It's very basic.
大卫·马兰：它非常基础。

39
00:02:23,990 --> 00:02:26,198
But what is it about these words that are very basic?
但是这些单词中什么很基础呢？

40
00:02:26,198 --> 00:02:27,687
Do you want to identify yourself?
你想自我介绍吗？

41
00:02:27,687 --> 00:02:28,270
AKSHAYA: Sure.
阿克沙雅：当然。

42
00:02:28,270 --> 00:02:31,570
They're all one syllable and they're very simple like colors and stuff
它们都是一个音节的，而且很简单，就像颜色和那些东西

43
00:02:31,570 --> 00:02:32,070
like that.
就像那样。

44
00:02:32,070 --> 00:02:32,945
DAVID MALAN: Spot-on.
大卫·马兰：完全正确。

45
00:02:32,945 --> 00:02:35,620
So like they're very short words they're very short sentences.
所以，就像它们是很短的单词，很短的句子。

46
00:02:35,620 --> 00:02:38,050
And you would expect that of a younger person.
而且你会期望一个更年轻的人会这样。

47
00:02:38,050 --> 00:02:40,822
All right, let's go ahead and hand the mic to your next volunteer
好的，让我们把麦克风递给下一个志愿者

48
00:02:40,822 --> 00:02:42,530
here if you'd like to introduce yourself.
如果你想自我介绍。

49
00:02:42,530 --> 00:02:43,030
ETHAN: Yes.
伊森：好的。

50
00:02:43,030 --> 00:02:43,810
Hi, I'm Ethan.
你好，我是伊森。

51
00:02:43,810 --> 00:02:46,752
I'm a first year in Canada, and I'll be concentrating in economics.
我是一年级学生，在加拿大学习，我将专注于经济学。

52
00:02:46,752 --> 00:02:47,710
DAVID MALAN: Wonderful.
大卫·马兰：太棒了。

53
00:02:47,710 --> 00:02:50,860
And in your folder, we have another story to share.
你的文件夹里，我们还有另一个故事要分享。

54
00:02:50,860 --> 00:02:52,480
ETHAN: Congratulations.
伊森：恭喜你。

55
00:02:52,480 --> 00:02:53,740
Today is your day.
今天是你的日子。

56
00:02:53,740 --> 00:02:55,480
You're off to great places.
你要去很棒的地方。

57
00:02:55,480 --> 00:02:56,730
You're off and away.
你出发了。

58
00:02:56,730 --> 00:02:59,230
DAVID MALAN: So this text might sound familiar, particularly
大卫·马兰：所以这段文字可能听起来很熟悉，尤其是在

59
00:02:59,230 --> 00:03:00,880
on the heels of high school, perhaps.
高中毕业之后。

60
00:03:00,880 --> 00:03:05,310
What grade level might he be reading at?
他的阅读水平可能是几年级？

61
00:03:05,310 --> 00:03:06,450
So maybe 5th grade.
所以也许是五年级。

62
00:03:06,450 --> 00:03:07,620
And why 5th grade?
为什么是五年级？

63
00:03:07,620 --> 00:03:09,740
AUDIENCE: [INAUDIBLE]
观众：[听不清]

64
00:03:09,740 --> 00:03:11,030
DAVID MALAN: OK.
大卫·马兰：好的。

65
00:03:11,030 --> 00:03:11,540
Yeah.
是的。

66
00:03:11,540 --> 00:03:13,040
So a little more complicated.
所以稍微复杂一点。

67
00:03:13,040 --> 00:03:16,850
Like the words-- we've got some more punctuation, we have an apostrophe,
比如这些单词，我们有一些标点符号，我们有一个撇号，

68
00:03:16,850 --> 00:03:17,892
we have longer sentences.
我们有更长的句子。

69
00:03:17,892 --> 00:03:20,392
And indeed, according to one algorithm, not quite 5th grade,
事实上，根据一种算法，还没有到五年级，

70
00:03:20,392 --> 00:03:22,640
but we would adjudicate your reading level to be 3rd.
但我们会判断你的阅读水平是三年级。

71
00:03:22,640 --> 00:03:25,280
But let's see if we can't do one final flourish here
但是，让我们看看是否可以在这里做最后的润色

72
00:03:25,280 --> 00:03:28,190
if you'd like to introduce yourself and your story.
如果你想自我介绍和你的故事。

73
00:03:28,190 --> 00:03:29,840
MIKE: Hi, I'm Mike.
迈克：你好，我是迈克。

74
00:03:29,840 --> 00:03:30,920
I'm also a first year.
我也是一年级。

75
00:03:30,920 --> 00:03:33,020
I'm in Weld, and I'm planning on concentrating
我在韦尔德，我正在计划专注于

76
00:03:33,020 --> 00:03:34,185
in biomedical engineering.
生物医学工程。

77
00:03:34,185 --> 00:03:35,060
DAVID MALAN: Welcome.
大卫·马兰：欢迎。

78
00:03:35,060 --> 00:03:36,980
And your tale?
你的故事呢？

79
00:03:36,980 --> 00:03:41,750
MIKE: It was a bright, cold day in April and the clocks were striking 13.
迈克：那是四月里一个晴朗寒冷的日子，钟敲了13下。

80
00:03:41,750 --> 00:03:45,440
Winston Smith, his chin nuzzled into his breast in an effort
温斯顿·史密斯，下巴紧贴着胸膛，努力地

81
00:03:45,440 --> 00:03:49,130
to escape the vile wind, slipped quickly through the glass doors
躲避恶风，迅速穿过玻璃门

82
00:03:49,130 --> 00:03:51,710
of victory mansions, though not quickly enough
胜利大厦，尽管不够快

83
00:03:51,710 --> 00:03:55,445
to prevent a swirl of gritty dust from entering along with him.
阻止一股沙尘随他一起进入。

84
00:03:55,445 --> 00:03:57,320
DAVID MALAN: All right, so escalated quickly.
大卫·马兰：好的，所以迅速升级了。

85
00:03:57,320 --> 00:03:59,960
And someone's guess at this reading level?
有人猜一下他的阅读水平？

86
00:03:59,960 --> 00:04:01,083
AUDIENCE: 1984.
观众：1984。

87
00:04:01,083 --> 00:04:02,125
DAVID MALAN: What's that?
大卫·马兰：你说什么？

88
00:04:02,125 --> 00:04:05,320
Oh, OK, 1984 is indeed the text in question, and in what
哦，好的，1984确实是讨论的文本，你是在几年级读的这本书？

89
00:04:05,320 --> 00:04:08,050
grade did you perhaps read that book?
你也许是在几年级读的这本书？

90
00:04:08,050 --> 00:04:09,670
So I'm hearing 8th, I'm hearing 10th.
所以，我听到的是八年级，我听到的是十年级。

91
00:04:09,670 --> 00:04:12,490
So indeed, 10th grade is what a certain algorithm would actually
所以，事实上，十年级是某种算法实际上

92
00:04:12,490 --> 00:04:14,260
adjudicate that reading level to be at.
判断的阅读水平。

93
00:04:14,260 --> 00:04:15,610
And consider now the heuristics.
现在考虑一下启发式方法。

94
00:04:15,610 --> 00:04:19,158
So we started with very small words, very small sentences, very easy words,
所以我们从非常小的单词，非常小的句子，非常简单的单词开始，

95
00:04:19,158 --> 00:04:21,700
and then things sort of escalated into more interesting, more
然后事情逐渐升级，变得更有意思，更多

96
00:04:21,700 --> 00:04:25,460
sophisticated English, more interesting sentence construction and the like.
复杂的英语，更有趣的句子结构等等。

97
00:04:25,460 --> 00:04:30,640
So I bet if we could somehow capture those characteristics of text,
所以，我打赌，如果我们能以某种方式捕捉到文本的那些特征，

98
00:04:30,640 --> 00:04:33,250
the length of the words and the lengths of the sentences
单词的长度和句子的长度

99
00:04:33,250 --> 00:04:35,680
and the position of the punctuation, I daresay,
以及标点符号的位置，我敢说，

100
00:04:35,680 --> 00:04:38,878
even using week 1 material and, today, week 2 material,
即使使用第一周的材料和，今天，第二周的材料，

101
00:04:38,878 --> 00:04:41,920
we'll be able to actually write code and implement an algorithm like that
我们实际上能够编写代码，并实现像这样的算法。

102
00:04:41,920 --> 00:04:44,380
can take these spoken words, put them to paper,
可以把这些口语文字写到纸上，

103
00:04:44,380 --> 00:04:47,590
and actually analyze roughly what that reading level might be.
并实际分析一下这个阅读水平大约是多少。

104
00:04:47,590 --> 00:04:49,390
So that's just a teaser of what lies ahead.
所以这只是对未来内容的预告。

105
00:04:49,390 --> 00:04:52,300
For now, allow us to thank our volunteers, each of whom
现在，让我们感谢我们的志愿者，每一位志愿者

106
00:04:52,300 --> 00:04:55,930
gets a wonderful parting gift here to read at home.
都会收到一份很棒的告别礼物，可以带回家阅读。

107
00:04:55,930 --> 00:04:58,410
[APPLAUSE]
[鼓掌]

108
00:04:58,410 --> 00:04:58,910
All right.
好的。

109
00:04:58,910 --> 00:05:01,110
And Thank you all so much.
非常感谢大家。

110
00:05:01,110 --> 00:05:05,730
So with that said, there's another domain that we'll explore this week,
话虽如此，本周我们将探索另一个领域，

111
00:05:05,730 --> 00:05:07,730
and indeed, what you'll find in the coming weeks
而且，你会发现，在接下来的几周里，

112
00:05:07,730 --> 00:05:11,150
is that beyond just focusing on some of the fundamentals and the basics
除了关注一些基础知识和基本概念之外，

113
00:05:11,150 --> 00:05:14,330
like we've really done in the past couple of weeks talking about loops
就像我们在过去几周谈论循环时所做的那样，

114
00:05:14,330 --> 00:05:16,340
and conditionals and Boolean expressions,
还有条件语句和布尔表达式，

115
00:05:16,340 --> 00:05:19,400
really building blocks or puzzle pieces that we can assemble together,
这些都是我们能够组装在一起的真正意义上的构建块或拼图碎片，

116
00:05:19,400 --> 00:05:22,070
we're going to increasingly start talking about applications
我们将越来越多地开始讨论这些概念的应用，

117
00:05:22,070 --> 00:05:25,250
of these ideas which, after all, is why any field is perhaps
毕竟，这正是任何领域可能

118
00:05:25,250 --> 00:05:26,460
important and applicable.
重要且可应用的原因。

119
00:05:26,460 --> 00:05:29,510
So here, for instance, we'll consider not only reading levels today,
因此，例如，我们今天不仅要考虑阅读水平，

120
00:05:29,510 --> 00:05:33,630
and in turn, in problem set 2 this week, but also the world of cryptography,
而且，在本周的习题集 2 中，还要考虑密码学的世界，

121
00:05:33,630 --> 00:05:36,860
which is the art, the science of scrambling, encrypting
密码学是混淆、加密信息的艺术，是科学。

122
00:05:36,860 --> 00:05:39,230
information, and ciphering it in such a way
它以这样的方式对信息进行加密，

123
00:05:39,230 --> 00:05:43,530
that you can send a message securely through the internet, through the air,
以便你可以安全地通过互联网、通过无线电发送信息，

124
00:05:43,530 --> 00:05:46,700
through any medium even though someone might intercept it.
通过任何媒介，即使有人可能拦截它。

125
00:05:46,700 --> 00:05:49,100
Ideally, thanks to cryptography, they shouldn't
理想情况下，由于密码学的存在，他们不应该

126
00:05:49,100 --> 00:05:53,240
be able to decrypt it or actually determine what it there says.
能够解密它，或者真正确定它上面写了什么。

127
00:05:53,240 --> 00:05:57,560
So for instance, if you were to receive a message like this, at first glance,
例如，如果你收到像这样的消息，乍一看，

128
00:05:57,560 --> 00:05:59,460
it's indeed a bit cryptic.
它确实有点神秘。

129
00:05:59,460 --> 00:06:02,400
Three words maybe, but by day's end, we'll
可能三个词，但到今天结束时，我们将

130
00:06:02,400 --> 00:06:04,830
have decrypted even this message for you.
为你解密这条消息。

131
00:06:04,830 --> 00:06:08,550
So up until now, though, we've had some sort of conceptual training wheels on.
不过，到目前为止，我们一直都在使用概念上的辅助轮。

132
00:06:08,550 --> 00:06:12,480
And I gave us this picture last week when we introduced the tool make via
上周我们介绍工具 make 时，我就画了这个图，

133
00:06:12,480 --> 00:06:15,870
which you can make programs out of your source code because you need to turn
你就可以用源代码制作程序，因为你需要将

134
00:06:15,870 --> 00:06:18,450
that source code into machine code, the 0's and 1's.
源代码转换成机器代码，也就是 0 和 1。

135
00:06:18,450 --> 00:06:20,970
And in the middle here was this thing called a compiler.
中间这个东西就叫做编译器。

136
00:06:20,970 --> 00:06:23,790
But it really has been kind of an abstraction for us,
但对我们来说，它实际上一直都是一个抽象的概念，

137
00:06:23,790 --> 00:06:27,690
and we've sort of had these metaphorical and physical training
我们一直在使用这种隐喻性的和实际上的辅助轮，

138
00:06:27,690 --> 00:06:30,450
wheels here in the sense that we haven't really
从某种意义上来说，我们并没有真正

139
00:06:30,450 --> 00:06:34,420
needed to care like what the compiler is doing, how it works and so forth.
需要关心编译器在做什么，它是如何工作的等等。

140
00:06:34,420 --> 00:06:38,400
But today, what we thought we'd do is peel back a bit of that layer so
但是今天，我们想做的是剥开那一层的部分内容，这样

141
00:06:38,400 --> 00:06:40,410
that even though after today you'll continue
即使在今天之后，你仍然会继续

142
00:06:40,410 --> 00:06:43,380
to be able to use commands like make and sort of return
使用像 make 这样的命令，并回归到

143
00:06:43,380 --> 00:06:46,275
to the beautiful abstraction that is not caring about some
这种美丽抽象的状态，这种状态是不关心一些

144
00:06:46,275 --> 00:06:48,150
of these lower-level details, we'll offer you
底层细节的，我们会为你提供

145
00:06:48,150 --> 00:06:49,980
a glimpse of how some of these things work.
对这些东西是如何工作的有一个简单的了解。

146
00:06:49,980 --> 00:06:52,350
Because so that inevitably when something goes wrong,
因为这样，当不可避免地出现错误时，

147
00:06:52,350 --> 00:06:54,540
you've got some bug, you're having some problem,
你遇到了一个错误，你遇到了一个问题，

148
00:06:54,540 --> 00:06:58,620
you'll have a bottom-up understanding of what it could actually be.
你将会从底层向上地理解它究竟是什么。

149
00:06:58,620 --> 00:07:01,620
And indeed, these basics, you'll find, will very often
而且，你会发现，这些基本概念往往会

150
00:07:01,620 --> 00:07:05,230
help you troubleshoot problems and really solve problems more generally.
帮助你排查问题，更普遍地解决问题。

151
00:07:05,230 --> 00:07:07,920
So here, for instance, is the code that we keep coming back to.
所以，例如，这就是我们一直在使用的代码。

152
00:07:07,920 --> 00:07:12,750
And this code here is the simplest of C programs that just says "hello, world."
这段代码是 C 语言中最简单的程序，它只输出“hello, world”。

153
00:07:12,750 --> 00:07:13,960
This is the source code.
这是源代码。

154
00:07:13,960 --> 00:07:16,260
This, we claimed, was the corresponding machine code.
我们声称，这是相应的机器代码。

155
00:07:16,260 --> 00:07:18,810
And it was that program called a compiler that
而那个叫做编译器的程序

156
00:07:18,810 --> 00:07:20,800
converted one into the other.
将一个转换成另一个。

157
00:07:20,800 --> 00:07:23,100
But let's dive a little more deeply this week
但本周，让我们更深入地了解一下

158
00:07:23,100 --> 00:07:25,920
into what we mean by compiling code.
我们所说的编译代码是什么意思。

159
00:07:25,920 --> 00:07:28,410
Like what is happening so that by day's end,
比如，到今天结束的时候，

160
00:07:28,410 --> 00:07:30,910
nothing really feels like magic anymore.
一切都变得不再像魔法一样。

161
00:07:30,910 --> 00:07:33,540
It's not just that it goes from source code to machine code
它不仅仅是从源代码到机器代码

162
00:07:33,540 --> 00:07:37,020
and that's that, you understand what's actually being done for you,
就是这样，你明白为你做了什么，

163
00:07:37,020 --> 00:07:40,694
and frankly, what other humans have done over the decades to make
坦白地说，还有几十年来，其他人做了些什么，才让

164
00:07:40,694 --> 00:07:45,597
make as beautifully abstract and as simple as it now might seem to be.
make 变得如此抽象，如此简单，就像现在看起来那样。

165
00:07:45,597 --> 00:07:47,430
So here are a couple of commands that you've
所以，这里有一些你一直以来习惯使用的命令，当你想

166
00:07:47,430 --> 00:07:50,305
been in the habit of running when you want to first compile your code
编译你的代码，然后执行你的代码时，就会使用这些命令。

167
00:07:50,305 --> 00:07:51,930
and then execute your code.
然后执行你的代码。

168
00:07:51,930 --> 00:07:56,280
But it turns out that make is actually running another command for you.
但事实证明，make 实际上是在为你运行另一个命令。

169
00:07:56,280 --> 00:07:59,190
The first of several white lies we'll tell in the course
这是我们这门课程中要讲的第一个善意的谎言，

170
00:07:59,190 --> 00:08:02,040
is that make itself is not a compiler, per se.
就是 make 本身并非严格意义上的编译器。

171
00:08:02,040 --> 00:08:06,580
It's actually a program that automatically runs a compiler for you.
它实际上是一个为你自动运行编译器的程序。

172
00:08:06,580 --> 00:08:07,770
And by that, I mean this.
我的意思是这个。

173
00:08:07,770 --> 00:08:13,650
Let me go over to VS Code here and let me create our familiar hello.c program.
让我到 VS Code 中创建一个我们熟悉的 hello.c 程序。

174
00:08:13,650 --> 00:08:20,310
And I'm going to go ahead and do include stdio.h, int main void, and inside
我将继续执行包含 stdio.h、int main void，以及里面

175
00:08:20,310 --> 00:08:25,027
of the curly braces, printf "hello," comma, "world," backslash n semicolon.
花括号的内容，printf "hello," 逗号，"world," 反斜杠 n 分号。

176
00:08:25,027 --> 00:08:27,360
So that's the code that we keep writing again and again.
这就是我们一直重复编写的代码。

177
00:08:27,360 --> 00:08:31,932
And up until now, if I wanted to compile that, I would do make hello
到目前为止，如果我想编译它，我会执行 make hello

178
00:08:31,932 --> 00:08:35,820
dot slash hello, and voila, now my program is made
点斜杠 hello，瞧，现在我的程序已经制作完成了，

179
00:08:35,820 --> 00:08:37,980
and it actually executes.
它实际上可以执行了。

180
00:08:37,980 --> 00:08:40,289
But what's actually going on underneath the hood
但是，实际上在幕后发生了什么

181
00:08:40,289 --> 00:08:43,799
there is that make is running an actual compiler for you,
就是 make 正在为你运行一个真正的编译器，

182
00:08:43,799 --> 00:08:46,980
and the reveal today is that the compiler we have been using
而今天要揭示的是，我们一直在使用的编译器

183
00:08:46,980 --> 00:08:49,170
is something called Clang for C language.
是一个叫做 Clang 的编译器，用于 C 语言。

184
00:08:49,170 --> 00:08:51,540
And this is just another program whose purpose in life
它只是另一个程序，它的生命目的

185
00:08:51,540 --> 00:08:54,510
is actually to do the conversion of source code to machine code.
实际上是将源代码转换成机器代码。

186
00:08:54,510 --> 00:08:57,360
But it turns out that Clang by itself can
但事实证明，Clang 本身就可以

187
00:08:57,360 --> 00:09:00,770
be used very simply like you see here, clang hello.c,
像这里看到的一样，非常简单地使用，clang hello.c，

188
00:09:00,770 --> 00:09:04,563
but it doesn't behave nearly as user-friendly as you might like.
但它的行为不像你期望的那样友好。

189
00:09:04,563 --> 00:09:06,480
So in particular, let me go ahead and do this.
因此，具体来说，让我继续执行这个操作。

190
00:09:06,480 --> 00:09:08,960
I'm going to go ahead and remove my compiled program
我将继续删除我的编译程序

191
00:09:08,960 --> 00:09:12,830
by running rm for remove, which I alluded to briefly last time.
通过运行 rm 来删除，我上次简要提到了它。

192
00:09:12,830 --> 00:09:16,260
And then I'm going to say y for yes, remove that regular file.
然后我会输入 y 代表是，删除那个普通文件。

193
00:09:16,260 --> 00:09:21,800
And if I go ahead now and run just clang of hello.c and hit Enter,
如果我现在继续运行 clang hello.c 并按回车，

194
00:09:21,800 --> 00:09:25,140
it seems to be successful, at least insofar as there's no error messages.
它似乎是成功的，至少没有错误消息。

195
00:09:25,140 --> 00:09:27,530
But if I try to do dot slash hello, Enter,
但是如果我尝试输入点斜杠 hello，回车，

196
00:09:27,530 --> 00:09:31,070
there is no such file or directory called hello.
没有名为 hello 的文件或目录。

197
00:09:31,070 --> 00:09:34,940
That is because by default, Clang somewhat goofily like just
这是因为默认情况下，Clang 有点笨拙，就像

198
00:09:34,940 --> 00:09:37,670
outputs a file name called a dot out.
输出一个名为点 out 的文件名。

199
00:09:37,670 --> 00:09:38,480
Like why a?
为什么是 a 呢？

200
00:09:38,480 --> 00:09:42,200
Well, it's sort of a simple name. a dot out, technically for assembler output,
好吧，它算是一个简单的名字。a 点 out，从技术上讲是用于汇编输出，

201
00:09:42,200 --> 00:09:44,270
but this just means this is the default file
但这只是意味着这是 Clang 将要给我们的默认文件

202
00:09:44,270 --> 00:09:45,770
name that Clang is going to give us.
名称。

203
00:09:45,770 --> 00:09:49,790
So OK, it turns out I can do dot slash a dot out Enter, and voila,
所以，我发现我可以用点斜杠 a 点 out 回车，瞧，

204
00:09:49,790 --> 00:09:53,723
that now is my program, but that's just a stupid name for a program.
现在这就是我的程序，但这只是程序的一个愚蠢的名字。

205
00:09:53,723 --> 00:09:54,890
It's not very user-friendly.
它不是非常人性化。

206
00:09:54,890 --> 00:09:56,598
It's certainly not an icon you would want
它肯定不是你想放在人们的桌面或手机上的图标。

207
00:09:56,598 --> 00:09:58,680
to put on people's desktops or phones.


208
00:09:58,680 --> 00:10:00,070
So how can we do better?
我们如何才能做得更好？

209
00:10:00,070 --> 00:10:03,600
Well, it turns out, with Clang, we can configure it using
事实证明，对于 Clang，我们可以使用它来配置它

210
00:10:03,600 --> 00:10:05,983
what we'll call command line arguments.
我们称之为命令行参数。

211
00:10:05,983 --> 00:10:09,150
And command line arguments are actually something we've been using thus far,
命令行参数实际上是我们一直在使用的，

212
00:10:09,150 --> 00:10:12,390
we just didn't slap this word on it, but command line arguments
我们只是没有用这个词来描述它，但命令行参数

213
00:10:12,390 --> 00:10:15,600
are additional words or shorthand notation
是你在命令提示符处键入的附加词语或简写符号，

214
00:10:15,600 --> 00:10:18,660
that you typed at your command prompt that somehow
它们以某种方式

215
00:10:18,660 --> 00:10:21,270
modify the behavior of a program.
修改程序的行为。

216
00:10:21,270 --> 00:10:23,310
And you can perhaps guess where this is going.
也许你已经猜到我们要做什么了。

217
00:10:23,310 --> 00:10:28,140
It turns out that if I actually want to create a program called hello--
事实证明，如果我实际上想创建一个名为 hello 的程序——

218
00:10:28,140 --> 00:10:31,200
not a.out, which is the default, I can actually
不是 a.out，它是默认的，我实际上可以

219
00:10:31,200 --> 00:10:36,420
do this-- clang, space, dash lowercase o, space, hello,
这样做—— clang，空格，短横线小写 o，空格，hello，

220
00:10:36,420 --> 00:10:40,260
or whatever I want to call the thing, space, hello.c.
或者我想要叫它什么名字，空格，hello.c。

221
00:10:40,260 --> 00:10:42,630
And now if I hit Enter, nothing seems to happen,
现在如果我按回车，似乎什么也没发生，

222
00:10:42,630 --> 00:10:48,490
but now if I do ./hello and Enter, now I've actually got that program.
但现在如果我输入 ./hello 并按回车，现在我实际上得到了那个程序。

223
00:10:48,490 --> 00:10:49,737
So why is make useful?
那么，为什么 make 有用呢？

224
00:10:49,737 --> 00:10:51,570
Well, it just saves us the trouble of having
好吧，它只是省去了我们每次都必须

225
00:10:51,570 --> 00:10:55,230
to type out this longer line of command any time
键入这长长的命令行的麻烦。

226
00:10:55,230 --> 00:10:56,940
we actually want to compile the code.
我们实际上想要编译代码。

227
00:10:56,940 --> 00:10:59,430
But in fact, it gets even worse than that
但实际上，它比这更糟糕

228
00:10:59,430 --> 00:11:01,860
with commands like clang or compilers in general
像 clang 这样的命令或者一般意义上的编译器

229
00:11:01,860 --> 00:11:04,470
because consider this code here.
因为考虑一下这里代码。

230
00:11:04,470 --> 00:11:08,010
Not just the version of "hello, world," but maybe the second version wherein
不仅仅是 "hello, world" 的版本，也许是第二个版本，其中

231
00:11:08,010 --> 00:11:11,700
last week, I started to get user input by adding the CS50 Library using
上周，我开始通过添加 CS50 库来获取用户输入，使用

232
00:11:11,700 --> 00:11:14,370
get_string and then saying, "hello," comma, "David."
get_string 然后说 "hello"，逗号，"David"。

233
00:11:14,370 --> 00:11:18,210
Well, if I go back to VS Code and I modify this program
好吧，如果我回到 VS Code 并修改这个程序

234
00:11:18,210 --> 00:11:19,810
to be that same one--
变成和之前一样的——

235
00:11:19,810 --> 00:11:23,490
so let me go ahead and include cs50.h at the top.
所以，让我在顶部添加 cs50.h。

236
00:11:23,490 --> 00:11:27,000
Let me get rid of this simple print line and instead give myself
让我去掉这简单的打印行，取而代之的是给自己

237
00:11:27,000 --> 00:11:33,510
a string called name equals get_string, "What's your name?"
一个名为 name 的字符串，等于 get_string，"你的名字是什么？"

238
00:11:33,510 --> 00:11:35,610
Question mark, just like we did in Scratch.
问号，就像我们在 Scratch 中做的那样。

239
00:11:35,610 --> 00:11:39,510
Then I can do printf, quote-unquote, "hello," comma.
然后我可以执行 printf，引号，"hello"，逗号。

240
00:11:39,510 --> 00:11:41,532
And previously I typed "world."
之前我输入的是 "world"。

241
00:11:41,532 --> 00:11:44,490
I obviously don't want to type "David" because I want it to be dynamic.
我显然不想输入 "David"，因为我希望它是动态的。

242
00:11:44,490 --> 00:11:47,430
What did I type last week for as a placeholder?
上周我输入了什么作为占位符？

243
00:11:47,430 --> 00:11:50,980
So yeah, just-- not Command-S, but %S. So %S in this case,
所以，是的，不是 Command-S，而是 %S。在这种情况下，%S，

244
00:11:50,980 --> 00:11:53,070
which is a placeholder for any such string.
它是一个占位符，用于任何这样的字符串。

245
00:11:53,070 --> 00:11:56,550
Then I can still do my new line, close, quote, comma, and then
然后我仍然可以执行我的换行，关闭，引号，逗号，然后

246
00:11:56,550 --> 00:12:00,630
I can substitute in something like the value of the name variable.
我可以代入类似于 name 变量的值。

247
00:12:00,630 --> 00:12:03,430
All right, so if I go ahead now and compile this,
好的，所以如果我现在继续编译它，

248
00:12:03,430 --> 00:12:06,300
now last week, I could just do make hello and I'm on my way,
上周，我可以直接执行 make hello，然后我就完成了，

249
00:12:06,300 --> 00:12:07,570
it worked just fine.
它运行得很好。

250
00:12:07,570 --> 00:12:10,440
But if I instead do clang manually, it turns out
但是如果我手动执行 clang，结果发现

251
00:12:10,440 --> 00:12:16,650
that this is not going to be sufficient now. clang -o hello, space, hello.c.
现在这将不再足够了。clang -o hello，空格，hello.c。

252
00:12:16,650 --> 00:12:19,200
Exact same thing I typed a moment ago, but I
和刚才我输入的完全一样，但是我

253
00:12:19,200 --> 00:12:21,940
think I'm going to see some errors.
我认为我将看到一些错误。

254
00:12:21,940 --> 00:12:24,580
So what's this error hinting at here?
那么，这里错误提示的是什么？

255
00:12:24,580 --> 00:12:27,120
Well, at the very bottom, it's a bit arcane with its output,
好吧，在最底部，它的输出有点深奥，

256
00:12:27,120 --> 00:12:30,400
and much of this you can ignore, but there are some certain key words.
而且其中大部分你可以忽略，但有一些特定的关键词。

257
00:12:30,400 --> 00:12:33,240
What's the first maybe keyword you recognize in these three
在这三行错误输出中，你认识的第一个关键词可能是哪一个？

258
00:12:33,240 --> 00:12:36,130
lines of erroneous output?


259
00:12:36,130 --> 00:12:37,273
So it mentions main.
所以它提到了 main。

260
00:12:37,273 --> 00:12:40,440
That's not that much of a clue because that's the only thing I wrote so far.
这不太是一个线索，因为到目前为止，这是我唯一写的东西。

261
00:12:40,440 --> 00:12:42,060
Second line, though, get_string.
第二行，get_string。

262
00:12:42,060 --> 00:12:46,050
There's some issue with an undefined reference to get_string.
关于 get_string 的未定义引用存在一些问题。

263
00:12:46,050 --> 00:12:47,590
Now why might that be?
为什么会出现这种情况呢？

264
00:12:47,590 --> 00:12:51,820
I did include cs50.h, but that's apparently not
我已经包含了 cs50.h，但这显然

265
00:12:51,820 --> 00:12:54,520
enough to teach the compiler about get_string.
不足以教编译器关于 get_string 的知识。

266
00:12:54,520 --> 00:12:58,630
Well, it turns out that if you're using a third-party library, one
事实证明，如果你使用的是第三方库，一个

267
00:12:58,630 --> 00:13:02,740
that doesn't necessarily come with C the language, something like CS50's, it
并非 C 语言自带的库，例如 CS50 库，它

268
00:13:02,740 --> 00:13:05,860
turns out that you additionally have to tell the compiler that you
原来你还要额外地告诉编译器你

269
00:13:05,860 --> 00:13:07,060
want to use that library.
想使用那个库。

270
00:13:07,060 --> 00:13:08,890
And not just by including the header file,
不仅仅是包含头文件，

271
00:13:08,890 --> 00:13:11,450
but by an additional command as well.
还要通过一个额外的命令。

272
00:13:11,450 --> 00:13:15,010
So when you run Clang, you want to provide an additional
所以当你运行 Clang 时，你想要提供一个额外的

273
00:13:15,010 --> 00:13:16,900
rather command line argument.
命令行参数。

274
00:13:16,900 --> 00:13:21,580
Literally -l for library, which is a term I used last week, cs50.
实际上是 -l 代表 library（库），这是我上周用过的术语，cs50。

275
00:13:21,580 --> 00:13:23,620
A library is just code that someone else wrote
库只是其他人写的代码

276
00:13:23,620 --> 00:13:25,640
that you want to use in your project.
你想在你的项目中使用它。

277
00:13:25,640 --> 00:13:29,380
So if I really want to compile this version that uses the CS50 Library,
所以如果我真的想编译这个使用 CS50 库的版本，

278
00:13:29,380 --> 00:13:34,660
I can still do clang o hello hello.c, but before I finish my thought,
我仍然可以执行 clang o hello hello.c，但在我想完之前，

279
00:13:34,660 --> 00:13:40,450
I need to tell the compiler to link, so to speak, in the library CS50.
我需要告诉编译器连接，也可以说是链接，CS50 库。

280
00:13:40,450 --> 00:13:44,350
And now I hit Enter, the error message goes away, I can do ./hello,
现在我按回车，错误消息消失了，我可以执行 ./hello，

281
00:13:44,350 --> 00:13:47,410
I can type in my name, and voila, we're back to week 1.
我可以输入我的名字，瞧，我们回到了第一周。

282
00:13:47,410 --> 00:13:49,987
And this is why, suffice it to say, we introduce make,
这就是我们引入 make 的原因，不难理解，

283
00:13:49,987 --> 00:13:51,070
which is not a CS50 thing.
这不是CS50的东西。

284
00:13:51,070 --> 00:13:54,070
This is a popular tool that real people in the real world
这是一个现实世界中真实的人们使用的流行工具

285
00:13:54,070 --> 00:13:56,480
use to automate these kinds of processes.
用来自动化这类流程。

286
00:13:56,480 --> 00:13:59,050
So unbeknownst to you, make has been using
所以在你不知情的情况下，make一直在使用

287
00:13:59,050 --> 00:14:03,670
the -o for you. make, unbeknownst to you, has been using -l cs50 for you
-o 命令。在你不知情的情况下，make一直在为你使用-l cs50命令

288
00:14:03,670 --> 00:14:06,650
just because it makes our lives easier.
仅仅是因为它使我们的生活更轻松。

289
00:14:06,650 --> 00:14:08,560
But today, we thought we would deliberately
但今天，我们想故意

290
00:14:08,560 --> 00:14:11,440
peel back this layer so we at least understand
剥开这一层，以便我们至少了解

291
00:14:11,440 --> 00:14:16,300
what's going on behind this abstraction that is make itself
make本身这一抽象背后的情况

292
00:14:16,300 --> 00:14:17,750
and compiling more generally.
以及更一般的编译过程。

293
00:14:17,750 --> 00:14:21,880
So let me propose that compiling itself is not quite what
所以我想说，编译本身并不完全是

294
00:14:21,880 --> 00:14:22,960
we've described it to be.
我们所描述的那样。

295
00:14:22,960 --> 00:14:25,840
Compiling is like this catch-all phrase that apparently I claim
编译就像是一个万能词语，我似乎声称

296
00:14:25,840 --> 00:14:27,650
goes from source code to machine code.
它将源代码转换为机器码。

297
00:14:27,650 --> 00:14:30,710
But if we really want to get pedantic, which we'll do briefly,
但如果我们真的想要吹毛求疵，我们会简单地进行一下，

298
00:14:30,710 --> 00:14:33,640
but this is not a sign of things to come because this, too,
但这并不意味着未来会一直这样，因为这也会

299
00:14:33,640 --> 00:14:39,250
will be abstract away, compiling is just one of four steps that are involved
被抽象化，编译只是涉及到的四个步骤中的一个

300
00:14:39,250 --> 00:14:43,010
in turning source code that you and I write into those 0's and 1's.
将你和我的源代码转换为0和1。

301
00:14:43,010 --> 00:14:45,010
But through an understanding of these four steps
但是，通过理解这四个步骤

302
00:14:45,010 --> 00:14:46,780
today, you'll hopefully better understand
今天，你应该会更好地理解

303
00:14:46,780 --> 00:14:49,480
how to troubleshoot issues like that and just know
如何解决类似的问题，并且知道

304
00:14:49,480 --> 00:14:51,680
what's happening because it's not, in fact, magic.
发生了什么，因为实际上这不是魔法。

305
00:14:51,680 --> 00:14:55,850
It's just the result of years of humans developing these four steps here.
这只是人类多年来开发这四个步骤的结果。

306
00:14:55,850 --> 00:14:58,870
So when you run make, what's happening?
所以当你运行make时，发生了什么？

307
00:14:58,870 --> 00:15:02,450
Or in turn, when you run clang, four different things are happening.
或者换句话说，当你运行clang时，会发生四件事。

308
00:15:02,450 --> 00:15:04,360
And the first one is called pre-processing.
第一个叫做预处理。

309
00:15:04,360 --> 00:15:05,720
So what is this all about?
所以，这到底是怎么回事呢？

310
00:15:05,720 --> 00:15:07,270
Well, let's consider this code here.
好吧，让我们看看这里这段代码。

311
00:15:07,270 --> 00:15:09,730
And this code is a little bit interesting
这段代码有点意思

312
00:15:09,730 --> 00:15:13,850
insofar as it's one of the more complicated examples from last week.
因为它算是上周比较复杂的例子之一。

313
00:15:13,850 --> 00:15:18,550
And you'll notice, for instance, that I had include stdio at the top
你会注意到，例如，我在顶部包含了stdio

314
00:15:18,550 --> 00:15:19,900
so I could use printf.
这样我就可以使用printf函数了。

315
00:15:19,900 --> 00:15:24,340
I had main down here, whose purpose in life was just to meow three times.
我在下面写了main函数，它的唯一作用就是叫三声喵。

316
00:15:24,340 --> 00:15:27,880
And then recall we made our own meow function just like we did in week 0
然后记得我们自己制作了一个喵函数，就像我们在第0周用Scratch做的那样

317
00:15:27,880 --> 00:15:31,630
with Scratch that just printed out, quote-unquote, "meow."
只是输出“喵”这个词。

318
00:15:31,630 --> 00:15:37,210
But I also included this line here, which we called what?
但我还在此处包含了这行代码，我们称它为？

319
00:15:37,210 --> 00:15:39,760
This was a prototype.
这是一个原型。

320
00:15:39,760 --> 00:15:41,470
And why did I have to include it there?
为什么我必须把它包含在里面？

321
00:15:41,470 --> 00:15:45,070
Or equivalently, what would happen if I didn't include a prototype up
或者等效地，如果我不包含一个原型在

322
00:15:45,070 --> 00:15:45,790
at the top there?
顶部呢？

323
00:15:45,790 --> 00:15:46,693
Yeah?
对吧？

324
00:15:46,693 --> 00:15:51,255
AUDIENCE: [INAUDIBLE]
听众：[听不清]

325
00:15:51,255 --> 00:15:52,130
DAVID MALAN: Exactly.
大卫·马兰：没错。

326
00:15:52,130 --> 00:15:55,820
If I didn't include it up here, the program, when trying to compile main,
如果我不把它包含在这里，程序在尝试编译main函数时

327
00:15:55,820 --> 00:15:59,370
would not know what meow is because it's not defined until later.
将不知道meow是什么，因为它直到之后才会定义。

328
00:15:59,370 --> 00:16:02,210
So this is kind of like a little hint of what is to come.
所以这有点像未来即将发生的事情的一个小提示。

329
00:16:02,210 --> 00:16:05,750
Alternatively, we could just move this whole thing up at the top of the file,
或者，我们可以直接将整个东西移动到文件顶部，

330
00:16:05,750 --> 00:16:08,120
but I claim that just devolves into a big mess
但我认为，这最终会变成一团糟

331
00:16:08,120 --> 00:16:10,250
eventually once you have many different functions.
最终你会拥有许多不同的函数。

332
00:16:10,250 --> 00:16:13,590
Like you can't realistically put them all at the top to solve this problem.
就像你不能现实地将它们都放在顶部来解决这个问题。

333
00:16:13,590 --> 00:16:15,870
So these prototypes solve that problem.
所以这些原型解决了这个问题。

334
00:16:15,870 --> 00:16:16,760
So nothing new here.
所以这里没有新东西。

335
00:16:16,760 --> 00:16:20,750
Just a reminder of what motivated this one line of prototype.
只是一个提醒，说明是什么促使了这行原型代码。

336
00:16:20,750 --> 00:16:24,290
Now let's consider this simpler program, which
现在让我们考虑这个更简单的程序，它

337
00:16:24,290 --> 00:16:26,945
is just the one we wrote most recently in VS Code.
是我们最近在VS Code中编写的程序。

338
00:16:26,945 --> 00:16:28,820
This program prompts the human for their name
这个程序提示用户输入他们的姓名

339
00:16:28,820 --> 00:16:30,590
and then says hello to that person.
然后向那个人问好。

340
00:16:30,590 --> 00:16:33,710
But it has two includes at the top of the file.
但是它在文件顶部包含了两个头文件。

341
00:16:33,710 --> 00:16:37,070
And in fact, any line of C that starts with this hash symbol
实际上，任何以这个井号开头的C语言代码行

342
00:16:37,070 --> 00:16:40,220
is what we'll call now a preprocessor directive.
我们现在称之为预处理指令。

343
00:16:40,220 --> 00:16:42,950
It's not really a word you need to remember in your vocabulary,
这不是你必须记住的一个词，

344
00:16:42,950 --> 00:16:46,310
but it is a little bit different from most every other line
但它与大多数其他代码行略有不同

345
00:16:46,310 --> 00:16:47,900
because it starts with that hash.
因为它以井号开头。

346
00:16:47,900 --> 00:16:50,420
That's a special symbol in C.
这是C语言中的一个特殊符号。

347
00:16:50,420 --> 00:16:52,750
And what this means is the following.
这意味着以下几点。

348
00:16:52,750 --> 00:16:57,570
This very first line, cs50.h, is indeed a file that I and CS50 staff
这第一行，cs50.h，实际上是一个文件，由我和CS50的工作人员

349
00:16:57,570 --> 00:17:02,400
wrote and we installed somewhere in VS Code for you, somewhere in the cloud.
编写并安装在你的VS Code中的某个地方，云端中的某个地方。

350
00:17:02,400 --> 00:17:07,859
And I've claimed you need to use this header file in order to use get_string.
我声称你需要使用这个头文件才能使用get_string函数。

351
00:17:07,859 --> 00:17:12,290
So just logically, what is probably inside of cs50.h?
所以，从逻辑上讲，cs50.h里可能有什么？

352
00:17:15,089 --> 00:17:16,170
Yeah?
对吧？

353
00:17:16,170 --> 00:17:17,610
AUDIENCE: Function [INAUDIBLE].
听众：函数[听不清]。

354
00:17:23,628 --> 00:17:24,670
DAVID MALAN: Super close.
大卫·马兰：非常接近。

355
00:17:24,670 --> 00:17:27,589
So the function called get_string that does the getting of a string,
所以这个叫做get_string的函数，它负责获取字符串，

356
00:17:27,589 --> 00:17:30,038
but it's not quite as much as the function itself.
但它并不完全是函数本身。

357
00:17:30,038 --> 00:17:33,080
It's actually a little bit less than that, but you're on the right track.
实际上比这少一点，但你是在正确的轨道上。

358
00:17:33,080 --> 00:17:37,940
What is inside of cs50.h, presumably?
cs50.h里面应该是什么？

359
00:17:37,940 --> 00:17:40,560
Just a what?
只是一个什么？

360
00:17:40,560 --> 00:17:43,770
Just a prototype for?
只是一个原型，用于？

361
00:17:43,770 --> 00:17:44,820
Which function?
哪个函数？

362
00:17:44,820 --> 00:17:45,750
get_string.
get_string函数。

363
00:17:45,750 --> 00:17:48,390
So admittedly, there's some other stuff in there, too,
所以不可否认，里面也有一些其他的东西，

364
00:17:48,390 --> 00:17:51,930
but the important line for today's discussion is that inside of cs50.h
但是对于今天的讨论，重要的是，在cs50.h里面

365
00:17:51,930 --> 00:17:55,740
is indeed one line of code that defines what the return value, what
的确有一行代码，定义了返回值、

366
00:17:55,740 --> 00:17:59,610
the name is, and what the arguments, if any, are to get_string,
函数名，以及get_string函数的参数，如果有的话，

367
00:17:59,610 --> 00:18:00,880
and some other stuff.
以及一些其他的东西。

368
00:18:00,880 --> 00:18:05,130
And so what happens effectively when you compile your code,
所以当你编译你的代码时，实际上发生了什么，

369
00:18:05,130 --> 00:18:07,080
step 1 is this pre-processing line.
第一步就是这条预处理指令。

370
00:18:07,080 --> 00:18:09,960
And essentially, there is some code that someone else wrote inside
本质上，clang编译器内部有一些其他人编写的代码，

371
00:18:09,960 --> 00:18:13,710
of the clang compiler that looks for a line that starts with hash include,
它会寻找以井号include开头的代码行，

372
00:18:13,710 --> 00:18:17,580
and when it sees that, it goes and finds this file and effectively copies
当它看到这个时，它就会去找到这个文件，并且实际上会复制

373
00:18:17,580 --> 00:18:21,240
and pastes the contents of that file right there into your code
并将该文件的内容粘贴到你的代码中

374
00:18:21,240 --> 00:18:23,130
so that you don't have to go find the file,
这样你就不用去查找文件，

375
00:18:23,130 --> 00:18:25,840
copy and paste it, and make a mess of your own code.
复制粘贴它，并弄乱你自己的代码。

376
00:18:25,840 --> 00:18:29,550
So in particular, it's effectively as though you're copying and pasting
所以，特别地，它实际上就像你在复制粘贴

377
00:18:29,550 --> 00:18:32,910
the prototype of get_string to the very top of your file,
get_string函数的原型到你的文件顶部，

378
00:18:32,910 --> 00:18:35,550
thereby teaching the compiler that it exists.
由此告诉编译器它的存在。

379
00:18:35,550 --> 00:18:38,550
By that same logic, what is probably in stdio.h?
用同样的逻辑，stdio.h 中可能包含什么？

380
00:18:41,740 --> 00:18:43,690
The prototype for?
对于什么？

381
00:18:43,690 --> 00:18:44,710
For printf.
对于 printf。

382
00:18:44,710 --> 00:18:46,280
And indeed, exactly that.
的确如此，就是它。

383
00:18:46,280 --> 00:18:49,450
So this line effectively gets replaced with the equivalent
因此，这行代码实际上被替换成了等效的代码

384
00:18:49,450 --> 00:18:52,150
of the prototype for printf, which, for today's purposes,
printf 函数的原型，就今天而言，

385
00:18:52,150 --> 00:18:55,210
is a bit more complicated, so let me wave my hand at the dot-dot-dot
稍微复杂一点，所以我在省略号部分挥挥手

386
00:18:55,210 --> 00:18:57,850
just because it takes a variable number of arguments
因为它接收可变数量的参数

387
00:18:57,850 --> 00:19:00,760
depending on how many placeholders or format codes you have.
取决于你用了多少占位符或格式代码。

388
00:19:00,760 --> 00:19:03,290
But effectively, that, too, is what's happening.
但实际上，就是这样。

389
00:19:03,290 --> 00:19:06,190
So the preprocessor step, step 1 of 4, just
因此，预处理步骤，4 个步骤中的第 1 步，仅仅

390
00:19:06,190 --> 00:19:08,097
does that find and replace, if you will.
进行查找和替换，如果你愿意。

391
00:19:08,097 --> 00:19:10,430
Now there's some-- again, some other stuff in that file,
现在这个文件中有一些其他的内容，

392
00:19:10,430 --> 00:19:12,580
and this, too, is kind of a white lie. printf
这也算是一个善意的谎言。printf

393
00:19:12,580 --> 00:19:15,790
probably has its own file because that's a really big library,
可能拥有自己的文件，因为这是一个非常大的库，

394
00:19:15,790 --> 00:19:17,930
but the essence of it is exactly this.
但它的本质正是如此。

395
00:19:17,930 --> 00:19:21,010
So preprocessing converts all of those hash
所以预处理将所有这些哈希

396
00:19:21,010 --> 00:19:24,520
include lines to whatever the underlying prototypes are
include 行转换为底层的原型

397
00:19:24,520 --> 00:19:26,650
within the file plus some other stuff.
在文件中，以及一些其他内容。

398
00:19:26,650 --> 00:19:29,920
Now compiling we use it as this catch-all phrase, but it turns out,
现在我们用编译这个万能短语，但事实证明，

399
00:19:29,920 --> 00:19:32,100
it has a very specific meaning that's worth
它有非常具体的含义，值得

400
00:19:32,100 --> 00:19:33,850
knowing about even though after today, you
了解，即使在今天之后，你

401
00:19:33,850 --> 00:19:37,120
can go back to using compiling as the sort of catch-all phrase.
可以继续使用编译作为万能短语。

402
00:19:37,120 --> 00:19:41,390
So when you've got this same code here after the pre-processing step
所以当你拥有这段代码，在预处理步骤之后

403
00:19:41,390 --> 00:19:42,420
has happened.
已经完成。

404
00:19:42,420 --> 00:19:44,900
So this is essentially happening in the computer's memory.
所以这本质上是在计算机内存中发生的。

405
00:19:44,900 --> 00:19:49,400
It's not changing your hello.c file permanently or anything like that.
它不会永久地改变你的 hello.c 文件，或进行任何类似的操作。

406
00:19:49,400 --> 00:19:54,890
This code gets, quote-unquote, "compiled" into something
这段代码被“编译”成了

407
00:19:54,890 --> 00:19:57,120
that looks more like this.
更像这样的东西。

408
00:19:57,120 --> 00:19:59,660
And this is a scarier language that we won't spend time
这是一门更可怕的语言，我们不会在这门课上花时间

409
00:19:59,660 --> 00:20:00,860
on in this particular class.
学习它。

410
00:20:00,860 --> 00:20:02,690
This is what's known as assembly language.
这就是所谓的汇编语言。

411
00:20:02,690 --> 00:20:06,710
And back in the day, before there was C, humans
在 C 语言出现之前，人们

412
00:20:06,710 --> 00:20:09,110
wrote this to program their computers.
用它来为他们的计算机编写程序。

413
00:20:09,110 --> 00:20:12,440
Similarly, before there was assembly code back in the day,
同样，在汇编代码出现之前，

414
00:20:12,440 --> 00:20:15,163
humans very initially used what instead?
人们最初使用什么？

415
00:20:15,163 --> 00:20:16,080
AUDIENCE: 0's and 1's.
观众：0 和 1。

416
00:20:16,080 --> 00:20:19,430
DAVID MALAN: So 0's and 1's-- like they actually wrote the machine code
大卫·马兰：所以 0 和 1 - 就像他们实际上编写了机器代码

417
00:20:19,430 --> 00:20:23,360
painfully, be it in code or be it in punch cards like physical objects
非常痛苦，无论是代码还是像物理对象一样的穿孔卡片

418
00:20:23,360 --> 00:20:24,000
or the like.
等等。

419
00:20:24,000 --> 00:20:25,730
So again, these are sort of abstractions,
所以，这些都是抽象的东西，

420
00:20:25,730 --> 00:20:27,660
but we're rewinding for today in time.
但我们今天要回到过去。

421
00:20:27,660 --> 00:20:30,860
But what this compiler for C is doing is converting C
但 C 语言的编译器所做的就是将 C 语言

422
00:20:30,860 --> 00:20:33,380
into this other language called assembly language.
转换为另一种语言，叫做汇编语言。

423
00:20:33,380 --> 00:20:35,630
And even though this looks very esoteric,
虽然它看起来非常深奥，

424
00:20:35,630 --> 00:20:37,940
there's at least some juicy things in here.
但这里至少有一些有趣的东西。

425
00:20:37,940 --> 00:20:40,580
If I highlight get_string, it's mentioned in this code.
如果我高亮显示 get_string，它在这段代码中被提及。

426
00:20:40,580 --> 00:20:42,560
printf is mentioned in this code.
printf 在这段代码中被提及。

427
00:20:42,560 --> 00:20:44,540
And even some of these keywords here that
甚至这里的一些关键字

428
00:20:44,540 --> 00:20:48,320
are spelled a bit weirdly, this relates to subtracting and moving
拼写有点奇怪，这与减法和移动相关

429
00:20:48,320 --> 00:20:51,480
something in memory and calling a function, calling a function.
内存中的某些内容，以及调用函数、调用函数。

430
00:20:51,480 --> 00:20:53,450
So there's some semantics that are probably
所以有一些语义可能

431
00:20:53,450 --> 00:20:56,690
somewhat familiar even though this is not code we ourselves will write.
有些熟悉，即使这不是我们自己会写的代码。

432
00:20:56,690 --> 00:20:59,670
But unfortunately, this is not yet machine code,
但不幸的是，这还不是机器代码，

433
00:20:59,670 --> 00:21:02,370
and that's where step 3 comes in.
这就是第 3 步的用武之地。

434
00:21:02,370 --> 00:21:06,470
So step 3 of this four-step process is technically called assembling.
因此，这个四步过程中的第 3 步在技术上被称为汇编。

435
00:21:06,470 --> 00:21:12,320
And assembling just takes that assembly code and converts it, thankfully,
汇编只是将汇编代码转换成，谢天谢地，

436
00:21:12,320 --> 00:21:15,650
to the thing we do care about, the 0's and 1's.
我们真正关心的东西，0 和 1。

437
00:21:15,650 --> 00:21:18,830
So assembling takes assembly code converts it to 0's and 1's.
所以汇编将汇编代码转换为 0 和 1。

438
00:21:18,830 --> 00:21:21,020
As an aside, and I alluded to this earlier,
顺便说一下，我之前提过，

439
00:21:21,020 --> 00:21:26,810
the reason that Clang names its files a.out by default, assembler output,
Clang 将其文件默认命名为 a.out 的原因是，汇编器输出，

440
00:21:26,810 --> 00:21:30,740
is a side effect of that being one of the steps in this process,
是这个过程中的一个步骤的副作用，

441
00:21:30,740 --> 00:21:33,740
dealing with assembly language and its subsequent output.
处理汇编语言及其后续输出。

442
00:21:33,740 --> 00:21:36,680
All right, so here are some 0's and 1's, but unfortunately, there's
好的，所以这里有一些 0 和 1，但不幸的是，还有

443
00:21:36,680 --> 00:21:41,340
still that fourth and final step, which is a word that I also used earlier,
第四步也是最后一步，我之前也用过这个词，

444
00:21:41,340 --> 00:21:42,620
namely linking.
就是链接。

445
00:21:42,620 --> 00:21:45,420
So let me take a step back and look at this code here.
所以让我退一步，看看这里的代码。

446
00:21:45,420 --> 00:21:50,090
And even though this code is exactly as I wrote in VS Code in hello.c--
即使这段代码与我在 VS Code 中 hello.c 中编写的完全一样 -

447
00:21:50,090 --> 00:21:52,310
so no copying and pasting, no prototypes have
所以没有复制粘贴，没有原型

448
00:21:52,310 --> 00:21:55,610
been plugged in here, this is my code, technically, there's
被插入到这里，这是我的代码，从技术上来说，有

449
00:21:55,610 --> 00:21:59,270
three different files involved in compiling even something relatively
三个不同的文件参与编译，即使是像这样相对简单的东西

450
00:21:59,270 --> 00:22:00,170
simple like this.
简单的东西。

451
00:22:00,170 --> 00:22:03,560
There's obviously this thing itself, hello.c, which I wrote.
很明显，这个东西本身，hello.c，是我写的。

452
00:22:03,560 --> 00:22:08,600
There's apparently cs50.h, and there's apparently stdio.h.
很明显，cs50.h 和 stdio.h 也存在。

453
00:22:08,600 --> 00:22:12,650
But technically-- and you don't have to know this file name, per se, somewhere
但从技术上来说——你不需要知道这个文件名，在某处

454
00:22:12,650 --> 00:22:15,540
else on the computer's hard drive, so to speak,
在计算机的硬盘驱动器上，可以这么说，

455
00:22:15,540 --> 00:22:19,520
is a cs50.c file, which actually contains
有一个 cs50.c 文件，它实际上包含

456
00:22:19,520 --> 00:22:22,910
the staff's implementation of get_string and get_int and get_float
工作人员对 get_string、get_int 和 get_float 的实现

457
00:22:22,910 --> 00:22:24,320
and all of those other functions.
以及所有其他函数。

458
00:22:24,320 --> 00:22:28,460
Somewhere on the server's hard drive is stdio.c
服务器的硬盘驱动器上还有 stdio.c

459
00:22:28,460 --> 00:22:31,890
that implements printf and all of these other functions as well.
它实现了 printf 和所有其他函数。

460
00:22:31,890 --> 00:22:34,940
So the dot c is just inferred from the dot h here.
所以 .c 文件名是从这里的 .h 文件名推断出来的。

461
00:22:34,940 --> 00:22:38,450
You don't ever mention the dot c file, but someone else wrote those files,
你永远不会提到 .c 文件，但其他人写了这些文件，

462
00:22:38,450 --> 00:22:41,570
someone else stored them in the server for you--
其他人将它们存储在服务器上，供你使用 -

463
00:22:41,570 --> 00:22:43,220
CS50 staff in this case.
在这种情况下，是 CS50 工作人员。

464
00:22:43,220 --> 00:22:47,270
So technically, even when compiling a relatively short program like this,
所以从技术上来说，即使编译像这样的短程序，

465
00:22:47,270 --> 00:22:51,920
you're really combining three files at least at the end of the day.
实际上你至少组合了三个文件。

466
00:22:51,920 --> 00:22:54,020
And I'll write them from left to right. hello.c,
我会从左到右写它们。hello.c，

467
00:22:54,020 --> 00:23:01,920
which I wrote, cs50.c, which the staff wrote, and then stdio.c as well.
是我写的，cs50.c 是工作人员写的，还有 stdio.c。

468
00:23:01,920 --> 00:23:04,010
So somewhere there's these three files.
所以这些三个文件存在于某个地方。

469
00:23:04,010 --> 00:23:08,540
And Clang, our compiler, needs to compile each of these
而 Clang，我们的编译器，需要将这些文件中的每一个

470
00:23:08,540 --> 00:23:12,500
into the corresponding 0's and 1's.
编译成相应的 0 和 1。

471
00:23:12,500 --> 00:23:17,300
Lastly, this is not yet sufficient because these 0's and 1's haven't
最后，这还不够，因为这些0和1还没有

472
00:23:17,300 --> 00:23:18,333
been linked together.
被链接在一起。

473
00:23:18,333 --> 00:23:20,750
I mean, I deliberately left a gap here to imply that these
我的意思是，我故意在这里留了一个空隙，暗示这些

474
00:23:20,750 --> 00:23:22,880
are three separately-compiled files.
是三个独立编译的文件。

475
00:23:22,880 --> 00:23:25,760
So that fourth and final step called linking
所以第四步也是最后一步，叫做链接，

476
00:23:25,760 --> 00:23:28,430
takes all of these 0's and 1's and an intelligent way
它会以一种智能的方式将所有这些0和1

477
00:23:28,430 --> 00:23:35,300
combines them into just one final file named hello, named a.out,
组合成一个名为hello的最终文件，或者名为a.out，

478
00:23:35,300 --> 00:23:37,680
whatever the file name is of choice.
无论你选择什么文件名。

479
00:23:37,680 --> 00:23:40,820
So what you and I for the past week have just been calling compiling--
所以，过去一周你我一直在称之为编译——

480
00:23:40,820 --> 00:23:43,550
and that's what a normal person will use henceforth
而这也是普通人从今以后会用来

481
00:23:43,550 --> 00:23:46,490
to describe this whole process, technically, there's
描述整个过程的术语，从技术上讲，

482
00:23:46,490 --> 00:23:49,250
these four different steps underneath the hood, each of which
这四个不同的步骤隐藏在幕后，每一个步骤

483
00:23:49,250 --> 00:23:55,067
is sort of a representative of an evolution of technology over the years.
在某种程度上代表着多年来技术的演变。

484
00:23:55,067 --> 00:23:56,900
And nowadays, if we fast forward a few weeks
而如今，如果我们快进几周

485
00:23:56,900 --> 00:23:59,780
in class, when we start talking about Python, which
在课堂上，当我们开始谈论Python，它

486
00:23:59,780 --> 00:24:03,710
is another more modern language, that, too, is going to be conceptually even
是另一种更现代的语言，它在概念上也将更加

487
00:24:03,710 --> 00:24:06,090
higher level, even though underneath the hood,
高级，即使在幕后，

488
00:24:06,090 --> 00:24:09,330
there's going to be some lower-level principles at work.
将会有一些底层原理在起作用。

489
00:24:09,330 --> 00:24:16,010
So any questions on just terminology or these processes known as compiling?
那么，关于术语或这些被称为编译的过程，有什么问题吗？

490
00:24:16,010 --> 00:24:17,462
Yeah?
有吗？

491
00:24:17,462 --> 00:24:19,879
AUDIENCE: I didn't really understand what compiling means.
观众：我不太理解编译是什么意思。

492
00:24:19,879 --> 00:24:21,360
[INAUDIBLE]
[听不清]

493
00:24:21,360 --> 00:24:22,110
DAVID MALAN: Sure.
大卫·马兰：当然。

494
00:24:22,110 --> 00:24:29,400
Compiling, if I rewind, is the process of taking your source code, which
编译，如果我倒带一下，就是将你的源代码（它

495
00:24:29,400 --> 00:24:35,260
looks like this, recall-- whoops, this, and converting it into assembly code.
看起来像这样，你还记得吗？——哎呦，这个，然后将其转换为汇编代码。）

496
00:24:35,260 --> 00:24:38,640
So preprocessing just converts all of those hash
所以预处理只是将所有这些hash

497
00:24:38,640 --> 00:24:41,470
include lines and a few others to their equivalents.
include行和其他一些行转换为它们的等价物。

498
00:24:41,470 --> 00:24:42,210
So that's step 1.
所以这是第一步。

499
00:24:42,210 --> 00:24:46,920
Compiling converts the C code into the underlying assembly code.
编译将C代码转换为底层的汇编代码。

500
00:24:46,920 --> 00:24:51,750
The assembling step, step 3, converts the assembly code to 0's and 1's.
汇编步骤，第三步，将汇编代码转换为0和1。

501
00:24:51,750 --> 00:24:54,480
And then the fourth step, linking, combines
然后第四步，链接，将

502
00:24:54,480 --> 00:24:57,960
all of the 0's and 1's from the one, the two, the three or more files
来自一个、两个、三个或更多文件的所有0和1

503
00:24:57,960 --> 00:25:00,510
that are involved in your project and links them
参与到你的项目中，并将它们

504
00:25:00,510 --> 00:25:02,310
all together for you magically.
全部神奇地连接起来。

505
00:25:02,310 --> 00:25:06,060
But at the end of the day, all of this is happening automatically for you.
但归根结底，所有这些都是自动为你完成的。

506
00:25:06,060 --> 00:25:10,530
If I jump now to the end here, whereby just by running
如果我现在跳到最后，只需要运行

507
00:25:10,530 --> 00:25:14,310
make, which, in turn, runs clang for you, like all of this
make，它反过来会为你运行clang，就像所有这一切

508
00:25:14,310 --> 00:25:15,900
is abstracted away.
都被抽象掉了。

509
00:25:15,900 --> 00:25:19,620
But the key here is that even with these commands that we've been running,
但关键是，即使我们一直在运行这些命令，

510
00:25:19,620 --> 00:25:22,510
be it the make command or the clang command,
无论是make命令还是clang命令，

511
00:25:22,510 --> 00:25:28,570
everything should be explainable what you are typing at the prompt
你输入到提示符上的内容都应该是可以解释的

512
00:25:28,570 --> 00:25:29,410
ultimately.
最终。

513
00:25:29,410 --> 00:25:31,300
Each of those things has a purpose.
每一件事都有它的目的。

514
00:25:31,300 --> 00:25:33,850
So any questions, then, on what we've just
那么，关于我们刚刚

515
00:25:33,850 --> 00:25:38,018
now called compiling even though it's only when you take another CS
现在称为编译的东西，即使只有当你学习另一门计算机科学课程的时候，

516
00:25:38,018 --> 00:25:40,060
course that you might spend more time on assembly
你才会花更多时间在汇编

517
00:25:40,060 --> 00:25:42,940
language or these lower-level details?
语言或这些底层细节上？

518
00:25:42,940 --> 00:25:43,480
Yeah?
有吗？

519
00:25:43,480 --> 00:25:47,264
AUDIENCE: [INAUDIBLE]
观众：[听不清]

520
00:25:49,092 --> 00:25:50,300
DAVID MALAN: A good question.
大卫·马兰：问得好。

521
00:25:50,300 --> 00:25:51,740
Are there other types of compilers?
还有其他类型的编译器吗？

522
00:25:51,740 --> 00:25:52,240
Yes.
是的。

523
00:25:52,240 --> 00:25:57,320
Back when I took CS50, I used a popular compiler called GCC, the GNU Compiler
当我学习CS50的时候，我用过一个流行的编译器叫做GCC，即GNU编译器

524
00:25:57,320 --> 00:26:00,650
Collection, which still exists actually in the code space
集合，它实际上仍然存在于你用来学习CS50的代码空间中。

525
00:26:00,650 --> 00:26:02,120
that you're using for CS50.
你用来学习CS50的代码空间中。

526
00:26:02,120 --> 00:26:04,110
Clang is somewhat more recent.
Clang稍微晚一些。

527
00:26:04,110 --> 00:26:05,153
It's gaining popularity.
它正在越来越受欢迎。

528
00:26:05,153 --> 00:26:07,820
And frankly, we use it in large part because it's error messages
坦白地说，我们使用它的很大一部分原因是它的错误消息

529
00:26:07,820 --> 00:26:09,320
are slightly more user-friendly.
稍微更人性化一些。

530
00:26:09,320 --> 00:26:12,570
You might not believe us because if you encountered some errors with your code
你可能不信，因为如果你在过去一周遇到了代码错误，

531
00:26:12,570 --> 00:26:16,370
this past week, they were probably just as arcane as the error messages I saw,
它们可能和我在过去看到过的错误消息一样难懂，

532
00:26:16,370 --> 00:26:18,598
but it's better than it was some years ago.
但比几年前好多了。

533
00:26:18,598 --> 00:26:20,390
And there's alternatives to compiling, too,
还有编译的替代方案，

534
00:26:20,390 --> 00:26:24,100
but more on that when we get to Python as well.
但我们会在学习Python的时候详细介绍。

535
00:26:24,100 --> 00:26:26,080
Other questions?
还有其他问题吗？

536
00:26:26,080 --> 00:26:26,580
No?
没有吗？

537
00:26:26,580 --> 00:26:27,080
All right.
好的。

538
00:26:27,080 --> 00:26:31,020
Well, what are the implications of the fact that we're going from source code
那么，我们从源代码转换到机器码，这有什么影响呢？

539
00:26:31,020 --> 00:26:32,190
to machine code?
转换到机器码？

540
00:26:32,190 --> 00:26:35,010
Well, it stands to reason that if you can compile code,
那么，如果你可以编译代码，

541
00:26:35,010 --> 00:26:38,970
maybe you can decompile it-- that is, go in the reverse direction.
也许你可以反编译它——也就是说，反向操作。

542
00:26:38,970 --> 00:26:42,010
Go from 0's and 1's to actual source code.
从0和1转换为实际的源代码。

543
00:26:42,010 --> 00:26:45,477
Now that would be handy if you want to go in as a programmer and change
如果你想作为一名程序员进入程序内部并修改

544
00:26:45,477 --> 00:26:48,060
something in a program that you or someone else already wrote.
你或其他人已经写好的程序中的某些东西，这会很方便。

545
00:26:48,060 --> 00:26:51,330
It's maybe not ideal for your intellectual property,
但如果你最初是编写该程序的人，这对你自己的知识产权来说可能不太理想。

546
00:26:51,330 --> 00:26:54,780
though, if you are the person who wrote that program in the first place.
但如果你最初是编写该程序的人，这对你自己的知识产权来说可能不太理想。

547
00:26:54,780 --> 00:26:57,810
If you are Microsoft and you wrote Microsoft Word or Excel
如果你就是微软，是你编写了Microsoft Word或Excel，

548
00:26:57,810 --> 00:27:01,290
that people with Macs and PCs and phones have installed on their devices,
这些程序被安装在使用Mac、PC和手机的人们的设备上，

549
00:27:01,290 --> 00:27:04,440
it doesn't actually sound very appealing if any old customer
如果任何一个老顾客

550
00:27:04,440 --> 00:27:08,830
can take those 0's and 1's and reverse them, reverse engineer them,
可以获取这些0和1并反转它们，对其进行逆向工程，

551
00:27:08,830 --> 00:27:11,157
so to speak, into the original source code
也可以说，反编译成最初的源代码，

552
00:27:11,157 --> 00:27:13,740
because then they can have their own version of Microsoft Word
因为那样他们就可以拥有自己版本的Microsoft Word，

553
00:27:13,740 --> 00:27:17,100
and make changes to it without really having put in all of the R&D
并且可以对其进行修改，而无需投入所有用于构建最初版本的研发

554
00:27:17,100 --> 00:27:19,980
that it might have taken to build the first version thereof.
投入所有用于构建最初版本的研发工作。

555
00:27:19,980 --> 00:27:22,720
But it turns out that reverse engineering--
但事实证明逆向工程——

556
00:27:22,720 --> 00:27:26,050
so doing things in the opposite direction-- is easier
也就是反向操作——说起来容易做起来难，因为正如你所见，

557
00:27:26,050 --> 00:27:29,740
said than done because there are multiple ways, as you've seen already,
说起来容易做起来难，因为正如你所见，

558
00:27:29,740 --> 00:27:31,300
to implement programs.
有很多方法可以实现程序。

559
00:27:31,300 --> 00:27:35,440
Like loops alone, you can use for loops, while loops, even do-while loops.
比如循环，你可以使用for循环、while循环，甚至do-while循环。

560
00:27:35,440 --> 00:27:37,540
And so there's other ways-- there's multiple ways
所以还有其他方法——有很多方法

561
00:27:37,540 --> 00:27:38,960
to solve the same problem.
来解决同一个问题。

562
00:27:38,960 --> 00:27:41,590
So even if you try to reverse engineer a program
所以即使你试图反编译一个程序

563
00:27:41,590 --> 00:27:44,440
and convert machine code back to source code,
并将机器码转换回源代码，

564
00:27:44,440 --> 00:27:48,170
there's not necessarily going to be an obvious way to do so.
也不一定会有明显的方法可以做到。

565
00:27:48,170 --> 00:27:50,620
And the reality is, that it ends up being such a mess
而现实是，它最终会变得非常混乱，

566
00:27:50,620 --> 00:27:53,350
because you lose the variable names typically,
因为你通常会丢失变量名，

567
00:27:53,350 --> 00:27:57,070
you lose the function names typically, that what you end up looking at
你通常会丢失函数名，最终你会看到的东西

568
00:27:57,070 --> 00:28:01,300
might very well be C code, but it's completely difficult for you,
很可能就是 C 代码，但对你来说，

569
00:28:01,300 --> 00:28:03,040
even a good programmer, to read.
即使是优秀的程序员，也很难阅读。

570
00:28:03,040 --> 00:28:06,520
And generally, the mindset is, if you're really good enough
通常情况下，心态是，如果你足够优秀

571
00:28:06,520 --> 00:28:09,782
to decompile code in that way and read it subsequently
以这种方式反编译代码并随后阅读它

572
00:28:09,782 --> 00:28:11,740
even without good variable names, good function
即使没有好的变量名，好的函数

573
00:28:11,740 --> 00:28:14,950
names, good documentation and the like, could probably have just implemented
名，好的文档等等，可能你一开始就能够自己实现

574
00:28:14,950 --> 00:28:18,340
the program in the first place yourself without jumping through those hoops.
程序，而无需经历这些麻烦。

575
00:28:18,340 --> 00:28:20,440
So there's some practicality pushing back
所以有一些实用性在回击

576
00:28:20,440 --> 00:28:25,420
on what are otherwise potential threats to, say, your intellectual property.
对其他潜在的威胁，比如你的知识产权。

577
00:28:25,420 --> 00:28:28,150
But that's not going to be the case later on in the term when
但本学期后期情况并非如此，当

578
00:28:28,150 --> 00:28:31,270
we do get to languages like Python to some extent, other languages
我们确实接触到像 Python 这样的语言，在某种程度上，其他语言

579
00:28:31,270 --> 00:28:32,200
like JavaScript.
像 JavaScript 那样。

580
00:28:32,200 --> 00:28:34,870
Some of those are actually going to be readable by anyone.
其中一些实际上可以被任何人阅读。

581
00:28:34,870 --> 00:28:36,790
Any of your customers, any of your friends,
你的任何客户，你的任何朋友，

582
00:28:36,790 --> 00:28:39,950
and your family that actually use your programs.
以及使用你的程序的家人。

583
00:28:39,950 --> 00:28:43,540
So with that said, let's introduce now another tool to our toolkit
因此，现在让我们向工具包中引入另一个工具

584
00:28:43,540 --> 00:28:45,580
that will hopefully make some of the pain
希望这能够减轻一些痛苦

585
00:28:45,580 --> 00:28:47,470
from this past week when you did encounter
来自上周，当你遇到

586
00:28:47,470 --> 00:28:49,210
bugs a little more manageable.
bug 时，会更容易管理一些。

587
00:28:49,210 --> 00:28:52,330
And indeed, part of the process of writing code to this day
事实上，编写代码的过程的一部分直到今天

588
00:28:52,330 --> 00:28:53,680
is debugging it.
就是调试它。

589
00:28:53,680 --> 00:28:56,560
And it is a rare thing to write a program,
编写一个程序是件很罕见的事情，

590
00:28:56,560 --> 00:29:01,450
be it in C or any other language, and get it 100% right the first time.
无论是用 C 语言还是其他任何语言，第一次就能做到 100% 正确。

591
00:29:01,450 --> 00:29:05,360
I mean, to this day, I still, 20-plus years later, still write buggy code.
我的意思是，直到今天，我仍然，二十多年后，仍然会写出有 bug 的代码。

592
00:29:05,360 --> 00:29:08,695
Hopefully a little bit less of it, but any time you're adding a new feature,
希望 bug 少一些，但是无论什么时候你添加一个新功能，

593
00:29:08,695 --> 00:29:10,820
any time you're doing something for the first time,
无论什么时候你第一次做某件事，

594
00:29:10,820 --> 00:29:14,380
you're not necessarily going to see all of the possible mistakes.
你并不一定会看到所有可能的错误。

595
00:29:14,380 --> 00:29:18,910
So even in industry, bugs are omnipresent, which is really to say,
因此，即使在工业界，bug 无处不在，也就是说，

596
00:29:18,910 --> 00:29:22,360
having techniques to debug code-- that is, eliminate bugs,
拥有调试代码的技术，也就是说，消除 bug，

597
00:29:22,360 --> 00:29:23,740
is super compelling.
非常有说服力。

598
00:29:23,740 --> 00:29:26,920
Now just for a bit of history, here is Admiral Grace Hopper,
现在，让我们了解一点历史，这位是 Grace Hopper 海军上将，

599
00:29:26,920 --> 00:29:30,230
who was actually in not only the military,
她不仅在军队服役，

600
00:29:30,230 --> 00:29:33,070
but also on the faculty of Harvard years ago
而且很多年前也在哈佛大学任教

601
00:29:33,070 --> 00:29:35,860
and worked on a Harvard computer called the Harvard Mark
并参与开发了名为哈佛 Mark 的哈佛大学计算机

602
00:29:35,860 --> 00:29:39,250
I, which is actually on display at the School of Engineering and Applied
I，它现在实际上在工程与应用学院展出

603
00:29:39,250 --> 00:29:41,260
Sciences if you take a tour over there sometime.
科学学院，如果你有时间去参观一下。

604
00:29:41,260 --> 00:29:44,230
But also when working on the Harvard Mark II,
但她在开发哈佛 Mark II 的过程中，

605
00:29:44,230 --> 00:29:50,170
she is known for having at least popularized the phrase "bug" to mean
她以至少推广了“bug”一词来表示而闻名

606
00:29:50,170 --> 00:29:53,350
a mistake in a computer's program--
计算机程序中的错误——

607
00:29:53,350 --> 00:29:55,240
a mistake in a computer's code.
计算机代码中的错误。

608
00:29:55,240 --> 00:29:58,510
And the etymology of this supposedly is this here logbook
而这个词的词源据说是这份航海日志

609
00:29:58,510 --> 00:30:02,320
wherein she and her colleagues were documenting processes being computed
她和她同事记录了正在计算机上计算的过程

610
00:30:02,320 --> 00:30:04,960
on computers, that a moth actually got stuck
在计算机上，一只飞蛾卡住了

611
00:30:04,960 --> 00:30:09,250
in one of the relays, one of the mechanical-- the electric relays inside
在一个继电器中，一个机械——电继电器在

612
00:30:09,250 --> 00:30:13,450
of the very old now computer, and someone very cleverly
现在非常古老的计算机中，然后某人非常聪明地

613
00:30:13,450 --> 00:30:16,657
wrote, "First actual case of bug being found."
写下了：“第一个发现 bug 的真实案例”。

614
00:30:16,657 --> 00:30:18,490
So it wasn't she who actually discovered it,
所以发现它的人不是她，

615
00:30:18,490 --> 00:30:22,450
but this was a story she was thereafter fond of telling as a famed computer
但她后来很喜欢讲述这个故事，作为著名的计算机

616
00:30:22,450 --> 00:30:23,860
scientist thereafter.
科学家。

617
00:30:23,860 --> 00:30:28,210
We now know bugs to be all too familiar when it comes to writing our own code,
我们现在知道，当编写自己的代码时，bug 实在是太熟悉了，

618
00:30:28,210 --> 00:30:31,060
and I thought I would deliberately write some buggy code based
我想我会故意写一些有 bug 的代码，这些代码基于

619
00:30:31,060 --> 00:30:34,400
on some of the programs with which we experimented last week.
我们上周实验的一些程序。

620
00:30:34,400 --> 00:30:37,270
So let me go back over to VS Code here and let
所以，让我回到 VS Code，并让

621
00:30:37,270 --> 00:30:44,290
me propose that I do something somewhat simplistic just like this to print out
我提议我做一些简单的事情，就像这样，打印出

622
00:30:44,290 --> 00:30:47,140
a column of bricks of height 3.
一列高度为 3 的砖块。

623
00:30:47,140 --> 00:30:50,440
So I'm going into VS Code and I'm going to deliberately call this program
所以我要进入 VS Code，并且故意将这个程序命名为

624
00:30:50,440 --> 00:30:53,230
buggy.c because I intend to do this poorly.
buggy.c，因为我打算把它写得不好。

625
00:30:53,230 --> 00:30:58,760
I'm going to include stdio.h as before, int main void as before.
我将像以前一样包含 stdio.h，像以前一样包含 int main void。

626
00:30:58,760 --> 00:31:01,630
And in here, if I want to print a pyramid of height 3,
这里，如果我想打印一个高度为 3 的金字塔，

627
00:31:01,630 --> 00:31:04,720
I'm going to do 4 int i gets--
我要做 4 个 int i 获取——

628
00:31:04,720 --> 00:31:06,910
all right, I'm still new to programming in my mind
好吧，我仍然是一个新手，在我的脑海中

629
00:31:06,910 --> 00:31:09,820
here, so I know I'm supposed to start counting at 0, OK.
这里，我知道我应该从 0 开始计数，好的。

630
00:31:09,820 --> 00:31:13,480
And I want to do this until I count up to 3, so I'm going to do that.
我想一直这样做，直到我计数到 3，所以我将这样做。

631
00:31:13,480 --> 00:31:16,700
And then i++ I remember from class in this way.
然后是 i++，我从课堂上记得是这样的。

632
00:31:16,700 --> 00:31:20,500
And now I might go ahead and print out just a hash mark, backslash n,
现在我可以继续打印一个井号，一个反斜杠 n，

633
00:31:20,500 --> 00:31:23,710
which I do want because I want to move this cursor to the next line
因为我想要这样做，因为我想要将光标移动到下一行

634
00:31:23,710 --> 00:31:24,790
to make this vertical.
让它变成垂直的。

635
00:31:24,790 --> 00:31:29,730
But of course, if you've noticed with your eye already, when I do make buggy,
但是当然，如果你已经用眼睛注意到，当我执行 buggy 时，

636
00:31:29,730 --> 00:31:30,960
it compiles OK.
它编译正常。

637
00:31:30,960 --> 00:31:33,640
So no typos, no syntactical errors.
所以没有错别字，没有语法错误。

638
00:31:33,640 --> 00:31:37,620
But when I run this, I'm going to see how many bricks.
但是当我运行它时，我会看到有多少块砖。

639
00:31:37,620 --> 00:31:39,510
So four in this case.
在这种情况下是四块。

640
00:31:39,510 --> 00:31:41,650
Now this is meant to be a simplistic example
现在，这是一个简化的例子

641
00:31:41,650 --> 00:31:44,910
so that we don't spend time trying to figure out what the bug is, but rather,
这样我们就不必花费时间来弄清楚 bug 是什么，而是，

642
00:31:44,910 --> 00:31:48,210
focus on techniques for actually identifying the bug.
专注于识别 bug 的技术。

643
00:31:48,210 --> 00:31:50,010
So-- finding, rather, the bug.
所以—— 找到，而是 bug。

644
00:31:50,010 --> 00:31:52,170
So what's one of the first tools in your toolkit?
那么，工具包中的第一个工具是什么？

645
00:31:52,170 --> 00:31:55,470
Literally one you have already. printf is your friend.
实际上你已经有了。printf 是你的朋友。

646
00:31:55,470 --> 00:31:59,730
And it is a very quick and dirty tool for just seeing
它是一个非常快速而粗糙的工具，用来查看

647
00:31:59,730 --> 00:32:02,520
what's going on inside of the computer when
当你在计算机内部发生了什么，

648
00:32:02,520 --> 00:32:06,550
you don't have more sophisticated tools or even the time to use them.
你没有更复杂的工具，甚至没有时间使用它们。

649
00:32:06,550 --> 00:32:09,750
And so in this case, for instance, what I'd propose is that--
因此，在这种情况下，例如，我建议——

650
00:32:09,750 --> 00:32:11,610
all right, I'm obviously seeing four hashes.
好吧，我显然看到四个井号。

651
00:32:11,610 --> 00:32:13,710
And let me play a little slow here.
让我在这里慢一点。

652
00:32:13,710 --> 00:32:18,090
It'd be helpful for me to understand why logically I'm ending up with four, even
对我来说，了解为什么在逻辑上我最终得到四个会很有帮助，即使

653
00:32:18,090 --> 00:32:21,360
though I'm starting at 0 like I remember from class and I'm going up to 3
虽然我从 0 开始，就像我从课堂上记得的那样，我正在向上计数到 3

654
00:32:21,360 --> 00:32:25,870
as we did in class, like I'm just not seeing it in this particular story.
就像我们在课堂上做的那样，我在这里并没有看到这个故事。

655
00:32:25,870 --> 00:32:30,180
So what I would commonly do is go into my code and just help me see
因此，我通常会进入我的代码，并帮助我看到

656
00:32:30,180 --> 00:32:35,400
what's going on, and I might literally write a printf line like, i is %i,
发生了什么，我可能会直接写一行 printf 代码，比如， i 是 %i，

657
00:32:35,400 --> 00:32:39,490
backslash n, comma, and then just print out the value of i.
反斜杠 n，逗号，然后直接打印 i 的值。

658
00:32:39,490 --> 00:32:41,620
I just want to see on every iteration, what
我只想看看每次迭代，

659
00:32:41,620 --> 00:32:45,530
is i, what is i, what is i just to help me see what the computer already knows.
i 是什么，i 是什么，i 是什么，只是为了让我看看计算机已经知道什么。

660
00:32:45,530 --> 00:32:49,900
So let me go ahead and recompile buggy, let me rerun buggy,
所以让我继续重新编译 buggy，让我重新运行 buggy，

661
00:32:49,900 --> 00:32:51,910
and then let me make my terminal window bigger
然后让我把我的终端窗口放大

662
00:32:51,910 --> 00:32:53,410
just to make clear what's going on.
只是为了让大家清楚发生了什么。

663
00:32:53,410 --> 00:32:56,080
And now it's a little more pedantic.
现在有点过分了。

664
00:32:56,080 --> 00:33:01,150
Now i is 0, I get a hash. i is 1, I get a hash. i is 2, I get a hash.
现在 i 是 0，我得到一个井号。i 是 1，我得到一个井号。i 是 2，我得到一个井号。

665
00:33:01,150 --> 00:33:04,310
Wait a minute. i is 3, I get a hash.
等一下。i 是 3，我得到一个井号。

666
00:33:04,310 --> 00:33:07,250
So clearly now, it should be maybe more obvious to you,
所以现在很明显，也许对你来说更明显，

667
00:33:07,250 --> 00:33:09,430
especially if the syntax itself is unfamiliar,
尤其是如果语法本身不熟悉，

668
00:33:09,430 --> 00:33:11,680
I certainly don't want this last one printing,
我当然不想打印最后一个，

669
00:33:11,680 --> 00:33:14,810
or maybe equivalently, I don't want the first one printing.
或者等价地说，我不想打印第一个。

670
00:33:14,810 --> 00:33:17,830
So I can fix this in a couple of ways, but the solution,
我可以通过几种方法来解决这个问题，但是解决方案，

671
00:33:17,830 --> 00:33:22,810
the most canonical solution is probably to do what with my code?
最规范的解决方案可能是用我的代码做什么？

672
00:33:22,810 --> 00:33:24,430
To change to what to what?
改变什么？

673
00:33:24,430 --> 00:33:25,402
Yeah?
是吧？

674
00:33:25,402 --> 00:33:26,590
AUDIENCE: [INAUDIBLE]
观众：[听不清]

675
00:33:26,590 --> 00:33:27,340
DAVID MALAN: Yeah.
大卫·马兰：是。

676
00:33:27,340 --> 00:33:31,000
So change the less than or equal sign to just a less than sign.
所以把小于等于号改成小于号。

677
00:33:31,000 --> 00:33:36,580
So even though this is like counting from 0 to 3 instead of 1 through 3,
所以尽管这看起来像是从 0 到 3 而不是从 1 到 3 计数，

678
00:33:36,580 --> 00:33:39,890
it's the more typical programmatic way to write code like this.
但这是更典型的程序化编写这种代码的方式。

679
00:33:39,890 --> 00:33:43,600
And now, of course, if I do make buggy--
现在，当然，如果我做了 buggy--

680
00:33:43,600 --> 00:33:46,840
and I'll increase my terminal window again, ./buggy,
而且我会再次放大我的终端窗口，./buggy，

681
00:33:46,840 --> 00:33:49,360
now I see what's going on inside of the code.
现在我看到了代码内部发生了什么。

682
00:33:49,360 --> 00:33:53,080
Now it matches my expectations, and so now the bug is gone.
现在它符合我的预期，所以现在 bug 消失了。

683
00:33:53,080 --> 00:33:55,330
Now of course, if I'm submitting this or shipping it,
现在当然，如果我提交它或发布它，

684
00:33:55,330 --> 00:33:57,190
I should delete the temporary printf.
我应该删除临时 printf。

685
00:33:57,190 --> 00:34:00,610
And let me disclaim that using printf in this way just to help you
我必须声明，用这种方式使用 printf 只是为了帮助你

686
00:34:00,610 --> 00:34:03,100
see what's going on is generally a good thing,
看到发生了什么事通常是件好事，

687
00:34:03,100 --> 00:34:06,370
but generally adding a printf and a printf and a printf and a printf--
但是通常添加一个 printf 和一个 printf 和一个 printf 和一个 printf--

688
00:34:06,370 --> 00:34:10,665
like it starts to devolve into just trial and error and you
就像它开始演变成反复试错，然后你

689
00:34:10,665 --> 00:34:13,540
have no idea what's going on, so you're just printing out everything.
不知道发生了什么事，所以你就把所有东西都打印出来。

690
00:34:13,540 --> 00:34:17,230
Let me propose that if you ever find yourself slipping down
我想说的是，如果你发现自己滑下了

691
00:34:17,230 --> 00:34:20,260
that hill into just trying this, trying this, trying this,
那座山，只是尝试这个，尝试那个，尝试这个，

692
00:34:20,260 --> 00:34:22,659
you need a better tool, not just doing printf.
你需要更好的工具，而不仅仅是使用 printf。

693
00:34:22,659 --> 00:34:26,199
And frankly, it's annoying to use printf because every time you add a printf,
坦白说，使用 printf 很烦人，因为每次添加一个 printf，

694
00:34:26,199 --> 00:34:28,699
you have to recompile the code, rerun the code.
你必须重新编译代码，重新运行代码。

695
00:34:28,699 --> 00:34:31,230
It's just adding to the number of steps.
这只是增加了步骤的数量。

696
00:34:31,230 --> 00:34:34,550
So let me propose instead that we do this.
所以，我建议我们这样做。

697
00:34:34,550 --> 00:34:37,070
I'm going to go back into VS Code here and I'm
我要回到这里的 VS Code 中，我

698
00:34:37,070 --> 00:34:39,980
going to write a different program that actually
要写一个不同的程序，它实际上

699
00:34:39,980 --> 00:34:42,110
has a helper function, so to speak.
拥有一个辅助函数，可以这么说。

700
00:34:42,110 --> 00:34:44,840
A second function whose purpose in life is maybe just
第二个函数，它的生命意义也许只是

701
00:34:44,840 --> 00:34:46,940
to print that column for me.
为我打印那一列。

702
00:34:46,940 --> 00:34:50,685
So I'm going to say this-- void print_column,
所以我要这样写：void print_column，

703
00:34:50,685 --> 00:34:53,060
though I could call it anything I want, and this function
虽然我可以随意命名它，而这个函数

704
00:34:53,060 --> 00:34:56,570
is going to take a argument or a parameter called
将接收一个参数，叫做

705
00:34:56,570 --> 00:34:59,300
height which will tell it how many bricks to print,
height，它将告诉函数打印多少个砖块，

706
00:34:59,300 --> 00:35:01,070
how many vertical bricks.
多少个竖砖。

707
00:35:01,070 --> 00:35:05,900
I'm going to do the same kind of logic. for int i equals 0.
我要用同样的逻辑。for int i 等于 0。

708
00:35:05,900 --> 00:35:06,830
i is less than--
i 小于--

709
00:35:06,830 --> 00:35:09,830
I'm going to make the same mistake again-- less than or equal to height,
我将再次犯同样的错误：小于等于 height，

710
00:35:09,830 --> 00:35:10,850
i++.
i++。

711
00:35:10,850 --> 00:35:14,922
And then inside of this for loop, let me go ahead and print out the hash mark.
然后在这个 for 循环中，让我继续打印井号。

712
00:35:14,922 --> 00:35:16,880
So I've made the same mistake, but I've made it
所以，我犯了同样的错误，但我在

713
00:35:16,880 --> 00:35:20,900
in the context now of a helper function only because in main,
现在辅助函数的上下文中犯了这个错误，因为在 main 中，

714
00:35:20,900 --> 00:35:24,980
what I'd like to do now, just to be a little more sophisticated is get int
我现在想做的事情，为了更精致一点，就是获取 int

715
00:35:24,980 --> 00:35:27,300
from the user for the height.
从用户那里获取高度。

716
00:35:27,300 --> 00:35:31,190
And when I do get that int, I want to store it in a variable called n,
当我获取到那个 int 时，我想把它存储到一个叫做 n 的变量中，

717
00:35:31,190 --> 00:35:34,980
but I do need to give that variable a type like last week.
但是我需要给那个变量一个类型，就像上周一样。

718
00:35:34,980 --> 00:35:36,440
So I'll say that it's an integer.
所以我把它定义为整数。

719
00:35:36,440 --> 00:35:40,940
And now, lastly, I can print_column, passing in-- actually, I'll
现在，最后，我可以调用 print_column，传入参数--实际上，我将

720
00:35:40,940 --> 00:35:43,100
call it h just because height is h.
把它叫做 h，因为 height 就是 h。

721
00:35:43,100 --> 00:35:46,730
Print column h, semicolon.
打印列 h，分号。

722
00:35:46,730 --> 00:35:49,790
OK, so it's the exact same program except I'm getting user input now.
好的，所以它和之前的程序完全一样，除了我现在获取用户输入。

723
00:35:49,790 --> 00:35:53,030
So it's not just going to be 3, it's going to be a variable height,
所以它不再是固定的 3，而是一个可变的高度，

724
00:35:53,030 --> 00:35:55,108
but I've done something stupid.
但我做了一些愚蠢的事情。

725
00:35:55,108 --> 00:35:56,940
AUDIENCE: [INAUDIBLE]
观众：[听不清]

726
00:35:56,940 --> 00:35:58,690
DAVID MALAN: I've done two stupid things.
大卫·马兰：我犯了两个愚蠢的错误。

727
00:35:58,690 --> 00:36:02,310
So this, of course, is not supposed to be there, so I'll fix that.
所以，当然，这里不应该出现这个，所以我会把它改掉。

728
00:36:02,310 --> 00:36:03,390
And someone else.
还有其他人。

729
00:36:03,390 --> 00:36:05,265
What else have I done?
我还做了什么？

730
00:36:05,265 --> 00:36:08,990
AUDIENCE: [INAUDIBLE]
观众：[听不清]

731
00:36:08,990 --> 00:36:09,740
DAVID MALAN: Yeah.
大卫·马兰：是。

732
00:36:09,740 --> 00:36:11,070
I'm missing the prototype.
我漏掉了原型。

733
00:36:11,070 --> 00:36:16,040
And this is, let me reiterate, probably the only time where copy-paste is OK.
而且我要重申一遍，这可能是唯一可以复制粘贴的时候。

734
00:36:16,040 --> 00:36:17,960
Once you've implemented the function, you
一旦你实现了函数，你

735
00:36:17,960 --> 00:36:21,690
can copy paste its first line at a semicolon
可以复制粘贴它的第一行，加上分号

736
00:36:21,690 --> 00:36:25,265
so that it teaches the compiler that this function will exist.
这样它就可以告诉编译器这个函数将会存在。

737
00:36:25,265 --> 00:36:26,635
AUDIENCE: [INAUDIBLE]
观众：[听不清]

738
00:36:26,635 --> 00:36:28,010
DAVID MALAN: Three stupid things.
大卫·马兰：三件蠢事。

739
00:36:28,010 --> 00:36:28,510
OK.
好的。

740
00:36:28,510 --> 00:36:29,150
Thank you.
谢谢。

741
00:36:29,150 --> 00:36:31,520
So, good.
所以，很好。

742
00:36:31,520 --> 00:36:33,620
Include cs50.h.
包含 cs50.h。

743
00:36:33,620 --> 00:36:36,860
And now, anyone want to go for four?
现在，有人想要去尝试第四个吗？

744
00:36:36,860 --> 00:36:38,040
No?
没有？

745
00:36:38,040 --> 00:36:38,540
All right.
好的。

746
00:36:38,540 --> 00:36:39,582
Slightly unintended here.
这里有点意外。

747
00:36:39,582 --> 00:36:42,020
So let's see. make buggy.
我们来看看。make buggy。

748
00:36:42,020 --> 00:36:44,160
OK, no syntax errors thanks to you all.
好的，没有语法错误，感谢大家。

749
00:36:44,160 --> 00:36:47,090
So the code compiles, but of course, when I run buggy
所以代码可以编译，但当然，当我运行 buggy 时

750
00:36:47,090 --> 00:36:52,130
and I type in something like 3 manually, I'm still going to get 1, 2, 3 4 out.
我手动输入 3，我仍然会得到 1，2，3，4。

751
00:36:52,130 --> 00:36:54,500
So let me now introduce a more powerful tool
所以，现在我将介绍一个更强大的工具

752
00:36:54,500 --> 00:36:56,450
that's generally known as a debugger.
通常称为调试器。

753
00:36:56,450 --> 00:36:58,927
And within the VS Code environment that you're using,
在您正在使用的 VS Code 环境中，

754
00:36:58,927 --> 00:37:02,010
we actually have a command that makes it a little easier to use this tool,
我们实际上有一个命令，可以让你更轻松地使用这个工具，

755
00:37:02,010 --> 00:37:03,510
but we didn't write the tool itself.
但是我们并没有编写这个工具本身。

756
00:37:03,510 --> 00:37:07,040
You are about to see a very graphical, a very popular industry standard
您将看到一个非常图形化的、非常流行的行业标准

757
00:37:07,040 --> 00:37:11,510
tool called a debugger, but we'll start the debugger using a CS50-specific
称为调试器的工具，但我们将使用一个CS50特定的工具

758
00:37:11,510 --> 00:37:15,080
command called debug50, which just makes it easier with a single command
名为debug50的命令，它只需要一个命令就能简化操作

759
00:37:15,080 --> 00:37:17,655
to start the debugger without having to configure a text
启动调试器，而无需配置文本

760
00:37:17,655 --> 00:37:20,030
file with all of your preferred settings and all of that.
文件，里面包含您所有偏好的设置等等。

761
00:37:20,030 --> 00:37:22,710
It's just an annoying hoop otherwise to jump through.
否则就是一个需要跳过的令人讨厌的障碍。

762
00:37:22,710 --> 00:37:25,100
So what I'm going to do is go back to my code here.
所以我要回到我的代码这里。

763
00:37:25,100 --> 00:37:27,900
I have already compiled it, but just for good measure,
我已经编译了它，但为了保险起见，

764
00:37:27,900 --> 00:37:31,140
I'll make buggy again because the debugger needs your code
我会让它再次出现错误，因为调试器需要您的代码

765
00:37:31,140 --> 00:37:31,862
to be compiled.
被编译。

766
00:37:31,862 --> 00:37:33,570
It's not going to help with syntax errors
它不会帮助解决语法错误

767
00:37:33,570 --> 00:37:36,270
like the stupid mistakes I just made unintentionally,
就像我无意中犯的一些愚蠢错误，

768
00:37:36,270 --> 00:37:40,530
it will help you though with programmatic errors, logical errors
但它可以帮助您解决程序错误，逻辑错误

769
00:37:40,530 --> 00:37:42,870
in your code once your code is running.
在您的代码运行时。

770
00:37:42,870 --> 00:37:47,130
So to run debug50, I'm going to do this. debug50, space, and then
所以要运行debug50，我会这样做。debug50，空格，然后

771
00:37:47,130 --> 00:37:51,840
the exact same command I would normally run to just run the program itself.
与我通常运行程序时使用的命令完全相同。

772
00:37:51,840 --> 00:37:53,190
So ./buggy.
所以是./buggy。

773
00:37:53,190 --> 00:37:57,150
So exact same thing, ./buggy, but I prefix it now with debug50.
所以完全一样，./buggy，但我现在在它前面加上了debug50。

774
00:37:57,150 --> 00:37:59,172
When I hit Enter, a whole bunch of--
当我按下回车键时，一堆--

775
00:37:59,172 --> 00:38:01,380
another error is going to pop up on the screen, which
另一个错误将出现在屏幕上，这

776
00:38:01,380 --> 00:38:04,213
is a good reminder because this will happen to you, too, invariably.
是一个很好的提醒，因为这也会发生在你身上，不可避免地。

777
00:38:04,213 --> 00:38:07,560
It's reminding me that I have to set what's called a breakpoint.
它提醒我，我必须设置一个称为断点的设置。

778
00:38:07,560 --> 00:38:10,140
And as that word suggests, it is the point
正如这个词所暗示的那样，它就是那个点

779
00:38:10,140 --> 00:38:12,060
at which you want your code to break.
您希望代码中断的地方。

780
00:38:12,060 --> 00:38:15,420
Not break in make the situation worse sense, but rather,
不是让情况变得更糟，而是

781
00:38:15,420 --> 00:38:16,920
where do you want to pause?
您希望暂停在哪里？

782
00:38:16,920 --> 00:38:20,590
Execution, break, execution-- like hitting the brakes on a car
执行、中断、执行-- 就像踩汽车的刹车一样

783
00:38:20,590 --> 00:38:22,710
so the program doesn't run all at once.
这样程序就不会一次运行完。

784
00:38:22,710 --> 00:38:24,600
And you can put this any number of places,
你可以把它放在任何地方，

785
00:38:24,600 --> 00:38:26,308
and you might have done this accidentally
你可能无意中做过这件事

786
00:38:26,308 --> 00:38:29,040
if you've ever hovered over the gutter of VS Code,
如果你曾经将鼠标悬停在VS Code的代码行边距上，

787
00:38:29,040 --> 00:38:32,010
the left-hand side next to your line numbers.
行号旁边的左侧。

788
00:38:32,010 --> 00:38:34,180
See the little red dot that appears?
看到那里出现的红色小点了吗？

789
00:38:34,180 --> 00:38:38,560
If I click on any of these lines, that's going to set a breakpoint, so to speak.
如果我点击这些行中的任何一行，就会设置一个断点，可以这么说。

790
00:38:38,560 --> 00:38:41,310
And I want to break execution at main.
我想在main处中断执行。

791
00:38:41,310 --> 00:38:44,040
So I'm just going to click to the left of line 6 in this case.
所以我要点击第6行的左侧，在这种情况下。

792
00:38:44,040 --> 00:38:47,430
That makes it a darker red circle, a stop sign
这样就变成一个更深的红色圆圈，一个停止标志

793
00:38:47,430 --> 00:38:51,030
of sorts that tells the debugger to pause execution on that line,
它告诉调试器在那一行暂停执行，

794
00:38:51,030 --> 00:38:53,580
though I could put it elsewhere if I so choose.
虽然我可以根据需要把它放在其他地方。

795
00:38:53,580 --> 00:38:57,990
Let me go ahead and rerun debug50 ./buggy, Enter,
让我继续运行debug50 ./buggy，回车，

796
00:38:57,990 --> 00:39:00,652
and now a bunch of things are going to happen on the screen.
现在屏幕上会发生很多事情。

797
00:39:00,652 --> 00:39:03,360
It's going to look a little overwhelming perhaps at first glance,
乍一看，它可能看起来有点让人不知所措，

798
00:39:03,360 --> 00:39:05,950
but there's some useful stuff that just happened.
但是有一些有用的东西刚刚发生了。

799
00:39:05,950 --> 00:39:12,450
So one, my code is still here, but the line that I set the breakpoint on is--
所以，首先，我的代码仍然在这里，但是我设置断点的行是--

800
00:39:12,450 --> 00:39:16,080
rather, the first line of actual executable
更确切地说，是我设置的断点之下第一行实际可执行的

801
00:39:16,080 --> 00:39:20,970
code at or below the breakpoint I set is highlighted in this yellowish green
代码以这种淡黄绿色突出显示，这意味着这一行代码还没有执行。

802
00:39:20,970 --> 00:39:25,120
here, which says, this line of code has not yet been executed.
我们在这点上中断了，但如果我点击一个按钮，这一行代码

803
00:39:25,120 --> 00:39:28,590
We broke at this point, but if I click a button, this line of code
将会被执行。

804
00:39:28,590 --> 00:39:30,030
will be executed.
因为到目前为止，你写的每一个C程序都运行得飞快。

805
00:39:30,030 --> 00:39:33,750
Because up until now, every C program you write runs as fast as that.
我想踩刹车，在这里暂停一下。

806
00:39:33,750 --> 00:39:36,550
I want to pump the brakes and pause here.
但是请注意这里窗口的几个其他方面。

807
00:39:36,550 --> 00:39:39,190
But notice a few other aspects of the window here.
所以请注意这里上面的一些奇怪的东西。

808
00:39:39,190 --> 00:39:41,310
So notice that up here some weirdness.
那里提到了变量，我们对这些很熟悉。

809
00:39:41,310 --> 00:39:43,890
There's mentions of variables and we're familiar with these.
局部是一个我们本周会用到的术语。

810
00:39:43,890 --> 00:39:45,990
Local is a term we'll use this week.
但是有这个变量h，奇怪的是，

811
00:39:45,990 --> 00:39:48,210
But there's this variable h, which weirdly,
这个值21912是从哪里来的呢？

812
00:39:48,210 --> 00:39:51,300
where did the value 21912 come from?
所以事实证明，在C语言中，在你用一个值初始化一个变量之前

813
00:39:51,300 --> 00:39:57,750
So it turns out, in C, before you initialize a variable with a value
通过字面意义上的输入数字3，或者使用像get_int这样的函数，

814
00:39:57,750 --> 00:40:01,890
by literally typing the number 3, or by using a function like get_int,
它通常包含一个叫做垃圾值的变量。

815
00:40:01,890 --> 00:40:04,662
it often contains what's called a garbage value.
关于这些，我们将在几周后详细讲解。

816
00:40:04,662 --> 00:40:06,120
More on those in a couple of weeks.
但你可以把垃圾值看作

817
00:40:06,120 --> 00:40:07,950
But a garbage value is you can think of it
是计算机内存中运行程序之前残留的东西。

818
00:40:07,950 --> 00:40:10,680
as like remnants of whatever was in the computer's memory
这是一个过度简化的说法，

819
00:40:10,680 --> 00:40:12,280
before you ran your program.
但你不能指望一个变量在这种情况

820
00:40:12,280 --> 00:40:14,040
And that's a bit of a oversimplification,
下会拥有一个特定的值，

821
00:40:14,040 --> 00:40:18,150
but you cannot trust that a variable will have a certain value in this case
除非你自己设置了它。

822
00:40:18,150 --> 00:40:21,490
if you did not put one there yourself.
所以现在，h 是没有意义的。

823
00:40:21,490 --> 00:40:23,857
So for now, h is nonsensical.
它是一个垃圾值，没有任何意义。

824
00:40:23,857 --> 00:40:25,440
It's a garbage value it means nothing.
但一旦我执行这一行，它应该包含用户输入的任何内容。

825
00:40:25,440 --> 00:40:29,230
But once I execute this line, it should contain whatever the human types in.
好的。

826
00:40:29,230 --> 00:40:29,730
All right.
在下面，有一个观察区域，这是一个更复杂的功能。

827
00:40:29,730 --> 00:40:32,990
Down here, there's a watch section, which is a more sophisticated feature.
在下面是所谓的调用堆栈。

828
00:40:32,990 --> 00:40:34,740
Down here is what's called the call stack.
我们将在未来详细讲解。

829
00:40:34,740 --> 00:40:35,890
More on that in the future.
但现在这意味着我正在执行main函数，而不是

830
00:40:35,890 --> 00:40:39,240
But what this means for now is that I'm executing the main function, not,
例如，print_column。

831
00:40:39,240 --> 00:40:40,870
for instance, print_column.
所以请注意这里，这些是界面中最有用的控件。

832
00:40:40,870 --> 00:40:44,790
So notice up here, these are the most useful controls within the interface.
如果我点击这个播放按钮，它就会

833
00:40:44,790 --> 00:40:46,740
If I hit this Play button, it's just going
运行我的程序，直到结束，不再打扰我。

834
00:40:46,740 --> 00:40:50,640
to actually run my program to the end of it without bothering me further.
然而，我可以实际执行这一行代码，

835
00:40:50,640 --> 00:40:54,990
However, I can actually step over this line of code and execute it,
或者我可以进入这一行代码，并实际

836
00:40:54,990 --> 00:40:57,870
or I can step into this line of code and actually
查看get_int的内容，如果它在系统上可用的话。

837
00:40:57,870 --> 00:41:01,480
poke around the contents of get_int if it's available on the system.
所以从概念上来说，你可以执行这一行

838
00:41:01,480 --> 00:41:03,870
So conceptually you can either execute this line
或者你可以在概念上深入下去，看看这个函数内部有什么。

839
00:41:03,870 --> 00:41:08,745
or you can dive down conceptually deeper and see what's inside of that function.
最后，这将让你跳出，这将

840
00:41:08,745 --> 00:41:10,620
Lastly, this will let you step out, this will
让你重新启动整个过程，这将停止调试器。

841
00:41:10,620 --> 00:41:13,828
allow you to restart the whole process, and this will just stop the debugger.
所以这些按钮将是我们的好朋友。

842
00:41:13,828 --> 00:41:15,960
So these buttons are going to be our friends.
我要点击的第一个按钮是我描述的第一个按钮，

843
00:41:15,960 --> 00:41:19,840
And the one I'll click first is the first one I described,
也就是“单步跳过”。

844
00:41:19,840 --> 00:41:21,690
which is step over.
所以“单步跳过”并不意味着跳过这一步，它只是意味着执行这一步，

845
00:41:21,690 --> 00:41:26,180
So step over doesn't mean, skip this step, it just means execute it,
但不要因为深入到特定行中的细节而打扰我，

846
00:41:26,180 --> 00:41:30,000
but don't bother me by going into the weeds of what is on the specific line,


847
00:41:30,000 --> 00:41:30,740
namely get_int.
也就是 get_int 函数。

848
00:41:30,740 --> 00:41:32,990
So when I click this button in a moment, you'll
所以，当我过会儿点击这个按钮的时候，你就会

849
00:41:32,990 --> 00:41:36,830
see that my terminal, which is still at the bottom, prompts me for a height.
看到我的终端（还在底部）提示我输入高度。

850
00:41:36,830 --> 00:41:38,600
I'm going to go ahead and type 3.
我要输入 3。

851
00:41:38,600 --> 00:41:41,240
As soon as I hit Enter, what part of the screen
当我按下回车键后，屏幕的哪一部分

852
00:41:41,240 --> 00:41:44,285
probably will change based on what I've said?
可能会根据我所说发生变化？

853
00:41:47,280 --> 00:41:50,760
So h, the variable h should hopefully take on the number 3.
所以 h，变量 h 应该会取值为 3。

854
00:41:50,760 --> 00:41:53,340
And I'll probably see a different line of code
而且我可能还会看到不同的代码行

855
00:41:53,340 --> 00:41:57,990
highlighted, probably line 9 next once I'm done executing line 8.
被高亮显示，可能接下来就是第 9 行，一旦我执行完第 8 行。

856
00:41:57,990 --> 00:42:01,170
So let me go ahead and hit Enter and watch the top-left of the screen.
所以我按一下回车键，然后观察屏幕的左上角。

857
00:42:01,170 --> 00:42:08,580
And voila, h now has the value 3, and execution has now paused on line 9
瞧，h 现在值为 3，程序执行已经暂停在第 9 行

858
00:42:08,580 --> 00:42:12,900
because the debugger is allowing me to step through my code line by line.
因为调试器允许我逐行调试代码。

859
00:42:12,900 --> 00:42:16,998
Now let me go ahead and print out-- let me go ahead and just say, all right,
现在让我打印出来，让我先说一下，好吧，

860
00:42:16,998 --> 00:42:17,790
I'm done with this.
我已经完成了。

861
00:42:17,790 --> 00:42:19,950
Let's go ahead and run the rest of the program.
让我们继续执行程序的剩余部分。

862
00:42:19,950 --> 00:42:21,660
It clearly got the value 3.
它明显获取到了 3 这个值。

863
00:42:21,660 --> 00:42:22,658
But wait a minute--
等等，

864
00:42:22,658 --> 00:42:24,450
oh, and at this point, it closed the window
哦，到了这一步，它关闭了窗口

865
00:42:24,450 --> 00:42:28,530
in which I would have seen the output, I would have still seen four hashes.
我本来可以在里面看到输出，我本来还是会看到四个井号。

866
00:42:28,530 --> 00:42:29,950
So let me actually do this again.
所以让我再来一遍。

867
00:42:29,950 --> 00:42:34,392
Let me go back into debug50 by running the exact same command again.
让我再次运行同一个命令，回到 debug50。

868
00:42:34,392 --> 00:42:37,350
It's going to think for a moment, it's going to reconfigure the screen.
它会想一会儿，它会重新配置屏幕。

869
00:42:37,350 --> 00:42:38,892
I'm going to do the exact same thing.
我将执行完全相同的事情。

870
00:42:38,892 --> 00:42:41,100
I'm going to step over this line, but I'd
我要跳过这行，但是我想

871
00:42:41,100 --> 00:42:45,490
like to actually see what's going on inside of my print_column function.
实际看一下我的 print_column 函数内部发生了什么。

872
00:42:45,490 --> 00:42:48,580
So this time, instead of just saying run to the end
所以这次，我不会直接运行到结尾

873
00:42:48,580 --> 00:42:51,100
and close all the windows on me, let me go ahead
并关闭所有窗口，让我继续

874
00:42:51,100 --> 00:42:54,460
and step into my print_column function.
进入我的 print_column 函数。

875
00:42:54,460 --> 00:42:57,070
So don't step over, step into.
所以不要跳过，要进入。

876
00:42:57,070 --> 00:42:58,525
Because if I step over--
因为如果我跳过，

877
00:42:58,525 --> 00:43:00,400
and now this is what I meant to show earlier,
现在这就是我之前想展示的，

878
00:43:00,400 --> 00:43:02,710
you can see that it's still printing out 4.
你可以看到它仍然打印出 4。

879
00:43:02,710 --> 00:43:05,930
So in fact, let me undo this, let me just stop the whole thing.
所以实际上，让我撤销这个操作，让我直接停止整个程序。

880
00:43:05,930 --> 00:43:08,320
Let me rerun the command a final time.
让我最后一次重新运行命令。

881
00:43:08,320 --> 00:43:10,690
So it goes back to where we began before.
所以它又回到了我们之前开始的地方。

882
00:43:10,690 --> 00:43:15,520
It's going to prompt me again once I step over line 8 for a number like 3.
当我跳过第 8 行时，它会再次提示我输入一个数字，比如 3。

883
00:43:15,520 --> 00:43:19,930
But this time, instead of stepping over line 9, let's poke around.
但是这次，我们不是跳过第 9 行，而是探索一下。

884
00:43:19,930 --> 00:43:23,770
I wrote print_column, so let's look at print_column step by step,
我写了 print_column，所以让我们一步一步地看一下 print_column，

885
00:43:23,770 --> 00:43:26,800
step into it, and watch what happens to the yellow highlight.
进入它，然后观察黄色高亮发生了什么。

886
00:43:26,800 --> 00:43:30,220
It now jumps logically to the inside of print_column,
现在它逻辑地跳转到 print_column 的内部，

887
00:43:30,220 --> 00:43:32,510
thereby letting me walk through this code.
从而让我逐行查看这段代码。

888
00:43:32,510 --> 00:43:35,720
And now I can just step over each of these lines one at a time.
现在我可以一次跳过每一行。

889
00:43:35,720 --> 00:43:37,180
So stepping over.
所以跳过。

890
00:43:37,180 --> 00:43:38,440
OK, so what did it do?
好的，它做了什么？

891
00:43:38,440 --> 00:43:41,200
It did that whole narrative that I did verbally last week
它做了上周我用语言描述的整个流程

892
00:43:41,200 --> 00:43:43,720
where it compared i against height.
它将 i 与 height 进行比较。

893
00:43:43,720 --> 00:43:45,520
It then went inside of the loop.
然后它进入循环。

894
00:43:45,520 --> 00:43:48,940
When I click Step Over, watch what happens in my terminal-- one hash
当我点击“跳过”时，观察我的终端发生了什么，一个井号

895
00:43:48,940 --> 00:43:49,660
prints out.
被打印出来。

896
00:43:49,660 --> 00:43:51,460
Now line 14 is highlighted again.
现在第 14 行再次被高亮显示。

897
00:43:51,460 --> 00:43:54,220
It's comparing per the Boolean expression, i,
根据布尔表达式，它正在比较 i，

898
00:43:54,220 --> 00:43:55,900
is it less than or equal to height?
它是否小于或等于 height？

899
00:43:55,900 --> 00:43:59,770
If so, it's going to go ahead and print out the hash.
如果是，它将继续打印出井号。

900
00:43:59,770 --> 00:44:02,080
It's going to do this again, print out the hash.
它将再次执行此操作，打印出井号。

901
00:44:02,080 --> 00:44:05,020
But notice at the top-left of the screen, height
但请注意屏幕的左上角，height

902
00:44:05,020 --> 00:44:10,180
is still the same, it's still 3, but what has been changing, apparently?
仍然保持不变，仍然是 3，但明显发生了变化的是什么？

903
00:44:10,180 --> 00:44:11,960
i on each iteration.
每次迭代中的 i。

904
00:44:11,960 --> 00:44:16,240
So the debugger is letting me see what's going on slowly inside of this loop
所以调试器让我慢慢地看到这个循环内部发生了什么

905
00:44:16,240 --> 00:44:18,070
because i keeps getting incremented.
因为 i 不断地被递增。

906
00:44:18,070 --> 00:44:21,580
So if I step over this line now, notice that I've now printed 3.
所以如果我现在跳过这行，请注意我已经打印了 3 个。

907
00:44:21,580 --> 00:44:25,690
So ideally I want this loop to end, but if I click Step Over once more,
所以理想情况下我希望这个循环结束，但如果我再次点击“跳过”，

908
00:44:25,690 --> 00:44:29,710
notice that the value of i at top-left is 3,
请注意屏幕左上角 i 的值为 3，

909
00:44:29,710 --> 00:44:35,600
but 3 is less than or equal to height-- oh, now I get it, if I play along here.
但 3 小于或等于 height，哦，我现在明白了，如果我继续这样做。

910
00:44:35,600 --> 00:44:40,540
Now I see why less than or equals to, mathematically, is clearly incorrect.
现在我明白为什么从数学角度来说，小于或等于明显是不正确的。

911
00:44:40,540 --> 00:44:43,090
And as soon as that light bulb goes off, you can just sort of
一旦你恍然大悟，你就可以直接

912
00:44:43,090 --> 00:44:46,570
bail out, click the red Stop button to turn the debugger off,
退出，点击红色的“停止”按钮关闭调试器，

913
00:44:46,570 --> 00:44:50,560
go back in, fix your code, and voila, recompile, run it,
重新进入，修复你的代码，瞧，重新编译，运行它，

914
00:44:50,560 --> 00:44:51,950
and you're back in business.
你又可以继续了。

915
00:44:51,950 --> 00:44:55,480
So the takeaways here really are just what tools now exist?
所以这里真正的收获是，现在都有哪些工具？

916
00:44:55,480 --> 00:44:59,590
Printf is your friend, but only for quick-and-dirty debugging techniques.
Printf 是你的好朋友，但它只适用于快速调试的技术。

917
00:44:59,590 --> 00:45:04,930
Get into the habit now of using debug50, and in turn, VS Code's debugger.
现在养成使用 debug50 的习惯，进而使用 VS Code 的调试器。

918
00:45:04,930 --> 00:45:08,800
You will invariably not take this advice, say,
你不可避免地不会采纳这个建议，比如说，

919
00:45:08,800 --> 00:45:11,710
for problem set 2 as you first begin because it's
在开始做第二套问题集时，因为它

920
00:45:11,710 --> 00:45:15,340
going to feel easier and quicker just to use printf, just to use printf,
感觉用 printf 更简单快捷，用 printf 就好了，

921
00:45:15,340 --> 00:45:16,300
just to use printf.
用 printf 就好了。

922
00:45:16,300 --> 00:45:17,710
And the problem with that logic is that you
这种逻辑的问题在于你

923
00:45:17,710 --> 00:45:20,000
begin to build up like technical debt, so to speak,
开始积攒技术债务，可以这么说，

924
00:45:20,000 --> 00:45:21,760
where you really should have learned it earlier,
你本应该早点学习的，

925
00:45:21,760 --> 00:45:23,510
you really should have learned it earlier,
你本应该早点学习的，

926
00:45:23,510 --> 00:45:26,000
you really should have learned it earlier, at which point,
你本应该早点学习的，那样一来，

927
00:45:26,000 --> 00:45:29,350
you end up spending more time wasted using printf
你最终会浪费更多时间使用 printf

928
00:45:29,350 --> 00:45:32,720
and doing things manually than if you had just spent 10 minutes,
手动操作，而不是花 10 分钟，

929
00:45:32,720 --> 00:45:35,170
30 minutes just learning the user interface
30 分钟学习一下正规调试器的用户界面

930
00:45:35,170 --> 00:45:37,510
and the buttons of a proper debugger.
和按钮。

931
00:45:37,510 --> 00:45:40,390
So please take that advice because it will save you
所以请记住这条建议，因为它会为你节省

932
00:45:40,390 --> 00:45:45,480
significant amounts of time over time.
大量的宝贵时间。

933
00:45:45,480 --> 00:45:48,900
Questions on printf or debugging in this way?
关于 printf 或这种调试方法，有什么问题吗？

934
00:45:52,260 --> 00:45:54,790
Any questions on this?
关于这方面，有什么问题吗？

935
00:45:54,790 --> 00:45:55,290
No?
没有？

936
00:45:55,290 --> 00:45:55,800
OK.
好的。

937
00:45:55,800 --> 00:45:59,880
So let me give you a third and final technique for debugging, which has been
让我来介绍第三种也是最后一种调试技巧，它一直

938
00:45:59,880 --> 00:46:01,840
looming over us here for some time.
潜伏在我们身边。

939
00:46:01,840 --> 00:46:05,400
So there is actually this technique known as rubber duck debugging.
实际上有一种叫做“橡皮鸭调试”的技术。

940
00:46:05,400 --> 00:46:09,570
And in the absence of a roommate who is taking CS50 or who has taken CS50
如果没有一个正在学习 CS50 或已经学过 CS50 的室友

941
00:46:09,570 --> 00:46:13,140
or knows how to program, in the absence of having a TF or TA or CA
或者知道如何编程，如果没有助教或助教组成员，

942
00:46:13,140 --> 00:46:16,920
sitting next to you, in the absence of having a family member available to ask
坐在你旁边，因为没有家人可以问

943
00:46:16,920 --> 00:46:22,020
questions of, if you have simply an inanimate object on your desk,
一些问题，如果你只是在你的桌子上放了一个无生命的物体，

944
00:46:22,020 --> 00:46:25,440
goes the tradition, just talk to that inanimate object.
按照传统，就和那个无生命的物体说话。

945
00:46:25,440 --> 00:46:27,970
Better yet, if it's an adorable rubber duck in this way.
更好的是，如果它是一个可爱的橡皮鸭。

946
00:46:27,970 --> 00:46:31,560
And the idea of rubber duck debugging is that simply
而橡皮鸭调试的想法很简单

947
00:46:31,560 --> 00:46:34,930
by verbalizing literally out loud to this inanimate object--
就是把你的想法大声说出来，对着这个无生命的物体说出来——

948
00:46:34,930 --> 00:46:36,930
probably with the door closed and no one knowing
很可能是在关着门的情况下，没有人知道

949
00:46:36,930 --> 00:46:39,930
that you're talking to this rubber duck, you invariably
你在和这个橡皮鸭说话，你一定会

950
00:46:39,930 --> 00:46:44,070
end up hearing any illogic in your own thoughts, at which point
最终会听到你自己的想法中的任何逻辑错误，此时

951
00:46:44,070 --> 00:46:47,340
the proverbial light bulb tends to go off and you're like, oh, I'm an idiot.
灯泡就会亮起来，你会想，哦，我真是个笨蛋。

952
00:46:47,340 --> 00:46:50,310
It's supposed to be less than, not less than or equal to.
应该是小于，而不是小于等于。

953
00:46:50,310 --> 00:46:54,670
So literally just explaining to a duck or any inanimate object what's
所以，实际上，只要向一只鸭子或任何无生命的物体解释清楚你

954
00:46:54,670 --> 00:46:57,790
going on in your code will quite frequently just
代码中正在发生的事情，就经常会

955
00:46:57,790 --> 00:47:02,260
help you see in your mind's eye what it is you've been doing wrong.
帮助你在脑海中看到你一直在做错的地方。

956
00:47:02,260 --> 00:47:05,590
So rubber duck debugging is indeed a very effective technique
所以，橡皮鸭调试确实是一种非常有效的技巧

957
00:47:05,590 --> 00:47:09,550
even if you don't happen to have a small or large rubber duck.
即使你没有一只大小适宜的橡皮鸭。

958
00:47:09,550 --> 00:47:12,370
Of course, you're also welcome to use the CS50 Duck who
当然，你也可以使用 CS50 鸭子，它

959
00:47:12,370 --> 00:47:17,710
lives at cs50.ai, and also within a pane in VS Code at cs50.dev.
住在 cs50.ai 上，也在 cs50.dev 上的 VS Code 面板中。

960
00:47:17,710 --> 00:47:20,830
You can ask the CS50 Duck about concepts you don't understand,
你可以向 CS50 鸭子询问你不理解的概念，

961
00:47:20,830 --> 00:47:23,170
or you can even copy paste certain lines of code
或者，你甚至可以复制粘贴一些你可能在其中遇到麻烦的代码行

962
00:47:23,170 --> 00:47:27,460
with which you might be having trouble and ask the duck for its own advice.
并向鸭子寻求它自己的建议。

963
00:47:27,460 --> 00:47:28,180
All right.
好的。

964
00:47:28,180 --> 00:47:33,730
So, with those tools in our toolkit, let me propose now that we do--
有了这些工具，我现在提议我们

965
00:47:33,730 --> 00:47:37,390
that we introduce now a few lower-level features of C
介绍一些 C 的底层功能

966
00:47:37,390 --> 00:47:40,720
itself and better understand how we can start solving some of those problems
本身，并更好地理解如何开始解决其中的一些问题

967
00:47:40,720 --> 00:47:44,860
like the readability of text or the encryption of data.
比如文本的可读性或数据的加密。

968
00:47:44,860 --> 00:47:47,080
These were our so-called types last week when
这些就是我们上周所说的类型，当时

969
00:47:47,080 --> 00:47:51,490
we introduced at least a subset of them or used them just to store data
我们至少介绍了其中的一部分，或者只是用它们来存储数据

970
00:47:51,490 --> 00:47:53,328
in a certain format, so to speak.
用某种格式存储，可以这么说。

971
00:47:53,328 --> 00:47:55,870
Like in week 0, we said that everything at the end of the day
就像在第 0 周，我们说过，归根结底

972
00:47:55,870 --> 00:47:57,490
is just 0's and 1's, binary.
只是一些 0 和 1，二进制。

973
00:47:57,490 --> 00:48:03,130
And I claimed conceptually that how a computer knows if a set of bits
我从概念上声称，一台计算机如何知道一组比特

974
00:48:03,130 --> 00:48:08,230
is a number versus a letter versus a color or a sound or an image or a video
是一个数字还是一个字母，还是一种颜色或声音或图像或视频

975
00:48:08,230 --> 00:48:11,048
is just context-dependent, like you're using Photoshop
仅仅取决于上下文，就像你在使用 Photoshop

976
00:48:11,048 --> 00:48:13,090
or you're using Microsoft Word or something else.
或者你正在使用 Microsoft Word 或其他一些东西。

977
00:48:13,090 --> 00:48:16,420
But last week, we saw a little more precisely that it's
但上周，我们更精确地看到了，它

978
00:48:16,420 --> 00:48:18,490
not quite as broad strokes as that.
并不像那样笼统。

979
00:48:18,490 --> 00:48:23,680
It's more about what the programmer has told the software is
更多的是关于程序员告诉软件存储的是什么

980
00:48:23,680 --> 00:48:25,690
being stored in a given variable.
存储在给定的变量中。

981
00:48:25,690 --> 00:48:26,590
Is it an integer?
是一个整数吗？

982
00:48:26,590 --> 00:48:28,180
Is it a char, a character?
是一个字符吗？

983
00:48:28,180 --> 00:48:29,350
Is it a whole string?
是一个字符串吗？

984
00:48:29,350 --> 00:48:31,610
Is it a longer integer or the like?
是一个较长的整数或类似的东西吗？

985
00:48:31,610 --> 00:48:33,460
So you now have this control.
所以你现在有了这种控制权。

986
00:48:33,460 --> 00:48:36,340
The catch, though, recall, though, is that each of these types
不过，请记住，这些类型中的每一个

987
00:48:36,340 --> 00:48:39,710
has only a finite amount of space allocated to it.
只分配了有限的空间。

988
00:48:39,710 --> 00:48:43,060
So for instance, an integer is typically 4 bytes,
例如，一个整数通常是 4 字节，

989
00:48:43,060 --> 00:48:46,780
and 4 bytes is 32 bits because it's 8 times 4.
4 字节是 32 位，因为它是 8 乘以 4。

990
00:48:46,780 --> 00:48:49,390
32 bits, we claimed, is roughly 4 billion,
我们声称，32 位大约是 40 亿，

991
00:48:49,390 --> 00:48:52,120
but if you want to represent negative and positive numbers,
但如果你想表示负数和正数，

992
00:48:52,120 --> 00:48:55,330
the biggest integer you can store is like 2 billion.
你可以存储的最大整数大约是 20 亿。

993
00:48:55,330 --> 00:48:57,650
Now that's really big for a lot of applications,
对于很多应用来说，这确实很大，

994
00:48:57,650 --> 00:48:59,950
but years ago, Facebook, for instance, was
但几年前，例如，Facebook 使用的是

995
00:48:59,950 --> 00:49:04,100
rumored to be using integers when they had fewer users.
整数，因为当时他们的用户还不多。

996
00:49:04,100 --> 00:49:06,790
But now that they have billions of users--
但现在他们拥有数十亿用户——

997
00:49:06,790 --> 00:49:12,100
3-plus billion users, an integer is no longer big enough for the Facebooks,
30 多亿用户，一个整数对于 Facebook、

998
00:49:12,100 --> 00:49:15,620
the Googles, the Microsofts and so forth of the world.
Google、微软等世界巨头来说已经不够大了。

999
00:49:15,620 --> 00:49:21,520
So we also have longs, which use twice as many bytes, but exponentially
所以我们还有 longs，它使用两倍的字节数，但可以表示指数级

1000
00:49:21,520 --> 00:49:23,080
bigger range of values.
更大范围的值。

1001
00:49:23,080 --> 00:49:26,260
Meanwhile, a bool, interestingly, is a byte, which
与此同时，一个 bool 很有趣，它是一个字节，这

1002
00:49:26,260 --> 00:49:29,550
is kind of bad design in what sense?
从某种意义上来说，是一种糟糕的设计？

1003
00:49:29,550 --> 00:49:31,780
Why might that be bad design?
为什么这可能是一种糟糕的设计？

1004
00:49:31,780 --> 00:49:33,590
It's only-- it should only be 2--
它应该只有 2——

1005
00:49:33,590 --> 00:49:36,170
1 bit, rather, because a 0 or 1 should suffice.
1 位，因为 0 或 1 就足够了。

1006
00:49:36,170 --> 00:49:38,440
Turns out, it's just easier to use a whole byte
事实证明，使用一个完整的字节更容易

1007
00:49:38,440 --> 00:49:40,900
even though we're wasting seven of those bits,
即使我们浪费了其中的七位，

1008
00:49:40,900 --> 00:49:43,750
but bools are represented nonetheless with 1 byte.
但 bools 仍然用 1 个字节表示。

1009
00:49:43,750 --> 00:49:45,400
Chars are going to be 1 byte.
Chars 将是 1 个字节。

1010
00:49:45,400 --> 00:49:47,890
Floats tend to be 4 bytes.
Floats 通常是 4 个字节。

1011
00:49:47,890 --> 00:49:49,390
Doubles tend to be 8 bytes.
Doubles 通常是 8 个字节。

1012
00:49:49,390 --> 00:49:52,510
Some of this is system-dependent, but nowadays on modern computers,
其中一些是系统相关的，但如今在现代计算机上，

1013
00:49:52,510 --> 00:49:54,250
this tends to be a useful rule of thumb.
这往往是一个有用的经验法则。

1014
00:49:54,250 --> 00:49:56,710
The only one I can't commit to here is a string
唯一一个我无法在这里确定的就是字符串

1015
00:49:56,710 --> 00:49:58,900
because a string, recall, is a sequence of text.
因为字符串，请记住，它是一系列文本。

1016
00:49:58,900 --> 00:50:02,800
And maybe it has no characters, one character, two, 10, 100.
它可能没有字符，一个字符，两个字符，十个字符，一百个字符。

1017
00:50:02,800 --> 00:50:05,410
So it's a variable number of bytes presumably
所以它可能是一个可变数量的字节，

1018
00:50:05,410 --> 00:50:08,590
where each byte represents a given character.
其中每个字节代表一个给定的字符。

1019
00:50:08,590 --> 00:50:12,370
So with that said, how do we get from an actual computer
所以，话虽如此，我们如何从实际的计算机

1020
00:50:12,370 --> 00:50:16,060
to information being represented therein?
得到其中表示的信息？

1021
00:50:16,060 --> 00:50:19,270
Well, let me remind us that this is what's inside of our Macs, PCs, phones.
好吧，让我提醒大家，这就是我们 Mac、PC 和手机内部的东西。

1022
00:50:19,270 --> 00:50:22,220
Even though this isn't a scale and it might not be the same shape,
即使这不是一个比例，它可能不是同一个形状，

1023
00:50:22,220 --> 00:50:24,520
this is memory, random access memory.
这就是内存，随机存取内存。

1024
00:50:24,520 --> 00:50:26,890
And on these black chips, on the circuit board
在这些黑色芯片上，在电路板上

1025
00:50:26,890 --> 00:50:29,360
here, are the bytes that we keep talking about.
这里，就是我们一直在谈论的字节。

1026
00:50:29,360 --> 00:50:31,940
In fact, let's go ahead and zoom in on one of these chips,
事实上，让我们放大其中一个芯片，

1027
00:50:31,940 --> 00:50:33,110
fill the screen here.
填充屏幕。

1028
00:50:33,110 --> 00:50:35,820
And just for an artist's depiction's sake,
为了艺术表现的需要，

1029
00:50:35,820 --> 00:50:38,480
let me propose that if you've got, I don't know,
我建议，如果你有，我不知道，

1030
00:50:38,480 --> 00:50:43,340
a megabyte, a gigabyte-- like a lot of bytes packed into this chip nowadays,
一个兆字节，一个吉字节——就像如今大量字节被压缩到这个芯片中一样，

1031
00:50:43,340 --> 00:50:46,100
it stands to reason that no matter how many of them you have,
这是有道理的，无论你有多少个，

1032
00:50:46,100 --> 00:50:48,398
we could just number them from top to bottom
我们可以从上到下编号

1033
00:50:48,398 --> 00:50:50,690
and we could say that this is byte 1, or you know what?
我们可以说，这是字节 1，或者你知道吗？

1034
00:50:50,690 --> 00:50:55,950
This is byte 0, 1, 2, 3, and this is maybe byte 1 billion or whatever it is.
这是字节 0、1、2、3，而这可能是字节 10 亿，或其他任何东西。

1035
00:50:55,950 --> 00:50:58,370
So you can think of memory as having addresses
你可以将内存想象成拥有地址

1036
00:50:58,370 --> 00:51:03,020
or just locations, numeric indices that identify each of those bytes
或者说是位置，数值索引用于识别每一个字节

1037
00:51:03,020 --> 00:51:03,710
individually.
单独地。

1038
00:51:03,710 --> 00:51:04,550
Why a byte?
为什么是一个字节？

1039
00:51:04,550 --> 00:51:08,300
Individual bits are not that useful, so 8, again, 1 byte
单个比特没有那么有用，所以，再一次，一个字节

1040
00:51:08,300 --> 00:51:10,400
tends to be the de facto standard.
往往成为事实上的标准。

1041
00:51:10,400 --> 00:51:14,360
Let me-- so, for instance, if you're storing just a single character,
让我…… 比如，如果你只是存储一个字符

1042
00:51:14,360 --> 00:51:18,570
a char, it might be stored literally in this top-left corner, so to speak,
一个 char，它可能被存储在，这么说吧，这个左上角

1043
00:51:18,570 --> 00:51:20,600
of the chip of memory.
的内存芯片上。

1044
00:51:20,600 --> 00:51:23,060
If you're storing maybe an integer, 4 bytes,
如果你存储的是一个整数，4 个字节

1045
00:51:23,060 --> 00:51:24,830
it might take up that many bytes.
它可能会占用那么多字节。

1046
00:51:24,830 --> 00:51:28,760
If you're storing a long, it might take up that many bytes instead.
如果你存储的是一个长整型，它可能会占用那么多字节。

1047
00:51:28,760 --> 00:51:31,520
Now we don't have to dwell on the particulars of the circuit board
现在我们不需要详细了解电路板

1048
00:51:31,520 --> 00:51:34,580
and these traces and all the connections, so let me just abstract
以及这些迹线和所有连接，所以我只是抽象一下

1049
00:51:34,580 --> 00:51:37,550
this away and claim that what your computer's memory really
它，并声称计算机内存实际上

1050
00:51:37,550 --> 00:51:41,060
is is just kind of this canvas, I mean kind of in the Photoshop sense.
是，就是这种画布，我的意思是，有点像 Photoshop 的意义。

1051
00:51:41,060 --> 00:51:43,040
If you've ever made pictures, it's just a grid
如果你曾经做过图片，它只是一个网格

1052
00:51:43,040 --> 00:51:46,220
of pixels, up, down, left, right, that's really all your memory is.
像素，上下左右，这就是你内存的全部。

1053
00:51:46,220 --> 00:51:51,110
It's this canvas that you can manipulate the bits on to store numbers anywhere
这就是这块画布，你可以操作上面的比特，在任何地方存储数字

1054
00:51:51,110 --> 00:51:53,190
you want in the computer's memory.
你想要在计算机内存中。

1055
00:51:53,190 --> 00:51:55,400
So in fact, let's zoom in here and let's consider
所以，事实上，让我们放大这里，并考虑

1056
00:51:55,400 --> 00:52:01,640
how your computer is actually storing information using just these bytes.
你的计算机实际上是如何使用这些字节来存储信息的。

1057
00:52:01,640 --> 00:52:04,190
At the end of the day, no matter how sophisticated
最终，无论你的 Mac，你的 PC，你的手机多么复杂

1058
00:52:04,190 --> 00:52:07,280
your Mac, your PC, your phone is, like this is all
你的 Mac，你的 PC，你的手机，它所拥有的一切

1059
00:52:07,280 --> 00:52:10,310
it has access to for storing information.
可以用来存储信息。

1060
00:52:10,310 --> 00:52:13,010
It's a canvas of bytes, and what you do with this
它是一个字节的画布，你用它做什么

1061
00:52:13,010 --> 00:52:15,720
now really invites design decisions.
现在确实需要一些设计决策。

1062
00:52:15,720 --> 00:52:17,000
So let's consider this.
所以，让我们考虑一下。

1063
00:52:17,000 --> 00:52:20,060
Here is an excerpt from a program wherein maybe I'm
这里是从一个程序中摘录的一部分，我可能

1064
00:52:20,060 --> 00:52:22,160
prompting the user for three scores.
提示用户输入三个分数。

1065
00:52:22,160 --> 00:52:24,950
Like three test, scores, exam scores, something like that.
就像三个考试分数，测验分数，诸如此类。

1066
00:52:24,950 --> 00:52:27,035
And the purpose in life of this program is maybe
这个程序的目的是，也许

1067
00:52:27,035 --> 00:52:28,910
to average those three scores together if you
将这三个分数加在一起取平均值，如果你

1068
00:52:28,910 --> 00:52:31,118
want to get a sense of where you stand in some class.
想了解你在某个班级的成绩如何。

1069
00:52:31,118 --> 00:52:33,290
So we can certainly whip up some code like this.
所以我们当然可以写出这样的代码。

1070
00:52:33,290 --> 00:52:37,370
And in just a moment, let me go ahead and flip over to VS Code here.
过一会儿，让我切换到 VS Code。

1071
00:52:37,370 --> 00:52:41,420
And I'll write up a new program called scores.c.
我会写一个名为 scores.c 的新程序。

1072
00:52:41,420 --> 00:52:46,460
And in this, let me go ahead and first include stdio.h,
在里面，我首先要包含 stdio.h，

1073
00:52:46,460 --> 00:52:48,710
int main void at the top.
int main void 在最上面。

1074
00:52:48,710 --> 00:52:51,750
And in here, let me go ahead and assume that, eh,
在里面，我假设，呃

1075
00:52:51,750 --> 00:52:53,250
it's not been the greatest semester.
这学期过得不太好。

1076
00:52:53,250 --> 00:52:56,930
So my first score, which I'll call score1, was a 72,
所以我的第一个分数，我叫它 score1，是 72，

1077
00:52:56,930 --> 00:53:03,050
my second score was a 73, but my third score, score3, was like a 33.
我的第二个分数是 73，但我的第三个分数，score3，是 33。

1078
00:53:03,050 --> 00:53:05,832
Now you might remember these numbers in another context,
你现在可能在另一个情境中记得这些数字

1079
00:53:05,832 --> 00:53:08,540
they might spell a message, but in this case, it's just integers.
它们可能拼出一个消息，但在这个例子中，它只是整数。

1080
00:53:08,540 --> 00:53:12,320
It's just numbers because I'm telling the computer to treat these as ints.
它只是数字，因为我告诉计算机将它们视为整数。

1081
00:53:12,320 --> 00:53:15,750
Now if I want to figure out what my average is, I can do a bit of math.
现在，如果我想知道我的平均成绩，我可以做一些数学运算。

1082
00:53:15,750 --> 00:53:18,770
So let me just print out that my average is--
所以，让我输出我的平均成绩是——

1083
00:53:18,770 --> 00:53:20,600
and I don't want to shortchange myself.
我不想低估自己。

1084
00:53:20,600 --> 00:53:23,910
I'm not going to use %i because I don't want to lose even anything after
我不会使用 %i，因为我不想丢失小数点后的任何东西

1085
00:53:23,910 --> 00:53:24,660
the decimal point.
小数点。

1086
00:53:24,660 --> 00:53:26,540
So we're going to use a float instead.
所以我们将使用浮点数。

1087
00:53:26,540 --> 00:53:33,230
And my average i claim will be score1 plus score2 plus score3
而我的平均成绩，我声称是 score1 加上 score2 加上 score3

1088
00:53:33,230 --> 00:53:36,200
divided by 3, semicolon.
除以 3，分号。

1089
00:53:36,200 --> 00:53:38,840
With parentheses, because just like grade school math,
用括号，因为就像小学数学一样

1090
00:53:38,840 --> 00:53:41,580
like order of operations, I parenthesize the numerator,
就像运算顺序一样，我把分子加了括号

1091
00:53:41,580 --> 00:53:43,670
so I can divide the whole thing by 3.
这样我才能把整个式子除以 3。

1092
00:53:43,670 --> 00:53:45,350
But I have screwed up already.
但我已经搞砸了。

1093
00:53:45,350 --> 00:53:49,370
I am going to shortchange myself and not give myself as high a grade
我要低估自己，不给自己一个那么高的分数

1094
00:53:49,370 --> 00:53:51,977
as I deserve, but this one's subtle.
如我应得，但这有点微妙。

1095
00:53:51,977 --> 00:53:52,935
What have I done wrong?
我做错了什么？

1096
00:53:56,230 --> 00:53:59,740
Yeah, I might want to cast these scores to floats
是的，我可能想把这些分数转换为浮点数

1097
00:53:59,740 --> 00:54:05,290
because if you do integral math, divide an integer or the sum of an integers--
因为如果你做整数运算，用一个整数或多个整数的和来除

1098
00:54:05,290 --> 00:54:09,710
some integers by an integer, it's going to be an integer as the result,
一些整数，结果会是一个整数

1099
00:54:09,710 --> 00:54:12,730
so it's going to throw away anything after the decimal point.
所以它会丢弃小数点后的任何东西。

1100
00:54:12,730 --> 00:54:15,970
Even if it's something-point-1, something-point-5, something-point-9,
即使是某个数点 1，某个数点 5，某个数点 9

1101
00:54:15,970 --> 00:54:18,010
that fraction is going to be thrown away.
那个分数会被丢弃。

1102
00:54:18,010 --> 00:54:19,750
There's a bunch of ways to fix this.
有很多方法可以解决这个问题。

1103
00:54:19,750 --> 00:54:22,810
I could just use floats or doubles for all of these.
我可以直接对所有这些使用浮点数或双精度浮点数。

1104
00:54:22,810 --> 00:54:26,140
I could cast score1, score2, or score3 as you propose.
我也可以像你建议的那样将 score1、score2 或 score3 转换为浮点数。

1105
00:54:26,140 --> 00:54:28,780
Frankly, the simplest way is just change the denominator
坦率地说，最简单的方法就是改变分母

1106
00:54:28,780 --> 00:54:31,840
because so long as I've got one float involved in the math,
因为只要我的数学运算中包含一个浮点数

1107
00:54:31,840 --> 00:54:35,950
this will promote the whole arithmetic expression to being floating point
这将使整个算术表达式变为浮点运算

1108
00:54:35,950 --> 00:54:37,690
math instead of integer math.
而不是整数运算。

1109
00:54:37,690 --> 00:54:41,110
So let me go ahead now and do make scores, Enter.
所以我现在要执行 make scores，回车。

1110
00:54:41,110 --> 00:54:45,100
So far, so good. ./scores, and my average seems to be not great,
目前为止，一切都好。./scores，我的平均成绩似乎不太好

1111
00:54:45,100 --> 00:54:47,140
but 59.33333--
但 59.33333——

1112
00:54:47,140 --> 00:54:47,950
so in the third.
所以排在第三名。

1113
00:54:47,950 --> 00:54:50,200
But I would have lost that third if I hadn't
但如果我没有

1114
00:54:50,200 --> 00:54:52,940
used a float in this particular way.
用这种特殊方式使用浮点数，我就可能丢掉第三名。

1115
00:54:52,940 --> 00:54:56,570
Well, let's consider now what's actually going on inside of the computer
现在让我们看看计算机内部实际发生了什么

1116
00:54:56,570 --> 00:54:58,650
when I store these three variables.
当我存储这三个变量的时候。

1117
00:54:58,650 --> 00:55:01,175
So, back to the grid here, just my canvas of memory.
所以，回到这个网格，我的内存画布。

1118
00:55:01,175 --> 00:55:03,050
It doesn't really matter where things end up.
实际上，最终的位置并不重要。

1119
00:55:03,050 --> 00:55:04,820
I might put it here, I might put it there,
我可能会把它放在这里，我可能会把它放在那里

1120
00:55:04,820 --> 00:55:06,510
the computer makes these decisions.
这些都是由计算机决定的。

1121
00:55:06,510 --> 00:55:10,500
But for the artist's sake, I'm going to put it at the top left-hand corner
但是，为了艺术家的考虑，我要把它放在左上角

1122
00:55:10,500 --> 00:55:11,000
here.
这里。

1123
00:55:11,000 --> 00:55:15,710
So, score1 is containing the integer 72.
所以，score1 包含整数 72。

1124
00:55:15,710 --> 00:55:20,580
Why is it taking up four squares, though?
但是，为什么它占用了四个方格呢？

1125
00:55:20,580 --> 00:55:22,040
Because?
因为？

1126
00:55:22,040 --> 00:55:23,030
It's an integer.
它是一个整数。

1127
00:55:23,030 --> 00:55:25,500
And on this system, an integer is 4 bytes.
在这个系统上，一个整数是 4 个字节。

1128
00:55:25,500 --> 00:55:30,170
So I've drawn it to scale, if you will. score2 is the number 73,
所以，如果可以的话，我已经按比例绘制了。score2 是数字 73

1129
00:55:30,170 --> 00:55:32,150
it also takes 4 bytes.
它也占用了 4 个字节。

1130
00:55:32,150 --> 00:55:34,850
By coincidence, but also by convention, it


1131
00:55:34,850 --> 00:55:38,180
will likely end up next to the first integer


1132
00:55:38,180 --> 00:55:40,970
in memory because I've only got three variables going on anyway,


1133
00:55:40,970 --> 00:55:44,360
so the computer quite likely will store them back to back to back.


1134
00:55:44,360 --> 00:55:48,110
And indeed, by that logic, score3, containing the number 33,


1135
00:55:48,110 --> 00:55:50,060
is going to fill in this space here.


1136
00:55:50,060 --> 00:55:51,917
We'll consider down the road what happens


1137
00:55:51,917 --> 00:55:53,750
if things get fragmented-- something's here,


1138
00:55:53,750 --> 00:55:55,875
something's here, something's here, but for now, we


1139
00:55:55,875 --> 00:55:59,507
can assume that this is probably contiguous, though not necessarily so.


1140
00:55:59,507 --> 00:56:01,340
All right, so that's pretty straightforward,


1141
00:56:01,340 --> 00:56:02,750
but what's really going on?


1142
00:56:02,750 --> 00:56:04,940
Well, these are just bytes of memory--


1143
00:56:04,940 --> 00:56:07,850
that is, bits of memory times 8.


1144
00:56:07,850 --> 00:56:10,460
And so what's really going on is this pattern


1145
00:56:10,460 --> 00:56:14,150
of 0's and 1's is being stored to represent 72.


1146
00:56:14,150 --> 00:56:16,280
This pattern of 0's and 1's is being stored


1147
00:56:16,280 --> 00:56:19,220
to represent 73, and similarly, 33.


1148
00:56:19,220 --> 00:56:22,750
But that's a very low level detail that we don't really care about,


1149
00:56:22,750 --> 00:56:27,550
so we'll generally just think about these as numbers like 72, 73, 33.


1150
00:56:27,550 --> 00:56:28,050
All right.


1151
00:56:28,050 --> 00:56:32,280
So if we go back to the actual code, though, here, I


1152
00:56:32,280 --> 00:56:35,250
wonder if this is the best idea.


1153
00:56:35,250 --> 00:56:38,280
These three lines of code are correct.


1154
00:56:38,280 --> 00:56:41,670
I got my 59 and 1/3 for my average, which I claim


1155
00:56:41,670 --> 00:56:46,740
is correct, but code-wise, this should maybe rub you the wrong way.


1156
00:56:46,740 --> 00:56:49,890
Even if you hadn't programmed before CS50,


1157
00:56:49,890 --> 00:56:53,250
why might this not be the best approach to storing things


1158
00:56:53,250 --> 00:56:57,170
like scores in a program?


1159
00:56:57,170 --> 00:56:58,670
How might this get us in trouble?


1160
00:56:58,670 --> 00:56:59,240
Yeah?


1161
00:56:59,240 --> 00:57:03,890
AUDIENCE: [INAUDIBLE]


1162
00:57:03,890 --> 00:57:04,670
DAVID MALAN: Yeah.


1163
00:57:04,670 --> 00:57:06,410
It's not the best because you have to use a whole bunch


1164
00:57:06,410 --> 00:57:08,180
of different variables for each score.


1165
00:57:08,180 --> 00:57:11,330
They're almost identically named, though, but just imagine


1166
00:57:11,330 --> 00:57:15,620
in almost any question involving the design of your code, what happens is n,


1167
00:57:15,620 --> 00:57:18,170
the number of things involved, gets larger?


1168
00:57:18,170 --> 00:57:21,950
Am I really going to start writing code that has score4, score5, score6,


1169
00:57:21,950 --> 00:57:23,270
score10, score20?


1170
00:57:23,270 --> 00:57:27,560
I mean, your code is just going to look like this mess of mostly copy-paste


1171
00:57:27,560 --> 00:57:30,227
except that the number at the end of the variable is changing.


1172
00:57:30,227 --> 00:57:32,810
Like that should make you cringe a little bit because it's not


1173
00:57:32,810 --> 00:57:34,610
going to end well eventually.


1174
00:57:34,610 --> 00:57:37,280
And typographical errors are going to get in the way most likely


1175
00:57:37,280 --> 00:57:38,447
because we'll make mistakes.


1176
00:57:38,447 --> 00:57:41,240
So how can we do a little bit better than that?


1177
00:57:41,240 --> 00:57:45,750
Well, let me propose that we introduce what we're going to now call an array.


1178
00:57:45,750 --> 00:57:52,950
An array is a sequence of values back to back to back in memory.


1179
00:57:52,950 --> 00:57:57,870
So an array is just a chunk of memory storing values back to back to back.


1180
00:57:57,870 --> 00:57:59,810
So no gaps, no fragmentation.


1181
00:57:59,810 --> 00:58:02,870
From left to right, top to bottom, just as I already drew.


1182
00:58:02,870 --> 00:58:05,550
But these arrays in C, at least, are going


1183
00:58:05,550 --> 00:58:09,070
to give a slightly new syntax that addresses exactly your concern.


1184
00:58:09,070 --> 00:58:14,580
So here instead is I would propose how you define a one variable--


1185
00:58:14,580 --> 00:58:19,890
not three, one variable called scores, plural, each of whose values


1186
00:58:19,890 --> 00:58:24,150
is going to be an int, and you want three integers tucked away


1187
00:58:24,150 --> 00:58:25,420
in that variable.


1188
00:58:25,420 --> 00:58:28,440
So now I can pluralize the name of my variable


1189
00:58:28,440 --> 00:58:32,010
because by using square brackets and the number 3, I'm telling the compiler,


1190
00:58:32,010 --> 00:58:36,510
give me enough room for not one, not two, but three integers in total.


1191
00:58:36,510 --> 00:58:39,240
And the computer is going to do me a favor by storing them back


1192
00:58:39,240 --> 00:58:41,790
to back to back in the computer's memory.


1193
00:58:41,790 --> 00:58:45,810
Now assigning values to these variables is almost the same,


1194
00:58:45,810 --> 00:58:47,460
but the syntax looks like this.


1195
00:58:47,460 --> 00:58:53,370
To assign the first value, I do scores, bracket, 0 equals whatever, 72.


1196
00:58:53,370 --> 00:58:58,560
scores, bracket, 1 equals 73; scores, bracket, 2 equals 33.


1197
00:58:58,560 --> 00:59:00,360
And it's square brackets consistently.


1198
00:59:00,360 --> 00:59:02,220
And notice, this is a feature--


1199
00:59:02,220 --> 00:59:04,080
or a downside of C.


1200
00:59:04,080 --> 00:59:07,980
We very frequently use the same syntax for slightly different ideas.


1201
00:59:07,980 --> 00:59:12,180
This first line tells the computer, give me an array of size 3.


1202
00:59:12,180 --> 00:59:16,830
These next three lines mean, go into this array at location 0


1203
00:59:16,830 --> 00:59:18,060
and put this value there.


1204
00:59:18,060 --> 00:59:21,280
Location 1, put this value there; location 2, put this value there.


1205
00:59:21,280 --> 00:59:24,690
So same syntax, but different meaning depending on the context here.


1206
00:59:24,690 --> 00:59:28,470
But the equal sign indeed means that this is assignment from right


1207
00:59:28,470 --> 00:59:30,340
to left just like last week.


1208
00:59:30,340 --> 00:59:33,750
So what does this mean in the computer's memory?


1209
00:59:33,750 --> 00:59:38,192
Well, in this case here, we now have a slightly different way of doing this.


1210
00:59:38,192 --> 00:59:39,900
And actually, let me do it first in code.


1211
00:59:39,900 --> 00:59:43,440
Let me go back to VS Code here, and let me


1212
00:59:43,440 --> 00:59:48,100
propose that instead of having these three separate variables,


1213
00:59:48,100 --> 00:59:52,590
let me give myself an int, scores variable of size 3,


1214
00:59:52,590 --> 00:59:58,590
and then do scores, bracket, 0 equals 72; scores, bracket, 1 equals 73;


1215
00:59:58,590 --> 01:00:02,100
scores, bracket, 2 equals 33.


1216
01:00:02,100 --> 01:00:05,730
And now I have to change this syntax slightly, but same idea.


1217
01:00:05,730 --> 01:00:12,660
scores, bracket, 0; scores, bracket, 1; and lastly, scores, bracket, 2.


1218
01:00:12,660 --> 01:00:14,640
So a couple of key details.


1219
01:00:14,640 --> 01:00:16,000
I started counting at 0.


1220
01:00:16,000 --> 01:00:16,500
Why?


1221
01:00:16,500 --> 01:00:18,210
That's just the way it is with arrays.


1222
01:00:18,210 --> 01:00:21,818
You must start counting at 0 unless you want to waste one of those spaces.


1223
01:00:21,818 --> 01:00:23,610
And what you definitely don't want to do is


1224
01:00:23,610 --> 01:00:27,030
go into scores, bracket, 3 because I only
进入分数，方括号，3，因为我只

1225
01:00:27,030 --> 01:00:29,190
ask the computer for three integers.
要求计算机提供三个整数。

1226
01:00:29,190 --> 01:00:32,190
If I blindly do something like this, you're going too far.
如果我盲目地做这样的事情，那就太过分了。

1227
01:00:32,190 --> 01:00:34,830
You're going beyond the end of the chunk of memory
你超出了内存块的末尾

1228
01:00:34,830 --> 01:00:37,080
and bad things will often happen.
而且通常会出现不好的事情。

1229
01:00:37,080 --> 01:00:38,770
So we won't do that just yet.
所以我们现在还不这样做。

1230
01:00:38,770 --> 01:00:43,030
But for now, 0, 1, and 2 are the first, second, and third locations.
但目前，0、1和2是第一个、第二个和第三个位置。

1231
01:00:43,030 --> 01:00:48,030
So if I recompile this code-- so make scores seems OK. ./scores,
所以如果我重新编译这段代码 - 所以分数看起来没问题。./scores，

1232
01:00:48,030 --> 01:00:50,607
and I get the exact same answer there.
我得到了完全相同的答案。

1233
01:00:50,607 --> 01:00:52,440
But let me make it more dynamic because this
但我让它更动态，因为这

1234
01:00:52,440 --> 01:00:56,670
is a little stupid that I'm compiling a program with my scores hardcoded.
我用我的分数硬编码编译程序，这有点愚蠢。

1235
01:00:56,670 --> 01:00:59,380
What if I have a fourth exam tomorrow or something like that?
如果我明天有第四次考试之类的事情怎么办？

1236
01:00:59,380 --> 01:01:01,110
So let's make it more dynamic and I think
所以让我们让它更动态，我认为

1237
01:01:01,110 --> 01:01:03,460
the syntax will start to make a little more sense.
语法将开始变得更有意义。

1238
01:01:03,460 --> 01:01:07,270
Let's go ahead and use get_int and ask the user for a score.
让我们继续使用 get_int 并询问用户分数。

1239
01:01:07,270 --> 01:01:10,270
Let's go ahead and get_int and ask the user for another score.
让我们继续使用 get_int 并询问用户另一个分数。

1240
01:01:10,270 --> 01:01:15,090
Let's go ahead and get_int and ask the user for a third score,
让我们继续使用 get_int 并询问用户第三个分数，

1241
01:01:15,090 --> 01:01:18,720
now storing the return values in each of those variables.
现在将返回值存储在每个变量中。

1242
01:01:18,720 --> 01:01:20,970
If I now do make scores--
如果我现在执行 make scores -

1243
01:01:20,970 --> 01:01:22,530
oh, darn it.
哦，该死。

1244
01:01:22,530 --> 01:01:24,830
a mistake.
犯了一个错误。

1245
01:01:24,830 --> 01:01:28,130
Similar to one I've made before, but we didn't see the error message last time.
与我之前犯过的错误类似，但我们上次没有看到错误信息。

1246
01:01:28,130 --> 01:01:28,880
What'd I do wrong?
我做错了什么？

1247
01:01:28,880 --> 01:01:30,165
Yeah?
是吗？

1248
01:01:30,165 --> 01:01:31,040
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1249
01:01:31,040 --> 01:01:31,770
DAVID MALAN: OK.
大卫·马兰：好的。

1250
01:01:31,770 --> 01:01:33,915
What did I do wrong-- how about over here?
我做错了什么 - 在这里呢？

1251
01:01:33,915 --> 01:01:34,790
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1252
01:01:34,790 --> 01:01:35,210
DAVID MALAN: Yeah.
大卫·马兰：对。

1253
01:01:35,210 --> 01:01:36,900
So I'm missing the CS50 header file.
所以，我缺少 CS50 头文件。

1254
01:01:36,900 --> 01:01:38,060
So how do you know that?
你怎么知道？

1255
01:01:38,060 --> 01:01:40,550
Well, implicit declaration of function get_int.
嗯，隐式声明函数 get_int。

1256
01:01:40,550 --> 01:01:42,350
So it just doesn't know what get_int is.
所以它不知道 get_int 是什么。

1257
01:01:42,350 --> 01:01:44,660
Well, who does know what get_int is?
好吧，谁知道 get_int 是什么？

1258
01:01:44,660 --> 01:01:47,010
The CS50 Library, that should be your first instinct.
CS50 库，这应该是你的第一直觉。

1259
01:01:47,010 --> 01:01:47,510
All right.
好吧。

1260
01:01:47,510 --> 01:01:51,620
Let me go to the top here and let me go ahead and squeeze in the CS50 Library
让我到顶端，然后我继续将 CS50 库挤进去

1261
01:01:51,620 --> 01:01:52,460
like this.
像这样。

1262
01:01:52,460 --> 01:01:54,140
Now let me clear my terminal.
现在让我清空我的终端。

1263
01:01:54,140 --> 01:01:55,312
make scores again.
再次执行 make scores。

1264
01:01:55,312 --> 01:01:56,270
We're back in business.
我们回来了。

1265
01:01:56,270 --> 01:02:00,320
And notice, I don't need to do -l cs50.
注意，我不需要执行 -l cs50。

1266
01:02:00,320 --> 01:02:05,490
make is doing that for me for clang, but we don't even see clang being executed,
make 正在为我执行 clang，但我们甚至看不到 clang 被执行，

1267
01:02:05,490 --> 01:02:09,120
but it is being executed underneath the hood, so to speak.
但它是在幕后执行的，可以这么说。

1268
01:02:09,120 --> 01:02:10,970
All right, so ./scores, here we go.
好吧，所以 ./scores，我们开始了。

1269
01:02:10,970 --> 01:02:13,340
72, 73, 33.
72、73、33。

1270
01:02:13,340 --> 01:02:17,630
Math is still the same, but now the program is more interactive.
数学仍然是一样的，但现在程序更具交互性。

1271
01:02:17,630 --> 01:02:20,520
Now this, too, hopefully should rub you the wrong way.
现在，我希望这也会让你感到不舒服。

1272
01:02:20,520 --> 01:02:25,790
This is correct, I would claim, but bad design still.
我认为这是正确的，但设计仍然不好。

1273
01:02:25,790 --> 01:02:28,460
Reeks of week 0 inefficiencies.
散发出第 0 周的低效率。

1274
01:02:28,460 --> 01:02:29,030
Yeah?
是吗？

1275
01:02:29,030 --> 01:02:33,793
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1276
01:02:33,793 --> 01:02:34,460
DAVID MALAN: OK.
大卫·马兰：好的。

1277
01:02:34,460 --> 01:02:37,160
So I could ask the human how many scores do you want to input?
所以我可以问人类，你想要输入多少分数？

1278
01:02:37,160 --> 01:02:38,310
Let's come back to that.
让我们回到这一点。

1279
01:02:38,310 --> 01:02:42,550
But I think even in this construct, what better could I do?
但即使在这种结构中，我还能做些什么呢？

1280
01:02:42,550 --> 01:02:43,510
Use a loop, right?
使用循环，对吧？

1281
01:02:43,510 --> 01:02:46,060
Because I'm literally doing the same thing again and again.
因为我实际上是重复做着同样的事情。

1282
01:02:46,060 --> 01:02:48,530
And notice, this number is just changing slightly.
注意，这个数字只是稍微改变了。

1283
01:02:48,530 --> 01:02:51,490
I would think that a little plus-plus could help there. get_int Score,
我认为一个小小的加加可以帮助解决这个问题。 get_int Score，

1284
01:02:51,490 --> 01:02:53,960
get_int Score, get_int Score-- that's the exact same thing.
get_int Score、get_int Score - 这完全一样。

1285
01:02:53,960 --> 01:02:56,120
So a loop is a perfect solution here.
所以循环是这里完美的解决方案。

1286
01:02:56,120 --> 01:02:59,980
So let me go over into this code here, and I can still for now
所以让我看看这段代码，目前我仍然可以

1287
01:02:59,980 --> 01:03:02,440
declare it to be of size 3, but I think I
声明它的大小为 3，但我认为我可以

1288
01:03:02,440 --> 01:03:07,340
could do something like this-- for int i get 0, i is less than 3,
可以做这样的事情 - for int i 等于 0，i 小于 3，

1289
01:03:07,340 --> 01:03:10,090
so I'm not going to make the same buggy mistake as I made earlier.
所以，我不会犯和我之前一样的错误。

1290
01:03:10,090 --> 01:03:11,260
I++.
i++。

1291
01:03:11,260 --> 01:03:15,850
Inside of the loop now, I can do scores, bracket, i, and now
现在在循环内部，我可以执行 scores，方括号，i，现在

1292
01:03:15,850 --> 01:03:18,010
arrays are getting really interesting because you
数组变得非常有趣，因为你

1293
01:03:18,010 --> 01:03:22,570
can use and reuse them, but dynamically go to a specific location.
可以使用和重用它们，但可以动态地跳转到特定的位置。

1294
01:03:22,570 --> 01:03:25,510
Equals get_int, quote-unquote, "Score."
等于 get_int，引号，"分数"。

1295
01:03:25,510 --> 01:03:29,110
Now I can type that phrase just once and this loop ultimately
现在我可以只输入一次这个短语，而这个循环最终

1296
01:03:29,110 --> 01:03:31,330
will do the same thing, but it's getting better.
会做同样的事情，但它正在变得更好。

1297
01:03:31,330 --> 01:03:34,720
The code is getting better designed because it's more compact
代码设计得更好，因为它更加紧凑

1298
01:03:34,720 --> 01:03:36,250
and I'm not repeating myself.
而且我不再重复自己。

1299
01:03:36,250 --> 01:03:38,020
72, 73, 33.
72、73、33。

1300
01:03:38,020 --> 01:03:42,530
Still works the same, but we're iteratively improving the code here.
仍然是同样的效果，但我们正在迭代地改进这里的代码。

1301
01:03:42,530 --> 01:03:48,500
Now how else-- there's one design flaw here that I still don't love
现在还有什么 - 这里有一个设计缺陷，我仍然不喜欢

1302
01:03:48,500 --> 01:03:49,710
it's a little more subtle.
它更加微妙。

1303
01:03:49,710 --> 01:03:51,160
Any observations?
有什么观察？

1304
01:03:51,160 --> 01:03:57,462
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1305
01:03:57,462 --> 01:03:58,670
DAVID MALAN: Ah, interesting.
大卫·马兰：啊，有趣。

1306
01:03:58,670 --> 01:04:01,460
So instead of dividing by 3.0, maybe I should divide it
所以，与其除以 3.0，也许我应该除以

1307
01:04:01,460 --> 01:04:05,480
by the array size, which at the moment is technically still 3,
数组大小，目前技术上仍然是 3，

1308
01:04:05,480 --> 01:04:10,670
but I do concur that that is worrisome because they could get out of sync.
但我同意，这令人担忧，因为它们可能不同步。

1309
01:04:10,670 --> 01:04:13,550
But there's something else that still isn't quite right.
但还有其他一些地方不太对劲。

1310
01:04:13,550 --> 01:04:14,965
Yeah?
是吗？

1311
01:04:14,965 --> 01:04:19,090
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1312
01:04:19,090 --> 01:04:22,292
DAVID MALAN: I'm OK moving to this zero-indexed model.
大卫·马兰：我不介意转向这种从零开始的索引模型。

1313
01:04:22,292 --> 01:04:23,500
So this is a new term of art.
所以这是一个新的术语。

1314
01:04:23,500 --> 01:04:27,470
To index into an array means to go to a specific location.
索引到数组意味着跳转到特定的位置。

1315
01:04:27,470 --> 01:04:31,120
So here, I'm indexing into location i, but i is going
所以，在这里，我正在索引到位置 i，但 i 将要

1316
01:04:31,120 --> 01:04:33,250
to start at 0 and then 1 and then 2.
从 0 开始，然后是 1，然后是 2。

1317
01:04:33,250 --> 01:04:34,390
I'm actually OK with that.
我实际上对这一点没有意见。

1318
01:04:34,390 --> 01:04:37,600
Even though in common day life we would say score1, score2, score3,
即使在日常生活中我们会说分数 1，分数 2，分数 3，

1319
01:04:37,600 --> 01:04:39,730
as a programmer, I just have to get into the habit
作为一名程序员，我必须养成

1320
01:04:39,730 --> 01:04:43,450
of saying score0, score1, score2 now.
现在说分数 0，分数 1，分数 2 的习惯。

1321
01:04:43,450 --> 01:04:44,350
But something else.
但还有其他事情。

1322
01:04:44,350 --> 01:04:45,306
Yeah?
是吗？

1323
01:04:45,306 --> 01:04:47,540
AUDIENCE: I could compute the average.
观众：我可以计算平均值。

1324
01:04:47,540 --> 01:04:49,850
DAVID MALAN: I could also compute the average in a loop
大卫·马兰： 我也可以在循环中计算平均值

1325
01:04:49,850 --> 01:04:54,290
because indeed, this is only going-- so solving the problem halfway.
因为实际上，这仅仅是解决问题的一半。

1326
01:04:54,290 --> 01:04:56,240
I'm gathering the information in the loop,
我在循环中收集信息，

1327
01:04:56,240 --> 01:04:58,200
but then I'm manually writing it all out.
但是之后我又手动把所有信息都写出来。

1328
01:04:58,200 --> 01:05:01,730
So it does feel like there should be a better solution here.
所以感觉这里应该有更好的解决方案。

1329
01:05:01,730 --> 01:05:05,540
But let me also identify one other issue I really don't like,
但让我指出另一个我不喜欢的点，

1330
01:05:05,540 --> 01:05:06,710
and this is, indeed, subtle.
这确实很微妙。

1331
01:05:06,710 --> 01:05:11,180
I've got 3 here, I've got 3 here, and I essentially have 3 here,
这里有 3，这里也有 3，这里本质上也有 3，

1332
01:05:11,180 --> 01:05:12,750
albeit a floating point version.
尽管是浮点数版本。

1333
01:05:12,750 --> 01:05:16,550
This is just ripe for me making a mistake eventually and changing one
这样很容易让我最终犯错，改变其中一个

1334
01:05:16,550 --> 01:05:18,840
of those values, but not the other two?
值，而不是另外两个？

1335
01:05:18,840 --> 01:05:20,090
So how might I fix this?
那么我该如何解决呢？

1336
01:05:20,090 --> 01:05:22,200
I might at least do something like this.
我至少可以做这样的事。

1337
01:05:22,200 --> 01:05:28,010
I could say integer maybe n for scores, I'll set that equal to 3.
我可以说整数，比如 scores 的 n，我将其设置为 3。

1338
01:05:28,010 --> 01:05:31,430
I could then use n here, I could use n here.
然后我可以在此处使用 n，也可以在此处使用 n。

1339
01:05:31,430 --> 01:05:33,742
I could use n here, but that's a step backwards
我可以在此处使用 n，但这是一种倒退

1340
01:05:33,742 --> 01:05:36,950
because I don't want an int because I'm going to run into the same math issue
因为我不想要一个 int，因为我将遇到与之前相同数学问题

1341
01:05:36,950 --> 01:05:40,250
as before, but I could convert it-- that is, cast it to a float,
就像之前一样，但我可以将其转换，即将其转换为浮点数，

1342
01:05:40,250 --> 01:05:42,920
and we did that briefly last week.
我们上周简单地做了这件事。

1343
01:05:42,920 --> 01:05:47,730
But there's one other thing I could do here that we did introduce last week.
但还有另一件事，我们上周介绍过。

1344
01:05:47,730 --> 01:05:51,150
This is better because I don't have a magic number floating around
这样做更好，因为我没有一个魔法数字到处乱飘

1345
01:05:51,150 --> 01:05:53,490
in multiple places.
在多个地方。

1346
01:05:53,490 --> 01:05:56,160
Yeah, if I really want to be proper, I should probably
是的，如果我真想严格一点，我应该

1347
01:05:56,160 --> 01:05:58,440
say this should be a constant integer.
说这应该是一个常量整数。

1348
01:05:58,440 --> 01:05:58,950
Why?
为什么？

1349
01:05:58,950 --> 01:06:01,200
Because I don't want to accidentally change it myself.
因为我不想意外地自己改变它。

1350
01:06:01,200 --> 01:06:03,242
I don't want to be collaborating with a colleague
我不想与同事合作

1351
01:06:03,242 --> 01:06:04,800
and they foolishly change it on me.
然后他们愚蠢地改变它。

1352
01:06:04,800 --> 01:06:09,060
This just sends a stronger signal to the compiler, do not let the humans change
这样向编译器发送更强烈的信号，不要让人类改变

1353
01:06:09,060 --> 01:06:10,000
this value.
这个值。

1354
01:06:10,000 --> 01:06:12,960
And now just to point out one other feature of C,
现在，只是指出 C 语言的另一个特性，

1355
01:06:12,960 --> 01:06:16,650
if you have a number like this, like the number 3,
如果你有一个像这样的数字，比如数字 3，

1356
01:06:16,650 --> 01:06:18,990
I've deliberately capitalized this variable name really
我特意将这个变量名首字母大写，

1357
01:06:18,990 --> 01:06:19,915
for the first time.
这是第一次。

1358
01:06:19,915 --> 01:06:22,290
Any time you have a constant, it tends to be a convention
任何时候你有一个常量，它往往是一个约定

1359
01:06:22,290 --> 01:06:25,000
to capitalize it just to draw your attention to it.
将其首字母大写只是为了引起你的注意。

1360
01:06:25,000 --> 01:06:26,580
It doesn't mean anything technically.
从技术上讲，这没有任何意义。

1361
01:06:26,580 --> 01:06:28,950
Capitalizing a variable does nothing to it,
将变量首字母大写对其没有任何影响，

1362
01:06:28,950 --> 01:06:31,660
but it draws attention visually to it to the human.
但它在视觉上提醒了人类。

1363
01:06:31,660 --> 01:06:33,930
So if you declare something as a constant,
因此，如果你将某个东西声明为常量，

1364
01:06:33,930 --> 01:06:37,050
it's commonplace to capitalize it just because.
通常的做法就是将其首字母大写。

1365
01:06:37,050 --> 01:06:41,790
Moreover, if you have a constant that you might want to occasionally modify--
此外，如果你有一个你可能偶尔想要修改的常量 -

1366
01:06:41,790 --> 01:06:45,660
maybe next semester when there's four exams or five exams instead of three,
也许下学期会有四次或五次考试，而不是三次，

1367
01:06:45,660 --> 01:06:48,900
it actually is OK sometimes to define what
实际上，有时可以定义

1368
01:06:48,900 --> 01:06:52,080
might be called a global variable, a variable that is not
可以称之为全局变量，一个不在

1369
01:06:52,080 --> 01:06:57,280
inside of curly braces, it's literally at the top of the file outside of main,
花括号内，它实际上位于文件顶部，main 函数之外，

1370
01:06:57,280 --> 01:06:59,890
and despite what I said about scope last week,
尽管上周我说了关于作用域的事情，

1371
01:06:59,890 --> 01:07:05,170
a global variable like this on line 4 will be in scope
像第 4 行这样的全局变量将在这个作用域内

1372
01:07:05,170 --> 01:07:07,550
to every function in this file.
对这个文件中的每个函数都有效。

1373
01:07:07,550 --> 01:07:09,880
So it's actually a way of sharing a variable
所以这实际上是一种在

1374
01:07:09,880 --> 01:07:13,090
across multiple functions, which is generally fine if you're
多个函数之间共享变量的方法，如果你使用的是常量，通常没问题。

1375
01:07:13,090 --> 01:07:14,230
using a constant.
使用常量。

1376
01:07:14,230 --> 01:07:18,010
If you intend to change it, there's probably a better way
如果你打算改变它，可能还有更好的方法

1377
01:07:18,010 --> 01:07:21,310
than actually using a global variable, but this is just
而不是真的使用全局变量，但这仅仅是

1378
01:07:21,310 --> 01:07:23,620
in contrast to what I previously did, which I would
与我之前所做的形成对比，我会将其称之为

1379
01:07:23,620 --> 01:07:26,810
call, by contrast, a local variable.
对比而言，一个局部变量。

1380
01:07:26,810 --> 01:07:30,563
But again, I'm just trying to reduce the probability of making mistakes
但再一次，我只是想降低犯错的概率

1381
01:07:30,563 --> 01:07:31,480
somewhere in the code.
在代码中的某个地方。

1382
01:07:31,480 --> 01:07:32,170
And I do agree.
我同意。

1383
01:07:32,170 --> 01:07:35,560
I don't like that I'm still adding all of these scores
我不喜欢我仍然手动添加所有这些分数

1384
01:07:35,560 --> 01:07:39,130
manually even though clearly I had a loop a moment ago.
手动添加，尽管我刚才明显使用了循环。

1385
01:07:39,130 --> 01:07:40,990
But for now, let's at least consider what's
但现在，让我们至少考虑一下

1386
01:07:40,990 --> 01:07:43,130
been going on inside of the computer's memory.
计算机内存中发生了什么。

1387
01:07:43,130 --> 01:07:48,880
So with this array, I now have not three variables, score1, score2, score3.
因此，使用这个数组，我现在不是三个变量，score1，score2，score3。

1388
01:07:48,880 --> 01:07:53,530
I have one variable, an array variable, called scores, plural.
我有一个变量，一个数组变量，称为 scores，复数形式。

1389
01:07:53,530 --> 01:07:57,700
And if I want to access the first element, its scores, bracket, 0.
如果我想访问第一个元素，就是 scores，中括号，0。

1390
01:07:57,700 --> 01:08:00,400
If I want to access the second element, its scores, bracket, 1.
如果我想访问第二个元素，就是 scores，中括号，1。

1391
01:08:00,400 --> 01:08:03,100
If I want to access the third element, it's scores, bracket, 2.
如果我想访问第三个元素，就是 scores，中括号，2。

1392
01:08:03,100 --> 01:08:07,480
If I were to make a mistake and do scores, bracket, 3,
如果我犯错，写成 scores，中括号，3，

1393
01:08:07,480 --> 01:08:11,380
which is the fourth element, I'd end up in no man's land here,
这是第四个元素，我将陷入无人区，

1394
01:08:11,380 --> 01:08:15,307
and worst case, your program could crash or something weird will happen,
最糟糕的情况是，你的程序可能会崩溃，或者发生一些奇怪的事情，

1395
01:08:15,307 --> 01:08:17,140
spinning beach balls, those kinds of things.
出现旋转的沙漏，类似的事情。

1396
01:08:17,140 --> 01:08:18,910
Just don't make those mistakes.
不要犯这种错误。

1397
01:08:18,910 --> 01:08:21,310
And C makes it easy to make those mistakes,
C 语言很容易让你犯这些错误，

1398
01:08:21,310 --> 01:08:25,300
so the onus is really on you programmatically.
所以责任实际上在你，你需要通过编程来解决。

1399
01:08:25,300 --> 01:08:31,960
Questions on this use of arrays?
关于数组的这种使用，有什么问题吗？

1400
01:08:31,960 --> 01:08:33,580
Question on this use of arrays?
关于数组的这种使用，有什么问题吗？

1401
01:08:33,580 --> 01:08:34,359
Yeah, in back.
是的，后面那位。

1402
01:08:34,359 --> 01:08:36,283
AUDIENCE: Is there any way [INAUDIBLE]?
观众： 有没有办法 [听不清]？

1403
01:08:43,870 --> 01:08:45,370
DAVID MALAN: A really good question.
大卫·马兰： 非常好的问题。

1404
01:08:45,370 --> 01:08:48,279
Is there any way to create an array just by using syntax alone
有没有办法只使用语法，

1405
01:08:48,279 --> 01:08:49,899
without prompting the human for it?
而不提示用户？

1406
01:08:49,899 --> 01:08:51,490
Short answer, yes.
简短的回答是，可以。

1407
01:08:51,490 --> 01:08:56,529
If you want to have an array of integers called, for instance, array,
如果你想要一个叫做 array 的整数数组，

1408
01:08:56,529 --> 01:09:01,090
you could actually do like 13, 42, 50, something like this,
你实际上可以写成 13, 42, 50，类似这样的形式，

1409
01:09:01,090 --> 01:09:04,300
would give you an array if you use this syntax.
如果你使用这种语法，它将给你一个数组。

1410
01:09:04,300 --> 01:09:08,680
This would give you an array of size 3 where the three values by default
这样会给你一个大小为 3 的数组，其中三个值默认情况下

1411
01:09:08,680 --> 01:09:10,600
are 13, 42 and 50.
分别为 13, 42 和 50。

1412
01:09:10,600 --> 01:09:13,370
It's not syntax we'll use for now, but there is syntax like that.
我们现在不会使用这种语法，但确实存在这样的语法。

1413
01:09:13,370 --> 01:09:15,970
It's not quite as user-friendly, though, as other languages
不过，它不像其他语言那样用户友好

1414
01:09:15,970 --> 01:09:19,060
if you've indeed programmed before.
如果你以前确实进行过编程。

1415
01:09:19,060 --> 01:09:24,439
Other questions on this use of arrays?
关于数组的这种使用，还有其他问题吗？

1416
01:09:24,439 --> 01:09:26,550
Yeah, in front.
是的，前面那位。

1417
01:09:26,550 --> 01:09:29,050
AUDIENCE: [INAUDIBLE]
观众： [听不清]

1418
01:09:29,050 --> 01:09:30,924
DAVID MALAN: Is there a way to copy what?
大卫·马兰： 有没有办法复制什么？

1419
01:09:30,924 --> 01:09:33,399
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1420
01:09:33,399 --> 01:09:36,310
DAVID MALAN: Oh, is there a way to calculate the length of an array?
大卫·马兰：哦，有没有办法计算数组的长度？

1421
01:09:36,310 --> 01:09:39,910
Short answer, no, and I'm about to show you one demonstration of this.
简短的回答，没有，我将展示一个演示。

1422
01:09:39,910 --> 01:09:43,899
Those of you who have programmed before in Java, in JavaScript,
你们中之前用 Java 或 JavaScript 编程过的人，

1423
01:09:43,899 --> 01:09:47,270
in certain other languages, it's very easy to get the length of an array.
在其他某些语言中，获取数组的长度非常容易。

1424
01:09:47,270 --> 01:09:49,720
You essentially just ask the array, what's its length?
你只需要问问数组，它的长度是多少？

1425
01:09:49,720 --> 01:09:51,880
C does not give you that capability.
C 语言没有提供这种功能。

1426
01:09:51,880 --> 01:09:56,560
The onus is entirely on you and me to remember, s as with another variable,
记住数组的长度，就像其他变量一样，

1427
01:09:56,560 --> 01:09:59,300
like n, how long the array is.
就像变量 n 一样，记住数组的长度。

1428
01:09:59,300 --> 01:10:01,760
And so in fact, let me go ahead and do this.
实际上，让我继续做这件事。

1429
01:10:01,760 --> 01:10:06,430
I'm going to go ahead and open up a baking style, a program
我将打开一个烘焙风格的程序，

1430
01:10:06,430 --> 01:10:09,940
that I wrote in advance here which kind of escalates quickly,
我提前写好的，它会很快升级，

1431
01:10:09,940 --> 01:10:13,990
but there's not really too many new ideas here except for the array
除了数组之外，这里没有太多新想法，

1432
01:10:13,990 --> 01:10:14,800
specifics.
细节。

1433
01:10:14,800 --> 01:10:19,450
So this is scores.c premade this time.
所以这次是预先制作的 scores.c。

1434
01:10:19,450 --> 01:10:20,650
And notice what I have.
注意我有什么。

1435
01:10:20,650 --> 01:10:25,750
One, I've included cs50.h and stdio.h at the top, so that's the same.
首先，我在顶部包含了 cs50.h 和 stdio.h，所以这和之前一样。

1436
01:10:25,750 --> 01:10:28,630
I have declared a constant called n, set it equal to 3.
我声明了一个名为 n 的常量，并将其设置为 3。

1437
01:10:28,630 --> 01:10:31,270
That is now the same as of my most recent change.
这与我最近的修改相同。

1438
01:10:31,270 --> 01:10:36,380
I did introduce an average function, which was one of the remaining concerns
我引入了一个 average 函数，这是我剩下的一个问题，

1439
01:10:36,380 --> 01:10:40,220
that I could compute the average with some kind of loop, too.
我可以使用某种循环计算平均值。

1440
01:10:40,220 --> 01:10:42,980
That average function is going to return a float, which is what.
average 函数将返回一个浮点数，也就是。

1441
01:10:42,980 --> 01:10:46,100
I want my average to be a float with the fraction.
我希望我的平均值是一个带小数的浮点数。

1442
01:10:46,100 --> 01:10:47,180
But notice this.
但请注意这一点。

1443
01:10:47,180 --> 01:10:50,360
In answer to your question, if I want a function called
为了回答你的问题，如果我想要一个名为

1444
01:10:50,360 --> 01:10:55,100
average to do something iterate over an array step by step by step,
average 的函数来做一些事情，一步步地遍历数组，

1445
01:10:55,100 --> 01:10:58,430
add up all the numbers, and divide by the total number of numbers,
将所有数字加起来，然后除以数字总数，

1446
01:10:58,430 --> 01:11:03,350
I need to give it the array of numbers, and I need to tell it how many of those
我需要将数字数组传递给它，并且需要告诉它有多少个

1447
01:11:03,350 --> 01:11:03,950
numbers are.
数字。

1448
01:11:03,950 --> 01:11:06,230
So I literally have to pass in two values.
因此我必须传递两个值。

1449
01:11:06,230 --> 01:11:09,890
Meanwhile, this code is the same as before inside of main.
同时，这段代码在 main 函数内部与之前相同。

1450
01:11:09,890 --> 01:11:13,430
I'm declaring a variable called scores of size n.
我声明了一个名为 scores 的变量，大小为 n。

1451
01:11:13,430 --> 01:11:16,430
I'm iterating from i to n.
我从 i 迭代到 n。

1452
01:11:16,430 --> 01:11:17,990
And actually-- yep.
实际上 - 是的。

1453
01:11:17,990 --> 01:11:22,520
And then in this loop, I'm assigning each of the scores a return
然后在这个循环中，我为每个分数分配一个返回值

1454
01:11:22,520 --> 01:11:23,750
value of get_int.
get_int 的值。

1455
01:11:23,750 --> 01:11:27,350
The last line of main is this-- print out the average with f,
main 函数的最后一行是 - 使用 f 打印平均值，

1456
01:11:27,350 --> 01:11:31,280
but don't just do it manually by adding and dividing with parentheses.
但不要使用括号手动进行加法和除法。

1457
01:11:31,280 --> 01:11:36,080
Call the average function, pass in the length of the array and the array
调用 average 函数，传入数组的长度和数组

1458
01:11:36,080 --> 01:11:41,810
itself, and hope that it returns a float that then gets plugged into percent f
本身，并希望它返回一个浮点数，然后被插入到百分号 f 中

1459
01:11:41,810 --> 01:11:45,260
So I would claim that pretty much all of this, even though it's a lot,
所以我会说，尽管代码量很大，但这几乎所有东西

1460
01:11:45,260 --> 01:11:46,550
should be familiar.
都应该很熟悉。

1461
01:11:46,550 --> 01:11:50,780
There's no real new ideas except for this use of the global variable now
除了现在使用全局变量以及

1462
01:11:50,780 --> 01:11:52,590
and this average function.
average 函数之外，没有真正的新想法。

1463
01:11:52,590 --> 01:11:54,740
So let me scroll down to the average function
所以让我向下滚动到 average 函数，

1464
01:11:54,740 --> 01:11:57,530
because this is the takeaway from this final example.
因为这是从这个最后的例子中得到的启示。

1465
01:11:57,530 --> 01:11:59,570
In this example here--
在这个例子中 -

1466
01:11:59,570 --> 01:12:01,640
let me scroll up to the average function,
让我向上滚动到 average 函数，

1467
01:12:01,640 --> 01:12:04,790
copy-pasted the prototype for the very first line.
复制粘贴了第一行的原型。

1468
01:12:04,790 --> 01:12:06,980
And here's how I'm computing the average.
这是我计算平均值的方法。

1469
01:12:06,980 --> 01:12:11,240
There's different ways of doing this, but here's an accumulator way.
有多种方法可以做到这一点，但这里是一种累加器方法。

1470
01:12:11,240 --> 01:12:15,260
On line 28, I'm declaring a variable inside of the average function called
在第 28 行，我在 average 函数内部声明了一个名为

1471
01:12:15,260 --> 01:12:17,540
sum, and I'm just initializing it to 0.
sum 的变量，并且将其初始化为 0。

1472
01:12:17,540 --> 01:12:18,050
Why?
为什么？

1473
01:12:18,050 --> 01:12:20,630
Mentally I want to add up all of the person scores
在脑海中，我想将所有人的分数加起来

1474
01:12:20,630 --> 01:12:24,480
and then I want to divide by the total and that's my mathematical average.
然后除以总数，这就是我的数学平均值。

1475
01:12:24,480 --> 01:12:28,970
So here's my loop where I'm iterating from 0 up to, but not
所以这是我的循环，我从 0 迭代到，但不包括

1476
01:12:28,970 --> 01:12:32,060
through the length-- so that should be three times.
长度 - 因此应该是三次。

1477
01:12:32,060 --> 01:12:37,950
I am adding to the sum variable whatever is at the i-th location, so to speak,
我将 i 位置的值添加到 sum 变量中，可以这么说，

1478
01:12:37,950 --> 01:12:38,850
of the array.
数组中的值。

1479
01:12:38,850 --> 01:12:42,050
So this is array, bracket 0; array, bracket, 1; array, bracket,
所以这是数组，方括号 0；数组，方括号，1；数组，方括号，

1480
01:12:42,050 --> 01:12:43,860
2 on each iteration.
在每次迭代中都是 2。

1481
01:12:43,860 --> 01:12:46,670
And then the last thing I'm doing is a nice one-liner.
最后我要做的是一个简洁的一行代码。

1482
01:12:46,670 --> 01:12:51,470
I'm dividing the sum, which is an int, which is the sum of 72, 73, 33,
我将 sum 除以 length，sum 是一个整数，是 72、73、33 的总和，

1483
01:12:51,470 --> 01:12:56,550
divided by the length, which is 3, but 3 is not a float, so I cast it to a float
除以 length，length 是 3，但 3 不是浮点数，所以将其强制转换为浮点数

1484
01:12:56,550 --> 01:13:03,060
so that the end value, hopefully, is going to be 59.33333 and so forth.
这样，最终的值，希望是 59.33333 等等。

1485
01:13:03,060 --> 01:13:06,380
So the only thing that's weird syntactically is this, though.
所以唯一语法上奇怪的是这个。

1486
01:13:06,380 --> 01:13:10,430
When you define a function in C that takes an argument that isn't just
在 C 语言中定义一个函数，它接受一个参数，该参数不仅仅是

1487
01:13:10,430 --> 01:13:14,640
a simple char, isn't just a simple integer, it's actually an array,
一个简单的字符，也不仅仅是一个简单的整数，它实际上是一个数组，

1488
01:13:14,640 --> 01:13:17,090
you don't have to know the array's length in advance.
你不必提前知道数组的长度。

1489
01:13:17,090 --> 01:13:19,820
You can just put square brackets after the name you give it.
你只需要在给它起的名字后面加上方括号。

1490
01:13:19,820 --> 01:13:21,237
And I don't have to call it array.
我无需称它为 array。

1491
01:13:21,237 --> 01:13:23,930
I could call it x or y or z or anything else.
我可以称它为 x 或 y 或 z 或其他任何东西。

1492
01:13:23,930 --> 01:13:26,390
I called it array just to make clear that it's an array,
我称之为 array 只是为了明确它是一个数组，

1493
01:13:26,390 --> 01:13:30,620
but you do need to know the length somehow.
但你必须以某种方式知道长度。

1494
01:13:30,620 --> 01:13:31,120
OK.
好的。

1495
01:13:31,120 --> 01:13:37,820
Questions on combining those ideas in that there way?
关于将这些想法以这种方式组合在一起，有什么问题吗？

1496
01:13:41,170 --> 01:13:42,980
Any questions?
还有其他问题吗？

1497
01:13:42,980 --> 01:13:43,850
No?
没有？

1498
01:13:43,850 --> 01:13:44,420
All right.
好的。

1499
01:13:44,420 --> 01:13:46,790
Well, we've only dealt with numbers thus far.
好吧，到目前为止，我们只处理了数字。

1500
01:13:46,790 --> 01:13:50,340
It would be nice to actually deal with letters and words and paragraphs
能够处理字母、单词和段落，

1501
01:13:50,340 --> 01:13:52,340
and the like, much like our readability example,
等等，就像我们的可读性示例一样，

1502
01:13:52,340 --> 01:13:56,150
but I think first, some snacks and some fruit are served in the transept.
但我认为首先，一些小吃和水果将在横廊提供。

1503
01:13:56,150 --> 01:13:57,140
So we'll see you in 10.
所以我们 10 分钟后再见。

1504
01:13:57,140 --> 01:13:59,480
See you in 10.
10 分钟后再见。

1505
01:13:59,480 --> 01:14:00,320
All right.
好的。

1506
01:14:00,320 --> 01:14:01,190
So we're back.
所以我们回来了。

1507
01:14:01,190 --> 01:14:02,960
And up until now, we've been representing
直到现在，我们一直在表示

1508
01:14:02,960 --> 01:14:05,060
just numbers underneath the hood, but we've
只是幕后数字，但我们已经

1509
01:14:05,060 --> 01:14:07,760
introduced arrays, which gave us this ability, recall,
引入了数组，它赋予了我们这种能力，记得吗？

1510
01:14:07,760 --> 01:14:10,260
to store numbers back to back to back.
存储连续的数字。

1511
01:14:10,260 --> 01:14:13,310
So it turns out, you actually had this capability for the past
事实证明，你实际上在上周就拥有了这种能力，

1512
01:14:13,310 --> 01:14:15,620
week even though you might not have realized it.
即使你可能没有意识到。

1513
01:14:15,620 --> 01:14:19,100
And let me propose that we first consider very simple example of three
让我们先考虑一个非常简单的例子，有三个

1514
01:14:19,100 --> 01:14:20,750
chars instead of three integers.
字符，而不是三个整数。

1515
01:14:20,750 --> 01:14:23,390
And for simplistically, I'm going to call them c1, c2,
为了简单起见，我将它们称为 c1、c2，

1516
01:14:23,390 --> 01:14:25,400
and c3 just for the sake of discussion.
以及 c3，仅供讨论。

1517
01:14:25,400 --> 01:14:29,090
But I'm going to put our familiar characters, "HI!"
但是，我将使用单引号将我们熟悉的字符“HI！”

1518
01:14:29,090 --> 01:14:32,330
in those variables using single quotes because again.
放入这些变量中，因为再次。

1519
01:14:32,330 --> 01:14:35,900
That's what you do when using individual chars
这就是使用单个字符时要做的

1520
01:14:35,900 --> 01:14:40,282
to make the point that I can store three chars in three separate variables.
是为了说明我可以在三个单独的变量中存储三个字符。

1521
01:14:40,282 --> 01:14:41,990
So let me go ahead and go over to VS Code
所以让我继续去 VS Code

1522
01:14:41,990 --> 01:14:45,180
here and let me create something called hi.c.
这里，让我创建一个名为 hi.c 的文件。

1523
01:14:45,180 --> 01:14:50,970
And in this program, I'll first include stdio.h, int main void as before.
在这个程序中，我将首先包含 stdio.h，int main void，如前所述。

1524
01:14:50,970 --> 01:14:53,430
And then inside of main, let's just do exactly that.
然后在 main 内部，我们只需要做这些。

1525
01:14:53,430 --> 01:14:57,540
Char c1 equals, quote-unquote, capital H. Char C2 equals,
Char c1 等于，引号，大写 H。Char C2 等于，

1526
01:14:57,540 --> 01:15:00,420
quote-unquote, capital I. Char C3 equals,
引号，大写 I。Char C3 等于，

1527
01:15:00,420 --> 01:15:02,550
quote-unquote, exclamation point.
引号，感叹号。

1528
01:15:02,550 --> 01:15:06,450
So clearly not the best approach, but just for demonstration's sake.
显然，这不是最好的方法，但只是为了演示。

1529
01:15:06,450 --> 01:15:09,780
And here now that you understand hopefully
现在你应该明白

1530
01:15:09,780 --> 01:15:12,780
from week 1 that really number-- and really, from week 0,
从第一周开始，数字实际上是-- 实际上，从第零周开始，

1531
01:15:12,780 --> 01:15:16,020
that numbers are just letters, which can be something more, too.
数字只是字母，也可以是更多的东西。

1532
01:15:16,020 --> 01:15:18,570
We can really just use our basic understanding of C
我们实际上只需要使用我们对 C 的基本理解

1533
01:15:18,570 --> 01:15:21,180
to tinker with these ideas now and see them such
来研究这些想法，看看它们

1534
01:15:21,180 --> 01:15:24,900
that there is indeed going to be no magic happening for us ultimately.
最终不会有任何魔法发生。

1535
01:15:24,900 --> 01:15:31,800
So let me go ahead and print out three characters-- %c, %c, %c, backslash n.
所以，让我继续打印出三个字符-- %c、%c、%c、反斜杠 n。

1536
01:15:31,800 --> 01:15:34,800
And then print out c1, c2, c3.
然后打印出 c1、c2、c3。

1537
01:15:34,800 --> 01:15:36,690
So I've got three separate placeholders.
所以我有三个单独的占位符。

1538
01:15:36,690 --> 01:15:40,560
And we haven't really had occasion to use %c, but it means put char here,
我们还没有真正使用 %c 的机会，但它的意思是把 char 放到这里，

1539
01:15:40,560 --> 01:15:44,760
unlike %s, which is put a whole string here, or %i, put an integer.
与 %s 不同，它把整个字符串放在这里，或者 %i，把整数放在这里。

1540
01:15:44,760 --> 01:15:49,290
Let me go ahead and make hi, no syntax errors, ./hi,
让我继续创建 hi，没有语法错误，./hi，

1541
01:15:49,290 --> 01:15:51,330
and it should print out "HI!"
它应该打印出“HI！”

1542
01:15:51,330 --> 01:15:53,400
in exclamation points because I'm printing out
用感叹号，因为我打印的是

1543
01:15:53,400 --> 01:15:54,870
just three simple characters.
三个简单的字符。

1544
01:15:54,870 --> 01:15:57,850
But per our discussion as far back as week 0,
但正如我们在第零周的讨论中提到的，

1545
01:15:57,850 --> 01:16:01,440
letters are just numbers and numbers are just letters,
字母只是数字，数字只是字母，

1546
01:16:01,440 --> 01:16:03,840
it just depends on the context in which we use them.
这取决于我们使用它们的上下文。

1547
01:16:03,840 --> 01:16:05,792
So let me change this %c to an i.
所以让我把这个 %c 改成 i。

1548
01:16:05,792 --> 01:16:08,250
And I'm going to add a space just so that you can obviously
我将添加一个空格，这样你就可以很明显地

1549
01:16:08,250 --> 01:16:10,050
separate one number from another.
将一个数字与另一个数字分开。

1550
01:16:10,050 --> 01:16:14,850
Change this to i, change this to i, but still print out c1, c2, c3.
将这个改成 i，将这个改成 i，但仍然打印出 c1、c2、c3。

1551
01:16:14,850 --> 01:16:16,650
So no integers, per se.
所以，严格来说，没有整数。

1552
01:16:16,650 --> 01:16:19,500
Let me just print out those chars.
让我只打印出这些字符。

1553
01:16:19,500 --> 01:16:26,670
Let me do make hi, no errors, ./hi, and now I see 72, 73, 33.
让我执行 make hi，没有错误，./hi，现在我看到 72、73、33。

1554
01:16:26,670 --> 01:16:31,270
So in the case of chars and ints, you can actually treat one as the other
所以，对于字符和整数来说，你实际上可以将其中一个视为另一个

1555
01:16:31,270 --> 01:16:33,850
so long as you have enough bits to fit one in the other.
只要你有足够的位来容纳其中一个。

1556
01:16:33,850 --> 01:16:36,450
You don't have to cast even or do anything explicitly.
你甚至不需要进行强制类型转换或显式地做任何事情。

1557
01:16:36,450 --> 01:16:38,340
You do have to cast one of--
你确实需要将其中一个--

1558
01:16:38,340 --> 01:16:41,910
converting an integer to a float to make clear to the compiler
将一个整数转换为浮点数，以便让编译器清楚地知道

1559
01:16:41,910 --> 01:16:44,160
that you really intend to do this because that
你确实想这样做，因为

1560
01:16:44,160 --> 01:16:47,400
could be destructive if it can't quite represent the number as you intend.
如果它无法按照你的意愿表示这个数字，可能会破坏性。

1561
01:16:47,400 --> 01:16:50,880
But in this case here, I think we're OK just poking around and seeing
但在这种情况下，我认为我们没问题，只要四处看看，看看

1562
01:16:50,880 --> 01:16:52,750
what's going on underneath the hood.
引擎盖下发生了什么。

1563
01:16:52,750 --> 01:16:55,202
Well, what is going on underneath the hood memory-wise?
那么，从内存的角度来看，引擎盖下发生了什么？

1564
01:16:55,202 --> 01:16:56,410
Well, something very similar.
嗯，非常相似。

1565
01:16:56,410 --> 01:16:57,780
Here's that canvas of memory.
这是内存的画布。

1566
01:16:57,780 --> 01:17:00,570
And maybe we got lucky and it's in the top left-hand corner
也许我们很幸运，它在左上角

1567
01:17:00,570 --> 01:17:03,270
like this-- c1, c2, c3.
像这样-- c1、c2、c3。

1568
01:17:03,270 --> 01:17:05,790
But these are just three individual characters,
但这些只是三个单独的字符，

1569
01:17:05,790 --> 01:17:08,970
but we're getting awfully close to what we last week called
但我们越来越接近上周所说的

1570
01:17:08,970 --> 01:17:12,270
a string, which are just characters, a sequence of characters
字符串，它只是字符，从左到右的字符序列

1571
01:17:12,270 --> 01:17:13,500
from left to right.
从左到右。

1572
01:17:13,500 --> 01:17:19,530
And in fact, I think if we combine this revelation that these are just
事实上，我认为如果我们将这些只是

1573
01:17:19,530 --> 01:17:22,410
numbers underneath the hood back to back to back combined
引擎盖下的数字，背靠背地组合起来

1574
01:17:22,410 --> 01:17:25,620
with the idea of an array from earlier, we can
与之前数组的概念结合起来，我们可以

1575
01:17:25,620 --> 01:17:27,690
start to see what's really going on.
开始看到真正发生了什么。

1576
01:17:27,690 --> 01:17:31,920
Because indeed, underneath the hood, this is just a number, 72, 73, 33.
因为实际上，在引擎盖下，这只是一个数字，72、73、33。

1577
01:17:31,920 --> 01:17:34,290
And really, if we go lower level than that,
实际上，如果我们比这更低一层，

1578
01:17:34,290 --> 01:17:36,870
it's these three patterns of 0's and 1's.
它就是这三个 0 和 1 的模式。

1579
01:17:36,870 --> 01:17:39,270
That's all that's going on inside of the computer,
这就是计算机内部发生的事情，

1580
01:17:39,270 --> 01:17:43,380
but it's our use of int that shows it to us as an integer.
但我们使用 int 使它显示为整数。

1581
01:17:43,380 --> 01:17:47,250
It's our use of char that makes it clear that it's a char, or equivalently,
我们使用 char 使它清楚地显示它是字符，或者等效地，

1582
01:17:47,250 --> 01:17:50,260
%i and %c respectively.
分别为 %i 和 %c。

1583
01:17:50,260 --> 01:17:52,180
But what exactly is a string?
但字符串到底是什么？

1584
01:17:52,180 --> 01:17:54,540
Well, it's really just a sequence of characters,
嗯，它实际上只是一系列字符，

1585
01:17:54,540 --> 01:17:56,530
and so why don't we go there?
所以我们为什么不去那里呢？

1586
01:17:56,530 --> 01:17:59,400
Let me propose that we actually give ourselves an actual string,
我建议我们给自己一个真正的字符串，

1587
01:17:59,400 --> 01:18:02,260
call it s-- we'll use double quotes this time.
称之为 s-- 这次我们将使用双引号。

1588
01:18:02,260 --> 01:18:05,760
So if I go back to VS Code here, let me shorten this program
所以，如果我回到 VS Code，让我缩短这个程序

1589
01:18:05,760 --> 01:18:10,440
and just give myself a single string s, set it equal to "HI!"
只给自己一个字符串 s，将其设置为“HI！”

1590
01:18:10,440 --> 01:18:11,310
in double quotes.
用双引号。

1591
01:18:11,310 --> 01:18:16,740
And then below that, let's go ahead and print out %s, backslash n,
然后在它下面，让我们继续打印出 %s、反斜杠 n，

1592
01:18:16,740 --> 01:18:18,180
and then s itself.
然后是 s 本身。

1593
01:18:18,180 --> 01:18:21,120
And then, turns out, for reasons we'll soon
然后，事实证明，由于我们很快就会看到的

1594
01:18:21,120 --> 01:18:23,670
see, I do need to include the CS50 Library so as
原因，我需要包含 CS50 库，以便

1595
01:18:23,670 --> 01:18:27,750
to use the actual keyword string here even though I'm not using get_string,
在这里使用实际的关键字字符串，即使我没有使用 get_string，

1596
01:18:27,750 --> 01:18:29,490
but more on that another time.
但我们会在另一个时间讨论这个问题。

1597
01:18:29,490 --> 01:18:34,950
But if I now do make hi, it does compile ./hi and it still prints out the exact
但如果我现在执行 make hi，它确实编译了 ./hi，并且仍然打印出完全相同的

1598
01:18:34,950 --> 01:18:35,920
same thing.
东西。

1599
01:18:35,920 --> 01:18:38,370
But what's going on inside of the computer's memory
但是，当我使用一个名为 s 的字符串而不是三个字符时，计算机内存中发生了什么？

1600
01:18:38,370 --> 01:18:42,550
when I use a string called s instead of three chars, well,
嗯，你可以把字符串看作至少占用了三个字节，H、

1601
01:18:42,550 --> 01:18:46,300
you can think of the string as taking up at least three bytes, H,
I、感叹号。

1602
01:18:46,300 --> 01:18:47,690
I, exclamation point.
但它不是三个单独的变量，它是一个变量。

1603
01:18:47,690 --> 01:18:50,440
But it's not three separate variables, it's one variable.
但现在这到底是什么样子，尤其是

1604
01:18:50,440 --> 01:18:53,620
But what does this really look like now, especially
如果我添加回黄色线条？

1605
01:18:53,620 --> 01:18:56,020
if I add back the yellow lines?


1606
01:18:56,020 --> 01:19:00,970
s is really just an array of characters.
字符串实际上就是一个字符数组。

1607
01:19:00,970 --> 01:19:04,170
So we called it a string last week, and I claim today
上周我们把它称为字符串，而今天我声称

1608
01:19:04,170 --> 01:19:10,320
that this is an abstraction in the CS50 library that's giving us this string,
这是 CS50 库中提供的抽象，它给了我们这个字符串，

1609
01:19:10,320 --> 01:19:13,560
but it's really just an array of size at least 3
但实际上它只是一个至少包含 3 个元素的数组

1610
01:19:13,560 --> 01:19:16,560
here where s, bracket, 0 presumably gives me the H, s, bracket,
在这里，s 方括号 0 应该会给我 H，s 方括号

1611
01:19:16,560 --> 01:19:19,720
1 is the I, s, bracket, 2 is the exclamation point.
1 是 I，s 方括号 2 是感叹号。

1612
01:19:19,720 --> 01:19:22,410
But just by saying string, all of that happens automatically.
但只要说字符串，所有这些都会自动发生。

1613
01:19:22,410 --> 01:19:25,320
I don't even need to tell the computer how many chars are
我甚至不需要告诉计算机有多少个字符

1614
01:19:25,320 --> 01:19:27,880
going to be in this string all at once.
会同时出现在这个字符串中。

1615
01:19:27,880 --> 01:19:31,680
So in fact, let me go over to maybe a variant of this program
事实上，让我去看看这个程序的变体

1616
01:19:31,680 --> 01:19:33,570
and we can see this syntactically.
我们可以从语法上看到这一点。

1617
01:19:33,570 --> 01:19:37,480
So instead of printing out the whole string with %s,
所以，与其用 %s 打印出整个字符串，

1618
01:19:37,480 --> 01:19:43,320
let me actually be a little curious and print out %c, %c, %c,
让我有点好奇，打印出 %c, %c, %c，

1619
01:19:43,320 --> 01:19:47,490
and then change s to s, bracket, 0, s, bracket, 1, s, bracket, 2.
然后将 s 更改为 s 方括号 0，s 方括号 1，s 方括号 2。

1620
01:19:47,490 --> 01:19:49,140
Which is not better in any sense.
这在任何意义上都不更好。

1621
01:19:49,140 --> 01:19:51,000
This is way more tedious now, but it does
现在这太繁琐了，但它确实

1622
01:19:51,000 --> 01:19:54,840
demonstrate that I can treat here in week 2
证明了我可以在第二周将它

1623
01:19:54,840 --> 01:19:57,870
as though it's an array, which means even in week 1 it was an array,
当做数组，这意味着即使在第一周它也是数组，

1624
01:19:57,870 --> 01:19:58,840
we just didn't know it.
我们只是不知道。

1625
01:19:58,840 --> 01:20:01,730
We didn't have the syntax with which to express that.
我们没有语法来表达这一点。

1626
01:20:01,730 --> 01:20:05,740
So if I now do make hi, still compiles ./hi.
所以如果我现在执行 make hi，它仍然可以编译 ./hi。

1627
01:20:05,740 --> 01:20:09,370
Same exact output, but I'm now just kind of manipulating
输出完全相同，但我现在只是在操纵

1628
01:20:09,370 --> 01:20:11,380
the string in these different ways because I
字符串以不同的方式，因为我

1629
01:20:11,380 --> 01:20:13,720
a string is just an array of characters, so I can
字符串只是一个字符数组，所以我可以

1630
01:20:13,720 --> 01:20:16,450
treat with the square bracket notation.
用方括号表示法处理。

1631
01:20:16,450 --> 01:20:21,100
But how do I know-- how does the computer know where hi ends?
但是我如何知道，计算机如何知道 hi 在哪里结束？

1632
01:20:21,100 --> 01:20:23,890
And this is where strings get a little dangerous.
这就是字符串变得有点危险的地方。

1633
01:20:23,890 --> 01:20:26,050
Like a char is 1 byte no matter what.
就像一个 char 无论如何都是 1 个字节。

1634
01:20:26,050 --> 01:20:28,480
1 char, 1 character, that's it.
1 个 char，1 个字符，就是这样。

1635
01:20:28,480 --> 01:20:31,180
But a string, recall my question mark from earlier,
但一个字符串，还记得我之前问的？

1636
01:20:31,180 --> 01:20:33,415
could be null bytes if it's--
如果它是空字节，那么它

1637
01:20:33,415 --> 01:20:37,610
you would think could be 0 bytes if you have nothing in it inside the quotes.
你可能认为它可以是 0 字节，如果你在引号里什么都没有。

1638
01:20:37,610 --> 01:20:40,930
It could be one character, two, 10, 100 like I claimed,
它可以是一个字符，两个，十个，一百个，就像我之前所说的，

1639
01:20:40,930 --> 01:20:44,140
but how does the computer know where strings end?
但计算机如何知道字符串在哪里结束？

1640
01:20:44,140 --> 01:20:47,560
Like how does the computer not know that the string is not
就像计算机如何不知道字符串不是

1641
01:20:47,560 --> 01:20:49,510
the whole row of memory here?
这里一整行的内存？

1642
01:20:49,510 --> 01:20:51,350
How does it know that it ends here?
它怎么知道它在这里结束？

1643
01:20:51,350 --> 01:20:54,880
Well, it turns out, all this time, when we've been using, quote-unquote,
事实证明，一直以来，当我们使用所谓的

1644
01:20:54,880 --> 01:20:58,120
string and using get_string from the CS50 library,
字符串和使用 CS50 库中的 get_string 时，

1645
01:20:58,120 --> 01:21:00,640
there's actually a special sentinel value
实际上有一个特殊的哨兵值

1646
01:21:00,640 --> 01:21:03,580
at the end of every string in a computer's memory
在计算机内存中每个字符串的末尾

1647
01:21:03,580 --> 01:21:06,700
that tells the computer string, stops here.
告诉计算机字符串在这里停止。

1648
01:21:06,700 --> 01:21:08,890
And the sentinel value-- and by sentinel, I
哨兵值，而哨兵的意思是

1649
01:21:08,890 --> 01:21:13,820
just mean special value that the world decided on decades ago, is all 0 bits.
几十年前全世界决定好的特殊值，都是 0 位。

1650
01:21:13,820 --> 01:21:20,210
If you have a byte with all 0 bits in it, that means string ends here.
如果你有一个字节，其中所有位都是 0，这意味着字符串在这里结束。

1651
01:21:20,210 --> 01:21:23,920
So the implication is that the computer now, using a loop or something,
因此，这意味着计算机现在，使用循环或其他东西，

1652
01:21:23,920 --> 01:21:26,650
can print out char, char, char-- oh, done,
可以打印出 char，char，char，哦，完成了，

1653
01:21:26,650 --> 01:21:28,750
because it sees this special value.
因为它看到了这个特殊值。

1654
01:21:28,750 --> 01:21:32,800
If it didn't have that, it might blindly go char, char, char, char char--
如果没有它，它可能会盲目地继续 char，char，char，char char，

1655
01:21:32,800 --> 01:21:37,450
printing out values of memory that don't belong to that given string.
打印出不属于给定字符串的内存值。

1656
01:21:37,450 --> 01:21:39,490
So I was correcting myself verbally a moment ago
所以，我之前在口头上纠正了自己

1657
01:21:39,490 --> 01:21:44,140
because I said that this string is of length 3, it's 3 bytes, but it's not.
因为我说这个字符串的长度是 3，它是 3 个字节，但它不是。

1658
01:21:44,140 --> 01:21:47,290
Every string in the world, both last week and now, this
世界上所有的字符串，无论是在上周还是现在，这个

1659
01:21:47,290 --> 01:21:51,430
is actually n plus 1 bytes where n is the actual human length
实际上是 n 加 1 个字节，其中 n 是实际的人类长度

1660
01:21:51,430 --> 01:21:54,220
that you care about, H-I, exclamation point, or 3,
你关心的，H-I，感叹号，或者 3，

1661
01:21:54,220 --> 01:21:59,110
but it's always going to use one extra byte for this so-called zero value
但它总是会为这个所谓的零值使用一个额外的字节

1662
01:21:59,110 --> 01:21:59,770
at the end.
在末尾。

1663
01:21:59,770 --> 01:22:03,220
And this 0 value is very tedious to write a 0--
而这个 0 值用 0 来写很繁琐，

1664
01:22:03,220 --> 01:22:04,630
as 8 0 bits.
用 8 个 0 位来写。

1665
01:22:04,630 --> 01:22:07,240
So we would actually typically just write it as a 0.
所以我们实际上通常只是把它写成 0。

1666
01:22:07,240 --> 01:22:10,420
But you don't want to confuse a 0 on the screen-- it's actually being
但你不想将屏幕上的 0 与它混淆，它实际上是

1667
01:22:10,420 --> 01:22:12,290
like the number 0 on the keyboard.
像键盘上的数字 0。

1668
01:22:12,290 --> 01:22:16,000
And so we would actually typically write this symbol with a backslash 0.
所以，我们实际上通常用反斜杠 0 来写这个符号。

1669
01:22:16,000 --> 01:22:19,960
So this is the char-based representation of 0.
所以，这是 0 的基于字符的表示。

1670
01:22:19,960 --> 01:22:21,970
So it means the exact same thing, this is just
所以，它的意思完全一样，这只是

1671
01:22:21,970 --> 01:22:26,470
C notation that indicates that this is 8 0 bits,
C 语言中的表示法，表明这是 8 个 0 位，

1672
01:22:26,470 --> 01:22:29,380
but just makes clear that it's not literally the number
但它只是表明它不是字面上的数字

1673
01:22:29,380 --> 01:22:32,320
0 that you want to see on the screen, it's a sentinel value
0，你想要在屏幕上看到，它是一个哨兵值

1674
01:22:32,320 --> 01:22:34,880
that is terminating this here string.
它终止了这里的字符串。

1675
01:22:34,880 --> 01:22:38,480
So now what can I do once I know this information?
那么，现在我知道了这些信息之后，我能做什么呢？

1676
01:22:38,480 --> 01:22:41,740
Well, I can actually even see this let me go back to this code
好吧，我实际上甚至可以看看它，让我回到这段代码

1677
01:22:41,740 --> 01:22:42,790
here in VS Code.
在 VS Code 中。

1678
01:22:42,790 --> 01:22:46,190
Let me change these %c's to %i's just like before.
让我像之前一样将这些 %c 更改为 %i。

1679
01:22:46,190 --> 01:22:50,290
And now, we'll see again those same numbers, make hi, ./hi,
现在，我们将再次看到相同的数字，make hi，./hi，

1680
01:22:50,290 --> 01:22:51,730
there are the three.
那里有三个。

1681
01:22:51,730 --> 01:22:56,410
I can technically poke around a little bit further, %i one more,
从技术上来说，我可以再深入一点，%i 再加一个，

1682
01:22:56,410 --> 01:22:58,210
and let's look at s, bracket, 3.
让我们看看 s 方括号 3。

1683
01:22:58,210 --> 01:23:02,060
I was not exaggerating earlier when I said,
我之前说的时候没有夸张，

1684
01:23:02,060 --> 01:23:06,260
in general, if you go past the end of an array, bad things can happen.
一般来说，如果你越过数组的末尾，可能会发生不好的事情。

1685
01:23:06,260 --> 01:23:10,030
But in this case, I know that there is one more thing at the end of this array
但在这种情况下，我知道这个数组的末尾还有一个东西

1686
01:23:10,030 --> 01:23:13,210
because this is how strings are built. This is not a CS50 thing,
因为字符串就是这样构建的。这不是 CS50 的东西，

1687
01:23:13,210 --> 01:23:17,440
this is a thing in C. Every string in the world in double quotes
这是 C 语言中的东西。世界上每个用双引号表示的字符串

1688
01:23:17,440 --> 01:23:20,780
ends with a backslash 0-- that is 8 0 bits.
都以反斜杠 0 结尾，即 8 个 0 位。

1689
01:23:20,780 --> 01:23:24,400
So if I really want, I can see this by printing out s, bracket, 3,
所以，如果我真的想，我可以通过打印 s 方括号 3 来看到这一点，

1690
01:23:24,400 --> 01:23:26,290
which is the fourth and final location.
它是第四个也是最后一个位置。

1691
01:23:26,290 --> 01:23:34,120
If I recompile my code now, make hi ./hi, I should see 72, 73, 33, and 0.
如果我现在重新编译我的代码，make hi ./hi，我应该看到 72、73、33 和 0。

1692
01:23:34,120 --> 01:23:35,470
That's always been there.
它一直都在那里。

1693
01:23:35,470 --> 01:23:40,900
So I'm always using 4 bytes, somewhat wastefully, but somewhat necessarily
所以，我总是使用 4 个字节，有点浪费，但也有必要

1694
01:23:40,900 --> 01:23:45,080
so that the computer actually knows where that string ends.
这样计算机才能知道字符串在哪里结束。

1695
01:23:45,080 --> 01:23:48,070
So if we go back to the memory representation of this here,
所以，如果我们回到这里的内存表示，

1696
01:23:48,070 --> 01:23:52,990
it's just as though you have an array of integers being stored contiguously back
它就像你有一个整数数组，连续地存储在后面

1697
01:23:52,990 --> 01:23:56,800
to back to back, the last one of which means this is the end of the array
从头到尾，最后一个意味着数组的结束

1698
01:23:56,800 --> 01:24:00,120
of characters, but because I'm using, quote-unquote, "string,"
字符的数组，但因为我使用了“字符串”，

1699
01:24:00,120 --> 01:24:04,080
because I'm using %s and %c, I'm not seeing these numbers by default,
因为我使用 %s 和 %c，所以我默认情况下看不到这些数字，

1700
01:24:04,080 --> 01:24:08,950
I'm seeing H-I, exclamation point unless I explicitly tell printf, no, no, no,
我看到的是H-I，感叹号，除非我明确地告诉printf，不，不，不，

1701
01:24:08,950 --> 01:24:13,470
no, show me with %i these actual integers.
不，用 %i 显示这些实际的整数。

1702
01:24:13,470 --> 01:24:15,840
This, then, is how you can think about the string.
那么，这就是你可以思考字符串的方式。

1703
01:24:15,840 --> 01:24:17,100
Like you don't really need to think about
就像你真的不需要思考

1704
01:24:17,100 --> 01:24:18,540
it as being individual characters.
它是一个个的字符。

1705
01:24:18,540 --> 01:24:21,600
This is just s, and it has some length here,
这只是 s，它在这里有一定的长度，

1706
01:24:21,600 --> 01:24:26,760
but it does not necessarily an array that you yourself have to create,
但它不一定是你自己必须创建的数组，

1707
01:24:26,760 --> 01:24:30,820
you get it automatically just by using a string.
你只要使用一个字符串就可以自动获得它。

1708
01:24:30,820 --> 01:24:32,910
Now there's just-- not to add on to the jargon.
现在，只是 - 不想加更多术语。

1709
01:24:32,910 --> 01:24:35,760
This backslash 0, these 8 0 bits, there's
这个反斜杠 0，这 8 个 0 位，有

1710
01:24:35,760 --> 01:24:37,290
actually a technical term for them.
实际上有一个技术术语来称呼它们。

1711
01:24:37,290 --> 01:24:38,430
You can call them NUL.
你可以称它们为 NUL。

1712
01:24:38,430 --> 01:24:41,430
It's typically written in all caps like this, confusingly.
它通常像这样写成全大写，让人困惑。

1713
01:24:41,430 --> 01:24:44,580
In a couple of weeks, we're going to see another word pronounced null,
几周后，我们将看到另一个发音为 null 的词，

1714
01:24:44,580 --> 01:24:48,720
but spelled N-U-L-L. Left hand wasn't talking to right hand years ago,
但拼写为 N-U-L-L。几年前，左手没有和右手交流，

1715
01:24:48,720 --> 01:24:54,000
but N-U-L means this is the 0 byte that terminates strings,
但 N-U-L 意味着这是终止字符串的 0 字节，

1716
01:24:54,000 --> 01:24:56,520
that indicate the end of a string.
指示字符串的结束。

1717
01:24:56,520 --> 01:25:00,070
And fun fact, you've actually seen this before even though we glossed over it.
有趣的事实是，你实际上之前已经见过它了，即使我们一带而过。

1718
01:25:00,070 --> 01:25:02,490
Here's that ASCII chart from last time.
这是上次的 ASCII 表。

1719
01:25:02,490 --> 01:25:08,850
If I focus on the leftmost column, guess what is the 0 ASCII character?
如果我关注最左边的列，猜猜 0 ASCII 字符是什么？

1720
01:25:08,850 --> 01:25:09,480
NUL.
NUL。

1721
01:25:09,480 --> 01:25:14,005
You never see null on the screen, it's just how you pronounce 8 0 bits.
你永远不会在屏幕上看到 null，它只是你如何发音 8 个 0 位。

1722
01:25:14,005 --> 01:25:14,810
Whew!
呼！

1723
01:25:14,810 --> 01:25:17,360
questions on this representation of strings?
关于这种字符串表示方式有什么问题吗？

1724
01:25:17,360 --> 01:25:18,250
Yeah?
有吗？

1725
01:25:18,250 --> 01:25:20,090
AUDIENCE: Are strings [INAUDIBLE]?
观众：字符串 [听不清]？

1726
01:25:20,090 --> 01:25:22,380
DAVID MALAN: Are string structured differently in other languages?
大卫·马兰：字符串在其他语言中结构不同吗？

1727
01:25:22,380 --> 01:25:22,760
Yes.
是的。

1728
01:25:22,760 --> 01:25:24,590
They are more powerful in other languages.
它们在其他语言中功能更强大。

1729
01:25:24,590 --> 01:25:28,070
In C, you have to build them yourself in this way.
在 C 语言中，你必须以这种方式自己构建它们。

1730
01:25:28,070 --> 01:25:29,900
More on that when we get to Python.
我们将在学习 Python 时进一步讨论。

1731
01:25:29,900 --> 01:25:30,710
Other questions.
其他问题。

1732
01:25:30,710 --> 01:25:31,593
Yeah?
有吗？

1733
01:25:31,593 --> 01:25:41,170
AUDIENCE: [INAUDIBLE]
观众： [听不清]

1734
01:25:41,170 --> 01:25:42,670
DAVID MALAN: A really good question.
大卫·马兰：一个非常好的问题。

1735
01:25:42,670 --> 01:25:45,840
Does that mean we don't have a function to get the length of a string?
这意味着我们没有获取字符串长度的函数吗？

1736
01:25:45,840 --> 01:25:47,700
Do we have to create it?
我们必须自己创建它吗？

1737
01:25:47,700 --> 01:25:51,360
Short answer, there is a function, but you have to-- someone
简短的回答，有一个函数，但你必须 - 有人

1738
01:25:51,360 --> 01:25:52,540
had to write code for it.
必须为它编写代码。

1739
01:25:52,540 --> 01:25:56,010
You can't just ask the string itself like you can in JavaScript or Java.
你不能像在 JavaScript 或 Java 中那样直接询问字符串本身。

1740
01:25:56,010 --> 01:25:57,150
What is the--
是什么 -

1741
01:25:57,150 --> 01:25:59,355
AUDIENCE: [INAUDIBLE]
观众： [听不清]

1742
01:25:59,355 --> 01:26:00,480
DAVID MALAN: Yeah, you can.
大卫·马兰：是的，你可以。

1743
01:26:00,480 --> 01:26:04,230
It's actually more similar to Python than it is to JavaScript or Java,
它实际上更类似于 Python，而不是 JavaScript 或 Java，

1744
01:26:04,230 --> 01:26:07,110
but we'll see that in just a few minutes, in fact.
但事实上，我们将在几分钟内看到这一点。

1745
01:26:07,110 --> 01:26:09,340
So let's introduce maybe a couple of strings.
所以让我们介绍几个字符串。

1746
01:26:09,340 --> 01:26:12,360
So here's two strings in the abstract called s and t,
所以这里有两个抽象的字符串，分别叫 s 和 t，

1747
01:26:12,360 --> 01:26:15,210
and I've initialized them arbitrarily to "HI!" and "BYE!"
我将它们任意初始化为“HI！”和“BYE！”

1748
01:26:15,210 --> 01:26:18,840
just so we can explore what's going to actually happen underneath the hood.
这样我们就可以探索幕后实际上会发生什么。

1749
01:26:18,840 --> 01:26:20,640
So let me go back to VS Code.
所以让我回到 VS Code。

1750
01:26:20,640 --> 01:26:23,680
Let me just completely change this program to be that instead.
让我完全改变这个程序，改为那样。

1751
01:26:23,680 --> 01:26:26,280
So string equals, quote-unquote, "HI!"
所以 string 等于，引号，"HI！"

1752
01:26:26,280 --> 01:26:28,860
String t equals, quote-unquote, "BYE!"
String t 等于，引号，"BYE！"

1753
01:26:28,860 --> 01:26:29,860
in all caps.
全部大写。

1754
01:26:29,860 --> 01:26:34,620
And then let's print them both out very simply. %s backslash n, s.
然后让我们简单地把它们都打印出来。%s 反斜杠 n，s。

1755
01:26:34,620 --> 01:26:39,570
Print out %s backslash n, t just so we can see what's going on.
打印出 %s 反斜杠 n，t，这样我们就可以看到发生了什么。

1756
01:26:39,570 --> 01:26:44,183
If I do make hi ./hi, I should, of course, see these two strings.
如果我执行 make hi ./hi，我当然应该看到这两个字符串。

1757
01:26:44,183 --> 01:26:46,350
But what's going on inside of the computer's memory?
但是计算机内存内部发生了什么？

1758
01:26:46,350 --> 01:26:48,868
Well, in this computer's memory, assuming
好吧，在这台计算机的内存中，假设

1759
01:26:48,868 --> 01:26:51,660
these are the only two variables involved and assuming the computer
这两个是唯一涉及的变量，并且假设计算机

1760
01:26:51,660 --> 01:26:55,170
is just doing things top to bottom, "HI!"
只是从上到下执行，“HI！”

1761
01:26:55,170 --> 01:26:58,260
is probably going to be stored somewhere like this on my canvas of memory,
可能会被存储在我的内存画布上的某个地方，

1762
01:26:58,260 --> 01:26:58,950
"BYE!"
"BYE！"

1763
01:26:58,950 --> 01:27:00,290
is probably going to be stored there.
可能会被存储在那里。

1764
01:27:00,290 --> 01:27:03,165
And it's wrapping around, but that's just an artist's representation.
它正在循环，但这只是艺术家的表示方式。

1765
01:27:03,165 --> 01:27:05,380
But notice that it is now really important
但请注意，现在非常重要

1766
01:27:05,380 --> 01:27:08,890
that there is this NUL byte at the end of each string
在每个字符串的末尾都有这个 NUL 字节

1767
01:27:08,890 --> 01:27:11,650
because that's how the computer is going to know where "HI!"
因为这是计算机如何知道 "HI！"

1768
01:27:11,650 --> 01:27:13,630
ends and where "BYE!"
结束，以及 "BYE！"

1769
01:27:13,630 --> 01:27:15,670
begins, otherwise you might see "HI!"
开始，否则你可能会看到 "HI！"

1770
01:27:15,670 --> 01:27:16,360
"BYE!"
"BYE！"

1771
01:27:16,360 --> 01:27:20,380
all on the screen at once if there weren't the sentinel value indicating
全部同时出现在屏幕上，如果没有这个哨兵值指示

1772
01:27:20,380 --> 01:27:23,860
to printf, stop at this character.
告诉 printf，在此字符处停止。

1773
01:27:23,860 --> 01:27:26,290
But that's all that's going on in your program
但这就是你的程序中发生的一切

1774
01:27:26,290 --> 01:27:29,080
when you have two variables in this way.
当你以这种方式拥有两个变量时。

1775
01:27:29,080 --> 01:27:32,290
And in fact, what's really going on and things get a little more interesting
事实上，真正发生的事情，事情变得更加有趣

1776
01:27:32,290 --> 01:27:37,310
here, if I were to want two of these things,
在这里，如果我想要两个这样的东西，

1777
01:27:37,310 --> 01:27:40,630
notice that I could refer to them two as arrays.
请注意，我可以将它们两个称为数组。

1778
01:27:40,630 --> 01:27:43,990
So s, bracket, 0, 1, 2, and even 3.
所以 s，方括号，0，1，2，甚至 3。

1779
01:27:43,990 --> 01:27:47,110
t, bracket, 0, 1, 2, and even 3 and 4.
t，方括号，0，1，2，甚至 3 和 4。

1780
01:27:47,110 --> 01:27:51,460
But if I want to actually really blend some ideas,
但是如果我想真正混合一些想法，

1781
01:27:51,460 --> 01:27:54,190
just playing around with these basic principles now,
现在只是玩玩这些基本原则，

1782
01:27:54,190 --> 01:27:56,140
notice what I can do in this version.
注意在这个版本中我可以做什么。

1783
01:27:56,140 --> 01:27:59,200
If I know I've got two arrays in VS Code,
如果我知道我在 VS Code 中有两个数组，

1784
01:27:59,200 --> 01:28:02,950
I don't strictly need to do string s and t and u
我不需要严格地使用 string s 和 t 和 u

1785
01:28:02,950 --> 01:28:08,260
and v. That's devolving back into the scores1, scores2, scores3 mantra where
和 v。这又回到了 scores1、scores2、scores3 的模式，在那里

1786
01:28:08,260 --> 01:28:10,277
I had multiple variables almost the same name
我有几个变量几乎相同的名字

1787
01:28:10,277 --> 01:28:12,610
even though I'm using different letters of the alphabet.
即使我使用不同的字母。

1788
01:28:12,610 --> 01:28:13,840
What if I want--
如果我想 -

1789
01:28:13,840 --> 01:28:15,280
what if I do this?
如果我这样做？

1790
01:28:15,280 --> 01:28:19,660
string words, and if I want to store two words in the computer's memory, fine.
string words，如果我想在计算机内存中存储两个单词，没问题。

1791
01:28:19,660 --> 01:28:22,700
Create an array of two strings.
创建一个包含两个字符串的数组。

1792
01:28:22,700 --> 01:28:23,620
But what is a string?
但什么是字符串？

1793
01:28:23,620 --> 01:28:28,870
A string is an array of characters, so it's getting a little bit trippy here,
字符串是字符数组，所以这里有点奇怪，

1794
01:28:28,870 --> 01:28:32,290
but the ideas are still going to be the same. words, bracket,
但想法仍然是一样的。words，方括号，

1795
01:28:32,290 --> 01:28:34,540
0 could certainly equal "HI!"
0 当然可以等于“HI！”

1796
01:28:34,540 --> 01:28:39,280
words, bracket, 1 can certainly equal "BYE!" just like the scores example.
words，括号，1 当然可以等于“BYE！”，就像分数示例一样。

1797
01:28:39,280 --> 01:28:42,910
And then if I want to print these things with %s, I can print out words,
然后，如果我想用 %s 打印这些东西，我可以打印出 words，

1798
01:28:42,910 --> 01:28:44,080
bracket, 0.
括号，0。

1799
01:28:44,080 --> 01:28:48,820
And then I can print out %s backslash n words bracket 1.
然后我可以打印出 %s 反斜杠 n words 括号 1。

1800
01:28:48,820 --> 01:28:52,520
And the example is not going to be any different in terms of its output,
并且这个例子在输出方面不会有任何不同，

1801
01:28:52,520 --> 01:28:58,240
but I've now avoided s and t, I now just have one variable called words
但是我现在避免了 s 和 t，我现在只有一个名为 words 的变量

1802
01:28:58,240 --> 01:29:00,710
containing both of these here things.
包含这两者。

1803
01:29:00,710 --> 01:29:02,800
And if I really want to poke around, here's
如果我真的想四处探查，这里就是

1804
01:29:02,800 --> 01:29:06,490
where things get even more visually overwhelming,
事情变得更加直观地让人不知所措的地方，

1805
01:29:06,490 --> 01:29:09,640
but just the logical extension of these same ideas.
但只是这些相同想法的逻辑扩展。

1806
01:29:09,640 --> 01:29:13,300
Right now is the previous version where I had two variables, s and t.
现在是之前我使用两个变量 s 和 t 的版本。

1807
01:29:13,300 --> 01:29:17,290
If I now use this new version where I have one variable called words,
如果我现在使用这个新的版本，我有一个名为 words 的变量，

1808
01:29:17,290 --> 01:29:22,060
just like this here, the picture should follow logically like this.
就像这样，图片应该逻辑上像这样。

1809
01:29:22,060 --> 01:29:26,320
words, bracket, 0 is this string; words, bracket, 1 is this string;
words，括号，0 是这个字符串；words，括号，1 是这个字符串；

1810
01:29:26,320 --> 01:29:27,940
but what is each string?
但是每个字符串是什么？

1811
01:29:27,940 --> 01:29:29,840
It's an array of characters.
它是一个字符数组。

1812
01:29:29,840 --> 01:29:36,520
And so you can also think of it like this, where this H is words, bracket,
所以你也可以这样想，这里这个 H 是 words，括号，

1813
01:29:36,520 --> 01:29:37,930
0, bracket, 0.
0，括号，0。

1814
01:29:37,930 --> 01:29:41,440
So the 0-th character of the 0-th word.
所以是第 0 个单词的第 0 个字符。

1815
01:29:41,440 --> 01:29:45,580
And this is words, bracket, 0, 1; words, bracket, 0, 2; words, bracket, 0, 3.
而这是 words，括号，0，1；words，括号，0，2；words，括号，0，3。

1816
01:29:45,580 --> 01:29:49,180
And then words, bracket, 1, 0.
然后是 words，括号，1，0。

1817
01:29:49,180 --> 01:29:52,382
So it's kind of like a two-dimensional array, almost.
所以它几乎就像一个二维数组。

1818
01:29:52,382 --> 01:29:54,340
And you can think about it that way if helpful.
如果你觉得有用，可以这样想。

1819
01:29:54,340 --> 01:29:58,400
But for now, it's just applying the same principles to the code.
但现在，它只是将相同的原则应用于代码。

1820
01:29:58,400 --> 01:30:01,930
So if I go to my code here and I've got my "HI!" and my "BYE!"--
所以如果我到我的代码这里，我有了我的“HI！”和我的“BYE！”--

1821
01:30:01,930 --> 01:30:07,000
this is going to look a little stupid, but let me change this %s to %c, %c,
这看起来有点愚蠢，但让我把这个 %s 变成 %c，%c，

1822
01:30:07,000 --> 01:30:09,640
%c, and print out words, bracket, 0.
%c，然后打印出 words，括号，0。

1823
01:30:09,640 --> 01:30:11,620
words, bracket, 0, bracket 1.
words，括号，0，括号 1。

1824
01:30:11,620 --> 01:30:16,900
words, bracket, 0, bracket, 2 to print out that three-letter word.
words，括号，0，括号，2，用来打印出那个三个字母的单词。

1825
01:30:16,900 --> 01:30:21,550
And now down here, let me print out %c, %c, %c,
现在这里，让我打印出 %c，%c，%c，

1826
01:30:21,550 --> 01:30:24,340
%c because it's four letters in BYE, exclamation point.
%c，因为 BYE 有四个字母，感叹号。

1827
01:30:24,340 --> 01:30:28,570
This is words, bracket, 1, but the first character; words, bracket, 1,
这是 words，括号，1，但第一个字符；words，括号，1，

1828
01:30:28,570 --> 01:30:32,920
the second character; words, bracket, 1, the third character;
第二个字符；words，括号，1，第三个字符；

1829
01:30:32,920 --> 01:30:34,948
and words, bracket, 1, the fourth character.
以及 words，括号，1，第四个字符。

1830
01:30:34,948 --> 01:30:37,240
It's hard to say when you're typing a different number,
当你输入一个不同的数字时很难说，

1831
01:30:37,240 --> 01:30:40,810
but that's what we get by using zero indexing, so to speak.
但这就是我们使用零索引的方式，可以这么说。

1832
01:30:40,810 --> 01:30:41,720
make hi.
make hi。

1833
01:30:41,720 --> 01:30:42,220
Whew!
哇！

1834
01:30:42,220 --> 01:30:42,940
No mistakes.
没有错误。

1835
01:30:42,940 --> 01:30:43,780
"HI!"
“HI！”

1836
01:30:43,780 --> 01:30:45,440
Says the same thing.
说的是同一件事。

1837
01:30:45,440 --> 01:30:46,840
So again, there's no magic.
所以，再一次，这里没有魔法。

1838
01:30:46,840 --> 01:30:49,630
Like you are fully in control over what's going
就像你完全控制着发生的事情

1839
01:30:49,630 --> 01:30:51,560
on inside of the computer's memory.
在计算机的内存里。

1840
01:30:51,560 --> 01:30:54,250
And now that we have this array syntax with square brackets,
现在我们有了这个带方括号的数组语法，

1841
01:30:54,250 --> 01:30:58,740
you can both create these things and then manipulate them or access them
你既可以创建这些东西，然后操纵它们或访问它们

1842
01:30:58,740 --> 01:31:01,310
however you so choose.
随你喜欢。

1843
01:31:01,310 --> 01:31:01,810
Whew!
哇！

1844
01:31:01,810 --> 01:31:08,540
Questions on arrays or strings in this way?
关于数组或字符串，有疑问吗？

1845
01:31:08,540 --> 01:31:10,032
Yeah, over here.
是啊，这边。

1846
01:31:10,032 --> 01:31:13,340
AUDIENCE: Can you have any array that has multiple data types in it?
观众：你可以有一个包含多种数据类型的数组吗？

1847
01:31:13,340 --> 01:31:13,880
DAVID MALAN: Good question.
大卫·马兰：好问题。

1848
01:31:13,880 --> 01:31:16,255
Can you have an array with multiple different data types?
你可以有一个包含多种数据类型的数组吗？

1849
01:31:16,255 --> 01:31:19,310
Short answer, no; longer answer, sort of,
简短的回答，不行；更长的回答，算是吧，

1850
01:31:19,310 --> 01:31:22,670
but not in nearly the same user-friendly way as with languages
但不像 Python 或 JavaScript 或其他语言那样友好。

1851
01:31:22,670 --> 01:31:25,220
like Python or JavaScript or others.
比如 Python 或 JavaScript 等等。

1852
01:31:25,220 --> 01:31:30,580
So assume for now arrays should be the same type in C. Other questions?
所以现在假设 C 中的数组应该都是同一类型。还有其他问题吗？

1853
01:31:30,580 --> 01:31:31,997
Yeah, over here.
是啊，这边。

1854
01:31:31,997 --> 01:31:34,432
AUDIENCE: When you talk about [INAUDIBLE]??
观众：当你谈论 [听不清] ??

1855
01:31:47,113 --> 01:31:48,780
DAVID MALAN: Oh, a really good question.
大卫·马兰：哦，一个非常好的问题。

1856
01:31:48,780 --> 01:31:51,500
It will-- so for those who couldn't hear,
它会——对于那些没听清的人，

1857
01:31:51,500 --> 01:31:54,425
if you were to look past the end of one array,
如果你要看一个数组的末尾之后，

1858
01:31:54,425 --> 01:31:56,550
would you start to see the beginning of the second?
你会开始看到第二个数组的开头吗？

1859
01:31:56,550 --> 01:31:58,008
In this case, maybe the word "BYE!"
在这种情况下，可能是“BYE！”这个词。

1860
01:31:58,008 --> 01:32:01,070
Could depend on the particulars of your code in the computer.
这可能取决于你计算机代码的具体情况。

1861
01:32:01,070 --> 01:32:02,250
Let's try this.
让我们试试这个。

1862
01:32:02,250 --> 01:32:07,310
So let's get a little greedy here and go one past H-I, exclamation point,
所以让我们贪心一点，从 H-I，感叹号，之后的一个位置开始，

1863
01:32:07,310 --> 01:32:11,450
null character by looking at words, bracket, 0, 3,
空字符，通过查看 words，括号，0，3，

1864
01:32:11,450 --> 01:32:16,220
which should actually be our null character, so that's going to be there.
这实际上应该是我们的空字符，所以它会出现在那里。

1865
01:32:16,220 --> 01:32:18,350
And actually, let's see.
实际上，让我们看看。

1866
01:32:18,350 --> 01:32:19,490
Let's go ahead and do this.
让我们来做这个。

1867
01:32:19,490 --> 01:32:21,530
Make hi ./hi.
Make hi ./hi。

1868
01:32:21,530 --> 01:32:25,310
Still works as expected, but let me change this to integer,
仍然按预期工作，但让我把它改为整数，

1869
01:32:25,310 --> 01:32:27,770
integer so we can actually see what's going on.
整数，这样我们就可以看到发生了什么。

1870
01:32:27,770 --> 01:32:28,610
Integer.
整数。

1871
01:32:28,610 --> 01:32:32,840
And now, if I recompile make hi, I should see the same thing,
现在，如果我重新编译 make hi，我应该看到相同的结果，

1872
01:32:32,840 --> 01:32:34,100
but numerically.
但以数字形式。

1873
01:32:34,100 --> 01:32:37,430
And now what I think you're proposing is let's get a little crazy
现在我认为你正在提议的是，让我们疯狂一点

1874
01:32:37,430 --> 01:32:41,000
and go even past that to what could be location 4,
并且超越它，到达可能是位置 4 的地方，

1875
01:32:41,000 --> 01:32:45,740
but we know semantically doesn't exist, but maybe is bumping up against "BYE!"
但我们知道从语义上来说它不存在，但它可能会碰到“BYE！”。

1876
01:32:45,740 --> 01:32:49,140
So make hi ./hi.
所以 make hi ./hi。

1877
01:32:49,140 --> 01:32:52,440
And guess what 66 is.
猜猜 66 是什么。

1878
01:32:52,440 --> 01:32:54,360
Well, just the B, but yes.
嗯，只是 B，但没错。

1879
01:32:54,360 --> 01:32:59,600
66, recall, is capital B because in week 0, capital A was 65.
记住，66 是大写 B，因为在第 0 周，大写 A 是 65。

1880
01:32:59,600 --> 01:33:01,350
So indeed, now we're really poking around.
所以，现在我们真的在四处探查了。

1881
01:33:01,350 --> 01:33:02,267
And you can get crazy.
你可以变得很疯狂。

1882
01:33:02,267 --> 01:33:05,520
Like, what's 400 characters away and see what's going on there.
比如，看看 400 个字符之外是什么，看看那里发生了什么。

1883
01:33:05,520 --> 01:33:07,870
Eventually your program will probably crash,
最终你的程序可能会崩溃，

1884
01:33:07,870 --> 01:33:12,300
and so don't poke around too much, but more on that in the coming days, too.
所以不要探查太多，但我们将在接下来的几天里详细讨论这个问题。

1885
01:33:12,300 --> 01:33:16,298
All right, well how about some other revelations and problem-solving?
好的，那么其他的一些启示和问题解决呢？

1886
01:33:16,298 --> 01:33:18,840
Now coming back to the question about strings length earlier,
现在回到之前关于字符串长度的问题，

1887
01:33:18,840 --> 01:33:21,465
and we'll see if we can then tie this all together to something
我们来看看是否可以把这些东西都联系起来，形成一个

1888
01:33:21,465 --> 01:33:24,390
like cryptography in the end and manipulating strings
最终像密码学一样，操纵字符串

1889
01:33:24,390 --> 01:33:26,580
for the purpose of sending them securely.
以安全地发送它们为目的。

1890
01:33:26,580 --> 01:33:30,430
So let me propose that we go into VS Code here again in a moment.
所以，我建议我们一会儿再次进入 VS Code。

1891
01:33:30,430 --> 01:33:32,430
And I'm going to create a program called length.
我将创建一个名为 length 的程序。

1892
01:33:32,430 --> 01:33:36,490
Let's actually figure out ourselves the length of a string initially.
让我们自己来算算字符串的长度。

1893
01:33:36,490 --> 01:33:39,750
So I'm going to go ahead and code length.c.
所以我要开始编写length.c代码。

1894
01:33:39,750 --> 01:33:42,450
I'm going to go ahead and include cs50.h.
我要包含cs50.h头文件。

1895
01:33:42,450 --> 01:33:46,170
I'm going to include stdio.h, int main void.
我要包含stdio.h头文件，定义主函数。

1896
01:33:46,170 --> 01:33:49,620
And then inside of main, I'm going to prompt the user for their name.
然后在主函数中，我将提示用户输入姓名。

1897
01:33:49,620 --> 01:33:51,930
get_string, quote-unquote, "Name."
使用get_string函数获取输入，并提示用户输入“姓名”。

1898
01:33:51,930 --> 01:33:55,152
And then I'm going to go ahead and I want
然后我要开始

1899
01:33:55,152 --> 01:33:56,610
to count the length of this string.
计算这个字符串的长度。

1900
01:33:56,610 --> 01:33:57,943
But I know what a string is now.
但现在我知道字符串是什么了。

1901
01:33:57,943 --> 01:34:01,720
It's char, char, char, char, and then eventually the null character.
它由一个一个字符组成，最终以一个空字符结尾。

1902
01:34:01,720 --> 01:34:02,685
So I can look for that.
所以我可以查找空字符。

1903
01:34:02,685 --> 01:34:04,560
And I can write this in a few different ways.
我可以使用多种方法来编写代码。

1904
01:34:04,560 --> 01:34:06,518
I know a bunch of different types of loops now,
我现在知道很多种循环类型，

1905
01:34:06,518 --> 01:34:10,440
but I'm going to go with a while loop by first declaring a variable n,
但我要使用while循环，首先定义一个名为n的变量，

1906
01:34:10,440 --> 01:34:12,618
for number of characters, set it equal to 0.
用于存储字符数量，并将其初始化为0。

1907
01:34:12,618 --> 01:34:14,910
It's like starting to count with your fingers all down,
就像从零开始用手指计数，

1908
01:34:14,910 --> 01:34:17,910
and I want to do the equivalent of this, counting each of the letters
我要做同样的事情，统计每个字母的数量

1909
01:34:17,910 --> 01:34:18,810
that I type in.
我输入的每个字符。

1910
01:34:18,810 --> 01:34:20,490
So I can do that as follows.
我可以按如下方式实现。

1911
01:34:20,490 --> 01:34:29,160
While the name variable at location n does not equal,
当name变量中第n个位置的值不等于

1912
01:34:29,160 --> 01:34:32,910
quote-unquote, backslash 0, which looks weird,
空字符（用反斜杠0表示），看起来很奇怪，

1913
01:34:32,910 --> 01:34:35,850
but it's just asking the question, is the character
但这只是在问，该位置的字符

1914
01:34:35,850 --> 01:34:39,850
at that location equal to the so-called null character?
是否等于空字符？

1915
01:34:39,850 --> 01:34:43,560
Which is written with single quotes and backslash 0 by convention.
根据惯例，空字符用单引号和反斜杠0表示。

1916
01:34:43,560 --> 01:34:48,300
And what I want to do, while that is true, is just add 1 to n.
当条件为真时，我要做的就是将n加1。

1917
01:34:48,300 --> 01:34:52,440
And then at the very bottom here, let's just go ahead and print out with %i
然后在最后，我们使用%i打印

1918
01:34:52,440 --> 01:34:57,540
the value of n because presumably if I type in HI, exclamation point,
n的值，因为假设我输入的是HI，感叹号，

1919
01:34:57,540 --> 01:35:01,860
I'm starting at 0 and I'm going to have H, I, exclamation point,
我从0开始，然后会有H，I，感叹号，

1920
01:35:01,860 --> 01:35:05,800
null character so I don't increment n a fourth time.
空字符，所以我不会第四次增加n。

1921
01:35:05,800 --> 01:35:08,460
So let's go ahead and run down here.
让我们运行这段代码。

1922
01:35:08,460 --> 01:35:12,735
make length ./length, Enter.
输入make length ./length，然后回车。

1923
01:35:12,735 --> 01:35:15,360
Well, I guess I'm asking for name, so I'll do my name for real.
嗯，它要求我输入姓名，所以我就输入我的真实姓名。

1924
01:35:15,360 --> 01:35:18,840
David, five characters, and I indeed get 5.
David，有五个字符，我确实得到了5。

1925
01:35:18,840 --> 01:35:22,750
If I used a for loop, I could do something similar,
如果我使用for循环，我可以做类似的事情，

1926
01:35:22,750 --> 01:35:26,070
but I think this while loop approach, much like our counter from the past,
但我认为这种while循环方法，就像我们之前使用的计数器一样，

1927
01:35:26,070 --> 01:35:27,330
is fairly straightforward.
非常直观。

1928
01:35:27,330 --> 01:35:28,600
But what if I want to do this?
但如果我想这样做呢？

1929
01:35:28,600 --> 01:35:30,780
What if I want to make another function for this?
如果我想为此创建一个新函数？

1930
01:35:30,780 --> 01:35:32,100
Well, I could do that.
当然可以。

1931
01:35:32,100 --> 01:35:32,888
Let me--
让我

1932
01:35:32,888 --> 01:35:33,930
All right, let's do this.
好的，我们来试试。

1933
01:35:33,930 --> 01:35:36,840
Let's write a quick function called string_length.
让我们编写一个名为string_length的简短函数。

1934
01:35:36,840 --> 01:35:40,172
It's going to take a string called s or whatever as input.
它将接收一个名为s的字符串作为输入。

1935
01:35:40,172 --> 01:35:41,130
And then you know what?
然后你知道吗？

1936
01:35:41,130 --> 01:35:43,590
Let's just do this in that function.
让我们直接在这个函数中实现它。

1937
01:35:43,590 --> 01:35:45,810
I'm going to borrow my code from a moment ago.
我要从刚才的代码中借用一些代码。

1938
01:35:45,810 --> 01:35:47,720
I'm going to paste it into this function.
我要将代码粘贴到这个函数中。

1939
01:35:47,720 --> 01:35:49,470
But I'm not going to print out the length,
但我不会打印出长度，

1940
01:35:49,470 --> 01:35:51,060
I'm going to return the length n.
我会返回长度n。

1941
01:35:51,060 --> 01:35:53,280
So I have a helper function of sorts that's
所以，我创建了一个辅助函数，它

1942
01:35:53,280 --> 01:35:55,590
going to hand me back the length of the string,
将返回字符串的长度，

1943
01:35:55,590 --> 01:36:00,780
and that's why this returns an int, but takes a string as its argument.
因此它返回一个整数类型的值，但接收一个字符串作为参数。

1944
01:36:00,780 --> 01:36:01,860
How do I use this?
我该如何使用它呢？

1945
01:36:01,860 --> 01:36:04,120
Well, first, I do need to copy the prototype
首先，我需要复制函数原型

1946
01:36:04,120 --> 01:36:06,090
so I don't get into trouble as before.
以避免出现之前的问题。

1947
01:36:06,090 --> 01:36:07,020
Semicolon.
加上分号。

1948
01:36:07,020 --> 01:36:10,020
And then in my main function, what I think I can do now
然后在我的主函数中，我认为现在我可以

1949
01:36:10,020 --> 01:36:11,380
is something like this.
这样做。

1950
01:36:11,380 --> 01:36:17,942
I can do int length equals the string length of the name variable
我可以定义一个名为length的整数变量，并将其赋值为name变量的字符串长度

1951
01:36:17,942 --> 01:36:18,900
that was just typed in.
刚刚输入的姓名。

1952
01:36:18,900 --> 01:36:23,940
And now using printf %i, print out length, semicolon.
现在使用printf %i打印出length的值，加上分号。

1953
01:36:23,940 --> 01:36:25,440
So exact same logic.
所以逻辑完全相同。

1954
01:36:25,440 --> 01:36:28,050
The only thing I've done that's different this time is I've
这次我做的唯一不同的是，我

1955
01:36:28,050 --> 01:36:30,210
added a helper function just to demonstrate
添加了一个辅助函数，只是为了演示

1956
01:36:30,210 --> 01:36:32,610
how I can take some pretty basic functionality,
如何将一些非常基本的功能，

1957
01:36:32,610 --> 01:36:35,010
find the length of a string, and modularize it
找到字符串的长度，并将其模块化

1958
01:36:35,010 --> 01:36:38,040
into a function abstract it away so I never again have
封装成一个函数，将其抽象化，这样我就不再需要

1959
01:36:38,040 --> 01:36:39,270
to copy-paste that for loop.
复制粘贴那个for循环。

1960
01:36:39,270 --> 01:36:41,020
I now have a function called string_length
我现在有一个名为string_length的函数

1961
01:36:41,020 --> 01:36:43,695
that will solve this problem for me.
可以解决这个问题。

1962
01:36:43,695 --> 01:36:46,600
Whoops, wrong program. make length.
哎哟，程序错了，应该是make length。

1963
01:36:46,600 --> 01:36:47,100
Huh.
嗯？

1964
01:36:47,100 --> 01:36:51,590
Use of undeclared identifier 'name.'
使用未声明的标识符“name”。

1965
01:36:51,590 --> 01:36:53,090
What did I do wrong?
我做错了什么？

1966
01:36:53,090 --> 01:36:59,350
Apparently on line 16 of length.c, what did I do wrong here?
显然是在length.c的第16行，这里我做错了什么？

1967
01:36:59,350 --> 01:37:00,639
Yeah, in front.
是的，前面。

1968
01:37:00,639 --> 01:37:06,210
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1969
01:37:06,210 --> 01:37:06,960
DAVID MALAN: Good.
大卫·马兰：很好。

1970
01:37:06,960 --> 01:37:09,190
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1971
01:37:09,190 --> 01:37:09,940
DAVID MALAN: Good.
大卫·马兰：很好。

1972
01:37:09,940 --> 01:37:10,840
Perfect terminology.
完美的术语。

1973
01:37:10,840 --> 01:37:12,850
So name is local to main.
所以name只在main函数中可见。

1974
01:37:12,850 --> 01:37:16,930
The scope of name is main, though sounds similar, but different words.
name的作用域是main，虽然听起来相似，但却是不同的词语。

1975
01:37:16,930 --> 01:37:19,720
And so I'm actually should be calling this
所以，我实际上应该调用

1976
01:37:19,720 --> 01:37:24,970
s because s is the name of the local variable being passed in even though it
s，因为s是传入的局部变量的名称，即使它

1977
01:37:24,970 --> 01:37:29,410
happens to be 1 and the same as name because on line 9,
碰巧与name相同，因为在第9行，

1978
01:37:29,410 --> 01:37:32,060
I'm indeed passing in name as the argument.
我确实将name作为参数传入。

1979
01:37:32,060 --> 01:37:32,560
All right.
好的。

1980
01:37:32,560 --> 01:37:35,450
So this is where, again, copy-paste can sometimes get you into trouble.
所以，这里再次说明，复制粘贴有时会导致问题。

1981
01:37:35,450 --> 01:37:36,760
Let's try to make length again.
让我们再次尝试make length。

1982
01:37:36,760 --> 01:37:42,520
Now it works. ./length, D-A-V-I-D, and now we have a function that seems to be
现在它可以正常运行了。输入./length，然后输入D-A-V-I-D，现在我们有一个看起来正常的函数。

1983
01:37:42,520 --> 01:37:43,090
working.
工作。

1984
01:37:43,090 --> 01:37:45,490
But this is such like commodity functionality.
但这就像一种商品功能。

1985
01:37:45,490 --> 01:37:47,770
Like my God, like surely someone before us
我的天哪，肯定有人在我们之前

1986
01:37:47,770 --> 01:37:51,070
has written a function to get the length of a string before,
写过一个函数来获取字符串的长度，

1987
01:37:51,070 --> 01:37:53,080
and indeed, other people have.
确实如此，其他人也写过。

1988
01:37:53,080 --> 01:37:56,560
So it turns out that in C, just as you have the stdio library,
事实证明，在C语言中，就像你拥有stdio库一样，

1989
01:37:56,560 --> 01:38:00,580
you also have a string library whose header file is called, appropriately,
你也有一个字符串库，它的头文件被称为string.h，非常贴切。

1990
01:38:00,580 --> 01:38:01,600
string.h.
string.h。

1991
01:38:01,600 --> 01:38:05,200
In fact CS50 has documentation, therefore, in its own manual pages,
实际上，CS50 在其自己的手册页面中提供了文档，

1992
01:38:05,200 --> 01:38:08,020
so to speak, along with some sample usage thereof.
可以這麼說，還有一些示例用法。

1993
01:38:08,020 --> 01:38:10,580
But it turns out, in the string library, there
但事實證明，在字符串庫中，

1994
01:38:10,580 --> 01:38:13,850
is a very popular function analogous to the Python one
有一個非常流行的函數，類似於 Python 中的函數

1995
01:38:13,850 --> 01:38:16,370
that you asked about earlier called strlen
你之前問的叫做 strlen

1996
01:38:16,370 --> 01:38:19,250
where strlen, one word, no underscores, just
strlen，一個單詞，沒有下劃線，

1997
01:38:19,250 --> 01:38:20,875
figures out the length of a string.
計算字符串的長度。

1998
01:38:20,875 --> 01:38:23,000
And honestly, I've never looked at its source code,
老實說，我從未看過它的源代碼，

1999
01:38:23,000 --> 01:38:26,030
but it probably uses a while loop, maybe it uses a for loop,
但它可能使用了 while 循環，也許使用了 for 循環，

2000
01:38:26,030 --> 01:38:30,320
but it certainly uses the same idea of just iterating-- that is,
但它肯定使用了相同的迭代思想——也就是說，

2001
01:38:30,320 --> 01:38:33,380
walking from left to right over a variable
從左到右遍歷一個變量

2002
01:38:33,380 --> 01:38:36,860
in order to figure out what the length of a given string is.
以便找出給定字符串的長度。

2003
01:38:36,860 --> 01:38:38,040
So how do we use this?
那麼我們如何使用它呢？

2004
01:38:38,040 --> 01:38:42,410
Well if I go back to VS Code here, I can throw away
好吧，如果我回到 VS Code，我可以丟棄

2005
01:38:42,410 --> 01:38:44,810
the entirety of my string length function,
我的字符串長度函數的全部內容，

2006
01:38:44,810 --> 01:38:47,870
I can throw away the prototype, therefore,
因此，我可以丟棄原型，

2007
01:38:47,870 --> 01:38:52,640
and I can include a third header file, string.h, inside
我可以在裡面添加第三個頭文件 string.h

2008
01:38:52,640 --> 01:38:55,460
of which I claim now is this function called strlen
我現在聲稱這個函數叫做 strlen

2009
01:38:55,460 --> 01:38:58,370
that I can just now use out of the box for free
我現在就可以免費使用它

2010
01:38:58,370 --> 01:39:00,560
because someone else wrote this function for me.
因為其他人為我編寫了這個函數。

2011
01:39:00,560 --> 01:39:03,870
And string.h will teach the compiler that it exists.
而 string.h 將告訴編譯器它存在。

2012
01:39:03,870 --> 01:39:10,700
So if I now do make length and ./length, now I have a similarly working program
所以，如果我現在運行 make length 和 ./length，我現在有一個類似工作的程序

2013
01:39:10,700 --> 01:39:14,720
that doesn't bother having me write unnecessary code.
它不必讓我寫不必要的代碼。

2014
01:39:14,720 --> 01:39:16,880
So this is another example of a library.
所以這是另一個庫的例子。

2015
01:39:16,880 --> 01:39:22,060
The string library is just going to make our lives easier by not having to--
字符串庫只會讓我們的編程更輕鬆，而無需——

2016
01:39:22,060 --> 01:39:25,082
for us not having to reinvent some wheel.
讓我們不必重新發明輪子。

2017
01:39:25,082 --> 01:39:27,290
All right, well where else does this get interesting?
好吧，還有哪裡有趣呢？

2018
01:39:27,290 --> 01:39:29,730
How about something like this?
比如這樣？

2019
01:39:29,730 --> 01:39:31,970
Let me go back into VS Code here.
讓我回到 VS Code 中。

2020
01:39:31,970 --> 01:39:35,138
Let's create a program called string.c--
讓我們創建一個叫做 string.c 的程序——

2021
01:39:35,138 --> 01:39:38,180
we'll play around with our own strings-- that's going to start similarly.
我們將使用自己的字符串——開始方式類似。

2022
01:39:38,180 --> 01:39:44,030
So let's include cs50.h, let's include stdio.h,
所以讓我們包含 cs50.h，讓我們包含 stdio.h，

2023
01:39:44,030 --> 01:39:48,230
let's include string.h so we can use that same strlen function.
讓我們包含 string.h，以便我們可以使用相同的 strlen 函數。

2024
01:39:48,230 --> 01:39:50,030
int main void.
int main void.

2025
01:39:50,030 --> 01:39:51,810
And inside of this, let's do this.
在這裡面，讓我們做這個。

2026
01:39:51,810 --> 01:39:57,410
Let's get a string s and prompt the user for any old string as input.
讓我們獲取一個字符串 s 並提示用戶輸入任意字符串。

2027
01:39:57,410 --> 01:39:57,910
All right.
好的。

2028
01:39:57,910 --> 01:40:04,140
And then let's go ahead and maybe print out, quote-unquote, "Output."
然後，讓我們繼續打印，引號中的 “輸出”。

2029
01:40:04,140 --> 01:40:07,238
And I'm just going to line up my spaces just right because these words are
我將把我的空格對齊，因為這些單詞

2030
01:40:07,238 --> 01:40:09,780
slightly different lengths, but we'll see why I'm doing this.
長度略有不同，但我們會看到我為什麼這樣做。

2031
01:40:09,780 --> 01:40:11,860
It's just for aesthetics' sake in a moment.
這只是為了美觀。

2032
01:40:11,860 --> 01:40:13,380
And let's go ahead now and do this.
現在讓我們繼續做這個。

2033
01:40:13,380 --> 01:40:17,348
If I want to print out every character in a string, how can I now do this?
如果我想打印出字符串中的每個字符，我現在如何做到呢？

2034
01:40:17,348 --> 01:40:19,140
Well, this is actually a pretty common task
好吧，這其實是一個很常見的任務

2035
01:40:19,140 --> 01:40:23,580
even though this version, thereof, will seem pointless. for int i gets 0,
即使這個版本看起來毫無意義。for int i 獲取 0，

2036
01:40:23,580 --> 01:40:26,460
i is less than the length of s.
i 小於 s 的長度。

2037
01:40:26,460 --> 01:40:31,800
i++ is just the conventional way to start a loop that iterates from left
i++ 只是開始從左到右迭代循環的傳統方式

2038
01:40:31,800 --> 01:40:34,260
to right over a string of that length.
到那個長度的字符串。

2039
01:40:34,260 --> 01:40:38,190
And then let's go ahead and print out each character, %c,
然後，讓我們繼續打印出每個字符，%c，

2040
01:40:38,190 --> 01:40:43,800
printing out the string at location i using our fancy new array syntax.
使用我們新奇的數組語法打印出位於 i 位置的字符串。

2041
01:40:43,800 --> 01:40:45,780
And at the very end of this program, let's just
在這個程序的最後，讓我們

2042
01:40:45,780 --> 01:40:48,870
print out a new line character just to move the cursor to the bottom
打印一個換行符，以將光標移動到底部

2043
01:40:48,870 --> 01:40:50,200
like we've done in the past.
就像我們過去所做的那樣。

2044
01:40:50,200 --> 01:40:54,030
So this is kind of a stupid program like I am reinventing the wheel that is
所以，這個程序有點愚蠢，就像我在重新發明輪子一樣

2045
01:40:54,030 --> 01:40:56,130
the %s format code.
%s 格式代碼。

2046
01:40:56,130 --> 01:40:58,600
I already know that printf can print out a whole string.
我已經知道 printf 可以打印出整個字符串。

2047
01:40:58,600 --> 01:40:59,650
Suppose it didn't.
假設它不能。

2048
01:40:59,650 --> 01:41:03,100
Suppose I forgot about %s and I only knew about %c,
假設我忘記了 %s，我只知道 %c，

2049
01:41:03,100 --> 01:41:09,100
these lines of code here collectively will print out the entirety of a string
這裡的這些代碼將共同打印出整個字符串

2050
01:41:09,100 --> 01:41:12,050
character by character based on its length.
基於它的長度，逐個字符地打印。

2051
01:41:12,050 --> 01:41:17,770
So if I compile this program, make string ./string and type in my name--
所以，如果我編譯這個程序，運行 make string ./string 並輸入我的名字——

2052
01:41:17,770 --> 01:41:20,870
for instance, David, the output is D-A-V-I-D,
比如，David，輸出是 D-A-V-I-D，

2053
01:41:20,870 --> 01:41:22,870
and here's why I hit the spacebar an extra time,
這是為什麼我多按了一下空格鍵，

2054
01:41:22,870 --> 01:41:26,230
because I wanted input and output to line up nicely so we could see that
因為我希望輸入和輸出整齊地對齊，以便我們可以看到

2055
01:41:26,230 --> 01:41:27,680
they're, in fact, the same length.
它們事實上是相同的長度。

2056
01:41:27,680 --> 01:41:28,930
So let me just stipulate.
所以讓我簡單說明一下。

2057
01:41:28,930 --> 01:41:35,390
This code is correct, but there is an inefficiency with this line of code.
這個代碼是正確的，但這行代碼存在一個低效的地方。

2058
01:41:35,390 --> 01:41:38,020
Let's talk about design instinctively.
讓我們本能地談談設計。

2059
01:41:38,020 --> 01:41:42,550
What is maybe bad about this line of code 9--
這行代碼 9 有什麼不好——

2060
01:41:42,550 --> 01:41:44,650
line 9 that I've highlighted?
我已經突出顯示的第 9 行？

2061
01:41:44,650 --> 01:41:47,020
This one is subtle.
這個很微妙。

2062
01:41:47,020 --> 01:41:47,950
Let's go over here.
讓我們過去那邊看看。

2063
01:41:47,950 --> 01:41:51,900
AUDIENCE: [INAUDIBLE]
觀眾： [聽不清]

2064
01:41:51,900 --> 01:41:54,120
DAVID MALAN: Yeah.
大衛·馬蘭：是的。

2065
01:41:54,120 --> 01:41:58,930
I'm calling strlen inside of the loop again and again and again.
我在循環裡面不斷地調用 strlen。

2066
01:41:58,930 --> 01:41:59,430
Why?
為什麼？

2067
01:41:59,430 --> 01:42:00,847
Well, recall how for loops worked.
好吧，回憶一下 for 循環是如何工作的。

2068
01:42:00,847 --> 01:42:03,870
When we walked through it last week, that middle part of for loop
上週我們講解時，for 循環中間部分

2069
01:42:03,870 --> 01:42:07,230
in between the semicolons keeps getting checked, keeps getting checked,
分號之間的部分會不斷被檢查，不斷被檢查，

2070
01:42:07,230 --> 01:42:08,320
keeps getting checked.
不斷被檢查。

2071
01:42:08,320 --> 01:42:12,030
And so if you put a function call there, which is totally fine syntactically,
所以，如果你在那裡放一個函數調用，從語法上來說是完全沒問題的，

2072
01:42:12,030 --> 01:42:14,970
you're asking the same damn question again and again and again.
你一遍又一遍地問著相同的問題。

2073
01:42:14,970 --> 01:42:17,790
And the length of David, D-A-V-I-D, is never changing.
而且 David 的長度，D-A-V-I-D，從未改變。

2074
01:42:17,790 --> 01:42:21,330
So strlen, implemented decades ago by some other human,
所以 strlen，在幾十年前由其他人實現，

2075
01:42:21,330 --> 01:42:23,700
has some kind of loop in it, and you're literally
它裡面有某種循環，而你實際上

2076
01:42:23,700 --> 01:42:26,580
making that code run again and again and again just
不斷地執行那段代碼，

2077
01:42:26,580 --> 01:42:29,123
to get the same answer 5 again and again.
一遍又一遍地得到相同的答案 5。

2078
01:42:29,123 --> 01:42:30,540
So I think your instinct is right.
所以我認為你的直覺是正確的。

2079
01:42:30,540 --> 01:42:33,928
I could come up with another variable outside of the loop.
我可以想出另一個在循環外部的變量。

2080
01:42:33,928 --> 01:42:35,220
I could do something like this.
我可以做類似的事情。

2081
01:42:35,220 --> 01:42:40,830
int length equals strlen of s, and then I could just plug that in.
int length 等於 s 的 strlen，然後我就可以直接將它代入。

2082
01:42:40,830 --> 01:42:42,658
But there's a slightly more elegant way.
但有一個更優雅的方法。

2083
01:42:42,658 --> 01:42:44,700
If you like doing things with slightly less code,
如果你喜歡用更少的代碼做事，

2084
01:42:44,700 --> 01:42:46,440
this is correct as I've now written it.
這是我現在寫的，是正確的。

2085
01:42:46,440 --> 01:42:50,400
It's less efficient-- it's more efficient because I'm only
它效率更低——它效率更高，因為我只

2086
01:42:50,400 --> 01:42:53,440
calling strlen once now on this new line 9,
在新的第 9 行調用了一次 strlen，

2087
01:42:53,440 --> 01:42:56,560
but a more common way to write this would typically
但更常见的写法通常

2088
01:42:56,560 --> 01:42:58,360
be to do something like this.
是像这样做的。

2089
01:42:58,360 --> 01:43:02,860
After initializing i, you can also initialize something else like length.
初始化 i 后，还可以初始化其他东西，比如 length。

2090
01:43:02,860 --> 01:43:07,580
And you can set length equal to strlen of s, then your semicolon,
然后你可以将 length 设置为 s 的 strlen，然后是分号，

2091
01:43:07,580 --> 01:43:10,755
and now you can say while i is less than that length.
现在你可以说，只要 i 小于该长度。

2092
01:43:10,755 --> 01:43:12,130
Or I can tighten this up further.
或者我可以进一步紧凑。

2093
01:43:12,130 --> 01:43:15,580
If it's just a number and it's a super short loop, might as well just call it
如果它只是一个数字，而且是一个超短的循环，不妨直接称它为

2094
01:43:15,580 --> 01:43:16,120
n.
n。

2095
01:43:16,120 --> 01:43:20,920
So this now would be a canonical way of implementing the exact same idea,
所以现在将是实现完全相同想法的规范方法，

2096
01:43:20,920 --> 01:43:23,770
but without the inefficiency because now you're
但没有效率低下，因为现在你正在

2097
01:43:23,770 --> 01:43:28,150
calling strlen in the initialization part of for loop,
在 for 循环的初始化部分调用 strlen，

2098
01:43:28,150 --> 01:43:32,650
not inside of the Boolean expression that gets checked and executed
而不是在被检查和执行的布尔表达式内部

2099
01:43:32,650 --> 01:43:34,000
again and again.
一次又一次。

2100
01:43:34,000 --> 01:43:34,510
Yeah?
对吧？

2101
01:43:34,510 --> 01:43:38,965
AUDIENCE: [INAUDIBLE]
观众： [听不清]

2102
01:43:38,965 --> 01:43:39,840
DAVID MALAN: Correct.
大卫·马兰： 正确。

2103
01:43:39,840 --> 01:43:43,200
Well, I'm declaring i as an int, but by way of the comma,
好吧，我将 i 声明为一个 int，但通过逗号，

2104
01:43:43,200 --> 01:43:45,570
I am also declaring n as an int.
我也将 n 声明为一个 int。

2105
01:43:45,570 --> 01:43:49,110
So they've got to be the same type for this trick to work.
所以它们必须是相同类型，才能使这个技巧生效。

2106
01:43:49,110 --> 01:43:50,370
Good observation.
好的观察。

2107
01:43:50,370 --> 01:43:54,470
Other questions on this one here?
还有其他关于这个的问题吗？

2108
01:43:54,470 --> 01:43:54,970
No?
没有？

2109
01:43:54,970 --> 01:43:55,540
All right.
好吧。

2110
01:43:55,540 --> 01:43:58,900
Well, let's play around further here.
好吧，让我们进一步玩玩。

2111
01:43:58,900 --> 01:44:01,862
Let me propose that there's other libraries and header files
我来提议一下，还有其他库和头文件

2112
01:44:01,862 --> 01:44:03,320
as well that you might find useful.
也可能对你有用。

2113
01:44:03,320 --> 01:44:05,800
There's also something called ctype, which relates to types
还有一个叫做 ctype 的东西，它与类型有关

2114
01:44:05,800 --> 01:44:08,500
and c's that's got a bunch of useful functions
和 c 的，它有一堆有用的函数

2115
01:44:08,500 --> 01:44:12,200
that we can actually see if we visit the documentation here.
我们实际上可以在这里访问文档来查看。

2116
01:44:12,200 --> 01:44:14,200
But before we get there, let me actually whip up
但在我们到达那里之前，让我实际编写一个

2117
01:44:14,200 --> 01:44:17,680
a program that maybe does something a little bit fun, albeit low level,
一个程序，它可能做一些有趣的事情，虽然是低级的，

2118
01:44:17,680 --> 01:44:21,590
like forcing some string to uppercase if the human types it in lowercase.
比如强制将一些字符串转换为大写，如果用户输入的是小写。

2119
01:44:21,590 --> 01:44:25,120
So let me go ahead and write a program called uppercase.c.
所以让我先写一个叫做 uppercase.c 的程序。

2120
01:44:25,120 --> 01:44:27,940
Let me go ahead and give myself the same header files.
让我先给自己相同的头文件。

2121
01:44:27,940 --> 01:44:31,840
Include cs50.h, include stdio.h.
包含 cs50.h，包含 stdio.h。

2122
01:44:31,840 --> 01:44:34,960
And for now, let's include string.h for the length.
现在，让我们包含 string.h 来获取长度。

2123
01:44:34,960 --> 01:44:38,570
And let's go ahead and have int main void as before.
然后让我们像以前一样使用 int main void。

2124
01:44:38,570 --> 01:44:40,840
And inside of main, let's give myself a string
在 main 内部，让我们给自己一个字符串

2125
01:44:40,840 --> 01:44:46,780
s equaling get_string "Before," just so I know what the string is initially.
s 等于 get_string "Before"，这样我就知道字符串最初是什么。

2126
01:44:46,780 --> 01:44:50,560
Now I'm going to print out proactively "After" with two spaces
现在我要主动打印 "After" 以及两个空格

2127
01:44:50,560 --> 01:44:53,740
just so that things line up aesthetically on the screen
这样东西在屏幕上看起来会比较美观

2128
01:44:53,740 --> 01:44:55,580
because "After" is one character shorter.
因为 "After" 短了一个字符。

2129
01:44:55,580 --> 01:44:57,920
And now I'm going to do the same technique as before.
现在我要做与之前相同的技巧。

2130
01:44:57,920 --> 01:45:07,340
for int i equals 0, n equals the string length of s, i is less than n, i++.
for int i 等于 0，n 等于 s 的字符串长度，i 小于 n，i++。

2131
01:45:07,340 --> 01:45:10,940
And then inside of this loop, what do I want to do logically?
然后在这个循环内部，我逻辑上想要做什么？

2132
01:45:10,940 --> 01:45:15,710
I want to force these characters to uppercase if they are, in fact,
我想将这些字符强制转换为大写，如果它们实际上是

2133
01:45:15,710 --> 01:45:16,670
lowercase.
小写。

2134
01:45:16,670 --> 01:45:18,083
And so how might I do this?
那么我该如何做到呢？

2135
01:45:18,083 --> 01:45:20,000
Well, there's a bunch of ways to express this,
好吧，有很多种方法可以表达这一点，

2136
01:45:20,000 --> 01:45:22,640
but I'm going to do it maybe the most straightforward way
但我可能要采用最直接的方式

2137
01:45:22,640 --> 01:45:24,260
even if you've not seen this before.
即使你以前没有见过。

2138
01:45:24,260 --> 01:45:28,760
If the current letter in the string at location i,
如果字符串中位置 i 处的当前字母，

2139
01:45:28,760 --> 01:45:31,970
because I'm in a loop starting from 0 all the way up to, but not
因为我处在一个从 0 开始一直到，但不是

2140
01:45:31,970 --> 01:45:34,400
through the string length, is greater than
字符串长度，大于

2141
01:45:34,400 --> 01:45:42,110
or equal to a lowercase a, in single quotes, and that letter is less than
或等于一个单引号中的小写字母 a，并且该字母小于

2142
01:45:42,110 --> 01:45:43,970
or equal to a lowercase z.
或等于一个小写字母 z。

2143
01:45:43,970 --> 01:45:45,440
What does this mean in English?
用英语来说，这意味着什么？

2144
01:45:45,440 --> 01:45:48,740
Well, this essentially means if lowercase--
好吧，这本质上意味着如果小写——

2145
01:45:48,740 --> 01:45:52,280
logically, if it's greater than or equal to little a and less than
逻辑上，如果它大于或等于小写字母 a，并且小于

2146
01:45:52,280 --> 01:45:55,760
or equal to little z, it's somewhere between and z in lowercase.
或等于小写字母 z，那么它在小写字母 a 和 z 之间。

2147
01:45:55,760 --> 01:45:57,060
What do I want to do?
我想做什么？

2148
01:45:57,060 --> 01:45:58,670
Well, I want to force it to uppercase.
好吧，我想把它强制转换为大写。

2149
01:45:58,670 --> 01:46:03,260
So I want to print out a character without a new line yet
所以我想打印出一个字符，但还没有换行

2150
01:46:03,260 --> 01:46:07,880
that prints out the current character, but force it to uppercase.
它打印出当前字符，但强制它转换为大写。

2151
01:46:07,880 --> 01:46:09,120
Well, how can I do this?
好吧，我该怎么做呢？

2152
01:46:09,120 --> 01:46:12,560
Well, this is where this gets into some low-level hacking,
好吧，这就是它开始进行一些低级黑客操作的地方，

2153
01:46:12,560 --> 01:46:14,480
but notice the same ASCII chart.
但请注意相同的 ASCII 表。

2154
01:46:14,480 --> 01:46:17,640
Here's our uppercase letters from last time.
这是我们上次的大写字母。

2155
01:46:17,640 --> 01:46:20,900
Here's our lowercase characters, and let me highlight those.
这是我们的所有小写字符，让我突出显示它们。

2156
01:46:20,900 --> 01:46:25,370
Does anyone notice a relationship between capital A and lowercase a
有人注意到大写字母 A 和小写字母 a 之间的关系吗

2157
01:46:25,370 --> 01:46:29,540
that happens to be the same for capital B and lowercase b?
对于大写字母 B 和小写字母 b 也是一样吗？

2158
01:46:29,540 --> 01:46:33,000
AUDIENCE: Capital A [INAUDIBLE].
观众： 大写字母 A [听不清]。

2159
01:46:33,000 --> 01:46:33,750
DAVID MALAN: Yeah.
大卫·马兰： 是的。

2160
01:46:33,750 --> 01:46:35,170
Like this pattern is true.
就像这个模式是正确的。

2161
01:46:35,170 --> 01:46:40,140
So 97 minus 65 is 32, and that's true for every lowercase and uppercase
所以 97 减去 65 等于 32，对于所有的小写字母和大写字母来说都是这样

2162
01:46:40,140 --> 01:46:41,170
letter respectively.
字母。

2163
01:46:41,170 --> 01:46:42,420
So I can leverage that.
所以我利用了这一点。

2164
01:46:42,420 --> 01:46:43,950
And this is not a CS50 thing.
这不是 CS50 的东西。

2165
01:46:43,950 --> 01:46:44,850
Like this is ASCII.
就像这是 ASCII。

2166
01:46:44,850 --> 01:46:45,990
This is, in turn, Unicode.
反过来，这就是 Unicode。

2167
01:46:45,990 --> 01:46:47,533
This is how modern computers work.
这就是现代计算机的工作原理。

2168
01:46:47,533 --> 01:46:49,950
So if I go back to VS Code here, you know what I could do.
所以如果我回到 VS Code 这里，你知道我可以做什么。

2169
01:46:49,950 --> 01:46:52,350
Let's just literally subtract 32.
让我们直接减去 32。

2170
01:46:52,350 --> 01:46:55,440
But because I'm displaying this as a char, not as an int,
但因为我将其显示为 char，而不是 int，

2171
01:46:55,440 --> 01:47:01,080
I'm going to see the lowercase letter seemingly become an uppercase instead.
我将看到小写字母似乎变成了大写。

2172
01:47:01,080 --> 01:47:05,310
Else, if it's not lowercase-- maybe it's already uppercase,
否则，如果它不是小写——也许它已经是大写了，

2173
01:47:05,310 --> 01:47:09,420
maybe it is punctuation, let's just go ahead and print out with %c
也许它是标点符号，让我们直接使用 %c 打印出来

2174
01:47:09,420 --> 01:47:11,462
the original character unaltered.
原来的字符不作修改。

2175
01:47:11,462 --> 01:47:13,170
And then at the very end of this program,
然后在这个程序的最后，

2176
01:47:13,170 --> 01:47:17,670
let's print a new line just to move the cursor to the next line.
让我们打印一个换行符，以便将光标移动到下一行。

2177
01:47:17,670 --> 01:47:19,950
All right, so let's do make uppercase.
好了，让我们做 make uppercase。

2178
01:47:19,950 --> 01:47:22,500
And let me type ./uppercase.
然后让我输入 ./uppercase。

2179
01:47:22,500 --> 01:47:26,100
And I'll type in D-A-V-I-D, all lowercase, and now,
然后我会输入 D-A-V-I-D，全部小写，现在，

2180
01:47:26,100 --> 01:47:27,750
you'll see it's in all caps.
你会看到它全部是大写的。

2181
01:47:27,750 --> 01:47:31,920
If, though, I type in maybe my last name but capitalized M, that's OK,
但是，如果我输入我的姓氏，但 M 大写，那没关系，

2182
01:47:31,920 --> 01:47:34,930
the rest of it will still be capitalized for me.
其余部分仍然会为我大写。

2183
01:47:34,930 --> 01:47:36,710
Now I don't love this technique.
我现在不喜欢这种方法。

2184
01:47:36,710 --> 01:47:40,090
It's a little bit fragile because I had to do some math.
它有点脆弱，因为我不得不做一些数学运算。

2185
01:47:40,090 --> 01:47:43,220
I had to check my reference sheet and then incorporate it into my program.
我不得不查看我的参考表，然后将其整合到我的程序中。

2186
01:47:43,220 --> 01:47:45,940
Even though it will be correct, I could be a little more clever.
即使它将是正确的，我也可以更聪明一些。

2187
01:47:45,940 --> 01:47:47,607
I could actually do something like this.
我实际上可以做这样的事情。

2188
01:47:47,607 --> 01:47:49,720
Well, whatever the value of lowercase is--
好吧，无论小写字母的值是什么 -

2189
01:47:49,720 --> 01:47:53,650
lowercase a is minus whatever the value of capital A is,
小写 a 减去大写 A 的值，

2190
01:47:53,650 --> 01:47:56,378
and I could actually do it arithmetically even though that, too,
我实际上可以用算术的方式做到，即使这样，

2191
01:47:56,378 --> 01:47:59,170
is somewhat inefficient in that it's asking the same question again
效率有点低，因为它一直在问同样的问题

2192
01:47:59,170 --> 01:48:02,320
and again, but the compiler is probably smart enough to optimize that.
又问了一次，但编译器可能足够聪明，可以优化它。

2193
01:48:02,320 --> 01:48:05,830
And frankly, for those more comfortable, a good compiler
坦率地说，对于那些更熟悉的人来说，一个好的编译器

2194
01:48:05,830 --> 01:48:07,930
will also notice, no, no, no, no, you don't
也会注意到，不，不，不，不，你不想

2195
01:48:07,930 --> 01:48:09,910
want to call strlen again and again.
一次又一次地调用 strlen。

2196
01:48:09,910 --> 01:48:13,330
The compiler can do some of these optimizations for you,
编译器可以为你做一些这些优化，

2197
01:48:13,330 --> 01:48:15,610
but it's still good practice to get into yourself.
但养成良好的习惯仍然很重要。

2198
01:48:15,610 --> 01:48:17,080
But there's probably a better way.
但可能有一种更好的方法。

2199
01:48:17,080 --> 01:48:19,630
Instead of rolling this solution ourselves
与其自己编写这个解决方案

2200
01:48:19,630 --> 01:48:22,810
and subtracting 32 or doing any arithmetic,
并减去 32 或做任何算术运算，

2201
01:48:22,810 --> 01:48:24,730
let's use that ctype library.
让我们使用那个 ctype 库。

2202
01:48:24,730 --> 01:48:27,280
Let me go back up to my header files.
让我回到我的头文件。

2203
01:48:27,280 --> 01:48:29,890
Let's additionally include ctype.h.
让我们另外包含 ctype.h。

2204
01:48:29,890 --> 01:48:33,100
Let's pretend like I read the documentation in advance, which I did,
让我们假装我已经提前阅读了文档，实际上我已经阅读过了，

2205
01:48:33,100 --> 01:48:33,940
in fact.
事实上。

2206
01:48:33,940 --> 01:48:37,570
And let's instead of doing any math here,
我们不用在这里进行任何数学运算，

2207
01:48:37,570 --> 01:48:41,590
let's use a function that exists in that library called toupper
让我们使用该库中存在的一个名为 toupper 的函数

2208
01:48:41,590 --> 01:48:47,740
and pass to it whatever the current character is in s at location i.
并将当前 s 中第 i 个位置的字符传递给它。

2209
01:48:47,740 --> 01:48:50,860
Otherwise, I still print out the unchanged character.
否则，我仍然打印出未更改的字符。

2210
01:48:50,860 --> 01:48:54,880
And let me go ahead and do make uppercase ./uppercase.
让我继续执行 make uppercase ./uppercase。

2211
01:48:54,880 --> 01:49:00,190
And now without any math, no subtracting 32, that, too, also works.
现在不需要任何数学运算，也不需要减去 32，它也同样有效。

2212
01:49:00,190 --> 01:49:01,240
But it gets better.
但它变得更好了。

2213
01:49:01,240 --> 01:49:03,430
If you read the documentation for toupper,
如果你阅读了 toupper 的文档，

2214
01:49:03,430 --> 01:49:07,570
it turns out its documentation tells you, if C is already uppercase,
事实证明，它的文档告诉你，如果 C 已经是大写字母，

2215
01:49:07,570 --> 01:49:09,950
it just passes it through for you.
它会直接传递给你。

2216
01:49:09,950 --> 01:49:12,550
So you don't even need to ask this conditional question.
所以你甚至不需要问这个条件问题。

2217
01:49:12,550 --> 01:49:17,710
I can actually cut this to my clipboard, get rid of all of this,
我实际上可以将其剪切到我的剪贴板，摆脱所有这些，

2218
01:49:17,710 --> 01:49:21,430
and just replace that one line only and just
只替换那一行，然后

2219
01:49:21,430 --> 01:49:25,600
let toupper handle the situation for me because again, its documentation
让 toupper 为我处理这种情况，因为它的文档

2220
01:49:25,600 --> 01:49:28,120
has assured me that if it's already uppercase,
向我保证，如果它已经是大写字母，

2221
01:49:28,120 --> 01:49:30,890
it's just going to return the original value.
它只会返回原始值。

2222
01:49:30,890 --> 01:49:33,670
So if I make uppercase, this time, ./uppercase,
所以如果我这次执行 make uppercase ./uppercase，

2223
01:49:33,670 --> 01:49:36,640
now it works and now things are getting kind of fun.
现在它可以工作了，现在事情变得有点有趣了。

2224
01:49:36,640 --> 01:49:38,740
I mean, these are mundane tasks, admittedly,
我的意思是，这些都是平凡的任务，不可否认，

2225
01:49:38,740 --> 01:49:41,410
but at least I'm standing on the shoulders of smart people
但至少我站在聪明人的肩膀上

2226
01:49:41,410 --> 01:49:45,040
who came before me who implemented the string library, the ctype library--
在我之前实施了字符串库、ctype 库的人 -

2227
01:49:45,040 --> 01:49:51,760
heck, even the CS50 Library so I don't need to reinvent any of those wheels.
哎呀，甚至包括 CS50 库，所以我也不需要重新发明轮子。

2228
01:49:51,760 --> 01:49:57,750
Questions on any of these library techniques?
关于这些库技巧的任何问题？

2229
01:49:57,750 --> 01:50:00,240
It's all still arrays, it's all still strings and chars,
它们仍然是数组，仍然是字符串和字符，

2230
01:50:00,240 --> 01:50:05,110
but now we're leveraging libraries to solve some of our problems for us.
但现在我们正在利用库来解决我们的一些问题。

2231
01:50:05,110 --> 01:50:05,610
All right.
好的。

2232
01:50:05,610 --> 01:50:07,890
So let's come full circle to where we began,
所以让我们回到最初的地方，

2233
01:50:07,890 --> 01:50:10,950
where and I mentioned that some programs include
在那里，我提到了一些程序包含

2234
01:50:10,950 --> 01:50:12,630
support for command line arguments.
对命令行参数的支持。

2235
01:50:12,630 --> 01:50:18,210
Like Clang takes command line arguments words after the word clang.
就像 Clang 会接受在 clang 之后出现的命令行参数。

2236
01:50:18,210 --> 01:50:21,270
CD, which you've used in Linux, takes command line arguments.
CD（你在 Linux 中使用过）接受命令行参数。

2237
01:50:21,270 --> 01:50:24,510
If you type cd, space, pset1 or cd, space,
如果你输入 cd、空格、pset1 或 cd、空格，

2238
01:50:24,510 --> 01:50:28,200
mario in order to change directories into another folder.
mario 来切换目录到另一个文件夹。

2239
01:50:28,200 --> 01:50:31,140
If you do rm like I did earlier, you can remove a file
如果你像我之前一样使用 rm，你可以删除一个文件

2240
01:50:31,140 --> 01:50:33,510
by using a command line argument, a second word that
通过使用命令行参数，即第二个词，它

2241
01:50:33,510 --> 01:50:35,730
tells the computer what to remove.
告诉计算机要删除什么。

2242
01:50:35,730 --> 01:50:38,520
Well, it turns out that you, too, can write
事实证明，你也可以编写

2243
01:50:38,520 --> 01:50:43,230
code that takes words at the command prompt and uses them as input.
接受命令提示符下的单词并将其用作输入的代码。

2244
01:50:43,230 --> 01:50:47,040
Up until now, you and I have only gotten user input via get_string, get_int,
到目前为止，你和我都只通过 get_string、get_int 获取用户输入，

2245
01:50:47,040 --> 01:50:48,810
get_float, and functions like that.
get_float 和类似的函数。

2246
01:50:48,810 --> 01:50:52,230
You, too, can write code that take command line arguments which,
你也可以编写接受命令行参数的代码，它

2247
01:50:52,230 --> 01:50:54,240
frankly, just save the human time.
坦率地说，只是节省了用户的时间。

2248
01:50:54,240 --> 01:50:57,790
They can type their entire thought at the command line, hit Enter, and boom,
他们可以在命令行中输入完整的想法，按下回车键，然后，

2249
01:50:57,790 --> 01:51:01,240
the program can complete without prompting them and re-prompting them
程序可以完成，而无需提示他们并重新提示他们

2250
01:51:01,240 --> 01:51:02,020
again.
再次。

2251
01:51:02,020 --> 01:51:05,680
So here's where we can now start to take off some more training wheels.
所以现在我们可以开始去掉更多辅助轮。

2252
01:51:05,680 --> 01:51:10,000
Up until now, we've just put void inside of the parentheses here any time
到目前为止，我们只是在括号中放入 void，无论何时

2253
01:51:10,000 --> 01:51:11,620
we implement main.
我们实现 main。

2254
01:51:11,620 --> 01:51:15,130
It turns out that you can put something else in parentheses
事实证明，你可以在括号中放入其他内容

2255
01:51:15,130 --> 01:51:18,820
when using C. It's a mouthful, but you can replace void
在使用 C 时。这是一个很长的词，但你可以用它来替换 void

2256
01:51:18,820 --> 01:51:23,800
with this bigger expression.
这个更大的表达式。

2257
01:51:23,800 --> 01:51:25,240
But it's two things.
但它有两部分。

2258
01:51:25,240 --> 01:51:28,960
int, called argc by convention, and a string,
int，按照惯例称为 argc，以及一个字符串，

2259
01:51:28,960 --> 01:51:32,920
but not a string, actually an array of strings called argv.
但实际上不是字符串，而是称为 argv 的字符串数组。

2260
01:51:32,920 --> 01:51:35,320
And these terms are a little arcane, but argc means
这些术语有点深奥，但 argc 代表

2261
01:51:35,320 --> 01:51:38,770
argument count-- how many words did the human type at the prompt?
参数计数 - 用户在提示符中输入了多少个单词？

2262
01:51:38,770 --> 01:51:41,410
Argv stands for argument vector, which is generally
Argv 代表参数向量，通常

2263
01:51:41,410 --> 01:51:42,762
another term for an array--
是数组的另一个术语 -

2264
01:51:42,762 --> 01:51:44,470
you've heard it perhaps from mathematics.
你可能在数学中听说过它。

2265
01:51:44,470 --> 01:51:48,440
It's like a list of values, or in this case, a list of command line arguments.
它就像一个值列表，或者在这种情况下，一个命令行参数列表。

2266
01:51:48,440 --> 01:51:49,790
So C is special.
所以 C 是特殊的。

2267
01:51:49,790 --> 01:51:54,370
If you declare main as not taking void inside of parentheses, but rather,
如果你将 main 声明为不接受括号内的 void，而是接受

2268
01:51:54,370 --> 01:51:58,270
an int and an array of strings, C will figure out
一个 int 和一个字符串数组，C 会弄清楚

2269
01:51:58,270 --> 01:52:00,880
whatever the human typed at the prompt and hand it to you
用户在提示符中输入的内容，并将它传递给你

2270
01:52:00,880 --> 01:52:03,620
as an array and the length thereof.
作为一个数组及其长度。

2271
01:52:03,620 --> 01:52:05,830
So if I want to leverage this, I can start
所以如果我想利用这一点，我可以开始

2272
01:52:05,830 --> 01:52:10,940
to implement some programs of my own that actually incorporate command line
实现我自己的程序，这些程序实际上包含命令行

2273
01:52:10,940 --> 01:52:11,440
arguments.
参数。

2274
01:52:11,440 --> 01:52:14,980
For instance, let me go back in a moment here to VS Code.
例如，让我回到 VS Code 中。

2275
01:52:14,980 --> 01:52:19,090
Let me create a program, for instance, called greet.c
让我创建一个程序，例如，名为 greet.c

2276
01:52:19,090 --> 01:52:21,590
that's just going to greet the user in a few different ways.
它只是用几种不同的方式来问候用户。

2277
01:52:21,590 --> 01:52:24,580
So let me first do it the old way. cs50.h.
所以让我先用老方法。cs50.h。

2278
01:52:24,580 --> 01:52:27,430
Let me include stdio.h.
让我包含stdio.h。

2279
01:52:27,430 --> 01:52:29,740
Let me do int main void still.
让我仍然使用int main void。

2280
01:52:29,740 --> 01:52:30,950
So the old way.
所以是老方法。

2281
01:52:30,950 --> 01:52:34,420
And if I want to greet myself or Carter or Yulie or anyone else,
如果我想问候我自己、卡特、尤里或其他人，

2282
01:52:34,420 --> 01:52:39,850
I could do, old fashioned now, get the answer from the user, get_string.
我可以使用老方法，从用户那里获取答案，get_string。

2283
01:52:39,850 --> 01:52:42,670
Let's prompt for "What's your name?" question mark,
让我们提示“你叫什么名字？”问号，

2284
01:52:42,670 --> 01:52:44,200
just like we did in Scratch.
就像我们在Scratch中做的那样。

2285
01:52:44,200 --> 01:52:49,940
And then do printf, "Hello," comma, %s backslash n, answer.
然后执行printf，“你好，”逗号，%s 反斜杠n，答案。

2286
01:52:49,940 --> 01:52:53,320
So we've done this many times now this week and last.
所以我们这周和上周已经做了很多次了。

2287
01:52:53,320 --> 01:52:56,290
This is the old school way now of getting command line--
现在，这是从命令行获取用户输入的传统方式——

2288
01:52:56,290 --> 01:52:59,360
of getting user input by prompting them for it.
通过提示用户获取用户输入。

2289
01:52:59,360 --> 01:53:04,570
So if I do make greet /greet, there's no command line arguments at the prompt,
所以如果我执行make greet /greet，提示符中没有命令行参数，

2290
01:53:04,570 --> 01:53:06,610
I'm literally just running the program's name.
我只是在运行程序的名称。

2291
01:53:06,610 --> 01:53:10,690
If I hit Enter, though, now get_string kicks in, asks me for my name,
但是，如果我按Enter，get_string现在开始工作，会询问我的姓名，

2292
01:53:10,690 --> 01:53:12,370
and the program then greets me.
然后程序会向我问候。

2293
01:53:12,370 --> 01:53:13,510
But I can do--
但我可以——

2294
01:53:13,510 --> 01:53:17,530
otherwise, I could do something like this instead.
否则，我可以尝试这样操作。

2295
01:53:17,530 --> 01:53:20,290
First, answer's a little generic, so let's first change
首先，answer有点泛泛，所以让我们先更改

2296
01:53:20,290 --> 01:53:23,980
this back to name and back to name, but that's a minor improvement there
将其改回name，但那只是一个小的改进

2297
01:53:23,980 --> 01:53:25,480
just stylistically.
只是从风格上来说。

2298
01:53:25,480 --> 01:53:28,760
Let's, though, introduce now a command line argument
但是，让我们现在引入一个命令行参数

2299
01:53:28,760 --> 01:53:31,750
so that I can just greet myself by running the program, hitting Enter,
这样我就可以通过运行程序、按Enter键来问候自己，

2300
01:53:31,750 --> 01:53:33,820
and being done, no more get_string.
然后就完成了，不再需要get_string。

2301
01:53:33,820 --> 01:53:39,520
So I'm going to go ahead and change void to int argc, string
所以我将把void改为int argc，string

2302
01:53:39,520 --> 01:53:42,070
argv with square brackets.
带方括号的argv。

2303
01:53:42,070 --> 01:53:45,520
string means-- the square brackets means it's an array;
string代表——方括号意味着它是一个数组；

2304
01:53:45,520 --> 01:53:49,010
string means it's an array of strings; and argc, again,
string意味着它是一个字符串数组；而argc，再次强调，

2305
01:53:49,010 --> 01:53:51,898
is just an integer of the number of words typed.
只是一个表示输入单词数量的整数。

2306
01:53:51,898 --> 01:53:54,190
Now I'm going to somewhat dangerously going to do this.
现在我要冒险尝试一下。

2307
01:53:54,190 --> 01:53:56,770
I'm going to get rid of my use of get_string altogether,
我要完全放弃使用get_string，

2308
01:53:56,770 --> 01:54:01,060
and I'm going to change this line to be not name, which no longer exists,
我要更改这一行，不再使用name，因为name不存在了，

2309
01:54:01,060 --> 01:54:03,820
but I'm going to go into this array called argv
而是要进入这个名为argv的数组

2310
01:54:03,820 --> 01:54:08,050
and I'm going to go into location 1.
并进入第1个位置。

2311
01:54:08,050 --> 01:54:10,180
So I'm doing this on faith.
所以我凭着信念去做。

2312
01:54:10,180 --> 01:54:15,070
I haven't explained what I'm doing yet, but I'm going to do make greet ./greet,
我还没有解释我在做什么，但我将执行make greet ./greet，

2313
01:54:15,070 --> 01:54:19,310
and now I'm going to type my name at the command line just like with rm,
现在我要在命令行中输入我的姓名，就像使用rm一样，

2314
01:54:19,310 --> 01:54:20,740
with clang, with cd.
使用clang、使用cd。

2315
01:54:20,740 --> 01:54:23,440
With any of the commands you've written with multiple words,
对于你使用多个单词编写的任何命令，

2316
01:54:23,440 --> 01:54:25,090
I'm going to greet literally David.
我将直接向David问候。

2317
01:54:25,090 --> 01:54:29,110
So I hit Enter, and voila, I've somehow gotten access
所以，我按Enter键，瞧，我不知何故获得了访问权限

2318
01:54:29,110 --> 01:54:34,930
to what I typed at the prompt by accessing this special parameter called
通过访问这个名为argv的特殊参数，可以访问我在提示符中输入的内容

2319
01:54:34,930 --> 01:54:35,590
argv.
argv。

2320
01:54:35,590 --> 01:54:38,507
Technically you could call it anything you want, but the convention is
从技术上讲，你可以随意命名它，但惯例是

2321
01:54:38,507 --> 01:54:41,020
argv and argc from right to left here.
这里从右到左使用argv和argc。

2322
01:54:41,020 --> 01:54:42,280
Just a guess, then.
只是猜测而已。

2323
01:54:42,280 --> 01:54:47,230
What if I change this to print out bracket 0 and recompile the code?
如果我将此更改为打印方括号0，并重新编译代码？

2324
01:54:47,230 --> 01:54:49,570
And I run ./greet David?
然后我运行./greet David？

2325
01:54:49,570 --> 01:54:51,790
What might it say instinctively?
它会直觉地说些什么呢？

2326
01:54:54,490 --> 01:54:56,710
Any hunches?
有什么预感吗？

2327
01:54:56,710 --> 01:54:57,250
Yeah.
是的。

2328
01:54:57,250 --> 01:54:59,860
So it's going to say hello, ./greet.
所以它会说你好，./greet。

2329
01:54:59,860 --> 01:55:01,880
So it turns out, you get one for free.
所以事实证明，你得到一个免费的。

2330
01:55:01,880 --> 01:55:04,450
Whatever the name of your program is always
无论你的程序名称是什么，始终

2331
01:55:04,450 --> 01:55:07,420
accessible in argv at location 0.
可在argv的第0个位置访问。

2332
01:55:07,420 --> 01:55:08,380
That's just because.
这是因为。

2333
01:55:08,380 --> 01:55:09,340
It's a handy feature.
这是一个方便的功能。

2334
01:55:09,340 --> 01:55:12,548
In case there's an error or you need to tell the user how to use the program,
如果出现错误，或者你需要告诉用户如何使用程序，

2335
01:55:12,548 --> 01:55:15,970
you know what the command is that they ran, but at location 1,
你就会知道他们运行的命令是什么，但是在第1个位置，

2336
01:55:15,970 --> 01:55:18,610
maybe 2, maybe 3 are the additional words
可能是2、3或更多，是用户在命令行中输入的额外单词

2337
01:55:18,610 --> 01:55:20,590
that the human might have typed in.
用户可能输入的。

2338
01:55:20,590 --> 01:55:23,140
Well, let's do something a little smarter than this.
好吧，让我们尝试一些比这更聪明的做法。

2339
01:55:23,140 --> 01:55:25,420
Let me go back to version 1.
让我回到版本1。

2340
01:55:25,420 --> 01:55:27,610
Let me recompile it, make greet.
让我重新编译它，make greet。

2341
01:55:27,610 --> 01:55:31,930
Let me rerun ./greet David, and this seems to work fine.
让我重新运行./greet David，看起来工作正常。

2342
01:55:31,930 --> 01:55:35,080
What if I get a little curious and print out location 2?
如果我有点好奇，打印出第2个位置？

2343
01:55:35,080 --> 01:55:41,530
Let me recompile the code, make greet ./greet David, Enter, OK, there's null.
让我重新编译代码，make greet ./greet David，Enter，OK，那里是null。

2344
01:55:41,530 --> 01:55:45,580
And I mentioned we'd see N-U-L-L, and here's one incarnation thereof,
我提到过我们会看到N-U-L-L，这里就是其中一个体现，

2345
01:55:45,580 --> 01:55:47,270
but this is clearly wrong.
但这明显是错误的。

2346
01:55:47,270 --> 01:55:49,990
So I probably don't want to even let the user do this because I
所以，我可能不想让用户这样做，因为我

2347
01:55:49,990 --> 01:55:51,490
don't want them to see bogus output.
不想让他们看到错误的输出。

2348
01:55:51,490 --> 01:55:53,680
Like this is arguably the a bug in the code
就像这可能是一个代码中的错误

2349
01:55:53,680 --> 01:55:58,420
that it even bothered to show this by default. So what could I do instead?
它默认情况下甚至还显示了这一点。那我可以怎么做呢？

2350
01:55:58,420 --> 01:55:59,420
Well, what if I do this?
那么，如果我这样做呢？

2351
01:55:59,420 --> 01:56:07,490
If argc equals equals 2, then go ahead and comfortably
如果argc等于2，那么就可以轻松地

2352
01:56:07,490 --> 01:56:11,120
say printf "hello," argv, bracket, 1.
说printf “你好，”argv，方括号，1。

2353
01:56:11,120 --> 01:56:15,620
Else, if the human did not give exactly two arguments at the prompt,
否则，如果用户在提示符中没有给出恰好两个参数，

2354
01:56:15,620 --> 01:56:18,590
let's just print out some default value like "hello, world"
我们就打印出一些默认值，例如“你好，世界”

2355
01:56:18,590 --> 01:56:20,040
like from last week.
就像上周一样。

2356
01:56:20,040 --> 01:56:23,540
In other words now I'm doing this error checking with a conditional,
换句话说，我现在正在使用条件语句进行错误检查，

2357
01:56:23,540 --> 01:56:25,790
making sure with this Boolean expression only
确保只有这个布尔表达式

2358
01:56:25,790 --> 01:56:29,990
if argc equals equals 2, and therefore has two words in argv
如果argc等于2，因此argv中包含两个单词

2359
01:56:29,990 --> 01:56:31,410
do you want to proceed.
是否要继续。

2360
01:56:31,410 --> 01:56:35,700
And so now if I do make greet again, ./greet David, this now works.
所以，现在如果我再次执行make greet，./greet David，这就可以正常工作了。

2361
01:56:35,700 --> 01:56:40,460
But if I don't cooperate and I just run greet, what should it say?
但是，如果我不配合，只是运行greet，它应该说些什么呢？

2362
01:56:40,460 --> 01:56:41,690
Just hello, world.
就说你好，世界。

2363
01:56:41,690 --> 01:56:46,280
If I run David Malan as two words, what should it say?
如果我运行David Malan作为两个单词，它应该说些什么呢？

2364
01:56:46,280 --> 01:56:49,880
hello, world, because that's not exactly equal to 2.
你好，世界，因为那并不完全等于2。

2365
01:56:49,880 --> 01:56:52,910
Again, the first word in argv is always the program's name.
再次强调，argv中的第一个单词始终是程序的名称。

2366
01:56:52,910 --> 01:56:56,480
The second word is whatever the human, then, has typed.
第二个单词就是用户输入的。

2367
01:56:56,480 --> 01:56:59,750
Now if we don't even know in advance how many words they're going to be,
现在，如果我们事先不知道用户会输入多少个单词，

2368
01:56:59,750 --> 01:57:01,190
we can combine today's ideas.
我们可以将今天的想法结合起来。

2369
01:57:01,190 --> 01:57:04,190
This is going to look a little weird, but it's the same thing as before.
这看起来有点奇怪，但和以前一样。

2370
01:57:04,190 --> 01:57:09,920
for int i gets 0, i is less than--
for int i 获取0，i小于——

2371
01:57:09,920 --> 01:57:13,010
how about argc i++?
argc i++怎么样？

2372
01:57:13,010 --> 01:57:19,430
And then inside of this loop, I can print out %s, maybe backslash n, comma,
然后在这个循环内部，我可以打印出%s，也许还有反斜杠n，逗号，

2373
01:57:19,430 --> 01:57:23,660
and then print out argv, bracket, i.
然后打印 argv，括号和 i。

2374
01:57:23,660 --> 01:57:27,840
So I can have a loop that iterates argc number of times,
所以我可以有一个循环，迭代 argc 次，

2375
01:57:27,840 --> 01:57:29,660
once for every word at the prompt.
每次迭代都对应于命令提示符中的一个单词。

2376
01:57:29,660 --> 01:57:34,700
I can print out argv, bracket, i, which is the i-th word in that array
我可以打印 argv，括号和 i，它是数组中的第 i 个单词

2377
01:57:34,700 --> 01:57:35,730
from left to right.
从左到右。

2378
01:57:35,730 --> 01:57:40,700
And so if I now run make greet and I do ./greet alone,
所以，如果我现在运行 make greet 并执行 ./greet，

2379
01:57:40,700 --> 01:57:42,080
I just see the program's name.
我只会看到程序的名称。

2380
01:57:42,080 --> 01:57:47,010
If I do ./greet David, I see, those two, one after the other.
如果我执行 ./greet David，我会看到这两个单词，一个接一个。

2381
01:57:47,010 --> 01:57:50,350
If I do David Malan, I get those three words.
如果我执行 David Malan，我会得到这三个单词。

2382
01:57:50,350 --> 01:57:52,540
If I keep going, I'll get more and more words.
如果我继续输入，我会得到越来越多的单词。

2383
01:57:52,540 --> 01:57:56,040
So using just the length of the array and the name of the array,
所以，只使用数组的长度和数组的名称，

2384
01:57:56,040 --> 01:57:58,493
I can actually do quite a bit there.
我实际上可以做很多事情。

2385
01:57:58,493 --> 01:58:00,910
Now there's actually some fun things you can do with this,
现在，实际上有一些有趣的事情你可以用它来做，

2386
01:58:00,910 --> 01:58:02,340
and this is sort of beside the point, but there's
这有点偏离主题了，但是，

2387
01:58:02,340 --> 01:58:04,298
this thing in the world called ASCII art, which
世界上有一种叫做 ASCII 艺术的东西，它

2388
01:58:04,298 --> 01:58:07,290
is making pictures and beautiful things just using ASCII or maybe
就是使用 ASCII 或者可能是

2389
01:58:07,290 --> 01:58:09,990
nowadays Unicode characters, but without using emoji.
现在是 Unicode 字符，但没有使用表情符号。

2390
01:58:09,990 --> 01:58:12,300
Like emoji kind of make this a little too easy.
就像表情符号让这变得太容易了。

2391
01:58:12,300 --> 01:58:15,480
But if all you have are traditional largely English letters
但是如果你只有传统的，大部分是英文的字母

2392
01:58:15,480 --> 01:58:18,540
and punctuation, you can actually do some interesting things.
和标点符号，你实际上可以做一些有趣的事情。

2393
01:58:18,540 --> 01:58:21,910
On Linux systems-- for instance, if I go back to VS Code here,
在 Linux 系统上——例如，如果我回到这里的 VS Code，

2394
01:58:21,910 --> 01:58:25,835
let me increase the size of my terminal window here.
让我在这里增加终端窗口的大小。

2395
01:58:25,835 --> 01:58:27,960
And it turns out that we've pre-installed-- really,
事实证明，我们已经预先安装了——实际上，

2396
01:58:27,960 --> 01:58:32,010
for no compelling reason, but just for fun, a program called cowsay,
没有充分的理由，只是为了好玩，一个叫做 cowsay 的程序，

2397
01:58:32,010 --> 01:58:34,000
which has a cow say something.
它可以让一头奶牛说一些话。

2398
01:58:34,000 --> 01:58:37,920
So if I want to have a cow say "moo" in ASCII art, I can do this,
所以，如果我想让一头奶牛用 ASCII 艺术说“哞”，我可以这样做，

2399
01:58:37,920 --> 01:58:41,310
and you get an adorable cow saying something like "moo" on the screen.
你将会在屏幕上看到一只可爱的奶牛说“哞”。

2400
01:58:41,310 --> 01:58:43,680
But moo is a command line argument that is clearly
但是 moo 是一个命令行参数，它显然

2401
01:58:43,680 --> 01:58:46,590
modifying the output of this program because I could also
修改了这个程序的输出，因为我也可以

2402
01:58:46,590 --> 01:58:49,350
change it to say hello, comma, world, and now the cow
把它改为说 hello，逗号，world，现在奶牛

2403
01:58:49,350 --> 01:58:50,980
is going to say that instead.
将会说这句话。

2404
01:58:50,980 --> 01:58:53,460
So it takes multiple command line arguments, if you will.
所以它接受多个命令行参数，如果你愿意。

2405
01:58:53,460 --> 01:58:58,350
But it also takes what are called flags or switches whereby any command line
但是它也接受被称为标志或开关的东西，任何以破折号开头的命令行

2406
01:58:58,350 --> 01:59:01,740
argument that starts with a dash is usually like a special configuration
参数通常就像一个特殊的配置

2407
01:59:01,740 --> 01:59:04,860
option that you would only know exists by reading the documentation
选项，你只有通过阅读文档才会知道它的存在

2408
01:59:04,860 --> 01:59:06,300
or seeing a demonstration.
或者看到演示。

2409
01:59:06,300 --> 01:59:12,780
And if I have my syntax right, if I do cowsay -f, and maybe I'll do--
如果我的语法正确，如果我执行 cowsay -f，也许我会——

2410
01:59:12,780 --> 01:59:13,620
let's see.
让我们看看。

2411
01:59:13,620 --> 01:59:18,660
Instead of this cow say, how about I'll do -f for file,
与其让这头奶牛说，不如让我执行 -f 来表示文件，

2412
01:59:18,660 --> 01:59:20,460
and I'm going to change it into duck mode.
我将把它改为鸭子模式。

2413
01:59:20,460 --> 01:59:23,730
And I'm going to have this version of the ASCII art say quack.
我将让这个版本的 ASCII 艺术说 quack。

2414
01:59:23,730 --> 01:59:26,255
So it's a tiny little duck there, but it's saying quack.
所以，那是一只小鸭子，但是它说 quack。

2415
01:59:26,255 --> 01:59:28,380
And you can kind of waste a lot of time doing this.
你可以用这种方式浪费很多时间。

2416
01:59:28,380 --> 01:59:33,690
I can do cowsay -f dragon and say something like, RAWR,
我可以执行 cowsay -f dragon 并说类似 RAWR 的东西，

2417
01:59:33,690 --> 01:59:36,420
and this is just amazing.
这简直太棒了。

2418
01:59:36,420 --> 01:59:38,440
Again, not really academically compelling,
再说一次，从学术的角度来看，这并不令人信服，

2419
01:59:38,440 --> 01:59:41,880
but it does demonstrate, again, command line arguments, which are everywhere,
但是它确实再次演示了命令行参数，它们无处不在，

2420
01:59:41,880 --> 01:59:44,220
and you've indeed been using them already.
你实际上已经在使用它们了。

2421
01:59:44,220 --> 01:59:46,830
But there's one other feature we wanted to introduce you
但是，我们想向你介绍另一个功能

2422
01:59:46,830 --> 01:59:50,610
to today, which will be a useful building block, which will also
今天，它将是一个有用的构建模块，它也将

2423
01:59:50,610 --> 01:59:54,090
reveal one other thing about the code that we've been writing.
揭示我们一直在编写的代码中的另一个东西。

2424
01:59:54,090 --> 01:59:58,110
It turns out that all of the programs we've been writing thus far, eventually
事实证明，我们到目前为止编写的程序，最终

2425
01:59:58,110 --> 02:00:00,210
obviously exit because you see your prompt again
显然会退出，因为你又看到了你的命令提示符

2426
02:00:00,210 --> 02:00:02,680
unless you have an infinite loop such that it never ends.
除非你有一个无限循环，这样它就永远不会结束。

2427
02:00:02,680 --> 02:00:03,870
But eventually they exit.
但最终它们会退出。

2428
02:00:03,870 --> 02:00:07,560
And secretly, every program we've written thus far actually
而且，秘密地，我们到目前为止编写的每个程序实际上

2429
02:00:07,560 --> 02:00:09,240
has what's called an exit status.
都有一个叫做退出状态的东西。

2430
02:00:09,240 --> 02:00:11,730
It's like a special return value from the program
这就像程序本身的一个特殊返回值

2431
02:00:11,730 --> 02:00:14,310
itself that by default is always 0.
它默认情况下总是 0。

2432
02:00:14,310 --> 02:00:17,590
0 as a number in the world generally means everything's OK.
在世界上，0 通常意味着一切正常。

2433
02:00:17,590 --> 02:00:21,240
The flip side of that is because the world tends to use integers
另一方面，由于世界倾向于使用整数

2434
02:00:21,240 --> 02:00:23,460
and you've got four billion possibilities,
你有四十亿种可能性，

2435
02:00:23,460 --> 02:00:27,000
like every other number in the world when it comes to our program's exit
就像世界上其他任何数字一样，当谈到我们程序的退出

2436
02:00:27,000 --> 02:00:29,070
status is bad.
状态时，意味着是错误的。

2437
02:00:29,070 --> 02:00:30,750
If it's 1, it's probably bad.
如果是 1，它可能是错误的。

2438
02:00:30,750 --> 02:00:32,095
If it's negative 1, it's bad.
如果是负 1，它也是错误的。

2439
02:00:32,095 --> 02:00:34,470
And in fact, you've probably seen this in the real world.
事实上，你可能在现实世界中见过这种情况。

2440
02:00:34,470 --> 02:00:37,580
If you've ever had like a random error message on the screen--
如果你曾经在屏幕上看到过随机的错误消息——

2441
02:00:37,580 --> 02:00:39,330
here's a screenshot of Zoom, for instance.
例如，这是 Zoom 的一个截图。

2442
02:00:39,330 --> 02:00:43,920
And that screenshot, somewhat confusingly or unknowingly,
这个截图，有点令人困惑，或者说并不知情，

2443
02:00:43,920 --> 02:00:47,730
has an error code like 1132, that probably
有一个像 1132 这样的错误代码，这可能

2444
02:00:47,730 --> 02:00:52,500
means that the Zoom software that some other humans wrote incorrectly somehow
意味着 Zoom 软件，由其他人编写，不知何故写错了，

2445
02:00:52,500 --> 02:00:58,410
had an error and it did not exit with status 0, it exited with status 1132.
出现了错误，它没有以状态 0 退出，而是以状态 1132 退出。

2446
02:00:58,410 --> 02:01:00,480
And somewhere at Zoom, there's probably a file
在 Zoom 的某个地方，可能有一个文件

2447
02:01:00,480 --> 02:01:04,283
or a book that tells the programmers what this error code actually means.
或者一本书，告诉程序员这个错误代码的真正含义。

2448
02:01:04,283 --> 02:01:05,700
This is not useful for you and me.
这对我们来说没有用。

2449
02:01:05,700 --> 02:01:08,158
There's some programmer at Zoom who would probably be like,
Zoom 的某些程序员可能会说，

2450
02:01:08,158 --> 02:01:10,950
oh, I know what I did or my colleague did wrong in this case.
哦，我知道我或者我的同事在这个案例中做错了什么。

2451
02:01:10,950 --> 02:01:13,950
You've seen this elsewhere even though this is not quite the same thing,
你之前在其他地方见过这种情况，尽管它并不完全相同，

2452
02:01:13,950 --> 02:01:15,658
but we'll talk about this in a few weeks.
但我们将在几周后讨论它。

2453
02:01:15,658 --> 02:01:19,380
If you've ever seen 404, like numbers are everywhere, and on the web,
如果你曾经见过 404，就像数字无处不在，在网络上也是，

2454
02:01:19,380 --> 02:01:23,070
404 means like file not found.
404 表示文件未找到。

2455
02:01:23,070 --> 02:01:26,830
It means you made a typo, the web server deleted a file, or something like that,
这意味着你打错了字，Web 服务器删除了一个文件，或者类似的事情，

2456
02:01:26,830 --> 02:01:30,850
but this is just to say numbers are so often used to signify or represent
但是，这只是说数字经常用来表示或代表

2457
02:01:30,850 --> 02:01:31,350
errors.
错误。

2458
02:01:31,350 --> 02:01:33,600
Even though that's not an exit status, per se,
尽管它本身不是退出状态，

2459
02:01:33,600 --> 02:01:36,750
that's an HTTP status code, which we'll soon see.
那是 HTTP 状态码，我们很快就会看到。

2460
02:01:36,750 --> 02:01:40,590
But you have access to exit statuses as it relates
但是，你可以访问与

2461
02:01:40,590 --> 02:01:42,630
to command line software already.
命令行软件相关的退出状态。

2462
02:01:42,630 --> 02:01:46,250
Up until now, this is how we've been writing main, now
到目前为止，我们一直是这样编写 main 函数的，现在

2463
02:01:46,250 --> 02:01:48,740
with command line arguments, but we've also
有了命令行参数，但我们还有

2464
02:01:48,740 --> 02:01:51,770
been writing main with an int return value.
我一直在写主函数，它有一个整型返回值。

2465
02:01:51,770 --> 02:01:54,620
And you've never used this-- we didn't talk about this last week.
而且你从来没有用过它——我们上周没有讨论过这个。

2466
02:01:54,620 --> 02:01:57,740
I just ask that you trust me and just keep copying and pasting this.
我只要求你相信我，并继续复制粘贴这段代码。

2467
02:01:57,740 --> 02:02:00,590
But that int means that even your programs
但是，这个int意味着，即使是你的程序

2468
02:02:00,590 --> 02:02:05,660
can return values which can be useful even if you don't use command line
可以返回值，即使你不使用命令行，这些返回值也可能很有用

2469
02:02:05,660 --> 02:02:08,870
arguments and we just go back to the original version like void.
参数，我们只是回到像void这样的原始版本。

2470
02:02:08,870 --> 02:02:15,320
So for instance, if I go ahead and open up, for instance, VS Code again,
例如，如果我继续打开，例如，VS Code 再次，

2471
02:02:15,320 --> 02:02:16,670
I'll get rid of the dragon.
我会去掉那个龙。

2472
02:02:16,670 --> 02:02:19,460
And let's do one other program here called status just
让我们在这里做一个名为status的程序，只是

2473
02:02:19,460 --> 02:02:23,450
to play around with the idea of these so-called exit statuses.
为了玩玩这些所谓的退出状态的想法。

2474
02:02:23,450 --> 02:02:28,370
Let me just demonstrate the idea with an include cs50.h, include
让我用一个 include cs50.h, include 来演示这个想法

2475
02:02:28,370 --> 02:02:36,440
stdio.h, int main, and here I'll do int argc, string argv.
stdio.h, int main, 这里我将使用 int argc, string argv。

2476
02:02:36,440 --> 02:02:39,080
And then inside of main, let's do a similar program
然后在main内部，让我们做一个类似的程序

2477
02:02:39,080 --> 02:02:40,430
to before like the hello, world.
类似于之前的hello, world。

2478
02:02:40,430 --> 02:02:44,540
So printf "hello," comma, %s backslash n.
所以 printf "hello," 逗号, %s 反斜杠 n。

2479
02:02:44,540 --> 02:02:47,010
Then let's print out argv 1.
然后让我们打印argv 1。

2480
02:02:47,010 --> 02:02:52,300
But I only want to execute that line if the human gave me a command line
但是我只想在用户给我一个命令行参数的情况下执行那行代码

2481
02:02:52,300 --> 02:02:52,800
argument.
参数。

2482
02:02:52,800 --> 02:02:55,550
Otherwise I don't want to even say some default like hello, world.
否则我甚至不想说一些默认的，比如 hello, world。

2483
02:02:55,550 --> 02:03:00,250
I just want to abort early and just exit the program, no output whatsoever.
我只是想提前中止并退出程序，没有任何输出。

2484
02:03:00,250 --> 02:03:01,350
So I could do this.
所以我可以这样做。

2485
02:03:01,350 --> 02:03:05,523
If argc does not equal 2--
如果argc不等于2——

2486
02:03:05,523 --> 02:03:08,190
and it's a single equals, but it's a bang, an exclamation point,
这是一个单等号，但它是一个感叹号，

2487
02:03:08,190 --> 02:03:09,370
means not equal.
表示不等于。

2488
02:03:09,370 --> 02:03:11,580
So this is the opposite of equals equals.
所以这是等于等于的反义词。

2489
02:03:11,580 --> 02:03:14,730
Then previously I would have just printed hello, world,
然后之前我只会打印hello, world，

2490
02:03:14,730 --> 02:03:16,830
but now I want to print out an error message
但现在我想打印一个错误信息

2491
02:03:16,830 --> 02:03:21,210
like, "Missing command-line argument" just to explain to the user
比如，“缺少命令行参数”，只是为了向用户解释

2492
02:03:21,210 --> 02:03:26,520
why the program is about to terminate, and then I can return 1.
为什么程序即将终止，然后我可以返回1。

2493
02:03:26,520 --> 02:03:27,750
It's kind of arbitrary.
这有点随意。

2494
02:03:27,750 --> 02:03:30,700
I could also return 1132, but why start there?
我也可以返回1132，但为什么要从那里开始呢？

2495
02:03:30,700 --> 02:03:34,180
This is the only possible error that could go wrong in my program.
这是我的程序中唯一可能出错的地方。

2496
02:03:34,180 --> 02:03:35,490
So I'm going to start at 1.
所以我将从1开始。

2497
02:03:35,490 --> 02:03:39,150
Zoom clearly has 1,000-plus possible things that can go wrong
Zoom显然有1000多个可能出错的地方

2498
02:03:39,150 --> 02:03:42,660
in their source code, which is why the number got as big as 1132,
在他们的源代码中，这就是为什么这个数字达到了1132，

2499
02:03:42,660 --> 02:03:45,990
but I'm just going to arbitrarily, but conventionally return 1.
但我只是随意地，但按照惯例返回1。

2500
02:03:45,990 --> 02:03:52,110
But if everything is OK and I do-- it is not the case that argc does not equal 2
但是如果一切正常，我做到了——argc 不等于 2 并不是事实

2501
02:03:52,110 --> 02:03:57,360
and I actually get to line 11, I'm going to return 0 because 0, again, I claim,
而我实际上到达了第11行，我将返回0，因为0，我再次声明，

2502
02:03:57,360 --> 02:03:59,190
signifies success.
表示成功。

2503
02:03:59,190 --> 02:04:03,120
And all of this time, every program we've written-- you've written
一直以来，我们写的每一个程序——你写的

2504
02:04:03,120 --> 02:04:07,558
has secretly exited with 0 by default. But now
默认情况下，已经秘密地以0退出。但是现在

2505
02:04:07,558 --> 02:04:09,600
that our programs are getting more sophisticated,
我们的程序变得越来越复杂，

2506
02:04:09,600 --> 02:04:11,700
when something goes wrong, it turns out it's
当出现错误时，事实证明，它

2507
02:04:11,700 --> 02:04:15,085
useful to have the power to just return some other value even
能够返回其他值非常有用，即使

2508
02:04:15,085 --> 02:04:16,710
though the user is not going to see it.
用户不会看到它。

2509
02:04:16,710 --> 02:04:19,620
Even though the Zoom user shouldn't see it, it's still there.
尽管Zoom用户不应该看到它，但它仍然存在。

2510
02:04:19,620 --> 02:04:22,380
It's diagnostically useful to you, or in the case of a class,
这对你有诊断意义，或者在一个班级的情况下，

2511
02:04:22,380 --> 02:04:24,660
to your TF or TA or CA.
对你自己的TF、TA或CA。

2512
02:04:24,660 --> 02:04:30,930
So if I do make status now to compile this program and run ./status and type
所以如果我现在用 make status 来编译这个程序，然后运行 ./status 并输入

2513
02:04:30,930 --> 02:04:33,340
my first name I think this is a success.
我的名字，我认为这是成功的。

2514
02:04:33,340 --> 02:04:37,290
It should say hello, David and secretly exit with 0.
它应该说 hello, David 并且秘密地以 0 退出。

2515
02:04:37,290 --> 02:04:41,820
If you really want to see the 0, there's this arcane command you can type.
如果你真的想看到 0，有一个晦涩的命令你可以输入。

2516
02:04:41,820 --> 02:04:45,780
You can literally type at your prompt echo $?.
你可以在你的提示符下输入 echo $?。

2517
02:04:45,780 --> 02:04:48,810
It's weird symbology, but it's what the humans chose decades ago.
这是一个奇怪的符号，但这是人类几十年前选择的方式。

2518
02:04:48,810 --> 02:04:53,460
This will just show you what did the most recently-run program secretly exit
这将向你展示最近运行的程序秘密地退出了什么

2519
02:04:53,460 --> 02:04:54,010
with.
状态。

2520
02:04:54,010 --> 02:04:58,560
So if I do this in VS Code, I can do exit $?, Enter,
所以如果我在 VS Code 中这样做，我可以输入 exit $?，回车，

2521
02:04:58,560 --> 02:04:59,982
and there's that secret 0.
那里就有那个秘密的 0。

2522
02:04:59,982 --> 02:05:02,190
I could have been doing this week and last week, it's
我本来可以在本周和上周做的，它

2523
02:05:02,190 --> 02:05:03,330
just not that interesting.
只是不那么有趣。

2524
02:05:03,330 --> 02:05:08,340
But it is interesting, or at least marginally so, if I rerun status
但如果我重新运行 status，它很有趣，或者至少有点意思

2525
02:05:08,340 --> 02:05:12,060
and maybe I don't provide a command line argument or I provide too many.
也许我没有提供命令行参数，或者我提供了太多。

2526
02:05:12,060 --> 02:05:14,340
So argc does not equal 2.
所以 argc 不等于 2。

2527
02:05:14,340 --> 02:05:17,520
And I hit Enter, I get yelled at with the error message,
我按下回车键，我收到一个错误信息，

2528
02:05:17,520 --> 02:05:21,300
but I can see the secret status code, which is, indeed, 1.
但我可以看到秘密的状态代码，它确实是 1。

2529
02:05:21,300 --> 02:05:24,340
And so now if you're ever in the habit in either a class like this
所以现在，如果你习惯于在一个像这样的课堂上

2530
02:05:24,340 --> 02:05:27,090
or in the real world where you're automatically testing your code,
或者在现实世界中，你自动测试你的代码，

2531
02:05:27,090 --> 02:05:29,340
be it with check50 or in the real world, things called
无论是使用 check50 还是在现实世界中，被称为

2532
02:05:29,340 --> 02:05:31,590
unit tests and other third-party software,
单元测试和其他第三方软件，

2533
02:05:31,590 --> 02:05:36,150
those tests can actually detect these status code-- exit statuses
这些测试实际上可以检测到这些状态代码——退出状态

2534
02:05:36,150 --> 02:05:39,943
and know that your code succeed or fail, 0 or 1.
并知道你的代码成功或失败，0 或 1。

2535
02:05:39,943 --> 02:05:42,360
And if there's different types of failures it can detect--
如果存在不同的失败类型，它可以检测到——

2536
02:05:42,360 --> 02:05:48,630
status 2, status 3, status 1132, it's just one other tool in your toolkit.
状态 2，状态 3，状态 1132，它只是你的工具箱中的另一个工具。

2537
02:05:48,630 --> 02:05:51,240
But all of that is terribly low level, and really,
但这一切都非常底层，实际上，

2538
02:05:51,240 --> 02:05:54,900
the goal of this week-- and really, today, and really, code more generally,
本周的目标——实际上，今天，实际上，更广泛地说，代码

2539
02:05:54,900 --> 02:05:55,990
is to solve problems.
是为了解决问题。

2540
02:05:55,990 --> 02:05:58,380
So let's consider an increasingly important one, which
所以让我们考虑一个越来越重要的，那就是

2541
02:05:58,380 --> 02:06:01,650
is the ability to send information securely,
安全发送信息的能力，

2542
02:06:01,650 --> 02:06:04,980
whether it is in file format, wirelessly, or any other.
无论是文件格式，无线传输，还是其他任何方式。

2543
02:06:04,980 --> 02:06:08,640
Cryptography is the art and the science of encrypting.
密码学是加密的艺术和科学。

2544
02:06:08,640 --> 02:06:09,930
Scrambling information.
对信息进行加密。

2545
02:06:09,930 --> 02:06:12,510
So that even if I write a secret message to you
这样，即使我写了一封秘密信息给你

2546
02:06:12,510 --> 02:06:16,350
and I send it through this open audience with so many nosey eyes
而我把它通过这个开放的观众发送出去，有那么多爱管闲事的人

2547
02:06:16,350 --> 02:06:19,890
who could look at the message, if I've encrypted this message, none of them
他们可以查看信息，如果我对信息进行了加密，他们中没有人

2548
02:06:19,890 --> 02:06:22,800
should be able to read it, only you, whoever you are,
应该能够读到它，只有你，无论你是谁，

2549
02:06:22,800 --> 02:06:24,900
to whom I intended that message.
我打算把信息发给谁。

2550
02:06:24,900 --> 02:06:27,030
In the world of cryptography, then encryption
在密码学的世界里，加密

2551
02:06:27,030 --> 02:06:30,210
means scrambling the information so that only you and the recipient
意味着对信息进行加密，以便只有你和接收者

2552
02:06:30,210 --> 02:06:31,060
can receive it.
可以收到它。

2553
02:06:31,060 --> 02:06:34,380
So if we consider our black box like in week 0 and 1,
所以如果我们考虑第0周和第1周的黑色盒子，

2554
02:06:34,380 --> 02:06:36,030
here is the problem to be solved.
这就是要解决的问题。

2555
02:06:36,030 --> 02:06:38,910
And let me propose a couple of pieces of vocabulary.
并且让我提出几个词汇。

2556
02:06:38,910 --> 02:06:42,420
Plaintext is any message written in English or any human language
明文是指任何用英语或任何人类语言写成的信息

2557
02:06:42,420 --> 02:06:45,090
that you want to send and write yourself.
你想要发送并自己写的。

2558
02:06:45,090 --> 02:06:47,150
Ciphertext is what you want to convert it
密文是你想要转换的东西

2559
02:06:47,150 --> 02:06:49,850
to before you just hand it off to a bunch of random strangers
在你把它交给一群随机的陌生人之前

2560
02:06:49,850 --> 02:06:52,220
in the audience or a bunch of servers on the internet,
在观众中或互联网上的一堆服务器中，

2561
02:06:52,220 --> 02:06:54,432
any one of whom could look at your message.
任何一个都可以看到你的信息。

2562
02:06:54,432 --> 02:06:56,390
So in the black box is what we're going to call
所以，在黑盒子里，我们将它称为

2563
02:06:56,390 --> 02:07:02,000
a cipher, an algorithm for encrypting or scrambling information
密码，一种用于加密或扰乱信息的算法

2564
02:07:02,000 --> 02:07:03,268
in a reversible way.
以可逆的方式。

2565
02:07:03,268 --> 02:07:05,810
It doesn't suffice to just scramble the information randomly,
仅仅随机地打乱信息是不够的，

2566
02:07:05,810 --> 02:07:07,980
otherwise the recipient can't do anything with it.
否则接收者将无法对其进行任何操作。

2567
02:07:07,980 --> 02:07:11,660
It's an algorithm, a cipher that encrypts it in such a way
这是一种算法，一种以某种方式加密它的密码

2568
02:07:11,660 --> 02:07:13,280
that someone else can decrypt it.
以便其他人可以解密它。

2569
02:07:13,280 --> 02:07:14,750
And here's a common way.
这是一个常见的方法。

2570
02:07:14,750 --> 02:07:20,540
Most ciphers take as input not only the plaintext message in English
大多数密码不仅将英语中的明文信息作为输入

2571
02:07:20,540 --> 02:07:22,700
or whatever else, but also a key.
或其他任何东西，而且还有一个密钥。

2572
02:07:22,700 --> 02:07:25,400
And it's metaphorically like a key to open a lock,
它就像打开锁的钥匙一样，

2573
02:07:25,400 --> 02:07:29,300
but it's technically generally a number, like a really big number made up
但从技术上讲，它通常是一个数字，就像一个很大的数字

2574
02:07:29,300 --> 02:07:30,170
of lots of bits.
由很多位组成。

2575
02:07:30,170 --> 02:07:35,330
And not even 32, not even 64, sometimes 1,024 bits, which is crazy
甚至不是 32 位，甚至不是 64 位，有时是 1024 位，这太疯狂了

2576
02:07:35,330 --> 02:07:37,610
unpronounceable large, but the probability
难以发音的巨大，但概率

2577
02:07:37,610 --> 02:07:40,880
that someone is going to guess your key is just so, so small
有人会猜出你的密钥的概率非常非常小

2578
02:07:40,880 --> 02:07:43,850
that for all intents and purposes, you are, in fact, secure.
以至于从所有意图和目的来看，你实际上是安全的。

2579
02:07:43,850 --> 02:07:46,020
So what's an example of this, for instance?
例如，这是什么例子呢？

2580
02:07:46,020 --> 02:07:50,165
Suppose the secret message I want to send is innocuously just "HI!"
假设我想要发送的秘密信息仅仅是无害的“HI！”

2581
02:07:50,165 --> 02:07:52,790
Well, it'd be pretty stupid to write "HI!" on a piece of paper,
好吧，在纸上写“HI！”会很愚蠢，

2582
02:07:52,790 --> 02:07:54,707
hand it to someone in the audience, and expect
把它递给观众中的某个人，并期望

2583
02:07:54,707 --> 02:07:57,770
it to get all the way to the back without someone like glancing at it
它能一路传到后面，而不会有人看到它

2584
02:07:57,770 --> 02:08:00,510
and obviously seeing and reading the plaintext.
而且显然看到并阅读了明文。

2585
02:08:00,510 --> 02:08:03,650
So what if I, though, agree with someone in back, for instance,
所以，如果我，比如说，同意坐在后面的人，

2586
02:08:03,650 --> 02:08:05,570
that our secret is going to be 1?
我们的秘密将是 1？

2587
02:08:05,570 --> 02:08:07,790
And we have to agree upon that secret in advance,
我们必须事先就这个秘密达成一致，

2588
02:08:07,790 --> 02:08:10,160
but 1 just means that is my key.
但 1 仅仅意味着那就是我的密钥。

2589
02:08:10,160 --> 02:08:13,340
And let me propose that according to one popular cipher,
让我提议，根据一种流行的密码，

2590
02:08:13,340 --> 02:08:19,730
if I want to send "HI!", change the H to an I and the I to a J-- that is,
如果我想发送“HI！”，将 H 变成 I，将 I 变成 J，也就是说，

2591
02:08:19,730 --> 02:08:22,740
increment effectively every letter of the alphabet by one,
将字母表中的每个字母有效地增加 1，

2592
02:08:22,740 --> 02:08:25,830
and if you get to a Z, wrap back around to A, for instance.
如果你到了 Z，就回到 A，例如。

2593
02:08:25,830 --> 02:08:28,790
So shift the alphabet by one place in this case
所以，在这种情况下，将字母表向后移一位

2594
02:08:28,790 --> 02:08:31,200
and send this message now instead.
现在改发这条消息。

2595
02:08:31,200 --> 02:08:32,510
So is that secure?
那么，这安全吗？

2596
02:08:32,510 --> 02:08:35,240
Well, if one of you kind of nosily looks at this sheet of paper,
好吧，如果你们中的某个人偷偷地看这张纸，

2597
02:08:35,240 --> 02:08:36,440
you won't see "HI!"
你不会看到“HI！”

2598
02:08:36,440 --> 02:08:39,240
You will see some information leak in this algorithm.
你会看到一些信息泄露在这个算法中。

2599
02:08:39,240 --> 02:08:42,500
You'll see an exclamation point, so I'm enthusiastically saying something,
你会看到一个感叹号，所以我很热情地说着什么，

2600
02:08:42,500 --> 02:08:46,710
but you won't know what the message is unless you decrypt it.
但你不会知道信息是什么，除非你解密它。

2601
02:08:46,710 --> 02:08:50,720
Now that said, is this very secure, really, in practice?
话虽如此，但这在实践中真的非常安全吗？

2602
02:08:50,720 --> 02:08:51,950
I mean, not really.
我的意思是，不完全是。

2603
02:08:51,950 --> 02:08:55,520
Like, if you know I'm just using a key and I'm using the English alphabet,
比如，如果你知道我只是用了一个密钥，而且我用的是英语字母表，

2604
02:08:55,520 --> 02:08:58,220
you could probably brute force your way to a solution
你可能可以通过蛮力破解找到解决方案

2605
02:08:58,220 --> 02:09:01,520
by just trying 1, trying 2, trying 3, trying 25,
通过不断尝试 1，尝试 2，尝试 3，尝试 25，

2606
02:09:01,520 --> 02:09:03,740
go through all the possibilities tediously,
费力地尝试所有可能性，

2607
02:09:03,740 --> 02:09:05,660
but eventually it's probably going to pop out.
但最终它可能会跳出来。

2608
02:09:05,660 --> 02:09:08,090
This is actually known, though, as the Caesar cipher.
这实际上被称为凯撒密码。

2609
02:09:08,090 --> 02:09:12,080
And back in the day, before anyone else knew about or had invented encryption,
在过去，在其他人知道或发明加密之前，

2610
02:09:12,080 --> 02:09:15,260
Caesar, Julius Caesar, was known to use a cipher like this
凯撒，尤利乌斯·凯撒，以使用这样的密码而闻名

2611
02:09:15,260 --> 02:09:17,360
using a key of three, literally.
使用了一个 3 的密钥，真是的。

2612
02:09:17,360 --> 02:09:20,780
And I guess it works OK if you're literally the first human in the world
我想，如果你确实是世界上第一个想到这个主意的人

2613
02:09:20,780 --> 02:09:25,370
by lore to have thought of this idea, but of course, anyone who intercepts it
据说，但当然，任何截获它的人

2614
02:09:25,370 --> 02:09:29,330
could attack it nonetheless and figure things out a bit mathematically.
仍然可以攻击它，并用数学方法弄清楚一些事情。

2615
02:09:29,330 --> 02:09:31,140
13 is more common.
13 比较常见。

2616
02:09:31,140 --> 02:09:35,180
This is called ROT13 on the internet for rotate the letters of the alphabet 13.
这在互联网上被称为 ROT13，表示将字母表中的字母旋转 13 位。

2617
02:09:35,180 --> 02:09:38,240
That changes "HI!" to "UV!"
这将“HI！”变成“UV！”

2618
02:09:38,240 --> 02:09:39,937
You might think what's better than 13?
你可能会想，什么比 13 更好呢？

2619
02:09:39,937 --> 02:09:41,270
Well, let's double the security.
好吧，让我们将安全性提高一倍。

2620
02:09:41,270 --> 02:09:42,590
ROT26.
ROT26。

2621
02:09:42,590 --> 02:09:45,140
Why is this stupid?
为什么这很愚蠢？

2622
02:09:45,140 --> 02:09:48,140
I mean, there's like 26 letters in the alphabet, so like A becomes A. So
我的意思是，字母表中有 26 个字母，所以 A 就变成了 A。所以

2623
02:09:48,140 --> 02:09:49,730
that doesn't really help-- oh, wait.
这并没有真正帮助——哦，等等。

2624
02:09:49,730 --> 02:09:53,090
Oh, I'm pointing at something that's not on the screen, dammit.
哦，我在指向屏幕上没有的东西，该死。

2625
02:09:53,090 --> 02:09:58,190
Suppose the message is more lovingly, "I LOVE YOU," instead of just "HI!"
假设信息更深情一些，是“I LOVE YOU”，而不是仅仅是“HI！”

2626
02:09:58,190 --> 02:10:01,490
Same exact approach, whether or not there's punctuation, "I LOVE YOU,"
相同的方法，无论是否有标点符号，“I LOVE YOU”，

2627
02:10:01,490 --> 02:10:03,980
with an input of 13 might now become this.
输入 13 现在可能会变成这样。

2628
02:10:03,980 --> 02:10:07,130
And now it's getting a little less obvious what the ciphertext actually
现在，密文实际上代表什么变得不那么明显了

2629
02:10:07,130 --> 02:10:07,970
represents.
代表。

2630
02:10:07,970 --> 02:10:10,550
And now, what's twice as secure is 13?
现在，什么比 13 安全两倍呢？

2631
02:10:10,550 --> 02:10:15,260
Well, 26 is surely better, but of course, if you rotate 26 places,
好吧，26 当然更好，但当然，如果你旋转 26 位，

2632
02:10:15,260 --> 02:10:17,460
that, of course, just gives you the same thing.
当然，这只会给你相同的东西。

2633
02:10:17,460 --> 02:10:19,460
So there's a limit to this, but again, that just
所以，这有它的局限性，但同样，这仅仅

2634
02:10:19,460 --> 02:10:22,770
speaks to the cipher being used, which is very simple.
说明了所使用的密码非常简单。

2635
02:10:22,770 --> 02:10:26,417
There is much, much better, more sophisticated mathematical ciphers
有更多更好的，更复杂的数学密码

2636
02:10:26,417 --> 02:10:27,000
that are used.
被使用。

2637
02:10:27,000 --> 02:10:29,660
We're just starting with something simple here.
我们只是从这里开始一个简单的例子。

2638
02:10:29,660 --> 02:10:34,910
As for decryption, if I'm using a key of 1, how do I reverse the process?
关于解密，如果我使用的是 1 的密钥，我该如何逆转这个过程呢？

2639
02:10:34,910 --> 02:10:36,290
Yeah, so I just minus 1.
是的，所以我只需要减 1。

2640
02:10:36,290 --> 02:10:41,510
So B becomes A, C becomes B, A becomes Z. And if it's 13,
所以 B 变成 A，C 变成 B，A 变成 Z。如果它是 13，

2641
02:10:41,510 --> 02:10:45,390
I subtract 13 instead or whatever the key is, so long as sender
我就会减去 13 或者任何密钥，只要发送者

2642
02:10:45,390 --> 02:10:46,780
and receiver actually know it.
和接收者都知道它。

2643
02:10:46,780 --> 02:10:50,280
So in this case here, this is actually the message with which we began class.
所以，在这种情况下，这实际上就是我们开始上课时使用的那条信息。

2644
02:10:50,280 --> 02:10:53,730
If we have this message here and I used a key of 1 to encrypt it,
如果我们有这条信息，我用 1 的密钥加密了它，

2645
02:10:53,730 --> 02:10:57,220
well, decrypting, it might involve doing something like this.
好吧，解密，它可能涉及做一些类似的事情。

2646
02:10:57,220 --> 02:11:00,278
Here's those same letters on the screen, and I think in a moment
这是屏幕上相同的字母，我想过一会儿

2647
02:11:00,278 --> 02:11:02,070
before we adjourn, I'll mention too that we
在我们休会之前，我还想提一下，我们

2648
02:11:02,070 --> 02:11:04,230
might have encrypted a message in eight characters
可能在八个字符中加密了一条信息

2649
02:11:04,230 --> 02:11:06,360
this whole day, so if any of you took the time
这一整天，所以如果你有时间

2650
02:11:06,360 --> 02:11:08,660
and procrastinated and figured out what the light bulb spelled
然后拖延时间并弄清楚灯泡拼出了什么

2651
02:11:08,660 --> 02:11:10,743
and they didn't seem to spell anything in English,
而且它们似乎没有拼出任何英语单词

2652
02:11:10,743 --> 02:11:13,530
well, here now is the solution for cracking it.
那么，现在这里就是破解它的解决方案。

2653
02:11:13,530 --> 02:11:16,500
This, if I subtract 1, becomes what?
如果我减去 1，它会变成什么？

2654
02:11:16,500 --> 02:11:22,007
U becomes T. And this is obviously-- see where we're going with this?
U 变成 T。很明显—— 你明白我要表达的意思吗？

2655
02:11:22,007 --> 02:11:25,090
And if we keep going, subtracting 1-- so indeed, we're at the end of class
如果我们继续下去，减去 1—— 所以的确，我们已经到了课堂的最后

2656
02:11:25,090 --> 02:11:26,930
now because this was CS50.
现在是因为这是 CS50。

2657
02:11:26,930 --> 02:11:30,180
And the last thing we have to say is we have hundreds of ducks waiting for you
最后我们要说的是，我们有数百只鸭子在等着你

2658
02:11:30,180 --> 02:11:30,790
outside.
在外面。

2659
02:11:30,790 --> 02:11:33,120
So on the way out, grab your own rubber duck.
所以出门的时候，拿上你自己的橡皮鸭。

2660
02:11:33,120 --> 02:11:34,320
[APPLAUSE]
[掌声]

2661
02:11:34,320 --> 02:11:37,970
[MUSIC PLAYING]
[音乐播放]

