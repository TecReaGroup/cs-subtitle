1
00:00:00,000 --> 00:00:03,486
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,752 --> 00:01:03,600
SPEAKER 1: All right.
好的。

3
00:01:03,600 --> 00:01:06,200
So this is CS50, and this is week four.
所以这是 CS50，这是第四周。

4
00:01:06,200 --> 00:01:07,950
And this is actually one of the weeks that
这实际上是其中一周，

5
00:01:07,950 --> 00:01:11,040
really makes CS50, CS50, insofar as we'll
让 CS50 成为 CS50 的关键一周，因为我们将会

6
00:01:11,040 --> 00:01:13,590
take an even lower level look at how computers work,
以更低级的视角来观察计算机的工作原理，

7
00:01:13,590 --> 00:01:16,050
and in turn, what it is you're doing when you write code
反过来，也让你了解你在编写代码时所做的事情

8
00:01:16,050 --> 00:01:18,900
toward an end of really giving you a complete mental model of what's
最终是为了让你对计算机内部发生的一切有一个完整的模型，这样当你想

9
00:01:18,900 --> 00:01:21,983
going on inside, so that when you run to solve some problem, when you want
解决问题的时候，当你想要

10
00:01:21,983 --> 00:01:25,050
to fix, solve some problem, when you want to write some code,
修复或解决问题，当你想要编写一些代码的时候，

11
00:01:25,050 --> 00:01:28,260
you actually know what those building blocks inside of the computer
你实际上就会知道计算机内部的那些构建块

12
00:01:28,260 --> 00:01:29,570
itself actually are.
本身是什么。

13
00:01:29,570 --> 00:01:32,070
We'll, ultimately, too, take off some of the training wheels
最终，我们也会去掉一些辅助工具，

14
00:01:32,070 --> 00:01:34,570
that we've had on for the past few weeks, particularly in C,
比如过去几周一直在使用的工具，特别是 C 语言中的工具，

15
00:01:34,570 --> 00:01:37,150
and we'll also introduce more familiar media types.
我们还将介绍一些更常见的媒体类型。

16
00:01:37,150 --> 00:01:39,750
So files, like images are sort of everywhere.
所以，像图片这样的文件无处不在。

17
00:01:39,750 --> 00:01:41,730
And we'll introduce you to exactly what's
我们将会向你介绍，当你看到照片、GIF

18
00:01:41,730 --> 00:01:43,980
going on when you just look at a photograph, or a GIF,
或者 PNG 以及屏幕上的任何其他图像，比如这个图像的时候，到底发生了什么。

19
00:01:43,980 --> 00:01:47,190
or a PNG, or any kind of image on your screen like this one here.
这将会变得清晰起来，不像好莱坞的电视剧和电影，

20
00:01:47,190 --> 00:01:51,240
And it will become clear that, unlike Hollywood TV shows and movies,
如果你尝试将这样的图片进行放大，再放大，再放大，在电影中，通常

21
00:01:51,240 --> 00:01:53,790
if you try to enhance a picture like this
是为了找出坏人是谁，最后，

22
00:01:53,790 --> 00:01:57,450
to look closer, and closer, and closer, in the movies typically
你会发现信息不足，因为这些文件只有有限数量的比特

23
00:01:57,450 --> 00:02:00,540
trying to figure out who the bad guy is, for instance, eventually,
或者字节。

24
00:02:00,540 --> 00:02:04,600
you run out of information because there's only a finite number of bits
所以，如果你看到计算机上，只需要

25
00:02:04,600 --> 00:02:06,392
or bytes that compose these files.
点击一个按钮，然后“嘭”的一声，图片就被放大了，然后嫌疑人突然就清晰了，

26
00:02:06,392 --> 00:02:08,350
So any time you've seen computers that you just
那更像是好莱坞的电影，而不是计算机科学。

27
00:02:08,350 --> 00:02:11,410
hit a button, and boom, it's enhanced, and all of a sudden the suspect
但话虽如此，在学期后期，我们会

28
00:02:11,410 --> 00:02:14,770
is clear, that's a lot more Hollywood than it is computer science.
谈论人工智能。

29
00:02:14,770 --> 00:02:16,720
But with that said, later in the term, we
即使在那里可能没有那些信息，

30
00:02:16,720 --> 00:02:18,850
will talk about artificial intelligence.
通过统计推理、建模和预测，

31
00:02:18,850 --> 00:02:22,270
And even though there might not be that information there,
计算机越来越能够实际地创造

32
00:02:22,270 --> 00:02:25,720
through statistical reasoning, and modeling, and predictions,
信息，即使这些信息可能不存在，仅仅是基于

33
00:02:25,720 --> 00:02:28,090
can computers increasingly actually create
最有可能出现的场景。

34
00:02:28,090 --> 00:02:30,520
information, where perhaps there was none, just based
再过不久，我们会详细介绍这些内容。

35
00:02:30,520 --> 00:02:32,080
on what's most likely to be there?
但你会看到，屏幕上的所有这些点，所有的像素，

36
00:02:32,080 --> 00:02:34,030
So more on that before long, too.
可以看作是一个上下左右的网格，

37
00:02:34,030 --> 00:02:37,220
But you'll see that all of these dots on the screen, all of these pixels,
这些网格组成了图像。

38
00:02:37,220 --> 00:02:39,610
so to speak, are just a grid up, down, left, right that
我们很幸运地邀请到了三位志愿者上台，

39
00:02:39,610 --> 00:02:40,720
compose these pictures.
他们在讲座开始之前，利用便签纸创作了自己的像素艺术作品，

40
00:02:40,720 --> 00:02:43,300
And we're fortunate to have three volunteers on stage who
可以说，是利用这台画架创作的。

41
00:02:43,300 --> 00:02:47,620
kindly, just before the lecture began, created their own pixel artwork,
如果你们愿意，可以把这台画架转过来，

42
00:02:47,620 --> 00:02:49,870
so to speak, on this here easel.
让我们看看你们都做了些什么。

43
00:02:49,870 --> 00:02:52,310
If you guys would like to spin this around,
另外，如果你们愿意，可以向我们介绍一下自己，

44
00:02:52,310 --> 00:02:57,260
let's see what it is you've been working on.
作为我们今天的三位艺术家。

45
00:02:57,260 --> 00:03:00,010
And if you'd like to introduce yourselves as our three artists
好的。

46
00:03:00,010 --> 00:03:00,700
today, first.
我是 Talia。

47
00:03:00,700 --> 00:03:03,090
SPEAKER 2: Yes, I'm Talia.
我是一名大三学生，主修经济学，辅修计算机科学。

48
00:03:03,090 --> 00:03:07,000
I'm a junior at the college studying economics with a possible computer
你好。

49
00:03:07,000 --> 00:03:08,470
science secondary.
我叫 Bulut。

50
00:03:08,470 --> 00:03:09,450
SPEAKER 3: Hi.
我来自波士顿大学。

51
00:03:09,450 --> 00:03:10,440
My name is Bulut.
欢迎。

52
00:03:10,440 --> 00:03:12,310
I'm from BU.
我是 Assalo Caesar，是一位自学成才的计算机科学学生。

53
00:03:12,310 --> 00:03:13,470
SPEAKER 1: Welcome.
我从 16 岁开始就从事软件工程师的工作。

54
00:03:13,470 --> 00:03:16,530
SPEAKER 4: I'm a Assalo Caesar, self-taught computer science student.
不错。

55
00:03:16,530 --> 00:03:19,230
I've been working as a software engineer since age 16.
欢迎你们。

56
00:03:19,230 --> 00:03:20,010
SPEAKER 1: Nice.
另外，请你们描述一下你们用像素制作了什么。

57
00:03:20,010 --> 00:03:21,160
Well, welcome to you all.
我们做了一个烟花。

58
00:03:21,160 --> 00:03:22,830
And if you would like to give us a description of what it
好的，不错。

59
00:03:22,830 --> 00:03:24,510
is that you built out of pixels here.
因为我们给他们的都是便签纸，每个便签纸都代表着一个像素或者点。

60
00:03:24,510 --> 00:03:27,330
SPEAKER 2: So we built a firework.
通常来说，可能只有黑色或白色，

61
00:03:27,330 --> 00:03:28,920
SPEAKER 1: OK, nice.
但是我们这里的便签纸是粉色或蓝色。

62
00:03:28,920 --> 00:03:31,710
And it's very blocky because what we've given
所以，每一个便签纸都代表着屏幕上的一个点。

63
00:03:31,710 --> 00:03:34,890
them is post-it notes, each of which represents one of these pixels or dots.
我记得你们还做了一个作品，

64
00:03:34,890 --> 00:03:36,930
Now, typically, it might be black or white,
可能传达了更多信息，如果你们愿意，可以展示一下第二版本。

65
00:03:36,930 --> 00:03:39,580
but the post-it notes we have here are pink or blue.
我们又有了更多的像素艺术作品。

66
00:03:39,580 --> 00:03:41,580
So each of these represents a dot on the screen.
让我们为我们的志愿者鼓掌，他们仅凭像素就完成了这些作品。

67
00:03:41,580 --> 00:03:43,740
And I gather you did one other that actually
谢谢。

68
00:03:43,740 --> 00:03:47,820
conveys maybe a bit more information, if you want to reveal version two.
我们一如既往地准备了美味的超级马里奥兄弟奥利奥饼干，

69
00:03:47,820 --> 00:03:50,550
And thus we have yet more pixel art.
给在场的每一位。

70
00:03:50,550 --> 00:03:54,510
So maybe round of applause for what our volunteers were able to do using
非常感谢你们上来。

71
00:03:54,510 --> 00:03:55,380
pixels alone.
谢谢。

72
00:03:55,380 --> 00:03:56,010
Thank you.
但关键是，

73
00:03:56,010 --> 00:04:00,420
We have, as always, limited supply of delicious Super Mario Brothers
当屏幕上只有点的时候，你能做的事情就有限。

74
00:04:00,420 --> 00:04:01,500
Oreos for each of you.
当然，我们刚才看到的那个

75
00:04:01,500 --> 00:04:03,160
Thank you so much for coming up.
减压球的图片，质量更高。

76
00:04:03,160 --> 00:04:03,858
But thank you.
保真度更高，或者更准确地说，分辨率更高。

77
00:04:03,858 --> 00:04:05,650
But the point here, really, is that there's
而分辨率指的是屏幕上的点或像素数量。

78
00:04:05,650 --> 00:04:08,320
only so much you can do when you just have dots on the screen.
它们越小，屏幕上塞得越多，图像就越清晰。

79
00:04:08,320 --> 00:04:10,960
Now, of course, the image that we saw a moment ago of these
但最终，即使像这种像素艺术作品

80
00:04:10,960 --> 00:04:13,510
here stress balls is much higher quality.
也代表着你手机、笔记本电脑、台式机、电视上正在发生的事情，

81
00:04:13,510 --> 00:04:17,360
It's much higher fidelity, or more specifically, much higher resolution.
因为它们都是像素网格。

82
00:04:17,360 --> 00:04:20,490
And resolution just refers to how many dots or pixels are on the screen.
现在，在编写实际操作这些图像的代码之前，我们需要了解，

83
00:04:20,490 --> 00:04:22,240
And the smaller they are, and the more you
我们需要掌握一些用于导航文件的新语法。

84
00:04:22,240 --> 00:04:25,850
cram in on the screen, the clearer, and clearer the images are.
不仅是文本，还有存储在计算机上的文件，

85
00:04:25,850 --> 00:04:28,960
But at the end of the day, even this here pixel art
存储在服务器上的文件。

86
00:04:28,960 --> 00:04:32,950
represents what's going on your phone, your laptop, your desktop, your TV
但是，让我们考虑一下如何存储像这样的信息，

87
00:04:32,950 --> 00:04:36,160
nowadays, because all it is this grid of pixels.
但我们会简化它。

88
00:04:36,160 --> 00:04:39,820
Now, before we can actually write code that actually manipulates
这里有一个 0 和 1 的网格，显然。

89
00:04:39,820 --> 00:04:42,130
these kinds of images, we need to understand,
但我认为，每一个 0 或 1 都可以代表

90
00:04:42,130 --> 00:04:44,980
and we need to have some new syntax for navigating files.
一个像素，一个点。

91
00:04:44,980 --> 00:04:48,400
So not just text, but files stored somewhere on the computer,
如果这个点是 0，它就代表黑色。

92
00:04:48,400 --> 00:04:49,570
somewhere on the server.
 

93
00:04:49,570 --> 00:04:52,580
But let's consider how we might store even information like this.
 

94
00:04:52,580 --> 00:04:53,740
But we'll make it simpler.
 

95
00:04:53,740 --> 00:04:57,190
Here is a grid of zeros and ones, clearly.
 

96
00:04:57,190 --> 00:04:59,740
But I would argue that each of these might as well represent
 

97
00:04:59,740 --> 00:05:01,450
a pixel, an individual dot.
 

98
00:05:01,450 --> 00:05:04,720
And if that dot is a zero, it's representing the color black.
 



99
00:05:04,720 --> 00:05:09,040
If that dot is a one, it's representing the color white.
如果那个点是 1，它就代表白色。

100
00:05:09,040 --> 00:05:15,940
Given that, can anyone see what this grid is a picture of,
这样的话，有人能看出这个网格是什么图案吗？

101
00:05:15,940 --> 00:05:20,920
even though it's using zeros and ones and not post-it notes, like this here?
即使它使用的是 0 和 1，而不是便签，就像这里一样？

102
00:05:20,920 --> 00:05:23,360
Yeah, in the back?
嗯，在后面吗？

103
00:05:23,360 --> 00:05:25,010
It's a smiley face.
这是一个笑脸。

104
00:05:25,010 --> 00:05:26,150
How do you see that?
你怎么看出来的？

105
00:05:26,150 --> 00:05:28,260
Well, in a moment it's going to be super obvious.
好吧，一会儿就会非常明显。

106
00:05:28,260 --> 00:05:32,600
But if I actually get rid of the ones, leaving just the zeros,
但如果我真的去掉 1，只留下 0，

107
00:05:32,600 --> 00:05:35,467
there you have the zeros that were there just a moment ago.
这些 0 就出现了，它们刚刚才在那里。

108
00:05:35,467 --> 00:05:37,550
So what this translates to, typically on a screen,
所以，通常在屏幕上，这会被转化成

109
00:05:37,550 --> 00:05:40,670
is not a pattern of zeros and ones literally on the screen,
不是屏幕上的 0 和 1 的模式，

110
00:05:40,670 --> 00:05:41,970
but a pattern of dots.
而是一系列点的模式。

111
00:05:41,970 --> 00:05:46,070
So again, white might be one, and black might be--
所以，再次强调，白色可能是 1，而黑色可能是——

112
00:05:46,070 --> 00:05:48,110
one might be white.
1 可能代表白色。

113
00:05:48,110 --> 00:05:49,220
Zero might be black.
0 可能代表黑色。

114
00:05:49,220 --> 00:05:52,130
But we picture it, of course, on our screens as this actual grid.
但当然，我们在屏幕上看到的是这个网格。

115
00:05:52,130 --> 00:05:53,570
But that's really all we need.
但实际上，这就是我们所需要的。

116
00:05:53,570 --> 00:05:55,880
Inside of a file to store something like an image,
在存储图像之类的文件里，

117
00:05:55,880 --> 00:05:58,070
we just need a pattern of zeros and ones.
我们只需要一系列的 0 和 1。

118
00:05:58,070 --> 00:06:00,770
But of course, having more colors would be more interesting.
但当然，拥有更多颜色会更有趣。

119
00:06:00,770 --> 00:06:04,400
And if you actually have a larger grid, you can do even more with pixel art.
如果你有一个更大的网格，你就可以用像素画做更多的事情。

120
00:06:04,400 --> 00:06:06,740
And in fact for fun, at the beginning of the semester,
事实上，为了好玩，在学期开始的时候，

121
00:06:06,740 --> 00:06:10,220
we have a staff training with all of the teaching fellows, course assistants,
我们会对所有助教、课程助理进行培训，

122
00:06:10,220 --> 00:06:13,580
teaching assistants, and we gave them all this Google spreadsheet.
助教，然后我们给他们所有人一个 Google 表格。

123
00:06:13,580 --> 00:06:16,280
And we sort of resized all of the rows and columns
我们调整了所有行和列的大小

124
00:06:16,280 --> 00:06:19,440
to just be squares instead of the default rectangles.
使它们变成正方形而不是默认的矩形。

125
00:06:19,440 --> 00:06:21,980
And then we encouraged them to create something out of this.
然后我们鼓励他们用这个表格创作一些东西。

126
00:06:21,980 --> 00:06:25,230
And in fact, just a few weeks ago, here are some of this year's creations,
事实上，就在几周前，这里有一些今年的作品，

127
00:06:25,230 --> 00:06:28,410
creating, essentially, images using Google Spreadsheets
使用 Google 表格创建图像，

128
00:06:28,410 --> 00:06:32,080
by treating each of the cells as just a dot on the screen.
将每个单元格视为屏幕上的一个点。

129
00:06:32,080 --> 00:06:33,960
So here, we have a team who in a few minutes
所以，这里有一个团队，在几分钟内

130
00:06:33,960 --> 00:06:36,550
made a Super Mario World, a bigger canvas, of course,
做了一个超级马里奥世界，当然，画布比这里更大。

131
00:06:36,550 --> 00:06:37,680
than this here easel.
比这里画架更大。

132
00:06:37,680 --> 00:06:42,030
Here we have a pixel based version of Scratch.
这里有一个基于像素的 Scratch 版本。

133
00:06:42,030 --> 00:06:46,080
Here, we had an homage to the Harvard-Yale football competition.
这里，我们向哈佛-耶鲁橄榄球比赛致敬。

134
00:06:46,080 --> 00:06:48,960
And then here, we had a character of some sort.
然后这里，我们有一个角色。

135
00:06:48,960 --> 00:06:50,670
So this is what the team here did.
所以这是这个团队做的事情。

136
00:06:50,670 --> 00:06:52,290
And actually, if you'd like to play along at home
实际上，如果你想在家玩玩

137
00:06:52,290 --> 00:06:54,582
at the risk of distracting you the entirety of lecture,
冒着让你整节课都分心的风险，

138
00:06:54,582 --> 00:06:56,880
if you go to this URL here, it'll actually give you
如果你访问这个 URL，它会给你

139
00:06:56,880 --> 00:06:59,430
a copy of that same blank spreadsheet.
一个相同的空白表格的副本。

140
00:06:59,430 --> 00:07:02,010
But let's talk about representing, not just zeros and ones,
但让我们谈谈如何表示，不仅仅是 0 和 1，

141
00:07:02,010 --> 00:07:03,930
and black and white, but actual colors.
还有黑白色，而是真实的颜色。

142
00:07:03,930 --> 00:07:06,630
And so recall from week zero when we talked
所以，回想一下我们第一周讲的

143
00:07:06,630 --> 00:07:09,120
about how to represent information, colors among,
如何表示信息，颜色在其中，

144
00:07:09,120 --> 00:07:12,850
them we introduced RGB, which stands for red, green, blue.
我们介绍了 RGB，代表红、绿、蓝。

145
00:07:12,850 --> 00:07:15,600
And it's just this kind of convention of using some amount of red,
它就是一种约定，使用一定量的红色，

146
00:07:15,600 --> 00:07:18,660
some amount of green, and some amount of blue mixed together to give you
一定量的绿色，和一定量的蓝色混合在一起，给你

147
00:07:18,660 --> 00:07:20,895
the actual color that you want.
你想要的颜色。

148
00:07:20,895 --> 00:07:22,770
Well, it turns out in the world of computers,
好吧，在计算机的世界里，

149
00:07:22,770 --> 00:07:27,460
there's a standard way for describing those amounts of red, green, and blue.
有一种标准的方式来描述这些红、绿、蓝的量。

150
00:07:27,460 --> 00:07:29,460
At the end of the day, it's of course just bits.
归根结底，它只是比特。

151
00:07:29,460 --> 00:07:33,040
And equivalently, it's just numbers, like 72, 73,
等效地，它只是数字，比如 72、73，

152
00:07:33,040 --> 00:07:37,180
33 was the arbitrary example we used in week zero for the color yellow.
33 是我们第一周用来表示黄色的任意例子。

153
00:07:37,180 --> 00:07:40,500
But there actually tends to be a different notation by convention
但实际上，根据惯例，有一种不同的表示颜色的符号

154
00:07:40,500 --> 00:07:43,320
for representing colors that we'll actually see today, too,
我们会今天看到，

155
00:07:43,320 --> 00:07:45,160
as we explore the world of memory.
当我们探索记忆的世界。

156
00:07:45,160 --> 00:07:46,958
So here's a screenshot of Photoshop.
这是一张 Photoshop 的截图。

157
00:07:46,958 --> 00:07:49,500
If you've never used it before, this is like the color picker
如果你以前从未使用过它，它就像一个颜色选择器

158
00:07:49,500 --> 00:07:52,620
that you can pull up, just to pick any number of millions of colors
你可以调出来，选择数百万种颜色中的任何一种

159
00:07:52,620 --> 00:07:54,750
by clicking and dragging, or typing in numbers.
通过点击拖动，或输入数字。

160
00:07:54,750 --> 00:07:56,190
But notice down here.
但请注意这里。

161
00:07:56,190 --> 00:07:58,680
We've picked at the moment the color black by moving
我们现在选择黑色，通过移动

162
00:07:58,680 --> 00:08:01,480
the slider all the way down here to the bottom left hand corner.
滑块到底部左角。

163
00:08:01,480 --> 00:08:03,480
And what this user interface is telling us
这个用户界面告诉我们

164
00:08:03,480 --> 00:08:06,060
is that there's zero red, zero green, zero blue.
没有红色，没有绿色，没有蓝色。

165
00:08:06,060 --> 00:08:09,630
And a conventional way of writing this on a screen
在屏幕上写这个的常规方法是

166
00:08:09,630 --> 00:08:14,040
would be, literally, a hash symbol, and then three pairs of digits.
一个井号，然后是三个数字对。

167
00:08:14,040 --> 00:08:18,150
zero, zero for red, zero, zero for green, zero, zero for blue.
00 代表红色，00 代表绿色，00 代表蓝色。

168
00:08:18,150 --> 00:08:22,530
If by contrast, you were to pick the color, say, white in Photoshop,
相反，如果你在 Photoshop 中选择白色，

169
00:08:22,530 --> 00:08:23,580
it gets a little weird.
事情变得有点奇怪。

170
00:08:23,580 --> 00:08:27,210
Now it's a lot of red, a lot of green, a lot of blue, as you might expect,
现在有很多红色，很多绿色，很多蓝色，正如你所料，

171
00:08:27,210 --> 00:08:28,800
cranking all of those values up.
将所有这些值都调到最大。

172
00:08:28,800 --> 00:08:31,950
But the way you write it conventionally is not using decimal,
但你写它的常规方式不是使用十进制，

173
00:08:31,950 --> 00:08:34,710
but using letters of the alphabet, it would seem here.
而是使用字母，看起来是。

174
00:08:34,710 --> 00:08:38,130
So FF for red, FF, for Green, FF for blue.
所以 FF 代表红色，FF 代表绿色，FF 代表蓝色。

175
00:08:38,130 --> 00:08:39,270
More on that in a moment.
稍后详细说明。

176
00:08:39,270 --> 00:08:43,350
When it comes to representing red, here's a lot of red, 255.
当涉及到表示红色时，这里有很多红色，255。

177
00:08:43,350 --> 00:08:44,880
Zero green, zero blue.
零绿色，零蓝色。

178
00:08:44,880 --> 00:08:48,930
And so the pattern is now FF0000.
所以模式现在是 FF0000。

179
00:08:48,930 --> 00:08:52,740
Before I reveal what green is, what probably should it be?
在揭示绿色是什么之前，它可能应该是？

180
00:08:52,740 --> 00:08:53,520
What pattern?
什么模式？

181
00:08:53,520 --> 00:08:56,250
Yeah.
是的。

182
00:08:56,250 --> 00:08:56,760
Close.
接近。

183
00:08:56,760 --> 00:09:04,050
Not 0000FF, but 00FF00 because it seems to be following this pattern, indeed,
不是 0000FF，而是 00FF00，因为它似乎遵循这种模式，确实，

184
00:09:04,050 --> 00:09:05,940
from left to right of red, green, blue.
从左到右是红、绿、蓝。

185
00:09:05,940 --> 00:09:11,190
So zero red, 255 green, zero blue, and thus 00FF00.
所以是零红色，255 绿色，零蓝色，因此是 00FF00。

186
00:09:11,190 --> 00:09:15,150
And then lastly, if we do solid blue, it's zero red, zero green,
最后，如果我们使用纯蓝色，它是零红色，零绿色，

187
00:09:15,150 --> 00:09:18,660
a lot of blue, and thus 0000FF.
很多蓝色，因此是 0000FF。

188
00:09:18,660 --> 00:09:24,712
So somehow or other, FF is apparently representing the number 255.
所以不知何故，FF 显然代表数字 255。

189
00:09:24,712 --> 00:09:26,170
And we'll see why in just a moment.
我们很快就会明白原因。

190
00:09:26,170 --> 00:09:27,920
But recall that in the world of computers,
但请记住，在计算机的世界里，

191
00:09:27,920 --> 00:09:29,430
they just speak zeros and ones.
它们只说 0 和 1。

192
00:09:29,430 --> 00:09:31,872
And we've seen that already in black and white form.
我们已经在黑白形式中看到了这一点。

193
00:09:31,872 --> 00:09:34,830
We of course, in the real world, tend to use decimal instead of binary.
当然，在现实世界中，我们倾向于使用十进制而不是二进制。


194
00:09:34,830 --> 00:09:38,400
So we have 10 digits at our disposal, zero through nine.
所以我们有十个数字可以使用，从零到九。

195
00:09:38,400 --> 00:09:42,130
But it turns out that in the world of graphics and colors,
但事实证明，在图形和颜色的世界里，

196
00:09:42,130 --> 00:09:44,430
turns out in the world of computer memory,
事实证明，在计算机内存的世界里，

197
00:09:44,430 --> 00:09:48,480
it tends to be convenient not to use binary, per se, not to use decimal,
通常情况下，不使用二进制，也不使用十进制，

198
00:09:48,480 --> 00:09:50,880
per se, but to use something called hexadecimal,
而是使用一种叫做十六进制的东西，

199
00:09:50,880 --> 00:09:54,480
where as soon as you need more than 10 digits total,
只要你需要的数字超过10位，

200
00:09:54,480 --> 00:09:56,460
you start stealing from the English alphabet.
你就会开始从英文字母表中窃取。

201
00:09:56,460 --> 00:09:58,950
So the next few numbers, or digits rather,
所以接下来的几个数字，或者更确切地说，是数字，

202
00:09:58,950 --> 00:10:04,080
are A, B, C, D, E, F. And there's other systems that
是 A、B、C、D、E、F。还有其他系统使用更多字母，但可能是

203
00:10:04,080 --> 00:10:06,720
use even more letters of the alphabet, but this is probably
我们最后一次详细讨论的。

204
00:10:06,720 --> 00:10:08,680
the last we'll discuss in any detail.
所以，在这种情况下，我们共有 10 加 1，2，3，4，5，

205
00:10:08,680 --> 00:10:12,750
So in this case, we have a total of 10 plus one, two, three, four, five,
6，一共 16 个，也就是

206
00:10:12,750 --> 00:10:15,180
six, so 16 total, a.k.a.
十六进制，或者我们称之为 16 进制。

207
00:10:15,180 --> 00:10:18,262
hexadecimal, or what we might call base 16.
大小写实际上并不重要。

208
00:10:18,262 --> 00:10:20,220
And the capitalization actually doesn't matter.
通常使用大写或小写，

209
00:10:20,220 --> 00:10:22,825
It's conventional to use uppercase or lowercase,
只要你大体上保持一致。

210
00:10:22,825 --> 00:10:24,450
so long as you're generally consistent.
所以，hexa 代表 16，decimal 代表十进制。

211
00:10:24,450 --> 00:10:26,710
So hexa, implying 16, decimal.
因此，十六进制表示法，也称为 16 进制，

212
00:10:26,710 --> 00:10:30,360
So hexadecimal notation here, or otherwise known as base 16,
由于数学原因，可以追溯到我们第零周的讨论。

213
00:10:30,360 --> 00:10:34,440
for mathematical reasons that go back to our discussion in week zero.
所以这里有一些来自第零周的相同推理。

214
00:10:34,440 --> 00:10:37,500
So here's some of that same reasoning from week zero.
我们如何用十六进制的两位数来表示你我所知的十进制数？

215
00:10:37,500 --> 00:10:40,350
How might we go about representing using two
好吧，如果我们认为这是 16 的零次方，16

216
00:10:40,350 --> 00:10:44,980
digits in hexadecimal, different numbers that you and I know as decimal?
到一次方，如果我们进行计算，当然，

217
00:10:44,980 --> 00:10:49,925
Well, if we consider this as being the 16 to the zeros place, 16
这给了我们个位和十六位。

218
00:10:49,925 --> 00:10:52,300
to the ones place, and if we do out that math, of course,
所以我们只改变了基数，而不是第零周的故事。

219
00:10:52,300 --> 00:10:54,730
that gives us the ones place and the sixteens place.
所以，如果我们要开始用十六进制表示实际的值，

220
00:10:54,730 --> 00:10:57,750
So we've only changed the base, not the story from week zero.
这里有两个零。

221
00:10:57,750 --> 00:11:01,680
So if we were to start representing actual values in hexadecimal,
所以，是 1 乘以 0 加 16 乘以 0，当然，这给了我们

222
00:11:01,680 --> 00:11:03,930
here are two zeros.
你我所知的数字零。

223
00:11:03,930 --> 00:11:07,530
So that's 1 times 0 plus 16 times 0, which, of course, gives us
所以，在十六进制、二进制和十进制中，

224
00:11:07,530 --> 00:11:08,970
the number you and I know is zero.
表示你我所知的数字零的方法是相同的。

225
00:11:08,970 --> 00:11:12,030
So in hexadecimal, and in binary, and in decimal, it's
但这里现在是十六进制的数字一。

226
00:11:12,030 --> 00:11:15,030
the same way to represent the number you and I know as zero.
这里是数字二。

227
00:11:15,030 --> 00:11:17,640
But here now is the number one in hexadecimal.
这里是数字三、四、五、六、七、八、九。

228
00:11:17,640 --> 00:11:18,930
Here's the number two.
所以，到目前为止，它与我们的十进制世界是相同的。

229
00:11:18,930 --> 00:11:24,340
Here's the number three, four, five, six, seven, eight, nine.
但我如何将你我所说的十进制的10计算出来，

230
00:11:24,340 --> 00:11:28,120
So it's identical up until this point to our world of decimal.
根据我们目前所看到的？

231
00:11:28,120 --> 00:11:32,590
But how do I count up to what you and I would call 10 in decimal,
是的。

232
00:11:32,590 --> 00:11:36,130
according to what we're seeing here thus far?
所以现在它上升到 A，因为 A 似乎

233
00:11:36,130 --> 00:11:36,640
Yeah.
代表你我所知的 10。

234
00:11:36,640 --> 00:11:39,970
So now it goes up to A, because A would, apparently,
B 代表 11。

235
00:11:39,970 --> 00:11:41,940
represent what you and I know as 10.
C 代表 12、13、14、15。

236
00:11:41,940 --> 00:11:43,420
B represents 11.
不过，我如何将 16 计算出来？

237
00:11:43,420 --> 00:11:47,740
C represents 12, 13, 14, 15.
是的。

238
00:11:47,740 --> 00:11:50,890
How, though, do I count up to 16?
确实。

239
00:11:50,890 --> 00:11:52,330
Yeah.
所以不是 10，而是 1，0，因为左边第二列的 1

240
00:11:52,330 --> 00:11:53,080
Exactly.
实际上代表的是十六位。

241
00:11:53,080 --> 00:11:56,320
So not 10, quote unquote, but one, zero because the one
所以 16 乘以 1 等于 16，加上 1 乘以 0 等于 0，所以总共是 16。

242
00:11:56,320 --> 00:11:59,920
in the second column here to the left actually represents the sixteens place.
所以，现在是你可以我所认为的 17 的数字，

243
00:11:59,920 --> 00:12:05,180
So it's 16 times 1 gives you 16, plus 1 times 0 gives you 0, so 16 in total.
18、19、20、21，等等。

244
00:12:05,180 --> 00:12:09,350
So this now is the way the number you and I would think of as 17,
如果我们一直数下去，尽可能地数下去，那么十六进制中最大的数字是什么？

245
00:12:09,350 --> 00:12:13,990
18, 19, 20, 21, dot, dot, dot.
显然，最小的数字是 0，我说过最大的数字是 F。

246
00:12:13,990 --> 00:12:16,690
And if we go all the way up, as high up as we
所以，当你到达 FF 时，数学就会变得有点烦人。

247
00:12:16,690 --> 00:12:20,450
can count, well, what's the largest digit, apparently, in hexadecimal?
但现在是 16 乘以 15 加 1 乘以 15。

248
00:12:20,450 --> 00:12:23,980
The smallest is clearly zero, and the biggest I said was F.
实际上，这给了我们你我所知的数字 255。

249
00:12:23,980 --> 00:12:26,680
So once you get to FF, the math gets a little annoying.
所以，我们在 Photoshop 中看到了它。

250
00:12:26,680 --> 00:12:33,250
But this is now 16 times 15 plus 1 times 15.
我们现在在十六进制中看到了它。

251
00:12:33,250 --> 00:12:37,820
And what that gives us, actually, is the number you and I know as 255.
这不是你会经常做的数学，

252
00:12:37,820 --> 00:12:39,045
So we saw it in Photoshop.
但实际上，它与第零周的系统完全相同，

253
00:12:39,045 --> 00:12:40,420
We've seen it now in hexadecimal.
只是基数不同。

254
00:12:40,420 --> 00:12:42,545
This is not math that you would ever do frequently,
但为什么有这么多额外的复杂性？

255
00:12:42,545 --> 00:12:45,610
but indeed, it's the exact same system as week zero,
为什么我们要跳过这些障碍，引入另一个障碍，

256
00:12:45,610 --> 00:12:46,930
just with a different base.
只是为了给我们提供像这样的 FF 模式？

257
00:12:46,930 --> 00:12:48,890
But why all of this additional complexity?
事实证明，十六进制只是很方便。

258
00:12:48,890 --> 00:12:51,640
Why are we jumping through these hoops introducing yet another one
为什么呢？

259
00:12:51,640 --> 00:12:54,370
to give us just some pattern like this of FF?
好吧，如果你在你的字母表中有 16 个数字，

260
00:12:54,370 --> 00:12:57,070
Well, it turns out that hexadecimal is just convenient.
从 0 到 F，你需要多少位，多少个 0 和 1 来

261
00:12:57,070 --> 00:12:57,640
Why?
表示 16 个不同的值？

262
00:12:57,640 --> 00:13:00,400
Well, if you have 16 digits in your alphabet,
是 4 位，对吧？

263
00:13:00,400 --> 00:13:04,450
zero through F, how many bits, how many zeros and ones
因为如果你有 4 位，那就是第一个的两种可能性乘以

264
00:13:04,450 --> 00:13:09,330
do you need to represent 16 different values?
2，乘以 2，乘以 2。

265
00:13:09,330 --> 00:13:10,520
It's four, right?
所以是 16 种可能性。

266
00:13:10,520 --> 00:13:14,210
Because if you've got four bits, that's two possibilities for the first times
2 的四次方。

267
00:13:14,210 --> 00:13:16,070
2, times 2, times 2.
所以如果你有 4 位，由一个数字表示，

268
00:13:16,070 --> 00:13:17,660
So that's 16 possibilities.
对计算机科学家和程序员来说，这在实践中非常方便。

269
00:13:17,660 --> 00:13:18,900
2 to the fourth power.
所以 F 可能会代表 1111。

270
00:13:18,900 --> 00:13:22,190
And if you've got four bits represented by a single digit,
但这并不是一个完整的字节，一个字节是 8 位。

271
00:13:22,190 --> 00:13:25,970
it's just convenient in practice for computer scientists and programmers.
在计算中，没有人以 4 为单位计数。

272
00:13:25,970 --> 00:13:29,000
So F might indeed represent 1111.
它总是以 8、16、32、64 等为单位。

273
00:13:29,000 --> 00:13:31,280
But that's not a full byte, which is eight bits.
所以，事实证明，由于十六进制适合

274
00:13:31,280 --> 00:13:33,950
And no one counts in units of four in computing.
一次表示 4 位，如果你只使用其中两个，

275
00:13:33,950 --> 00:13:38,790
It's always in units of, like, eight, or 16, or 32, or 64, or the like.
你可以一次表示 8 位。

276
00:13:38,790 --> 00:13:42,110
So it turns out, though, because hexadecimal lends itself
而 8 位是一个字节，这是一个常见的度量单位。

277
00:13:42,110 --> 00:13:46,070
to representing four bits at a time, well, if you just use two of them,
这就是为什么即使是 Photoshop 也使用这种惯例，颜色程序也是如此，

278
00:13:46,070 --> 00:13:47,960
you can represent eight bits at a time.
web 开发一般来说，使用两个十六进制数字来表示单个字节。

279
00:13:47,960 --> 00:13:51,560
And eight bits is a byte, which is a common unit of measure.
因为左边的那个表示第一个比特，前四个比特。

280
00:13:51,560 --> 00:13:56,270
And this is why even Photoshop uses this convention, as do color programs,
右边的那个代表后四个比特。

281
00:13:56,270 --> 00:14:01,040
as does web development, more generally, of using two hexadecimal digits just
所以，这不是什么大问题。

282
00:14:01,040 --> 00:14:02,895
to represent single bytes.
只是很方便，即使这可能让人感觉一下子太多了。

283
00:14:02,895 --> 00:14:06,020
Because the one on the left represents the first bits, the first four bits.
那么，关于十六进制还有什么问题吗？

284
00:14:06,020 --> 00:14:08,250
The one on the right represents the second four bits.
是的，中间那位。

285
00:14:08,250 --> 00:14:10,020
So it's not a big deal, per se.
没有。

286
00:14:10,020 --> 00:14:14,040
It's just convenient, even though this might feel like a lot all at once.


290
00:14:21,690 --> 00:14:22,680
OK, no.
好的，没有。

291
00:14:22,680 --> 00:14:24,480
Questions on hexadecimal.
关于十六进制的问题。

292
00:14:24,480 --> 00:14:25,380
All right.
好的。

293
00:14:25,380 --> 00:14:32,220
So with this system in mind, let's go about considering where else we might
所以带着这个系统，我们来思考一下，在其他什么地方我们可能会

294
00:14:32,220 --> 00:14:34,110
see this in the computing world.
在计算世界中看到它。

295
00:14:34,110 --> 00:14:37,320
And I would propose that we consider, as we've done in the past,
我建议我们考虑一下，就像我们过去做的那样，

296
00:14:37,320 --> 00:14:40,420
that our computer is really just this grid of memory, for instance,
我们的计算机实际上只是一个内存网格，例如，

297
00:14:40,420 --> 00:14:42,990
where each of these squares represents a single byte.
其中每个方格代表一个字节。

298
00:14:42,990 --> 00:14:45,660
And I proposed a couple of times already that, when
我已经提出过几次，当

299
00:14:45,660 --> 00:14:47,580
we talk about a computer's memory, we can
我们谈论计算机内存时，我们可以

300
00:14:47,580 --> 00:14:50,970
think of them as each of these squares as having an individual location.
把它们想象成每个方格都有一个单独的位置。

301
00:14:50,970 --> 00:14:53,850
Like, I spitballed back in the day that maybe this is the first byte,
比如，我以前随意地说，也许这是第一个字节，

302
00:14:53,850 --> 00:14:55,350
the second byte, the third byte.
第二个字节，第三个字节。

303
00:14:55,350 --> 00:14:57,840
Maybe this is the billionth byte, so we can number
也许这是十亿分之一字节，所以我们可以对

304
00:14:57,840 --> 00:14:59,670
of the bytes inside of a computer.
计算机内部的字节进行编号。

305
00:14:59,670 --> 00:15:02,040
Well, it turns out, as we'll see today in code,
事实证明，正如我们今天在代码中所见，

306
00:15:02,040 --> 00:15:06,330
computers typically use numbers, indeed, to represent
计算机通常使用数字，实际上，来表示

307
00:15:06,330 --> 00:15:08,880
all of the bytes in their memory, and they typically
它们内存中的所有字节，并且它们通常

308
00:15:08,880 --> 00:15:11,740
use hexadecimal notation for such by convention.
按照惯例使用十六进制表示法。

309
00:15:11,740 --> 00:15:12,900
So what do I mean by that?
那我的意思是？

310
00:15:12,900 --> 00:15:15,000
Technically, if we were to start numbering these
从技术上讲，如果我们要开始给这些

311
00:15:15,000 --> 00:15:17,190
and count at zero, as most programmers would,
进行编号，并从零开始计数，正如大多数程序员会做的那样，

312
00:15:17,190 --> 00:15:19,960
this is byte zero, one, two, three, dot, dot, dot.
这是字节零，一，二，三，等等。

313
00:15:19,960 --> 00:15:21,580
This is byte 15.
这是字节15。

314
00:15:21,580 --> 00:15:25,060
But if I wanted to keep going, it would be then 16, 17, 18,
但是如果我想继续，那将是16，17，18，

315
00:15:25,060 --> 00:15:27,560
but that's not the true in hexadecimal.
但这在十六进制中并不正确。

316
00:15:27,560 --> 00:15:30,040
So instead in hexadecimal, once you hit the nine,
因此在十六进制中，一旦你达到九，

317
00:15:30,040 --> 00:15:33,160
you'd actually use A through F, just as I've proposed.
你实际上会使用 A 到 F，正如我所提议的那样。

318
00:15:33,160 --> 00:15:37,270
Meanwhile, if you kept going thereafter, you would have one zero.
同时，如果你继续往下，你会得到一个零。

319
00:15:37,270 --> 00:15:39,010
But as you noted, this is not 10.
但正如你所注意到的，这不是10。

320
00:15:39,010 --> 00:15:44,270
This is 16 here, 17, 18, 19.
这是16，17，18，19。

321
00:15:44,270 --> 00:15:46,250
And so here's where things get a little weird.
所以这里事情就有点奇怪了。

322
00:15:46,250 --> 00:15:47,680
I'm saying 16.
我说的是16。

323
00:15:47,680 --> 00:15:51,460
I'm saying 17, and you're obviously seeing what any reasonable person would
我说的是17，你显然看到了任何理性的人都会

324
00:15:51,460 --> 00:15:53,200
read as 10 and 11.
读成10和11。

325
00:15:53,200 --> 00:15:56,170
So there's this dichotomy, and so we need some convention
所以存在这种二分法，因此我们需要一些约定

326
00:15:56,170 --> 00:15:59,690
for making clear to the reader that these are hexadecimal numbers, not
让读者清楚地知道这些是十六进制数，而不是

327
00:15:59,690 --> 00:16:00,190
decimal.
十进制。

328
00:16:00,190 --> 00:16:01,960
Otherwise, it's completely ambiguous.
否则，它完全模棱两可。

329
00:16:01,960 --> 00:16:04,877
And the convention there, which you might have seen in the real world,
那里的约定，你可能在现实世界中见过，

330
00:16:04,877 --> 00:16:09,215
even though it's a bit weird, is just to prefix hexadecimal numbers with zero X.
尽管有点奇怪，但仅仅是在十六进制数前加一个零 X。

331
00:16:09,215 --> 00:16:10,840
It's not doing anything mathematically.
它在数学上没有任何作用。

332
00:16:10,840 --> 00:16:12,790
It's not multiplication or anything like that.
它不是乘法，也不是任何类似的东西。

333
00:16:12,790 --> 00:16:17,380
Just zero X means, here comes a hexadecimal number hereafter, just
仅仅是零 X 意味着，这里将有一个十六进制数，仅此而已

334
00:16:17,380 --> 00:16:20,170
to distinguish it from decimal.
用来区分它和十进制。

335
00:16:20,170 --> 00:16:24,190
And you can see that, even though we don't have enough room for 255 bytes,
你可以看到，尽管我们没有足够的空间容纳 255 个字节，

336
00:16:24,190 --> 00:16:26,482
you start to see patterns that we haven't even
你开始看到一些我们甚至还没有

337
00:16:26,482 --> 00:16:29,440
talked about yet because we're just using those two columns as the ones
讨论过，因为我们只是使用这两列作为个位

338
00:16:29,440 --> 00:16:32,620
place, the 16th place, and so forth.
位，第十六位，等等。

339
00:16:32,620 --> 00:16:35,540
Capital or uppercase is fine.
大写或小写都可以。

340
00:16:35,540 --> 00:16:36,040
All right.
好的。

341
00:16:36,040 --> 00:16:39,820
So with that said, let's actually do things more technically interesting,
所以说，让我们做一些更技术上有趣的事情，

342
00:16:39,820 --> 00:16:42,220
like looking back at some code that we've already seen
比如回顾一下我们已经看过的代码

343
00:16:42,220 --> 00:16:47,560
and seeing what we can actually glean from this newfound representation
并看看我们实际上能从这种新发现的表示中得到什么

344
00:16:47,560 --> 00:16:48,450
of memory location.
内存位置。

345
00:16:48,450 --> 00:16:51,700
So I'm going to go over to VS Code here, where I've opened my terminal window,
所以我要到这里的 VS Code 中，我在那里打开了我的终端窗口，

346
00:16:51,700 --> 00:16:53,020
but no code file yet.
但还没有代码文件。

347
00:16:53,020 --> 00:16:56,470
And I'm going to go ahead and create a file called addresses.c
我要创建一个名为 addresses.c 的文件

348
00:16:56,470 --> 00:17:01,270
because I want to start playing around now with the addresses of information
因为我想现在开始玩弄一下信息的地址

349
00:17:01,270 --> 00:17:02,390
in my computer.
在我的计算机中。

350
00:17:02,390 --> 00:17:05,170
And to do this, let me do something super simple first.
为了做到这一点，让我先做一些非常简单的事情。

351
00:17:05,170 --> 00:17:07,480
Let me include standard io.h.
让我包含标准 io.h。

352
00:17:07,480 --> 00:17:10,490
Let me do an int main void, no command line arguments.
让我做一个 int main void，没有命令行参数。

353
00:17:10,490 --> 00:17:13,359
And then in here, let me do exactly the line of code we just saw.
然后在这里，让我做我们刚看到的这一行代码。

354
00:17:13,359 --> 00:17:18,069
Declare an int called n, set it equal to a default value of 50.
声明一个名为 n 的 int，将其设置为默认值为 50。

355
00:17:18,069 --> 00:17:20,920
And just so that the program does something noteworthy,
为了让程序做一些值得注意的事情，

356
00:17:20,920 --> 00:17:24,339
let's have it actually print out %i backslash n,
让它实际上打印出 %i 反斜杠 n，

357
00:17:24,339 --> 00:17:25,960
and plug-in that value of n.
并插入 n 的值。

358
00:17:25,960 --> 00:17:28,720
So this is, like, week one stuff, just creating a variable,
所以这就像第一周的东西，只是创建了一个变量，

359
00:17:28,720 --> 00:17:32,030
and printing out its value, just to make sure that we're on the same page.
并打印出它的值，只是为了确保我们理解一致。

360
00:17:32,030 --> 00:17:35,800
So let me do make addresses in my terminal window, enter.
所以让我在我的终端窗口中输入 make addresses，回车。

361
00:17:35,800 --> 00:17:38,140
And when I do dot slash addresses, no surprise.
当我输入点斜杠 addresses 时，不出所料。

362
00:17:38,140 --> 00:17:40,780
I should indeed see the number 50.
我应该看到数字 50。

363
00:17:40,780 --> 00:17:45,200
But let's consider what that actually does inside of the computer
但让我们考虑一下它在计算机内部实际做了什么

364
00:17:45,200 --> 00:17:48,640
now by flipping over, for instance, to this same line of code,
现在，例如，翻转到同一行代码，

365
00:17:48,640 --> 00:17:50,505
and translating it into this same grid.
并将其翻译成相同的网格。

366
00:17:50,505 --> 00:17:52,630
So here's a grid of memory, and I don't necessarily
所以这是一个内存网格，我并不一定

367
00:17:52,630 --> 00:17:54,370
know where in the computer's memory it's going to end up.
知道它将在计算机内存的哪个位置结束。

368
00:17:54,370 --> 00:17:56,140
So I'm picking spots arbitrarily.
所以我随意选择位置。

369
00:17:56,140 --> 00:18:01,120
But I know that an int, typically, is four bytes on most systems.
但我知道，在大多数系统上，一个 int 通常是四个字节。

370
00:18:01,120 --> 00:18:03,700
And so I've used one, two, three, four squares.
所以我用了 1，2，3，4 个方格。

371
00:18:03,700 --> 00:18:06,610
And the first four that I assume are available are down here,
我假设下面这四个是可用的，

372
00:18:06,610 --> 00:18:09,220
and I'm calling this n, and I'm putting the value 50 in it.
我称之为 n，并将值 50 放入其中。

373
00:18:09,220 --> 00:18:13,900
So literally, when you write that line of code, int n equals 50 semicolon,
所以从字面上讲，当你写下那行代码，int n 等于 50 分号，

374
00:18:13,900 --> 00:18:16,960
the computer's doing something like this underneath the hood.
计算机在幕后做了类似的事情。

375
00:18:16,960 --> 00:18:20,630
Might be over here, might be over there, but I've drawn it simply down there.
可能在这里，可能在那里，但我只是简单地把它画在那里。

376
00:18:20,630 --> 00:18:24,760
But that means that that 50 and that variable n,
但这意味着 50 和变量 n，

377
00:18:24,760 --> 00:18:28,790
in particular, live somewhere in the computer's memory.
特别是，存在于计算机的内存中的某个地方。

378
00:18:28,790 --> 00:18:30,187
And where might it live?
它可能住在哪里？

379
00:18:30,187 --> 00:18:31,270
Well, I don't really know.
好吧，我真的不知道。

380
00:18:31,270 --> 00:18:34,850
And frankly, I'm not going to care, ultimately, after today.
坦白地说，从今天开始，我最终不会在乎。

381
00:18:34,850 --> 00:18:39,220
But let me propose that, if all of these bytes are numbered from zero on down,
但让我假设一下，如果所有这些字节都从零开始编号，

382
00:18:39,220 --> 00:18:42,823
maybe this is address OX123, for the sake of discussion.
也许这是地址 OX123，为了讨论方便。

383
00:18:42,823 --> 00:18:44,740
So it's a hexadecimal number, one, two, three.
所以这是一个十六进制数，一，二，三。

384
00:18:44,740 --> 00:18:46,240
It's not 123.
它不是 123。


```
385
00:18:46,240 --> 00:18:48,340
It's one, two, three, but in hexadecimal,
它是 1, 2, 3，但在十六进制中，

386
00:18:48,340 --> 00:18:50,140
just because it's a little easy to say.
只是因为它比较容易说。

387
00:18:50,140 --> 00:18:55,510
But that variable n clearly must live at some address.
但是这个变量 n 显然必须位于某个地址。

388
00:18:55,510 --> 00:18:57,860
So can we maybe see this?
所以我们能看到吗？

389
00:18:57,860 --> 00:19:02,710
Well, it turns out that in C, there is a bit more syntax we can introduce today
结果是，在 C 中，今天我们可以引入更多语法

390
00:19:02,710 --> 00:19:08,770
that actually gives you access to the locations of variables
它实际上让你可以访问变量在计算机内存中的位置

391
00:19:08,770 --> 00:19:10,810
inside of the computer's memory.
在计算机的内存中。

392
00:19:10,810 --> 00:19:13,000
The first of these is literally an ampersand,
第一个是真正的与符号，

393
00:19:13,000 --> 00:19:15,670
and you might pronounce that the address of operator.
你可以把它读作取地址运算符。

394
00:19:15,670 --> 00:19:18,250
Using a single ampersand, you can actually ask the computer
使用一个单独的与符号，你实际上可以问计算机

395
00:19:18,250 --> 00:19:19,990
at what address is this variable.
这个变量位于哪个地址。

396
00:19:19,990 --> 00:19:22,330
And then the asterisk here might be known
然后这里的星号可能被称为

397
00:19:22,330 --> 00:19:25,720
as the dereference operator, which allows you to take an address
解引用运算符，它允许你获取一个地址

398
00:19:25,720 --> 00:19:28,720
and go to it, kind of like following a map.
并转到它，就像在跟着地图走一样。

399
00:19:28,720 --> 00:19:29,620
X marks the spot.
X 标明了位置。

400
00:19:29,620 --> 00:19:32,630
The star will take you to that location in memory,
星号会带你到内存中的那个位置，

401
00:19:32,630 --> 00:19:34,520
so you can see what's actually there.
这样你就可以看到那里究竟是什么。

402
00:19:34,520 --> 00:19:35,720
So what do I mean by that?
我指的是什么？

403
00:19:35,720 --> 00:19:38,770
Well, let me go back over to VS Code here, and let me go ahead
好吧，让我回到 VS Code 这里，让我继续

404
00:19:38,770 --> 00:19:43,070
and change my program to be ever so slightly different, as follows.
将我的程序稍微修改一下，如下所示。

405
00:19:43,070 --> 00:19:46,870
I'm going to still declare n, just as before, to have the value of 50.
我仍然像以前一样声明 n，让它等于 50。

406
00:19:46,870 --> 00:19:49,630
But instead of printing out an integer, per se,
但我不会打印整数，

407
00:19:49,630 --> 00:19:51,790
I'm going to print out an address.
我会打印地址。

408
00:19:51,790 --> 00:19:56,380
And it turns out the format code for that, using printf, is %p.
事实证明，使用 printf 的格式代码是 %p。

409
00:19:56,380 --> 00:20:00,130
And if I want to print out now the address of n,
如果我现在想打印 n 的地址，

410
00:20:00,130 --> 00:20:02,950
recall that I have these two new capabilities, the first of which
请记住，我有这两种新功能，第一个是

411
00:20:02,950 --> 00:20:03,670
is germane.
相关的。

412
00:20:03,670 --> 00:20:07,120
The ampersand will get me the address of n.
与符号将获取 n 的地址。

413
00:20:07,120 --> 00:20:09,970
So let me go back now to VS Code, and let me make a change,
所以现在让我回到 VS Code，让我做一个改变，

414
00:20:09,970 --> 00:20:13,150
whereby I'm going to change the %i to %p,
我将把 %i 更改为 %p，

415
00:20:13,150 --> 00:20:16,720
which is going to show me an address, as opposed to an integer, per se.
这将显示地址，而不是整数本身。

416
00:20:16,720 --> 00:20:20,960
But I need to tell printf what address to show, so I don't want to print out n
但我需要告诉 printf 要显示哪个地址，所以我不想打印 n

417
00:20:20,960 --> 00:20:22,700
because that's literally the number 50.
因为那确实是数字 50。

418
00:20:22,700 --> 00:20:26,640
I want to print out the address of n, like, where is it in memory.
我想打印 n 的地址，比如，它在内存中的哪个位置。

419
00:20:26,640 --> 00:20:28,940
So here I prefix it with an ampersand.
所以这里我在它前面加一个与符号。

420
00:20:28,940 --> 00:20:32,990
And now if I go back into my terminal window, make addresses again,
现在如果我回到我的终端窗口，再次运行 addresses，

421
00:20:32,990 --> 00:20:34,520
dot slash addresses.
点斜杠 addresses。

422
00:20:34,520 --> 00:20:37,953
I'm not going to get as lucky as seeing OX123, probably,
我可能不会像看到 OX123 那样幸运，

423
00:20:37,953 --> 00:20:40,370
because I got even more memory than that in this computer.
因为我的这台电脑有比那更多的内存。

424
00:20:40,370 --> 00:20:44,300
But when I hit enter, I do indeed see OX something.
但当我按下回车键时，我确实看到了 OX 什么东西。

425
00:20:44,300 --> 00:20:46,940
And if I zoom in here, enhance, if you will,
如果我放大这里，增强，如果你愿意的话，

426
00:20:46,940 --> 00:20:51,090
it happens to be at this moment in time, on this server, OX7FFC3A7CFFBC.
它恰好是在这个时刻，在这个服务器上，OX7FFC3A7CFFBC。

427
00:20:54,980 --> 00:20:56,180
So it's a big address.
所以这是一个很大的地址。

428
00:20:56,180 --> 00:20:59,030
That's a really big number if we actually did all of the math.
如果我们真的把所有的数学计算都做一遍，那将是一个非常大的数字。

429
00:20:59,030 --> 00:21:00,290
But who really cares?
但谁在乎呢？

430
00:21:00,290 --> 00:21:04,430
Just the fact that it exists somewhere is the only point for now.
现在唯一重要的是，它确实存在于某个地方。

431
00:21:04,430 --> 00:21:10,670
So this %p symbol that we're passing into printf as a format code is
所以我们传递给 printf 的这个 %p 符号作为格式代码是

432
00:21:10,670 --> 00:21:15,350
leveraging the fact that C supports what are known as pointers.
利用了 C 支持所谓指针这一事实。

433
00:21:15,350 --> 00:21:20,000
So a pointer is really just an address, the address of some variable
所以指针实际上只是一个地址，某个变量的地址

434
00:21:20,000 --> 00:21:24,840
that you can even store in another variable called itself a pointer.
你甚至可以把它存储在另一个名为指针的变量中。

435
00:21:24,840 --> 00:21:26,130
So what do I mean by this?
我指的是什么？

436
00:21:26,130 --> 00:21:29,750
Well, if a pointer is an address, we can start to tinker with this same idea
好吧，如果指针是一个地址，我们可以开始使用同一个想法

437
00:21:29,750 --> 00:21:30,390
as follows.
如下所示。

438
00:21:30,390 --> 00:21:33,590
Let me actually go back to VS Code once more
让我回到 VS Code 这里

439
00:21:33,590 --> 00:21:35,940
and play around with syntax like this.
并尝试使用这样的语法。

440
00:21:35,940 --> 00:21:39,890
So let me still declare a variable called n and set it equal to 50.
所以让我声明一个名为 n 的变量，并将其设置为 50。

441
00:21:39,890 --> 00:21:43,010
But let's actually create an actual pointer,
但让我们实际创建一个真正的指针，

442
00:21:43,010 --> 00:21:47,000
a variable whose purpose in life is not to store a boring number like 50,
一个变量，它的作用不是存储像 50 这样的无聊数字，

443
00:21:47,000 --> 00:21:49,380
but the address of some value.
而是存储某个值的地址。

444
00:21:49,380 --> 00:21:51,920
And so the syntax for that is admittedly weird.
所以它的语法不可否认很奇怪。

445
00:21:51,920 --> 00:21:55,850
If you want p to be a pointer, a variable that stores an address,
如果你希望 p 是一个指针，一个存储地址的变量，

446
00:21:55,850 --> 00:21:59,838
you literally say int star for reasons we'll sort of see.
你会说 int star，原因我们稍后会看到。

447
00:21:59,838 --> 00:22:02,630
And this is different from the star I mentioned earlier for reasons
这与我之前提到的星号不同，原因

448
00:22:02,630 --> 00:22:03,530
we'll also see soon.
我们很快也会看到。

449
00:22:03,530 --> 00:22:06,710
But int star p means, hey compiler, give me
但 int star p 意味着，嘿，编译器，给我

450
00:22:06,710 --> 00:22:12,262
a variable called p, inside of which I can store the address of an integer.
一个名为 p 的变量，我可以在里面存储一个整数的地址。

451
00:22:12,262 --> 00:22:13,970
What address do you want to put in there?
你想把什么地址放进去？

452
00:22:13,970 --> 00:22:16,640
Well, now I can borrow that same syntax from a moment ago.
好吧，现在我可以借用刚才的语法。

453
00:22:16,640 --> 00:22:19,970
I can use ampersand n, which is going to say, hey compiler, give me-- or hey
我可以使用与符号 n，它将说，嘿，编译器，给我——或者嘿

454
00:22:19,970 --> 00:22:23,690
computer, give me the address of n itself.
电脑，给我 n 本身的地址。

455
00:22:23,690 --> 00:22:25,580
Previously, I didn't bother with a variable.
之前，我并没有考虑使用变量。

456
00:22:25,580 --> 00:22:28,760
I just sent the address of n into printf directly.
我只是直接把 n 的地址发送到 printf。

457
00:22:28,760 --> 00:22:30,660
But I can now play with it as follows.
但我现在可以这样玩。

458
00:22:30,660 --> 00:22:32,240
Let me go back to VS Code here.
让我回到 VS Code 这里。

459
00:22:32,240 --> 00:22:33,770
I'll clear my terminal window.
我会清除我的终端窗口。

460
00:22:33,770 --> 00:22:36,510
And let's just play around with two variables.
让我们用两个变量玩一下。

461
00:22:36,510 --> 00:22:41,060
So int star p-- so it's an asterisk, but most people would say star--
所以 int star p——它是一个星号，但大多数人会说 star——

462
00:22:41,060 --> 00:22:43,760
equals the address of n.
等于 n 的地址。

463
00:22:43,760 --> 00:22:47,270
And now, I can just tweak line seven ever so slightly.
现在，我可以稍微调整一下第七行。

464
00:22:47,270 --> 00:22:50,780
Instead of printing out in duplicate ampersand n,
而不是重复打印与符号 n，

465
00:22:50,780 --> 00:22:53,630
I can literally just pass in p for pointer.
我实际上可以直接传递 p 来作为指针。

466
00:22:53,630 --> 00:22:56,930
So I've not done anything really that interesting, other than add a variable,
所以我并没有做任何真正有趣的事情，除了添加一个变量，

467
00:22:56,930 --> 00:22:58,940
but just to show you the syntax via which
但只是为了向你展示语法，通过它

468
00:22:58,940 --> 00:23:01,400
you can create a variable whose purpose in life
你可以创建一个变量，它的作用是

469
00:23:01,400 --> 00:23:03,170
is to store one of these addresses.
存储这些地址之一。

470
00:23:03,170 --> 00:23:08,180
So let me go ahead and now and do make addresses once more.
所以现在让我继续运行 addresses。

471
00:23:08,180 --> 00:23:09,320
Dot slash addresses.
点斜杠 addresses。

472
00:23:09,320 --> 00:23:13,760
And we should see, indeed, pretty much the same idea, the address
我们应该会看到，确实，几乎相同的概念，地址

473
00:23:13,760 --> 00:23:19,850
at which n happens to be, now that I've recompiled and actually run my code.
n 恰好位于那里，因为我已经重新编译并实际运行了我的代码。

474
00:23:19,850 --> 00:23:22,550
But it gets a little more interesting than that.
但它比这更有趣。

475
00:23:22,550 --> 00:23:26,000
I can do one more thing when it comes to my computer's memory.
在涉及到我的计算机内存时，我可以做一件事情。

476
00:23:26,000 --> 00:23:29,840
In VS Code here, let me clear my terminal again, and let me see
在 VS Code 这里，让我再次清除我的终端，让我看看

477
00:23:29,840 --> 00:23:32,840
if I can perhaps reverse this process.
我是否可以反转这个过程。

478
00:23:32,840 --> 00:23:38,120
If n is 50, and p is storing the address of n,
如果 n 是 50，而 p 存储着 n 的地址，
```

479
00:23:38,120 --> 00:23:43,880
wouldn't it be interesting if I could somehow express, go to the address of n
如果我能以某种方式表达，去到 n 的地址，那不是很有趣吗？

480
00:23:43,880 --> 00:23:45,500
and tell me what is there.
并告诉我那里有什么。

481
00:23:45,500 --> 00:23:48,770
So to do that, I'm just kind of undoing all of the intellectual work
为了做到这一点，我正在撤销所有智力工作

482
00:23:48,770 --> 00:23:49,470
I'm doing here.
我在这里做。

483
00:23:49,470 --> 00:23:53,480
But if I want to print out an integer at some location, I can go back to %i,
但如果我想在某个位置打印一个整数，我可以回到 %i，

484
00:23:53,480 --> 00:23:55,400
just print an integer as always.
像往常一样打印一个整数。

485
00:23:55,400 --> 00:23:58,670
But p now is storing the address of someplace.
但 p 现在存储的是某个地方的地址。

486
00:23:58,670 --> 00:24:00,600
It is the treasure map, so to speak.
它可以算是藏宝图。

487
00:24:00,600 --> 00:24:02,840
So if I want to go where X marks the spot,
所以，如果我想去到 X 标注的地方，

488
00:24:02,840 --> 00:24:07,490
the syntax for that I claimed a moment ago is star p.
我刚才说过的语法是 star p。

489
00:24:07,490 --> 00:24:09,980
So star p means go to that address.
所以 star p 的意思是去到那个地址。

490
00:24:09,980 --> 00:24:12,230
Don't print the address, go to that address,
不要打印地址，去到那个地址，

491
00:24:12,230 --> 00:24:15,450
and show me what's inside of the computer's memory there.
并向我展示那里计算机内存中的内容。

492
00:24:15,450 --> 00:24:18,410
So now, if I go into my terminal and do make addresses,
所以现在，如果我进入我的终端并执行 make addresses，

493
00:24:18,410 --> 00:24:22,580
and do dot slash addresses, what should I see on the screen when I hit enter?
并执行 dot slash addresses，当我按回车键时，我应该在屏幕上看到什么？

494
00:24:22,580 --> 00:24:23,630
50.
50。

495
00:24:23,630 --> 00:24:26,060
So I indeed see now 50.
所以我现在确实看到了 50。

496
00:24:26,060 --> 00:24:29,600
Now, here's where it's an unfortunate choice of syntax
现在，这里 C 语言作者几十年前选择了一个不太好的语法

497
00:24:29,600 --> 00:24:32,120
from the authors of C decades ago.
从几十年前的 C 语言作者那里。

498
00:24:32,120 --> 00:24:34,713
Clearly, I'm using star in two different locations.
很明显，我在两个不同的位置使用了 star。

499
00:24:34,713 --> 00:24:37,130
And suffice it to say, it doesn't represent multiplication
可以这么说，它不代表乘法

500
00:24:37,130 --> 00:24:37,880
in either of them.
在任何一个中都不代表。

501
00:24:37,880 --> 00:24:40,190
It's being used to represent addresses somehow.
它被用来以某种方式表示地址。

502
00:24:40,190 --> 00:24:44,750
When, on line six, I specify a data type like int,
当在第六行，我指定一个数据类型，例如 int，

503
00:24:44,750 --> 00:24:47,330
and then I have a star, and then the name of a variable,
然后我有一个星号，然后是一个变量的名称，

504
00:24:47,330 --> 00:24:51,470
that is the syntax for declaring a pointer, for declaring
这就是声明指针的语法，用于声明

505
00:24:51,470 --> 00:24:53,690
a variable that will store an address.
一个将存储地址的变量。

506
00:24:53,690 --> 00:24:54,530
What address?
什么地址？

507
00:24:54,530 --> 00:24:57,440
Well, ampersand n, whatever that is, OX something.
嗯，ampersand n，无论它是什么，OX 等等。

508
00:24:57,440 --> 00:25:03,590
When you do a star and then the name of a pointer without specifying a type,
当你使用星号，然后是指针的名称，而没有指定类型时，

509
00:25:03,590 --> 00:25:05,670
this just means, go there.
这仅仅意味着，去到那里。

510
00:25:05,670 --> 00:25:09,530
So the star clearly is related to addresses.
所以，星号明显与地址相关。

511
00:25:09,530 --> 00:25:11,322
It's unfortunate that it's the same symbol.
不幸的是，它使用的是同一个符号。

512
00:25:11,322 --> 00:25:13,947
It would have been nice if they picked maybe a different symbol
如果他们能选择一个不同的符号

513
00:25:13,947 --> 00:25:14,660
of punctuation.
标点符号就好了。

514
00:25:14,660 --> 00:25:17,090
But they mean slightly different things in that context.
但在那个语境中，它们的意思略有不同。

515
00:25:17,090 --> 00:25:19,460
On line six, we're declaring the pointer,
在第六行，我们正在声明指针，

516
00:25:19,460 --> 00:25:23,910
declaring a variable called p that's going to point to an integers location.
声明一个名为 p 的变量，它将指向一个整数的位置。

517
00:25:23,910 --> 00:25:28,230
But when I say star p, that means go to that actual location.
但当我使用 star p 时，意味着去到实际位置。

518
00:25:28,230 --> 00:25:32,430
So just try to keep that in mind, even though it's ever so slightly subtly
所以，请牢记这一点，即使它非常细微

519
00:25:32,430 --> 00:25:33,070
different.
不同。

520
00:25:33,070 --> 00:25:36,060
So what's going on then inside of the computer's actual memory?
那么，计算机实际内存中发生了什么呢？

521
00:25:36,060 --> 00:25:38,320
Well, let's consider that in pictorial form again.
嗯，让我们再次用图像形式来考虑一下。

522
00:25:38,320 --> 00:25:41,370
So even though I've written the pointer in this way,
所以，即使我用这种方式写了指针，

523
00:25:41,370 --> 00:25:45,740
int then a space, then star p equals ampersand n semicolon, that
int，然后一个空格，然后是 star p 等于 ampersand n 分号，

524
00:25:45,740 --> 00:25:46,740
is the conventional way.
这是传统方式。

525
00:25:46,740 --> 00:25:49,157
That's how you'll see it on most websites, most textbooks.
你将在大多数网站和教科书中看到这种方式。

526
00:25:49,157 --> 00:25:51,990
Technically speaking, I will admit that it might actually
从技术角度来说，我承认，它实际上可能

527
00:25:51,990 --> 00:25:54,630
be easier to understand if you actually move
更容易理解，如果你实际上移动

528
00:25:54,630 --> 00:25:57,990
the asterisk a little to the left, because this makes, visually,
星号稍微向左一点，因为这样从视觉上看，

529
00:25:57,990 --> 00:26:03,570
I think, it even more clear that int star is the type of the variable p, as
我认为，它更加清楚地表明 int star 是变量 p 的类型，

530
00:26:03,570 --> 00:26:06,970
opposed to the star being somehow attached to the variable name itself.
而不是星号以某种方式与变量名本身相关联。

531
00:26:06,970 --> 00:26:10,050
However, you might also see it written with a space on either side, which
然而，你也可以看到它在两边都写着空格，这

532
00:26:10,050 --> 00:26:11,467
I don't think really helps anyone.
我认为对任何人都没有帮助。

533
00:26:11,467 --> 00:26:14,640
But the point is that white space does not matter in this context.
但关键是，在这种情况下空格并不重要。

534
00:26:14,640 --> 00:26:17,880
And the conventional way is to do it by prefixing
传统的方式是，在变量名前面添加

535
00:26:17,880 --> 00:26:19,320
the variable's name with the star.
星号。

536
00:26:19,320 --> 00:26:21,390
And this avoids getting into trouble when you
这样可以避免你在

537
00:26:21,390 --> 00:26:23,470
declare multiple variables at a time.
一次声明多个变量时遇到麻烦。

538
00:26:23,470 --> 00:26:26,970
But if it helps you to think about it, you can think of it as int star
但如果你觉得这样做有帮助，你可以把它看作 int star

539
00:26:26,970 --> 00:26:28,410
as being the type.
作为类型。

540
00:26:28,410 --> 00:26:30,970
It's not just an int, per se.
它不只是一个 int，本身。

541
00:26:30,970 --> 00:26:34,890
So with that said, let's consider now the canvas of computer's memory inside
所以，有了这些，让我们现在考虑一下计算机内存的画布，在

542
00:26:34,890 --> 00:26:36,930
of which we're storing n, and now, p.
其中我们存储了 n，以及现在的 p。

543
00:26:36,930 --> 00:26:39,840
So previously, I proposed that n is maybe, yeah,
所以，之前我提出 n 可能，是的，

544
00:26:39,840 --> 00:26:42,670
maybe it's done in the bottom right hand corner of the screen.
可能它在屏幕的右下角。

545
00:26:42,670 --> 00:26:45,660
So n is storing the number 50 here.
所以，n 这里存储了数字 50。

546
00:26:45,660 --> 00:26:47,460
But technically, n lives somewhere.
但从技术上说，n 存在于某个地方。

547
00:26:47,460 --> 00:26:51,720
And for simplicity, I'm going to claim it's at OX123, rather than the bigger
为了简单起见，我将声称它位于 OX123，而不是我们之前看到的更大的

548
00:26:51,720 --> 00:26:53,290
actual address we just saw.
实际地址。

549
00:26:53,290 --> 00:26:54,660
But what about p?
但 p 呢？

550
00:26:54,660 --> 00:26:58,530
Well, p itself is another variable that I declared separately,
嗯，p 本身是另一个我单独声明的变量，

551
00:26:58,530 --> 00:27:01,090
so it's got to live somewhere in the computer's memory.
所以它必须存在于计算机的内存中的某个地方。

552
00:27:01,090 --> 00:27:05,460
And it turns out, by convention, pointers take up more space.
事实证明，根据惯例，指针占用更多空间。

553
00:27:05,460 --> 00:27:09,150
They typically use eight bytes nowadays, rather than just four.
现在它们通常使用 8 个字节，而不是只有 4 个。

554
00:27:09,150 --> 00:27:09,720
Why is that?
为什么呢？

555
00:27:09,720 --> 00:27:11,910
Well, if you've got eight bytes, you can count even higher.
嗯，如果你有 8 个字节，你可以数到更高的数字。

556
00:27:11,910 --> 00:27:13,050
You can have even more addresses.
你可以拥有更多的地址。

557
00:27:13,050 --> 00:27:15,660
You can have more memory in your Mac, your PC, and phone.
你的 Mac、PC 和手机可以有更多的内存。

558
00:27:15,660 --> 00:27:16,630
That's a good thing.
这是一件好事。

559
00:27:16,630 --> 00:27:18,870
So pointers tend to be eight bytes, which
所以，指针往往是 8 个字节，

560
00:27:18,870 --> 00:27:21,900
is why I've used eight squares on the screen here.
这就是我在这里在屏幕上使用 8 个方格的原因。

561
00:27:21,900 --> 00:27:25,050
But what is actually p storing?
但 p 实际上存储的是什么？

562
00:27:25,050 --> 00:27:27,300
Well, it's just storing a number.
嗯，它只是存储了一个数字。

563
00:27:27,300 --> 00:27:29,610
Yes, it's technically an integer, but that integer
是的，从技术上讲它是一个整数，但那个整数

564
00:27:29,610 --> 00:27:34,900
is itself should be thought of as the address of some other value.
本身应该被认为是另一个值的地址。

565
00:27:34,900 --> 00:27:39,380
So n is down here at OX123. p is up here at who knows what address.
所以 n 在这里，位于 OX123。p 在那里，谁知道是什么地址。

566
00:27:39,380 --> 00:27:41,130
Doesn't matter for the sake of discussion,
为了讨论方便，

567
00:27:41,130 --> 00:27:46,050
but its value, what it's storing with its pattern of 64 bits
但它的值，它用 64 位的模式存储的内容

568
00:27:46,050 --> 00:27:49,200
is apparently OX123.
显然是 OX123。

569
00:27:49,200 --> 00:27:51,070
So how does this help us?
所以，这如何帮助我们呢？

570
00:27:51,070 --> 00:27:54,032
Well, if you think about this a little more abstractly, who
嗯，如果你抽象地想一想，谁

571
00:27:54,032 --> 00:27:56,490
cares about what else is going on in the computer's memory?
会关心计算机内存中其他发生了什么？

572
00:27:56,490 --> 00:27:59,317
It actually tends to be helpful to think about this pictorially
实际上，以图像形式思考这一点往往很有帮助

573
00:27:59,317 --> 00:28:00,900
as being a little something like this.
就像这样。

574
00:28:00,900 --> 00:28:02,700
At the end of the day, you and I, even when
最终，你和我，即使当

575
00:28:02,700 --> 00:28:05,760
we start writing code in C that uses pointers,
我们开始用 C 语言编写使用指针的代码时，


576
00:28:05,760 --> 00:28:09,270
generally, you and I are never going to care about the actual addresses.
通常情况下，你和我永远不会关心实际地址。

577
00:28:09,270 --> 00:28:12,000
Even though I showed you OX7 something, that's
即使我给你展示了OX7的某些东西，那也是

578
00:28:12,000 --> 00:28:13,930
not generally useful information.
通常无用的信息。

579
00:28:13,930 --> 00:28:16,500
It's suffices to know that it exists somewhere,
只要知道它存在于某个地方就够了，

580
00:28:16,500 --> 00:28:19,030
and let the computer figure out how to get there.
让计算机想办法找到它。

581
00:28:19,030 --> 00:28:22,980
And so very often when talking about pointers and addresses more generally,
因此，在谈论指针和地址时，

582
00:28:22,980 --> 00:28:25,275
people actually abstract them away, so to speak.
人们实际上会抽象掉它们，可以说是这样。

583
00:28:25,275 --> 00:28:27,150
So instead of literally writing on the screen
所以，与其在屏幕上直接写

584
00:28:27,150 --> 00:28:30,990
or the whiteboard when discussing this, OX123, what the actual address is,
或在讨论时写白板，OX123，实际地址是什么，

585
00:28:30,990 --> 00:28:32,130
who cares what it is?
谁在乎它是什么？

586
00:28:32,130 --> 00:28:36,630
It suffices that it's a value that leads me to the other value
只要它是一个能带我找到另一个值的变量就够了，

587
00:28:36,630 --> 00:28:41,320
that I care about, sort of the treasure map, as I described it earlier.
我关心的值，就像我之前描述的那样，就像藏宝图。

588
00:28:41,320 --> 00:28:45,360
So let's now connect this maybe a little more metaphorically.
现在让我们更形象地连接一下。

589
00:28:45,360 --> 00:28:47,220
So Carter, maybe here you might have noticed
卡特，也许你可能已经注意到

590
00:28:47,220 --> 00:28:50,670
that we've had for a while now these two mailboxes on the stage.
我们现在在舞台上已经有了这两个邮箱一段时间了。

591
00:28:50,670 --> 00:28:55,590
So this white one here is labeled p to represent our pointer variable.
这个白色的邮箱上标着p，代表我们的指针变量。

592
00:28:55,590 --> 00:28:59,490
Carter's is labeled n, representing our actual integer.
卡特的是标着n，代表我们的实际整数。

593
00:28:59,490 --> 00:29:01,350
And what's really kind of going on here is
实际上发生的事情是

594
00:29:01,350 --> 00:29:06,450
that, if I were to access the value inside of p,
如果我要访问p内部的值，

595
00:29:06,450 --> 00:29:10,950
much like we saw it up here, that's like opening this up and figuring out
就像我们在上面看到的，就像打开它，弄清楚

596
00:29:10,950 --> 00:29:12,300
what the actual value is.
实际值是什么。

597
00:29:12,300 --> 00:29:13,870
Now, this itself is a little arcane.
现在，这本身有点神秘。

598
00:29:13,870 --> 00:29:14,790
OX123.
OX123。

599
00:29:14,790 --> 00:29:17,370
And so if we actually do this a little more metaphorically,
因此，如果我们用更形象的方式来做这件事，

600
00:29:17,370 --> 00:29:24,690
we can maybe do this and point our way, if you don't mind.
我们可以这样做，并指向我们的方向，如果你不介意。

601
00:29:24,690 --> 00:29:30,082
So here we have a big pointer.
所以这里有一个大的指针。

602
00:29:30,082 --> 00:29:31,137
Oh, forgive me.
哦，原谅我。

603
00:29:31,137 --> 00:29:32,470
I guess we'll use this one here.
我想我们会用这个。

604
00:29:32,470 --> 00:29:33,100
OK.
好的。

605
00:29:33,100 --> 00:29:36,490
So we have this big pointer that's essentially
所以我们有一个大的指针，它本质上

606
00:29:36,490 --> 00:29:39,460
pointing at the location in memory that we care about, be it OX123,
指向我们关心的内存位置，无论是OX123，

607
00:29:39,460 --> 00:29:40,210
or something else.
还是其他东西。

608
00:29:40,210 --> 00:29:43,120
And then if we dereference this, that is, use the star notation,
然后，如果我们解引用它，也就是说，使用星号符号，

609
00:29:43,120 --> 00:29:46,870
star p, that's like asking Carter to go to that location,
星号p，就像让卡特去那个位置，

610
00:29:46,870 --> 00:29:48,850
open up the mailbox, and voila.
打开邮箱，瞧。

611
00:29:48,850 --> 00:29:50,620
What value do you have there?
你那里有什么值？

612
00:29:50,620 --> 00:29:51,250
Voila.
瞧。

613
00:29:51,250 --> 00:29:53,950
Maybe a big round of applause for Carter for having
也许我们可以为卡特鼓掌，因为他

614
00:29:53,950 --> 00:29:57,670
practiced this beforehand with me.
事先和我练习过。

615
00:29:57,670 --> 00:29:58,318
All right.
好的。

616
00:29:58,318 --> 00:30:00,860
That was mostly just an excuse to use the foam fingers today.
这主要只是今天用泡沫手指的借口。

617
00:30:00,860 --> 00:30:03,580
But with that said, that's hopefully a helpful metaphor,
但话说回来，这希望能成为一个有用的比喻，

618
00:30:03,580 --> 00:30:06,820
honestly, because these pointers, these addresses actually
说实话，因为这些指针，这些地址实际上

619
00:30:06,820 --> 00:30:08,828
tend to be among the more arcane topics in C
往往是C语言中比较神秘的主题之一，

620
00:30:08,828 --> 00:30:11,620
that, even if things are kind of clicking right now, as soon as you
即使现在一切都很好，一旦你

621
00:30:11,620 --> 00:30:13,780
start writing code involving addresses, it's
开始编写涉及地址的代码，这

622
00:30:13,780 --> 00:30:16,090
easy to get lost in some of the details.
很容易迷失在一些细节中。

623
00:30:16,090 --> 00:30:18,220
But metaphorically, these mailboxes are meant
但从比喻的角度来看，这些邮箱代表的其实是

624
00:30:18,220 --> 00:30:20,110
to represent, really, what's going on.
实际发生的事情。

625
00:30:20,110 --> 00:30:22,990
Mailboxes in the physical human world have addresses.
现实世界中的邮箱都有地址。

626
00:30:22,990 --> 00:30:26,710
I can go to that address, open it up, and then I can go to another address
我可以去那个地址，打开它，然后我可以去另一个地址

627
00:30:26,710 --> 00:30:30,230
by following that treasure map, if you will, or pictorially here,
通过跟随那张藏宝图，如果你愿意，或者在这里的图片中，

628
00:30:30,230 --> 00:30:33,840
the arrow that's pointing from one location to another.
指向从一个位置到另一个位置的箭头。

629
00:30:33,840 --> 00:30:36,890
So even though it's very weird syntax with ampersands, and asterisks,
所以，即使它使用符号、星号等，语法非常奇怪，

630
00:30:36,890 --> 00:30:39,920
and the like, it's just addresses in memory,
等等，它只是内存中的地址，

631
00:30:39,920 --> 00:30:42,780
much like mailboxes in the real world.
就像现实世界中的邮箱一样。

632
00:30:42,780 --> 00:30:46,940
So with that said, let's maybe begin to take off certain training
也就是说，我们现在开始重新学习一下字符串，

633
00:30:46,940 --> 00:30:51,030
wheels by revisiting what strings are, as we've been using them thus far.
就像我们一直在使用的那样。

634
00:30:51,030 --> 00:30:55,100
So here's a line of code in C that we've been using since week one,
这是一行C语言代码，我们从第一周就开始使用它了，

635
00:30:55,100 --> 00:30:59,210
really, where I declare a string variable called s, and set it equal to,
实际上，我声明了一个叫做s的字符串变量，并将它设置为等于，

636
00:30:59,210 --> 00:31:00,500
quote unquote, hi.
引号引起来，“hi”。

637
00:31:00,500 --> 00:31:05,240
Now, technically "hi" is three letters, or two letters in a punctuation symbol.
现在，从技术上讲，“hi”是三个字母，或者说是两个字母加一个标点符号。

638
00:31:05,240 --> 00:31:10,130
But how many bytes is that string taking up?
但是这个字符串占用了多少字节？

639
00:31:10,130 --> 00:31:13,268
Is it one, two, three, or was it--
是一个、两个、三个，还是说——

640
00:31:13,268 --> 00:31:14,060
I'm seeing it here.
我在这里看到了。

641
00:31:14,060 --> 00:31:14,510
It's four.
是四个。

642
00:31:14,510 --> 00:31:15,010
Why?
为什么？

643
00:31:17,440 --> 00:31:20,660
Yeah, there's always a null character that, even though you don't see it
是的，始终有一个空字符，即使你没有看到它

644
00:31:20,660 --> 00:31:25,440
on the screen, that is what terminates every string, we claimed, a while back.
在屏幕上，这就是我们之前声称的，结束每个字符串的东西。

645
00:31:25,440 --> 00:31:27,368
So if I were to draw this maybe "hi" ends up
所以，如果我要画出这个，也许“hi”最终会

646
00:31:27,368 --> 00:31:29,910
in the computer's memory down here, bottom right hand corner.
出现在计算机的内存中，在右下角。

647
00:31:29,910 --> 00:31:32,270
But it is indeed four bytes, not just three
但实际上是四个字节，不仅仅是三个

648
00:31:32,270 --> 00:31:35,060
because, secretly, there's always been that null character,
因为，秘密地，始终存在那个空字符，

649
00:31:35,060 --> 00:31:36,950
even though we as programmers don't often
即使我们作为程序员并不经常

650
00:31:36,950 --> 00:31:38,630
have to type it explicitly ourselves.
必须自己显式地输入它。

651
00:31:38,630 --> 00:31:40,500
That's what the double quotes do for us.
这就是双引号为我们做的。

652
00:31:40,500 --> 00:31:42,770
It terminates the string with that null character.
它用空字符结束字符串。

653
00:31:42,770 --> 00:31:46,190
Now, recall from week two when we talked about arrays,
现在，回想一下第二周我们谈论数组的时候，

654
00:31:46,190 --> 00:31:48,710
we started playing around with strings as really
我们开始把字符串视为真正的

655
00:31:48,710 --> 00:31:50,340
just being arrays of characters.
字符数组。

656
00:31:50,340 --> 00:31:53,840
So we call them a string, but we could treat them as arrays of char,
所以我们称它们为字符串，但我们可以把它们视为字符数组，

657
00:31:53,840 --> 00:31:54,720
so to speak.
可以说是这样。

658
00:31:54,720 --> 00:31:58,670
So if the string was called s, s bracket zero would give us the first char,
所以，如果字符串被称为s，s方括号0会给我们第一个字符，

659
00:31:58,670 --> 00:32:00,900
s bracket one the second, s bracket two the third.
s方括号1是第二个，s方括号2是第三个。

660
00:32:00,900 --> 00:32:03,410
And if you're really curious, s bracket three
如果你真的好奇，s方括号3

661
00:32:03,410 --> 00:32:05,730
would give you the last hidden null character,
会给你最后一个隐藏的空字符，

662
00:32:05,730 --> 00:32:08,150
which we saw on the screen as just a zero
我们在屏幕上看到的就是一个零

663
00:32:08,150 --> 00:32:11,450
when we printed it out, while tinkering with some actual code.
当我们在调试一些实际代码时，打印它出来。

664
00:32:11,450 --> 00:32:14,390
But technically, today, logically, it would
但从技术上讲，今天，逻辑上，它会

665
00:32:14,390 --> 00:32:17,300
seem that it's also true that H-I exclamation
看起来它也确实如此，H-I感叹号

666
00:32:17,300 --> 00:32:20,570
point and the null character must clearly live at some address.
点和空字符必须存在于某个地址。

667
00:32:20,570 --> 00:32:23,940
They must clearly live in their own mailbox, so to speak.
他们必须存在于自己的邮箱中，可以说是这样。

668
00:32:23,940 --> 00:32:28,610
So maybe, for the sake of discussion, this H today is at OX123.
所以，为了讨论起见，今天的H可能在OX123。

669
00:32:28,610 --> 00:32:33,840
But recall that arrays are characterized by contiguousness from left to right.
但请记住，数组的特点是从左到右连续。

670
00:32:33,840 --> 00:32:41,600
So if H is at OX123, it must be the case that I is at OX124, I is at 125,
所以，如果H在OX123，那么I一定在OX124，I在125，




671
00:32:41,600 --> 00:32:46,917
and the null character is at OX126 because those are one byte apart.
而空字符在 OX126 处，因为它们之间相差一个字节。

672
00:32:46,917 --> 00:32:48,750
And I deliberately chose numbers here where,
我特意在这里选择了数字，

673
00:32:48,750 --> 00:32:51,090
whether it's decimal or hexadecimal, it doesn't matter.
无论是十进制还是十六进制，都没有关系。

674
00:32:51,090 --> 00:32:53,970
These differ by just one byte themselves.
它们本身只相差一个字节。

675
00:32:53,970 --> 00:32:55,760
So that's what implies that they're indeed
所以这意味着它们确实是

676
00:32:55,760 --> 00:32:57,740
adjacent, or contiguous in memory.
相邻的，或者在内存中是连续的。

677
00:32:57,740 --> 00:32:59,000
But what is s then?
那么 s 是什么呢？

678
00:32:59,000 --> 00:33:02,540
When I declared s to be a string, what is
当我声明 s 是一个字符串时，是什么

679
00:33:02,540 --> 00:33:04,640
it that's been going in s all of this time
一直都在 s 里面呢？

680
00:33:04,640 --> 00:33:08,090
if, clearly, s is actually this thing here?
如果，很明显，s 实际上就是这里的东西呢？

681
00:33:08,090 --> 00:33:11,060
Well, strings have kind of been a white lie for a few weeks
好吧，字符串在过去几周里一直都是一个善意的谎言

682
00:33:11,060 --> 00:33:16,130
because s itself, technically, is a pointer.
因为 s 本身，从技术上来说，是一个指针。

683
00:33:16,130 --> 00:33:18,720
s is the address of this string.
s 是这个字符串的地址。

684
00:33:18,720 --> 00:33:20,810
So the string is somewhere in memory, but s
所以这个字符串在内存中的某个地方，但是 s

685
00:33:20,810 --> 00:33:23,870
itself is a separate variable that gives you
本身是一个独立的变量，它给你

686
00:33:23,870 --> 00:33:26,820
a clue as how to find all of those characters in memory.
一个线索，告诉你如何在内存中找到所有这些字符。

687
00:33:26,820 --> 00:33:28,820
So if you had to guess just intuitively now,
所以如果你现在必须凭直觉猜测，

688
00:33:28,820 --> 00:33:32,270
if this is the string actually in memory, that is, this
如果这是实际存储在内存中的字符串，也就是说，这个

689
00:33:32,270 --> 00:33:35,180
is the array of chars in memory, what would logically
是内存中的字符数组，那么从逻辑上来说，

690
00:33:35,180 --> 00:33:38,702
make sense to put as the value of s?
把什么作为 s 的值是有意义的？

691
00:33:38,702 --> 00:33:39,590
A pointer.
一个指针。

692
00:33:39,590 --> 00:33:40,430
Specifically?
具体来说呢？

693
00:33:43,190 --> 00:33:44,270
A pointer to h.
指向 h 的指针。

694
00:33:44,270 --> 00:33:45,830
And how would I express that?
我该如何表达呢？

695
00:33:45,830 --> 00:33:46,940
What's the actual value?
实际值是什么呢？

696
00:33:46,940 --> 00:33:54,800
OX123 might very well suffice as the value here of s.
OX123 很可能足以作为 s 的值。

697
00:33:54,800 --> 00:33:57,150
Now, why might that be?
现在，为什么可能是这样呢？

698
00:33:57,150 --> 00:33:59,780
Well, that essentially gives you enough information
嗯，这实际上给了你足够的关于

699
00:33:59,780 --> 00:34:03,950
to find the beginning of the string, "hi" in this case.
字符串开头的信息，在这种情况下是 "hi"。

700
00:34:03,950 --> 00:34:05,700
Now, you might think, well, wait a minute.
现在，你可能会想，等等。

701
00:34:05,700 --> 00:34:07,910
How does it know about the second character and the third character?
它怎么知道第二个字符和第三个字符呢？

702
00:34:07,910 --> 00:34:10,327
But now, if you kind of rewind in time, oh, wait a minute,
但是现在，如果你把时间倒流一下，哦，等等，

703
00:34:10,327 --> 00:34:14,420
maybe now the null character actually makes even more sense from week two.
也许现在空字符从第二周开始就更有意义了。

704
00:34:14,420 --> 00:34:15,050
Why?
为什么呢？

705
00:34:15,050 --> 00:34:18,139
Because if s technically storing the location
因为如果 s 从技术上来说存储的是

706
00:34:18,139 --> 00:34:20,420
of the beginning of the string, someone's
字符串开头的地址，那么有人

707
00:34:20,420 --> 00:34:23,330
got to keep track of where the string ends, presumably.
必须追踪字符串的结尾，应该是这样。

708
00:34:23,330 --> 00:34:26,780
And that's effectively the string itself because humans decided decades ago,
而这实际上就是字符串本身，因为人类在几十年前就决定了，

709
00:34:26,780 --> 00:34:29,870
let's just null terminate every string with a special
让我们用一个特殊的空字符来终止每个字符串，

710
00:34:29,870 --> 00:34:35,300
so character, zero, all zero bits, eight zero bits, specifically.
也就是零，所有位都是零，八个零位，具体来说。

711
00:34:35,300 --> 00:34:36,929
But and that's enough information.
但这已经足够的信息了。

712
00:34:36,929 --> 00:34:39,679
The sort of treasure map leads you to the beginning of the string,
这种“藏宝图”可以把你带到字符串的开头，

713
00:34:39,679 --> 00:34:41,719
and then you can use a for loop, a while loop,
然后你可以使用 for 循环、while 循环，

714
00:34:41,719 --> 00:34:44,880
or whatever to walk through the string, and that's what printf does.
或者其他方法来遍历字符串，这就是 printf 的作用。

715
00:34:44,880 --> 00:34:48,690
And you just stop as soon as you see that null character.
一旦你看到空字符，你就停止。

716
00:34:48,690 --> 00:34:52,444
So this then is what a string actually is.
所以，这就是字符串的真实面目。

717
00:34:52,444 --> 00:34:57,440
s is and has always been, since week one, a pointer, so to speak,
s 从第一周开始，一直都是，可以这样说，一个指针，

718
00:34:57,440 --> 00:35:01,710
that actually refers to the start of that array of characters.
它实际上指向字符数组的开头。

719
00:35:01,710 --> 00:35:04,550
And frankly, again, who cares about the OX123 specifics?
坦率地说，我们再次强调，谁在乎 OX123 的具体细节呢？

720
00:35:04,550 --> 00:35:07,550
We can abstract that away and actually just treat
我们可以将其抽象出来，实际上只需将

721
00:35:07,550 --> 00:35:11,690
s as, literally, an arrow that points to the beginning of that string
s 视为，字面意思上，一个指向字符串开头的箭头

722
00:35:11,690 --> 00:35:15,350
because it will be rare that we actually care about where this thing
因为我们很少会真正关心这个东西

723
00:35:15,350 --> 00:35:18,800
physically is in the computer's memory.
在计算机内存中的物理位置。

724
00:35:18,800 --> 00:35:23,390
Now, before we see this in code, any questions on this revelation?
现在，在我们看到代码之前，关于这个揭示有任何问题吗？

725
00:35:23,390 --> 00:35:23,900
Yeah.
是的。

726
00:35:23,900 --> 00:35:27,530
AUDIENCE: Have pointers gotten larger as computer memories
听众：随着几十年来计算机内存的增加，指针也变大了嗎？

727
00:35:27,530 --> 00:35:28,863
have increased over the decades?
在几十年来内存增加的情况下？

728
00:35:28,863 --> 00:35:29,488
SPEAKER 1: Yes.
演讲者 1：是的。

729
00:35:29,488 --> 00:35:32,840
Have pointers gotten larger as computers memory has increased over the decades?
随着几十年来计算机内存的增加，指针也变大了嗎？

730
00:35:32,840 --> 00:35:33,650
Short answer, yes.
简短的回答是，是的。

731
00:35:33,650 --> 00:35:36,530
Like, back in my day, we were limited to, like, two gigabytes
就像，在我那个年代，我们被限制在，大约，两个吉字节

732
00:35:36,530 --> 00:35:37,760
of memory total.
的总内存。

733
00:35:37,760 --> 00:35:38,600
Well, why two?
嗯，为什么是两个呢？

734
00:35:38,600 --> 00:35:42,260
Well, if you had 32-bit memory, or if you use 32 bits
嗯，如果你有 32 位内存，或者如果你使用 32 位

735
00:35:42,260 --> 00:35:45,650
to represent addresses, a.k.a. four bytes, as was conventional,
来表示地址，也就是四个字节，就像传统上那样，

736
00:35:45,650 --> 00:35:48,650
you can count recall as high as 4 billion values.
你可以统计到高达 40 亿个值。

737
00:35:48,650 --> 00:35:52,050
But generally, numbers are both negative and positive, so that halves it.
但通常情况下，数字既有负数也有正数，所以这将它减半。

738
00:35:52,050 --> 00:35:54,890
So the reason decades ago, computers, PCs, Macs
所以几十年前，计算机、PC、Mac

739
00:35:54,890 --> 00:35:58,670
could have no more than two gigabytes of memory was because, literally,
只能拥有不超过两个吉字节的内存，是因为，从字面上来说，

740
00:35:58,670 --> 00:36:01,250
the integers being used, the pointers being used
所使用的整数，所使用的指针

741
00:36:01,250 --> 00:36:03,830
were only four bits, that is 32 bits.
只有四位，也就是 32 位。

742
00:36:03,830 --> 00:36:06,620
Sorry, four bytes, that is, 32 bits long.
抱歉，是四个字节，也就是 32 位长。

743
00:36:06,620 --> 00:36:08,750
And so you literally could buy more memory.
因此，你可以买更多的内存。

744
00:36:08,750 --> 00:36:10,833
You could buy a third gigabyte, a fourth gigabyte,
你可以买第三个吉字节，第四个吉字节，

745
00:36:10,833 --> 00:36:13,280
but you literally had no way mathematically
但你从数学上来说真的没有办法

746
00:36:13,280 --> 00:36:16,530
to express all of those bigger locations.
来表达所有这些更大的位置。

747
00:36:16,530 --> 00:36:18,470
So it was effectively useless, in that case.
所以，在这种情况下，它实际上是无用的。

748
00:36:18,470 --> 00:36:21,680
In more modern times, computers tend now to use 64 bits, which
在更现代的时代，计算机现在倾向于使用 64 位，这

749
00:36:21,680 --> 00:36:23,220
allows you to count crazy high.
允许你统计到非常高的数字。

750
00:36:23,220 --> 00:36:27,140
And that's more than enough to address bigger chunks of memory.
而且这足以处理更大的内存块。

751
00:36:27,140 --> 00:36:28,100
Really good question.
真是个好问题。

752
00:36:28,100 --> 00:36:32,257
Others on memory thus far.
关于内存还有什么问题？

753
00:36:32,257 --> 00:36:32,840
No, all right.
没有，好的。

754
00:36:32,840 --> 00:36:36,810
Well, let's translate this a bit to code by going back over to VS Code here.
好吧，让我们通过回到 VS Code 来将这段内容翻译成代码。

755
00:36:36,810 --> 00:36:41,390
And let me propose now that we revisit maybe a simpler string
现在，我建议我们重新审视一下更简单的字符串

756
00:36:41,390 --> 00:36:43,110
example, as opposed to these integers.
示例，而不是这些整数。

757
00:36:43,110 --> 00:36:46,430
So let me go ahead and throw away all of this integer related code.
所以，让我继续把所有这些与整数相关的代码都扔掉。

758
00:36:46,430 --> 00:36:49,910
Let me go ahead and, for the moment, include CS50.h
让我继续，暂时，包含 CS50.h

759
00:36:49,910 --> 00:36:53,030
so that we have access to string and other things as in week one.
这样我们就可以像第一周一样访问字符串和其他内容。

760
00:36:53,030 --> 00:36:56,240
And let me do a string s equals quote unquote "HI" in all caps.
让我定义一个字符串 s，等于双引号内的 “HI”，所有字母都大写。

761
00:36:56,240 --> 00:37:00,845
And let me do a simple safety check %s backslash n s,
让我做一次简单的安全检查，%s 反斜杠 n s，

762
00:37:00,845 --> 00:37:04,100
just to make sure everything works as it did in week one.
只是为了确保一切像第一周那样工作。

763
00:37:04,100 --> 00:37:07,310
So make addresses, dot slash addresses, and I should indeed
所以，创建地址，点斜杠地址，我应该确实

764
00:37:07,310 --> 00:37:09,320
see "HI" on the screen.
在屏幕上看到 "HI"。

765
00:37:09,320 --> 00:37:12,680
Well, let's now kind of tinker with what's going on underneath the hood.
好吧，现在让我们仔细看看幕后发生了什么。

766
00:37:12,680 --> 00:37:17,100
And now, things can get a little more memory specific.
现在，事情会变得更具体一些，与内存相关。

767
00:37:17,100 --> 00:37:19,610
So I'm still going to declare s as a string up here.
所以我仍然要在这里声明 s 是一个字符串。



768
00:37:19,610 --> 00:37:20,360
But you know what?
但你知道吗？

769
00:37:20,360 --> 00:37:22,610
Instead of printing out the string itself,
与其直接打印字符串本身，

770
00:37:22,610 --> 00:37:26,870
let me actually treat s as the pointer I claim it is.
让我实际将 s 作为我声称的指针处理。

771
00:37:26,870 --> 00:37:30,210
I claim a string is just an address, so I have this new syntax today,
我声称字符串只是一个地址，所以今天我有了这个新的语法，

772
00:37:30,210 --> 00:37:33,120
%p to print out pointers, to print out addresses.
%p 用于打印指针，打印地址。

773
00:37:33,120 --> 00:37:35,340
Let's see what s actually is.
让我们看看 s 实际上是什么。

774
00:37:35,340 --> 00:37:39,870
Let me do make addresses again, dot slash addresses, and there it is.
让我再次执行 make addresses，点斜杠 addresses，它就在那儿。

775
00:37:39,870 --> 00:37:50,110
It's not as simple as OX123, but it is at location OX55C670878004.
它不像 OX123 那样简单，但它位于 OX55C670878004 位置。

776
00:37:50,110 --> 00:37:50,610
All right.
好吧。

777
00:37:50,610 --> 00:37:52,180
Who really cares, specifically?
具体来说，谁会在乎呢？

778
00:37:52,180 --> 00:37:55,450
But if we poke around a bit more, things might make a bit more sense.
但如果我们再探究一下，事情可能就会更清晰一些。

779
00:37:55,450 --> 00:37:56,100
Let's do this.
让我们试试。

780
00:37:56,100 --> 00:38:01,740
Let's also print out the address using %p of, how about the very first
让我们也使用 %p 打印出... 如何... 关于第一个...

781
00:38:01,740 --> 00:38:02,805
character of s.
s 的字符。

782
00:38:02,805 --> 00:38:06,720
So the very first character of is known as s bracket zero.
所以第一个字符被称为 s 方括号零。

783
00:38:06,720 --> 00:38:10,000
We did that in week two, treating a string as an array.
我们在第二周做过，将字符串当作数组处理。

784
00:38:10,000 --> 00:38:13,110
But how do I get the address of a character?
但是如何获得字符的地址？

785
00:38:13,110 --> 00:38:15,750
Well, I have our new symbol today, ampersand.
嗯，今天我们有新符号，取地址符。

786
00:38:15,750 --> 00:38:18,750
So even though this looks like a mouthful, ampersand, s, square bracket,
所以即使看起来很拗口，取地址符、s、方括号，

787
00:38:18,750 --> 00:38:21,015
zero, square bracket, it's just two ideas combined.
零、方括号，它只是将两个想法结合起来。

788
00:38:21,015 --> 00:38:24,900
s bracket zero gives you the first character in the string, s.
s 方括号零会给你字符串 s 中的第一个字符。

789
00:38:24,900 --> 00:38:28,620
And adding an ampersand at the beginning says, tell me what that address is.
在开头添加一个取地址符表示，告诉我那个地址是什么。

790
00:38:28,620 --> 00:38:34,260
So if I recompile this code, make addresses, dot slash addresses,
所以如果我重新编译这段代码，make addresses，点斜杠 addresses，

791
00:38:34,260 --> 00:38:37,680
even if you don't remember the value OX whatever,
即使你不记得 OX 后的值是多少，

792
00:38:37,680 --> 00:38:43,510
what are we going to see on the screen at a higher level?
我们将在屏幕上看到什么呢？

793
00:38:43,510 --> 00:38:46,780
Perhaps the same exact thing.
可能是完全相同的东西。

794
00:38:46,780 --> 00:38:47,320
Why?
为什么？

795
00:38:47,320 --> 00:38:49,070
Well, s is just an address.
嗯，s 只是一个地址。

796
00:38:49,070 --> 00:38:50,120
But what does that mean?
但这意味着什么呢？

797
00:38:50,120 --> 00:38:52,900
Well, it's just the address of its first character.
嗯，它只是第一个字符的地址。

798
00:38:52,900 --> 00:38:56,030
And we saw that per our picture a moment ago.
刚才我们从图中看到过。

799
00:38:56,030 --> 00:38:58,000
So can I see the contiguousness of this?
所以我能看到它的连续性吗？

800
00:38:58,000 --> 00:39:00,400
Well, I'm going to resort to some copy paste just for time's sake,
嗯，为了节省时间，我将使用一些复制粘贴，

801
00:39:00,400 --> 00:39:01,960
even though this is going to look a little silly,
即使看起来有点愚蠢，

802
00:39:01,960 --> 00:39:03,730
and I could certainly use a loop instead.
我当然可以使用循环来代替。

803
00:39:03,730 --> 00:39:07,420
But let me print out the second location, the third location, and heck,
但让我打印出第二个位置、第三个位置，以及...

804
00:39:07,420 --> 00:39:12,050
even the fourth location, whoops, the fourth location of that null character.
第四个位置... 哎呦，第四个位置，那个空字符的第四个位置。

805
00:39:12,050 --> 00:39:15,850
If I now do make addresses again and dot slash addresses, and zoom in,
如果我现在再次执行 make addresses，然后点斜杠 addresses，并放大，

806
00:39:15,850 --> 00:39:18,580
I don't really care about what these are, specifically.
具体来说，我不在乎它们是什么。

807
00:39:18,580 --> 00:39:22,560
But notice the first two are indeed the same because the first represents s.
但请注意，前两个确实是相同的，因为第一个代表 s。

808
00:39:22,560 --> 00:39:24,640
The first represents the first character of s,
第一个代表 s 的第一个字符，

809
00:39:24,640 --> 00:39:27,320
which now I reveal are exactly the same idea.
现在我揭示了它们实际上是同一个概念。

810
00:39:27,320 --> 00:39:30,580
And the next ones are literally just one byte
接下来的几个位置实际上只是相差一个字节

811
00:39:30,580 --> 00:39:34,490
away, ending in five, six, and seven, respectively.
而已，分别以五、六、七结尾。

812
00:39:34,490 --> 00:39:36,340
So again, the numbers in and of themselves
所以，再次强调，数字本身

813
00:39:36,340 --> 00:39:38,950
are not useful, actionable information, but it
并不是有用的、可操作的信息，但它

814
00:39:38,950 --> 00:39:44,240
does let us actually see what's going on underneath the hood.
确实让我们得以一窥幕后的运行机制。

815
00:39:44,240 --> 00:39:47,420
So just to rewind for a moment, let me actually go back to the original
所以，让我先倒回一下，回到最初的

816
00:39:47,420 --> 00:39:51,480
version, where I'm printing out the string itself, using %s.
版本，我使用 %s 打印出字符串本身。

817
00:39:51,480 --> 00:39:57,410
Let me remake addresses to make sure that, OK, it still prints out "HI".
让我重新执行 make addresses 来确保... 好了，它仍然打印出 "HI"。

818
00:39:57,410 --> 00:40:00,290
But what has been going on now all this time?
但一直以来都发生了什么呢？

819
00:40:00,290 --> 00:40:02,368
Well, let me go back to our simple line of code
嗯，让我回到我们从第一周就开始使用的那行简单的代码

820
00:40:02,368 --> 00:40:04,160
that we've been using since week one, which
从第一周开始使用，它

821
00:40:04,160 --> 00:40:07,730
gave us a string called s, setting it equal to the value of "HI".
为我们提供了一个名为 s 的字符串，并将其设置为 "HI" 的值。

822
00:40:07,730 --> 00:40:12,380
Let me propose now that strings were indeed this white lie.
现在让我假设，字符串确实是一种善意的谎言。

823
00:40:12,380 --> 00:40:14,750
And if I can unnecessarily dramatically say,
如果我可以用一种夸张的语调说，

824
00:40:14,750 --> 00:40:18,470
here we take the training wheels off and reveal
现在我们将去掉辅助轮，揭示

825
00:40:18,470 --> 00:40:30,080
that, all this time, string, string is probably, actually, what, technically?
一直以来，字符串，字符串可能实际上... 从技术上讲是什么？

826
00:40:30,080 --> 00:40:32,180
Yeah.
是的。

827
00:40:32,180 --> 00:40:35,210
A char star.
一个字符指针。

828
00:40:35,210 --> 00:40:36,270
That was amazing.
太棒了。

829
00:40:36,270 --> 00:40:37,080
Thank you for that.
谢谢。

830
00:40:37,080 --> 00:40:39,100
So yeah.
所以，是的。

831
00:40:39,100 --> 00:40:43,720
So it's a char star, which admittedly at first glance,
所以它是一个字符指针，不可否认的是，乍一看，

832
00:40:43,720 --> 00:40:46,870
just makes a simple idea look unnecessarily complicated.
它只是让一个简单的想法看起来不必要地复杂。

833
00:40:46,870 --> 00:40:50,410
And that's why in week one, we indeed introduced these training wheels,
这就是为什么在第一周，我们确实引入了这些辅助轮，

834
00:40:50,410 --> 00:40:55,720
whereby we, CS50, invented the datatype called string, just to kind of hide
通过这些辅助轮，我们，CS50，发明了名为字符串的数据类型，只是为了隐藏

835
00:40:55,720 --> 00:40:57,085
this lower level detail.
这个低级细节。

836
00:40:57,085 --> 00:40:58,960
If you will, string for us is an abstraction.
如果你愿意，字符串对我们来说是一种抽象。

837
00:40:58,960 --> 00:41:02,170
Now, that is to say string is not a CS50 specific word.
现在，也就是说，字符串不是 CS50 特定的词语。

838
00:41:02,170 --> 00:41:05,500
Every programmer in the world knows what a string is.
世界上每个程序员都知道字符串是什么。

839
00:41:05,500 --> 00:41:07,690
It is a sequence of characters.
它是一系列字符。

840
00:41:07,690 --> 00:41:09,190
It is an array of characters.
它是一个字符数组。

841
00:41:09,190 --> 00:41:12,220
But in C, technically, decades ago when it was invented,
但在 C 语言中，从技术上讲，几十年前发明 C 语言时，

842
00:41:12,220 --> 00:41:16,150
they didn't think, they didn't decide to create an actual data type called
他们没有想过，他们没有决定创建一个名为

843
00:41:16,150 --> 00:41:19,570
string because, especially if they were among those more comfortable,
字符串的数据类型，因为，特别是如果他们更喜欢使用

844
00:41:19,570 --> 00:41:23,470
char star is equivalent, and it achieves the exact same thing,
字符指针，它等效，并且实现了完全相同的功能，

845
00:41:23,470 --> 00:41:26,800
even though at a glance, we didn't want to start week one with that lower level
即使乍一看，我们不想在第一周就介绍那个低级

846
00:41:26,800 --> 00:41:27,670
detail.
细节。

847
00:41:27,670 --> 00:41:28,990
Question here in front.
前面有个问题。

848
00:41:33,020 --> 00:41:33,980
Sure.
当然。

849
00:41:33,980 --> 00:41:36,450
Can I clarify how the star makes it a string?
我能解释一下星号是如何让它成为字符串的吗？

850
00:41:36,450 --> 00:41:39,240
So we've, up until now, been just calling it a string
所以，到目前为止，我们一直在称之为字符串

851
00:41:39,240 --> 00:41:40,560
so that's s is a string.
所以 s 就是一个字符串。

852
00:41:40,560 --> 00:41:42,930
And that's a sufficient mental model.
这是一个足够的心理模型。

853
00:41:42,930 --> 00:41:44,900
But technically, what is a string?
但从技术上讲，字符串是什么？

854
00:41:44,900 --> 00:41:48,110
I claimed pictorially with my grid of memory
我在我的内存网格上画了图，

855
00:41:48,110 --> 00:41:50,670
that a string is really just an address.
声称字符串实际上只是一个地址。

856
00:41:50,670 --> 00:41:53,240
It's really just the address of its first character.
它实际上只是第一个字符的地址。

857
00:41:53,240 --> 00:41:57,410
I then tried to demonstrate as much in code by using percent p
然后，我尝试使用百分号 p 在代码中演示这一点，

858
00:41:57,410 --> 00:42:01,370
and showing you, literally, s is a value, like, OX something.
并向你展示，实际上，s 是一个值，比如 OX 后面的东西。

859
00:42:01,370 --> 00:42:05,220
And literally, its first character is at that same address, OX something.
实际上，它的第一个字符位于同一个地址，OX 后面的东西。

860
00:42:05,220 --> 00:42:09,050
So here, when I claim that string has never really existed,
所以，这里，当我声称字符串从未真正存在过时，

861
00:42:09,050 --> 00:42:13,250
except within the confines of CS50, technically, the data type of a string
除了在 CS50 的范围内，从技术上讲，字符串的数据类型

862
00:42:13,250 --> 00:42:15,450
is best expressed as char star.
最好表达为字符指针。

863
00:42:15,450 --> 00:42:15,950
Why?
为什么？


864
00:42:15,950 --> 00:42:19,760
Well, a string clearly can't just be a char because a char, by definition,
好吧，字符串显然不能仅仅是一个字符，因为根据定义，

865
00:42:19,760 --> 00:42:20,720
is a single character.
它是一个单字符。

866
00:42:20,720 --> 00:42:23,460
A string, we already know, is a sequence of characters.
我们已经知道，字符串是字符的序列。

867
00:42:23,460 --> 00:42:25,670
But how can you represent a sequence of characters?
但是，如何表示字符序列？

868
00:42:25,670 --> 00:42:29,480
You can call it a char star, which is a different data type that we're
你可以称它为字符星，这是一个我们今天第一次介绍的不同数据类型。

869
00:42:29,480 --> 00:42:31,100
introducing today for the first time.
我们今天第一次介绍。

870
00:42:31,100 --> 00:42:34,320
And the star just means that s itself is not a char.
星号只是表示s本身不是一个字符。

871
00:42:34,320 --> 00:42:38,400
The star means that s is the address of a char.
星号表示s是一个字符的地址。

872
00:42:38,400 --> 00:42:42,700
And by convention, it's the address of the first char in a string.
按照惯例，它是字符串中第一个字符的地址。

873
00:42:42,700 --> 00:42:48,090
So with that said, if I go back to my actual VS Code over here,
所以，说到这里，如果我回到我的VS Code，

874
00:42:48,090 --> 00:42:55,820
I can change, literally, char string to char star s.
我可以改变，实际上，将字符字符串改为字符星s。

875
00:42:55,820 --> 00:42:59,220
I can get rid of the CS50 library, our so-called training wheels,
我可以摆脱CS50库，我们所谓的辅助轮，

876
00:42:59,220 --> 00:43:02,220
which has been the goal for the past few weeks, to put them on initially
这是过去几周的目标，最初使用它们，

877
00:43:02,220 --> 00:43:04,300
and then take them off quite quickly.
然后快速移除它们。

878
00:43:04,300 --> 00:43:08,613
So now this is the same program, and %s is still the same. s is still the same.
所以现在，这还是同一个程序，%s 仍然是一样的。s 也仍然是一样的。

879
00:43:08,613 --> 00:43:10,030
Everything else is still the same.
其他都一样。

880
00:43:10,030 --> 00:43:12,600
All I've done is change, quote unquote, string to,
我所做的只是改变，换句话说，将字符串改为，

881
00:43:12,600 --> 00:43:16,200
quote unquote, char star, which obviates the need for the CS50 library.
换句话说，字符星，这避免了使用CS50库的必要性。

882
00:43:16,200 --> 00:43:18,870
And if I now do make addresses and dot slash addresses,
如果我现在使用make addresses 和 dot slash addresses，

883
00:43:18,870 --> 00:43:21,570
"HI" behaves exactly as it would.
"HI" 的行为和以前一样。

884
00:43:21,570 --> 00:43:25,470
So this is now raw native C code without any training wheels,
所以现在这是原始的本地C代码，没有任何辅助轮，

885
00:43:25,470 --> 00:43:30,840
without any CS50 scaffolding, that just uses these basic building
没有任何CS50支架，它只使用这些基本构建

886
00:43:30,840 --> 00:43:32,310
blocks and primitives.
块和基本类型。

887
00:43:32,310 --> 00:43:33,455
Other questions on this?
还有其他问题吗？

888
00:43:33,455 --> 00:43:36,890
AUDIENCE: Could you please clarify why we don't use the end symbol for that
观众：你能解释一下为什么我们不使用结束符号来表示那个

889
00:43:36,890 --> 00:43:38,310
s, as opposed to the other ones?
s，而不是其他符号？

890
00:43:38,310 --> 00:43:39,180
SPEAKER 1: Correct.
演讲者1：没错。

891
00:43:39,180 --> 00:43:44,320
Why don't we use the ampersand symbol for this, though we did earlier?
为什么我们不使用取地址符号来表示这个，虽然我们之前用过？

892
00:43:44,320 --> 00:43:47,670
So in this case, there's no reason for an ampersand
所以，在这种情况下，没有理由使用取地址符号

893
00:43:47,670 --> 00:43:52,620
because the ampersand tells you what the address of a variable is.
因为取地址符号告诉你变量的地址是什么。

894
00:43:52,620 --> 00:43:55,170
I'll concede that it probably would be a little more
我承认，这样做可能会更

895
00:43:55,170 --> 00:43:59,430
consistent for us to do this, which is maybe where your mind is going.
一致，可能这就是你的想法。

896
00:43:59,430 --> 00:44:02,880
Now, never mind the fact that looks even worse, I think, syntactically.
现在，别管它看起来更糟糕，我认为，在语法上。

897
00:44:02,880 --> 00:44:06,930
It's a reasonable instinct, but it turns out
这是一个合理的本能，但事实证明

898
00:44:06,930 --> 00:44:09,150
that two is what the double quotes are doing for you.
双引号为你做的正是这件事。

899
00:44:09,150 --> 00:44:11,790
The C compiler, called Clang, is smart enough
C编译器，叫做Clang，足够聪明

900
00:44:11,790 --> 00:44:15,060
to realize that when it sees double quotes around a sequence of characters,
意识到当它看到字符序列周围的双引号时，

901
00:44:15,060 --> 00:44:20,550
it wants to put the address of that first char in the variable for you.
它希望将第一个字符的地址放在你的变量中。

902
00:44:20,550 --> 00:44:23,850
But when we had a variable like n, which we created,
但是当我们有一个像n这样的变量时，它是我们创建的，

903
00:44:23,850 --> 00:44:26,020
you have to distinguish n from its address.
你必须区分n和它的地址。

904
00:44:26,020 --> 00:44:28,620
So that's why we prefixed n with an ampersand.
所以这就是为什么我们在n前面加上取地址符号。

905
00:44:28,620 --> 00:44:30,540
But the double quotes take care of it for you.
但是双引号为你处理了这件事。

906
00:44:30,540 --> 00:44:36,240
Other questions on these here addresses?
关于这些地址还有其他问题吗？

907
00:44:36,240 --> 00:44:36,880
No?
没有？

908
00:44:36,880 --> 00:44:37,380
All right.
好的。

909
00:44:37,380 --> 00:44:43,530
Well, beyond that, let me propose that we tinker with one other idea
除此之外，我想建议我们修改另一个想法

910
00:44:43,530 --> 00:44:46,170
to see how we actually invented this thing called a string.
看看我们是如何真正发明了这个叫做字符串的东西的。

911
00:44:46,170 --> 00:44:48,180
Well, I claim that string is just char star.
好吧，我认为字符串仅仅是字符星。

912
00:44:48,180 --> 00:44:50,430
You've actually seen this technique before.
你之前已经见过这种技术了。

913
00:44:50,430 --> 00:44:54,630
It was just a week ago that we tinkered with structures, custom data types
就在一周前，我们修改了结构，自定义数据类型

914
00:44:54,630 --> 00:44:55,890
to represent a person.
来表示一个人。

915
00:44:55,890 --> 00:44:59,530
And recall that we had a structure of a name and a number representing
你还记得，我们有一个表示人的结构，其中包含一个姓名和一个数字。

916
00:44:59,530 --> 00:45:00,030
a person.
一个人的结构。

917
00:45:00,030 --> 00:45:03,030
But more importantly, we had this keyword typedef,
但更重要的是，我们有这个关键字typedef，

918
00:45:03,030 --> 00:45:05,940
which defines your own type to be whatever you want.
它定义了你自己的类型，可以是你想要的任何类型。

919
00:45:05,940 --> 00:45:08,160
Now, we used it a little more powerfully last time
现在，我们上次使用它的时候更强大一些

920
00:45:08,160 --> 00:45:11,880
to actually represent a whole structure of a person, having a name,
来真正表示一个人的整个结构，包括姓名，

921
00:45:11,880 --> 00:45:12,790
and having a number.
还有数字。

922
00:45:12,790 --> 00:45:15,623
But at the end of the day, we really just invented our own data type
但归根结底，我们实际上只是发明了自己的数据类型

923
00:45:15,623 --> 00:45:17,910
that we called, obviously, person.
我们称之为，显然是，person。

924
00:45:17,910 --> 00:45:20,400
But and that represented, indeed, this structure.
但是它确实表示了这个结构。

925
00:45:20,400 --> 00:45:23,380
But typedef was really the enabling element there.
但typedef 确实是那里使能的元素。

926
00:45:23,380 --> 00:45:25,470
And so it turns out with typedef, you can create
所以，事实证明，使用typedef，你可以创建

927
00:45:25,470 --> 00:45:27,060
any number of data types of your own.
任意数量的你自己的数据类型。

928
00:45:27,060 --> 00:45:28,860
For instance, if you just really can't get
例如，如果你真的不能理解

929
00:45:28,860 --> 00:45:31,140
the hang of calling an integer an int, you
将整数称为int，你可以

930
00:45:31,140 --> 00:45:34,230
can create your own data type called integer
创建自己的数据类型，称为integer

931
00:45:34,230 --> 00:45:37,403
that itself is a synonym for int, because the way typedef works,
它本身是int的同义词，因为typedef 的工作方式，

932
00:45:37,403 --> 00:45:39,570
even though this one's even simpler than the struct,
即使这个比结构更简单，

933
00:45:39,570 --> 00:45:42,310
is you can read it from right to left.
就是你可以从右往左读它。

934
00:45:42,310 --> 00:45:47,662
This means give me a data type called integer that is actually an int.
这意味着给我一个叫做integer的数据类型，它实际上是一个int。

935
00:45:47,662 --> 00:45:49,870
And that's the same thing that happened a moment ago.
这就是刚才发生的事情。

936
00:45:49,870 --> 00:45:53,130
Give me a data type called person that is actually this whole structure.
给我一个叫做person的数据类型，它实际上是整个结构。

937
00:45:53,130 --> 00:45:54,760
But an integer is even simpler.
但整数更简单。

938
00:45:54,760 --> 00:45:56,340
Now, most people wouldn't do this.
现在，大多数人不会这样做。

939
00:45:56,340 --> 00:45:59,820
This really doesn't create any intellectual enhancement of the data
这并不会真正提高数据的智力水平

940
00:45:59,820 --> 00:46:02,130
types, but you could do it if you really wanted.
类型，但如果你真的想，你可以这样做。

941
00:46:02,130 --> 00:46:05,070
More commonly, and as you'll see this in code in the future,
更常见的是，你将在将来的代码中看到，

942
00:46:05,070 --> 00:46:07,470
would be not just a typedef something like an integer.
不仅仅是typedef像integer这样的东西。

943
00:46:07,470 --> 00:46:11,460
But it turns out, curiously, C has no data type for a byte.
但事实证明，奇怪的是，C没有表示字节的数据类型。

944
00:46:11,460 --> 00:46:15,750
Like, there's no built in obvious way to represent eight bits
就像，没有内置的明显方法来表示8位

945
00:46:15,750 --> 00:46:17,830
and store whatever you want in them.
并将你想要的任何东西存储在其中。

946
00:46:17,830 --> 00:46:21,720
However, you can use what's called a uint8_t, t
但是，你可以使用一个叫做uint8_t的东西，t

947
00:46:21,720 --> 00:46:25,530
which is a data type that comes with C. And frankly, those more comfortable
它是一个C自带的数据类型。坦率地说，那些更习惯

948
00:46:25,530 --> 00:46:27,600
might simply use this data type once you sort of
的人可能会简单地使用这种数据类型，一旦你 sort of

949
00:46:27,600 --> 00:46:29,070
commit to memory that it exists.
记住它存在。

950
00:46:29,070 --> 00:46:32,680
But honestly, for most of us, it's a lot more convenient to think of a byte
但说实话，对我们大多数人来说，将字节

951
00:46:32,680 --> 00:46:34,210
as being its own data type.
视为它自己的数据类型，会方便得多。

952
00:46:34,210 --> 00:46:37,540
When you want to write code that manipulates one or two or more bytes,
当你想要编写操纵一个、两个或更多字节的代码时，

953
00:46:37,540 --> 00:46:39,850
wouldn't it be nice to have a data type called byte?
拥有一个叫做字节的数据类型，难道不很好吗？

954
00:46:39,850 --> 00:46:43,630
So it turns out that you can represent a byte, which is eight bits using
所以，事实证明，你可以使用一个无符号的8位整数来表示一个字节，它有8位。

955
00:46:43,630 --> 00:46:45,830
an unsigned integer with 8 bits.
一个无符号的8位整数。

956
00:46:45,830 --> 00:46:49,900
And this is just a data type that's declared in some other C header file.
而这只是一个在其他C头文件中声明的数据类型。



957
00:46:49,900 --> 00:46:52,870
But long story short, you'll see and use this before long.
但长话短说，你很快就会看到并使用它。

958
00:46:52,870 --> 00:46:56,290
But it's just a synonym to make things a little more user friendly,
但这只是一个同义词，让事情更易于使用，

959
00:46:56,290 --> 00:46:58,885
like person, like string, like byte.
比如人、字符串、字节。

960
00:46:58,885 --> 00:47:02,860
So what is in the CS50 header file, among other things?
那么，除了其他内容，CS50 头文件里有什么？

961
00:47:02,860 --> 00:47:04,750
Literally, this line of code.
实际上，就是这行代码。

962
00:47:04,750 --> 00:47:07,180
This is the single line of code that we deploy
这就是我们在第一周之后部署的单行代码，

963
00:47:07,180 --> 00:47:11,260
in week one onward that teaches Clang to think of the word string
它让 Clang 从第一周开始就将“string”这个词

964
00:47:11,260 --> 00:47:15,550
as being synonymous with char star, so that you all never have to type,
视为与“char star”同义，这样你们就永远不必输入，

965
00:47:15,550 --> 00:47:20,470
or know, or think about char star until, wonderfully, today in week four,
知道或思考“char star”，直到今天，也就是第四周，

966
00:47:20,470 --> 00:47:22,670
a couple of weeks later instead.
也就是几周之后才需要。

967
00:47:22,670 --> 00:47:24,340
So that's all we've been doing.
所以，这就是我们一直在做的事情。

968
00:47:24,340 --> 00:47:27,430
That is the technical implementation of the training wheels.
这就是辅助轮的技术实现。

969
00:47:27,430 --> 00:47:32,870
It's just using a custom data type in this way.
它只是用这种方式使用自定义数据类型。

970
00:47:32,870 --> 00:47:37,970
So how about one other maybe pair of examples here with our addresses,
所以，我们再来看看地址的另一个例子，

971
00:47:37,970 --> 00:47:40,340
such that we can tinker a little bit further?
这样我们就可以进一步调整一下？

972
00:47:40,340 --> 00:47:44,600
It turns out that, once everything in the world
事实证明，一旦世界上的一切

973
00:47:44,600 --> 00:47:48,470
is addressable using these pointers, like using numeric addresses
都可以使用这些指针寻址，就像使用数值地址

974
00:47:48,470 --> 00:47:50,870
to represent where things are in memory, you can actually
来表示事物在内存中的位置，你实际上

975
00:47:50,870 --> 00:47:52,700
do something called pointer arithmetic.
可以做一些叫做指针运算的事情。

976
00:47:52,700 --> 00:47:54,680
And here, too, we the programmers generally
在这里，我们程序员通常

977
00:47:54,680 --> 00:47:59,640
don't care what the specific values are, but we care that they do exist.
并不关心具体的值是什么，但我们关心它们是否存在。

978
00:47:59,640 --> 00:48:02,600
And if they do exist, we can maybe do some arithmetic on them
如果它们存在，我们就可以对它们进行一些运算

979
00:48:02,600 --> 00:48:05,750
and add one to go to the next byte, add two to go to the next, next byte,
加 1 跳到下一个字节，加 2 跳到下下个字节，

980
00:48:05,750 --> 00:48:08,400
add three to go to the next, next, net byte, and so forth.
加 3 跳到下下下个字节，以此类推。

981
00:48:08,400 --> 00:48:12,710
So pointer arithmetic literally refers to doing math on addresses.
所以，指针运算实际上是指对地址进行数学运算。

982
00:48:12,710 --> 00:48:15,260
So how do we translate this into something actionable?
那么，我们如何将它转化为可操作的东西呢？

983
00:48:15,260 --> 00:48:18,410
Let me actually go back to VS Code here, and let
让我回到 VS Code，然后让

984
00:48:18,410 --> 00:48:21,210
me propose that we do something like the following.
我建议我们做以下事情。

985
00:48:21,210 --> 00:48:25,040
I'm going to throw away my first printf here.
我将丢弃第一个 printf。

986
00:48:25,040 --> 00:48:28,400
And I'm instead going to print out this string character by character,
我将逐个字符地打印出这个字符串，

987
00:48:28,400 --> 00:48:30,920
just like we did in week two.
就像我们在第二周做的那样。

988
00:48:30,920 --> 00:48:36,950
Let me go ahead and call printf, pass in %c for a single char, backslash n,
让我调用 printf，传入 %c 用于单个字符，反斜杠 n，

989
00:48:36,950 --> 00:48:40,610
comma, and now I want to print out the first character in s.
逗号，现在我想要打印出 s 中的第一个字符。

990
00:48:40,610 --> 00:48:45,250
Using array notation, what do I type to print the first character in s?
使用数组表示法，我应该输入什么才能打印出 s 中的第一个字符？

991
00:48:48,250 --> 00:48:49,530
Yep, over here.
没错，在这里。

992
00:48:49,530 --> 00:48:50,430
s bracket zero.
s 中括号 0。

993
00:48:50,430 --> 00:48:52,950
So s bracket zero gives me the first character in s.
所以 s 中括号 0 给出了 s 中的第一个字符。

994
00:48:52,950 --> 00:48:55,320
And let me copy paste just for demonstration sake
为了演示，让我复制粘贴

995
00:48:55,320 --> 00:48:58,200
here inside of my same curly braces, and print out
到我相同的括号里，打印出

996
00:48:58,200 --> 00:48:59,520
the second char, and the third.
第二个字符和第三个字符。

997
00:48:59,520 --> 00:49:00,840
And I don't care about the null character.
我不关心空字符。

998
00:49:00,840 --> 00:49:03,160
I just want to print the string itself for now.
我现在只想打印字符串本身。

999
00:49:03,160 --> 00:49:07,095
So even though this is jumping through way more hoops than just using %s
所以，虽然这比直接使用 %s 打印整个字符串要复杂得多，

1000
00:49:07,095 --> 00:49:10,530
and print the whole thing at once, it's again, just demonstrating how we can,
但它再次展示了我们如何，

1001
00:49:10,530 --> 00:49:12,840
at a lower level, manipulate these strings.
在更低层次上，操作这些字符串。

1002
00:49:12,840 --> 00:49:15,270
So let me do make addresses, dot slash addresses.
所以，让我做 make addresses，点斜杠 addresses。

1003
00:49:15,270 --> 00:49:18,090
And yet again, we see, somewhat stupidly, one
又一次，我们看到，有点愚蠢的是，一行

1004
00:49:18,090 --> 00:49:21,630
per line, H-I exclamation point.
一个字符，H-I 感叹号。

1005
00:49:21,630 --> 00:49:23,940
I can, of course fix that by getting rid of this.
当然，我可以通过去掉这个来解决。

1006
00:49:23,940 --> 00:49:27,052
I can get rid of this, and I can leave the last backslash n.
我可以去掉这个，并且保留最后一个反斜杠 n。

1007
00:49:27,052 --> 00:49:29,010
So let's just make it a look a little prettier.
所以，让我们让它看起来更漂亮一些。

1008
00:49:29,010 --> 00:49:32,070
Make addresses, dot slash addresses, enter,
Make addresses，点斜杠 addresses，回车，

1009
00:49:32,070 --> 00:49:34,320
and I can print it out all on one line.
然后我可以将它全部打印在一行上。

1010
00:49:34,320 --> 00:49:37,140
But now using pointer notation, it turns out
但是现在使用指针表示法，事实证明

1011
00:49:37,140 --> 00:49:40,230
we can do one other thing, which admittedly, for now,
我们还可以做另外一件事，虽然现在，

1012
00:49:40,230 --> 00:49:42,450
is going to feel like unnecessary complexity.
感觉有点过于复杂了。

1013
00:49:42,450 --> 00:49:46,420
But it's actually a really helpful tool to add to our toolkit, so to speak,
但它实际上是一个非常有用的工具，可以添加到我们的工具箱中，

1014
00:49:46,420 --> 00:49:48,820
whereby I could instead do this.
因此，我还可以这样做。

1015
00:49:48,820 --> 00:49:54,370
To print out the first character in s, yes, I can treat it as an array
要打印出 s 中的第一个字符，是的，我可以把它看作一个数组

1016
00:49:54,370 --> 00:49:56,560
and get the zeroth index.
然后获取索引 0。

1017
00:49:56,560 --> 00:49:59,800
However, what is s? s is just the address of a string.
但是，s 是什么呢？s 只是字符串的地址。

1018
00:49:59,800 --> 00:50:03,710
What does that mean? s is the address of the first char in the string.
这是什么意思？s 是字符串中第一个字符的地址。

1019
00:50:03,710 --> 00:50:09,560
So if I do star s, what's that going to print?
那么，如果我执行星号 s，它会打印什么呢？

1020
00:50:09,560 --> 00:50:11,090
Presumably h, right?
可能是 h，对吧？

1021
00:50:11,090 --> 00:50:18,410
Because if the first character in s is h, then star s will go to that address
因为如果 s 中的第一个字符是 h，那么星号 s 会跳转到那个地址

1022
00:50:18,410 --> 00:50:20,090
and show me what's actually there.
然后显示实际存在的内容。

1023
00:50:20,090 --> 00:50:21,930
And let me go ahead and do this again.
让我继续做这件事。

1024
00:50:21,930 --> 00:50:25,530
Let me copy paste twice and then tweak this a little bit.
让我复制粘贴两次，然后稍微修改一下。

1025
00:50:25,530 --> 00:50:27,920
I want to go to the next byte over.
我想跳到下一个字节。

1026
00:50:27,920 --> 00:50:29,780
Well, I could do s bracket one.
好吧，我可以使用 s 中括号 1。

1027
00:50:29,780 --> 00:50:34,760
All right, but I could instead go to s plus one.
好吧，但我也可以跳转到 s 加 1。

1028
00:50:34,760 --> 00:50:38,600
And I could instead go to s plus two, thereby
我也可以跳转到 s 加 2，从而

1029
00:50:38,600 --> 00:50:41,960
doing what we're calling pointer arithmetic, math on addresses.
进行我们称之为指针运算的操作，也就是对地址进行运算。

1030
00:50:41,960 --> 00:50:47,000
And now, if I go ahead and rerun make addresses, dot slash addresses, voila.
现在，如果我运行 make addresses，点斜杠 addresses，瞧。

1031
00:50:47,000 --> 00:50:48,710
Whoops, I forgot my backslash n.
哎呀，我忘记了反斜杠 n。

1032
00:50:48,710 --> 00:50:51,080
Let's fix that just to be tidy.
让我们把它修复一下，让它更整洁。

1033
00:50:51,080 --> 00:50:53,690
Dot slash addresses, voila.
点斜杠 addresses，瞧。

1034
00:50:53,690 --> 00:50:55,670
There is our "HI".
这就是我们的“HI”。

1035
00:50:55,670 --> 00:50:58,400
Now, this is not how a normal person would print out a string,
现在，这并不是正常人打印字符串的方式，

1036
00:50:58,400 --> 00:51:02,210
but it does go to show you that there's not really been any magic.
但这确实向你展示了，实际上并没有什么魔法。

1037
00:51:02,210 --> 00:51:05,390
Like, these characters are just where we predicted they would be.
就像，这些字符恰好位于我们预测它们应该出现的位置。

1038
00:51:05,390 --> 00:51:08,700
And now that you have this star notation, the dereference operator,
现在你有了这个星号表示法，也就是解除引用运算符，

1039
00:51:08,700 --> 00:51:12,120
which means go there, you have the ability to access individual values.
这意味着跳转到那里，你就可以访问单个值。

1040
00:51:12,120 --> 00:51:15,750
You even have the ability to ask where those things are by using ampersands,
你甚至可以使用取地址符来询问这些事物在何处，

1041
00:51:15,750 --> 00:51:16,480
as well.
也是。

1042
00:51:16,480 --> 00:51:20,820
But it turns out that the reason that we introduced the array syntax first
但事实证明，我们首先引入数组语法的原因

1043
00:51:20,820 --> 00:51:22,860
is that the array syntax is what the world would
是因为数组语法是世界所称的

1044
00:51:22,860 --> 00:51:26,040
call syntactic sugar for exactly this.
语法糖，用于实现这一点。

1045
00:51:26,040 --> 00:51:31,950
When you say s bracket zero, the compiler is essentially doing star s
当你使用 s 中括号 0 时，编译器本质上是在执行星号 s

1046
00:51:31,950 --> 00:51:33,300
and saving you the trouble.
并且为你省去了麻烦。

1047
00:51:33,300 --> 00:51:37,170
When you do s bracket one, the compiler is essentially
当你使用 s 中括号 1 时，编译器本质上是在

1048
00:51:37,170 --> 00:51:41,100
saving you the trouble of doing star, in parentheses, s plus one,
为你省去了执行星号，在括号中，s 加 1 的麻烦，




1049
00:51:41,100 --> 00:51:43,750
and same for the third char, as well.
并且第三个字符也是如此。

1050
00:51:43,750 --> 00:51:47,850
So all this time, pointers have been there underneath the hood.
所以一直以来，指针都在幕后。

1051
00:51:47,850 --> 00:51:50,760
They are what allow us to go to very specific memory locations.
它们允许我们访问非常具体的内存位置。

1052
00:51:50,760 --> 00:51:54,400
They are going to be what allow us soon to start manipulating files,
它们将很快让我们开始操作文件，

1053
00:51:54,400 --> 00:51:57,908
whether it's photographs of stress balls, or CSI style content.
无论是压力球的照片，还是犯罪现场调查风格的内容。

1054
00:51:57,908 --> 00:52:01,200
But for now, I think we should take our 10 minute break where whoopie pies will
但现在，我认为我们应该休息10分钟，期间将会供应松饼。

1055
00:52:01,200 --> 00:52:02,640
now be served in the transept.
它们将在横厅供应。

1056
00:52:02,640 --> 00:52:04,530
See you in 10.
10分钟后见。

1057
00:52:04,530 --> 00:52:05,270
All right.
好的。

1058
00:52:05,270 --> 00:52:08,520
So we are back, and we've clearly drawn too much attention to the stress balls
我们回来了，很明显，我们对压力球给予了过多的关注，

1059
00:52:08,520 --> 00:52:10,937
today because now we're all out of these and whoopie pies.
因为现在压力球和松饼都用完了。

1060
00:52:10,937 --> 00:52:12,297
But more next week.
但下周会有更多。

1061
00:52:12,297 --> 00:52:14,130
In the meantime, though, we thought we'd now
同时，我们认为现在应该

1062
00:52:14,130 --> 00:52:17,940
use some of these new building blocks, this idea of being able to manipulate
使用一些新的构建模块，也就是能够操作

1063
00:52:17,940 --> 00:52:20,610
underlying addresses, to revisit a couple of problems
底层地址，重新审视一些我们之前

1064
00:52:20,610 --> 00:52:23,580
that we kind of swept under the rug previously
暂时搁置的问题。

1065
00:52:23,580 --> 00:52:26,120
by avoiding these problems altogether.
通过完全避免这些问题。

1066
00:52:26,120 --> 00:52:27,120
So by that, I mean this.
我的意思是。

1067
00:52:27,120 --> 00:52:29,160
Let me go over to VS Code.
让我打开 VS Code。

1068
00:52:29,160 --> 00:52:31,690
And let me create another example called compare.c,
让我创建一个名为 compare.c 的另一个示例，

1069
00:52:31,690 --> 00:52:34,440
whose purpose in life in a moment is going to be to compare values
它的作用是比较值，

1070
00:52:34,440 --> 00:52:36,600
in kind of a very weak one way, too.
而且以一种非常弱的方式比较。

1071
00:52:36,600 --> 00:52:39,660
So let me go ahead and include CS50.h.
所以让我添加 CS50.h 头文件。

1072
00:52:39,660 --> 00:52:42,270
Let me go ahead and include standard io.h.
让我添加 stdio.h 头文件。

1073
00:52:42,270 --> 00:52:44,820
Let me do int main void, no command line arguments.
让我编写 int main void 函数，没有命令行参数。

1074
00:52:44,820 --> 00:52:49,000
And in here, let me just get two integers using getint as follows.
这里，让我使用 getint 获取两个整数，如下所示。

1075
00:52:49,000 --> 00:52:51,300
So getint, and we'll ask for i.
使用 getint 获取 i。

1076
00:52:51,300 --> 00:52:54,420
Let's go ahead and get int and ask for j,
让我们获取 j，

1077
00:52:54,420 --> 00:52:57,190
just so that we have two things to compare.
这样我们就有两个要比较的东西了。

1078
00:52:57,190 --> 00:52:59,200
And then I'm going to do something super simple.
然后我要做一件非常简单的事情。

1079
00:52:59,200 --> 00:53:03,630
So if i equals, equals j, then let's print out,
如果 i 等于 j，那么打印输出，

1080
00:53:03,630 --> 00:53:07,020
as we actually did in the past, same backslash n.
就像我们以前做的那样，相同的后斜杠 n。

1081
00:53:07,020 --> 00:53:10,430
Else, if they're not the same, let's of course, print out, for instance,
否则，如果它们不相同，那么打印输出，例如，

1082
00:53:10,430 --> 00:53:10,930
different.
不同。

1083
00:53:10,930 --> 00:53:13,890
So super simple program that we used the first time around, really,
这是一个非常简单的程序，我们在第一次的时候使用过它，

1084
00:53:13,890 --> 00:53:15,430
just to demonstrate conditionals.
只是为了演示条件语句。

1085
00:53:15,430 --> 00:53:18,550
But now, we'll use it to tease apart some subtleties.
但现在，我们将用它来揭示一些微妙之处。

1086
00:53:18,550 --> 00:53:21,990
So let me go ahead and compile this with make compare.
让我们用 make compare 命令编译这个程序。

1087
00:53:21,990 --> 00:53:23,730
Dot slash compare.
运行 compare 程序。

1088
00:53:23,730 --> 00:53:27,330
And we'll compare one and one for i and j respectively.
我们将分别比较 i 和 j 的值 1 和 1。

1089
00:53:27,330 --> 00:53:28,650
Those are, of course, the same.
当然，它们是相同的。

1090
00:53:28,650 --> 00:53:30,357
Let's compare one and two.
让我们比较 1 和 2。

1091
00:53:30,357 --> 00:53:31,690
Those are, of course, different.
当然，它们是不同的。

1092
00:53:31,690 --> 00:53:34,560
So long story short, this program seems to work,
总之，这个程序似乎可以正常工作，

1093
00:53:34,560 --> 00:53:36,630
and we won't dwell much further on it.
我们不会再深入研究它。

1094
00:53:36,630 --> 00:53:39,630
But let's consider for a moment what's going on inside of the computer's
但让我们思考一下，当代码在计算机中执行时，

1095
00:53:39,630 --> 00:53:42,250
memory when that code is executed.
内存中发生了什么。

1096
00:53:42,250 --> 00:53:43,920
So here's my canvas of memory.
这是我的内存画布。

1097
00:53:43,920 --> 00:53:45,660
Maybe i ends up over here.
i 可能在这里。

1098
00:53:45,660 --> 00:53:47,350
Maybe j ends up over here.
j 可能在这里。

1099
00:53:47,350 --> 00:53:51,480
Each of them I've drawn as four squares because integers are typically
我将它们都画成了四个方块，因为整数通常

1100
00:53:51,480 --> 00:53:53,260
four bytes, or 32 bits.
是四个字节，或 32 位。

1101
00:53:53,260 --> 00:53:56,520
So i has the value 50 here. i has the value 50.
所以 i 在这里的值是 50，i 的值也是 50。

1102
00:53:56,520 --> 00:53:59,220
So I accidentally typed one and one, but assume
我无意中输入了 1 和 1，但假设

1103
00:53:59,220 --> 00:54:00,940
that I had typed 50 in both cases.
我输入的都是 50。

1104
00:54:00,940 --> 00:54:03,340
They both live at these two separate locations.
它们都位于这两个不同的位置。

1105
00:54:03,340 --> 00:54:03,840
All right.
好的。

1106
00:54:03,840 --> 00:54:05,800
So that's all fine and good.
这些都很好。

1107
00:54:05,800 --> 00:54:09,960
And when we compare them, of course, 50 and 50, or one and one
当我们比较它们时，当然，50 和 50，或者 1 和 1

1108
00:54:09,960 --> 00:54:12,120
are, in fact, the exact same.
实际上是一样的。

1109
00:54:12,120 --> 00:54:16,290
But what if we actually compare different types of values?
但是如果我们比较不同类型的值呢？

1110
00:54:16,290 --> 00:54:18,210
Let me go back into VS Code here.
让我回到 VS Code 中。

1111
00:54:18,210 --> 00:54:22,050
And instead of integers, let's still, using the CS50 library,
让我们使用 CS50 库，但不再使用整数，

1112
00:54:22,050 --> 00:54:24,490
maybe use some strings instead.
而是使用一些字符串。

1113
00:54:24,490 --> 00:54:29,380
So let me go ahead and change my i and j to maybe s and t, respectively.
所以让我将 i 和 j 分别改为 s 和 t。

1114
00:54:29,380 --> 00:54:31,710
So string s equals getstring.
所以 string s 等于 getstring。

1115
00:54:31,710 --> 00:54:34,440
And I'll ask for s, quote unquote.
我将获取 s，带引号。

1116
00:54:34,440 --> 00:54:37,260
And then string t equals getstring.
然后 string t 等于 getstring。

1117
00:54:37,260 --> 00:54:39,900
And then I'll ask for t, quote unquote.
然后我将获取 t，带引号。

1118
00:54:39,900 --> 00:54:44,700
And then down here, I'll compare s equals, equals t.
然后在下面，我将比较 s 等于 t。

1119
00:54:44,700 --> 00:54:46,980
So here's the code, almost the same logically.
这是代码，逻辑上几乎相同。

1120
00:54:46,980 --> 00:54:50,760
I'm just getting different data types instead, still using the CS50 library.
我只是获取不同的数据类型，仍然使用 CS50 库。

1121
00:54:50,760 --> 00:54:54,930
So let's do make compare again, dot slash compare.
让我们再次运行 make compare，然后运行 compare 程序。

1122
00:54:54,930 --> 00:54:58,140
And let's type in something like "HI" exclamation point,
让我们输入一些内容，例如 "HI" 感叹号，

1123
00:54:58,140 --> 00:54:59,760
"HI" exclamation point.
"HI" 感叹号。

1124
00:54:59,760 --> 00:55:02,580
And that's interesting.
这很有趣。

1125
00:55:02,580 --> 00:55:05,320
All right, let's maybe try it again.
好的，让我们再试一次。

1126
00:55:05,320 --> 00:55:08,040
So maybe lowercase "hi", "hi".
也许是小写 "hi"，"hi"。

1127
00:55:08,040 --> 00:55:09,280
No, those are different.
不，它们是不同的。

1128
00:55:09,280 --> 00:55:12,190
Let's do it one more time, like "hi", "bye".
让我们再试一次，例如 "hi"，"bye"。

1129
00:55:12,190 --> 00:55:13,810
OK, so it half works.
好的，它部分起作用了。

1130
00:55:13,810 --> 00:55:17,210
But it seems to be saying different no matter what.
但它似乎始终显示不同。

1131
00:55:17,210 --> 00:55:18,420
Well, why might that be?
为什么呢？

1132
00:55:18,420 --> 00:55:20,170
Well, let me first just peel back a layer.
让我先揭开一层。

1133
00:55:20,170 --> 00:55:22,850
We already know that strings don't technically exist.
我们已经知道，字符串并不真正存在。

1134
00:55:22,850 --> 00:55:24,850
They're really char star.
它们其实是 char star。

1135
00:55:24,850 --> 00:55:28,120
And string here is char star.
这里的 string 是 char star。

1136
00:55:28,120 --> 00:55:32,590
So does this reveal, perhaps implicitly, why
这是否揭示了，也许是隐含的，为什么

1137
00:55:32,590 --> 00:55:35,860
s and t are being thought to be different, even though I literally
s 和 t 被认为是不同的，即使我实际上

1138
00:55:35,860 --> 00:55:37,105
typed "hi" twice?
输入了两次 "hi"？

1139
00:55:40,290 --> 00:55:43,830
Yeah, on line nine here, I'm really just comparing
是的，在第 9 行，我实际上只是比较

1140
00:55:43,830 --> 00:55:48,300
the addresses that are in s and t, and that's why I changed it to char star,
s 和 t 中的地址，这就是我将其改为 char star 的原因，

1141
00:55:48,300 --> 00:55:51,330
just not to change anything, but to make it even clearer
并不是要改变任何东西，而是为了更清楚地表明

1142
00:55:51,330 --> 00:55:53,520
that s and t are, in fact, addresses.
s 和 t 实际上是地址。

1143
00:55:53,520 --> 00:55:55,300
They're not strings, per se.
它们本身不是字符串。

1144
00:55:55,300 --> 00:55:57,870
They're the address of the first character in those strings.
它们是这些字符串中第一个字符的地址。

1145
00:55:57,870 --> 00:56:00,810
And even though they happen to be the same words that I typed in,
即使它们碰巧是我输入的相同单词，

1146
00:56:00,810 --> 00:56:03,790
it would seem to imply that they're ending up in different places.
这似乎暗示着它们最终处于不同的位置。

1147
00:56:03,790 --> 00:56:06,360
So here's another canvas of memory for this program.
这是这个程序的另一个内存画布。

1148
00:56:06,360 --> 00:56:08,850
And here, for instance, might be s with enough room
例如，这里可能是 s，它有足够的存储空间，





1149
00:56:08,850 --> 00:56:11,550
for eight bytes up here as a pointer.
这里作为指针使用八个字节。

1150
00:56:11,550 --> 00:56:14,790
Here maybe is where "hi" ended up for this particular story.
也许，对于这个特定的故事，“hi” 就存储在这里。

1151
00:56:14,790 --> 00:56:16,455
Well, what's actually going in s?
那么，s 里面实际存储的是什么？

1152
00:56:16,455 --> 00:56:21,930
Well, if h is at OX123, i is at OX124, and so forth, what's going in
如果 h 在 OX123，i 在 OX124，等等，那么存储在 

1153
00:56:21,930 --> 00:56:24,180
s is OX123.
s 中的值是 OX123。

1154
00:56:24,180 --> 00:56:29,520
But when I use get string a second time and type in "hi"
但是当我第二次使用 get string 函数输入 "hi"

1155
00:56:29,520 --> 00:56:33,090
exclamation point, even the exact same way, uppercase or lowercase,
感叹号时，即使采用完全相同的方式，大写或小写，

1156
00:56:33,090 --> 00:56:35,710
t is ending up, presumably, somewhere else in memory.
t 很可能存储在内存中的其他地方。

1157
00:56:35,710 --> 00:56:37,830
So it's maybe using these eight bytes over here.
所以它可能正在使用这里这八个字节。

1158
00:56:37,830 --> 00:56:41,430
The same letters, coincidentally, by nature of how getstring works,
巧合的是，由于 getstring 函数的工作原理，

1159
00:56:41,430 --> 00:56:44,580
are ending up in the computer's memory, maybe down there, bottom right
这些相同的字母最终存储在计算机内存中，可能在下面，右下角

1160
00:56:44,580 --> 00:56:45,270
hand corner.
的角落。

1161
00:56:45,270 --> 00:56:50,370
Those are presumably different addresses, OX456, 457, 458, 459.
这些地址很可能不同，OX456, 457, 458, 459。

1162
00:56:50,370 --> 00:56:54,720
So what's going to go in t as its value?
所以 t 的值将是什么？

1163
00:56:54,720 --> 00:56:57,370
OX456, according to this example.
根据这个例子，是 OX456。

1164
00:56:57,370 --> 00:57:00,750
And so when you literally compare s equals,
所以当你直接比较 s 等于

1165
00:57:00,750 --> 00:57:04,660
equals t, no, they're not the same.
等于 t 时，不，它们并不相同。

1166
00:57:04,660 --> 00:57:07,770
They are, in fact, different, even if what they're pointing at
事实上，它们是不同的，即使它们指向的是

1167
00:57:07,770 --> 00:57:08,887
happens to be the same.
相同的内容。

1168
00:57:08,887 --> 00:57:10,470
So the computer's taking us literally.
所以计算机是按照字面意思来理解的。

1169
00:57:10,470 --> 00:57:12,790
If you compare s and t respectively, it's
如果你分别比较 s 和 t，它

1170
00:57:12,790 --> 00:57:14,790
going to compare what their values actually are.
将比较它们的值是什么。

1171
00:57:14,790 --> 00:57:17,490
And their values are the addresses of the first letter
它们的值分别是第一个字母的地址

1172
00:57:17,490 --> 00:57:20,860
of this string, and the first letter of this string, respectively.
在这个字符串中的地址，和在这个字符串中的第一个字母的地址。

1173
00:57:20,860 --> 00:57:23,640
And if those addresses differ, which they clearly do,
如果这些地址不同，很明显它们是不同的，

1174
00:57:23,640 --> 00:57:25,600
they're going to be deemed different.
它们将被认为是不同的。

1175
00:57:25,600 --> 00:57:28,350
Now, you might wonder, well, this just seems stupidly inefficient.
现在，你可能想知道，好吧，这看起来太低效了。

1176
00:57:28,350 --> 00:57:31,930
Why put the same string in two different places?
为什么要把同一个字符串放在两个不同的地方？

1177
00:57:31,930 --> 00:57:34,415
Well, maybe the string needs to be changed later on,
好吧，也许这个字符串需要在以后进行修改，

1178
00:57:34,415 --> 00:57:36,790
and we might want to have two different versions thereof.
而且我们可能想要有这两个字符串的不同版本。

1179
00:57:36,790 --> 00:57:40,683
And frankly, the first time you call getstring, it does its thing.
坦率地说，第一次调用 getstring 函数时，它会执行它的操作。

1180
00:57:40,683 --> 00:57:43,100
The second time you call getstring, it does its own thing.
第二次调用 getstring 函数时，它会执行它自己的操作。

1181
00:57:43,100 --> 00:57:46,433
It doesn't necessarily know how many times it's been called in the past.
它不一定知道在过去被调用了多少次。

1182
00:57:46,433 --> 00:57:48,850
And so maybe there's no communication between those calls.
所以也许在这些调用之间没有通信。

1183
00:57:48,850 --> 00:57:50,860
And so surely, it's going to do the simple thing
因此，它肯定会做最简单的事情

1184
00:57:50,860 --> 00:57:54,160
and just create more memory, create more memory for each of those strings,
就是创建更多的内存，为每个字符串创建更多的内存，

1185
00:57:54,160 --> 00:57:56,350
duplicates though they may seem to be.
即使它们看起来像是重复的。

1186
00:57:56,350 --> 00:57:58,150
So what does this imply?
所以这意味着什么呢？

1187
00:57:58,150 --> 00:58:01,540
Well, you might recall that we avoided this problem altogether
你可能还记得，我们完全避免了这个问题

1188
00:58:01,540 --> 00:58:06,850
just a week ago by using what solution on line nine?
就在一周前，我们在第九行使用了什么解决方案？

1189
00:58:06,850 --> 00:58:10,240
I did not compare two strings using equals, equals last time.
上次我没有使用等于号来比较两个字符串。

1190
00:58:12,940 --> 00:58:13,780
Exactly.
没错。

1191
00:58:13,780 --> 00:58:18,250
We used the strcompare function, which is in string.h very deliberately
我们使用了 strcompare 函数，它在 string.h 中，这是特意选择的，

1192
00:58:18,250 --> 00:58:21,280
at the time, because I didn't want to trip over this mistake at the time
因为当时我不想在这个错误上绊倒，

1193
00:58:21,280 --> 00:58:24,010
until we were sort of ready and had the vocabulary to discuss it.
直到我们做好准备，并拥有讨论这个问题的词汇。

1194
00:58:24,010 --> 00:58:28,090
But I did not do s equals, equals t, even though, logically, that's
但是我没有做 s 等于 t，即使从逻辑上来说，这就是

1195
00:58:28,090 --> 00:58:30,330
what you're trying to do, compare for equality.
你想要做的事情，比较是否相等。

1196
00:58:30,330 --> 00:58:32,080
But if you know now what a string is, it's
但是如果你现在知道字符串是什么，它

1197
00:58:32,080 --> 00:58:34,480
an array of characters starting at some address.
是一个从某个地址开始的字符数组。

1198
00:58:34,480 --> 00:58:37,630
You really need someone something to do the heavy lifting
你真的需要有人或者某些东西来做重活

1199
00:58:37,630 --> 00:58:40,900
of comparing every one of those chars from left to right.
从左到右比较所有这些字符。

1200
00:58:40,900 --> 00:58:45,700
We did it ourselves last time by just implementing it in code two weeks ago.
我们上次通过在代码中实现它来自己做了这件事，那是两周前。

1201
00:58:45,700 --> 00:58:48,350
But strcompare compare does it for us.
但 strcompare 函数为我们做这件事。

1202
00:58:48,350 --> 00:58:55,030
So strcompare, s comma t actually weirdly returns three possible values,
所以 strcompare，s 逗号 t 实际上会返回三个可能的值，

1203
00:58:55,030 --> 00:58:59,140
zero if they're the same, a positive number if one comes before the other,
如果它们相同，则为零；如果一个在另一个之前，则为正数；

1204
00:58:59,140 --> 00:59:01,370
or a negative number if the opposite is true.
反之，则为负数。

1205
00:59:01,370 --> 00:59:04,420
So strcomp, remember, can be used for alphabetizing
所以 strcomp，请记住，可以用于字母排序

1206
00:59:04,420 --> 00:59:08,780
things, or ascii-betizing things, based on those Ascii values.
事物，或者基于 ASCII 值对事物进行 ASCII 排序。

1207
00:59:08,780 --> 00:59:12,910
So this version, if I open my terminal window now and do make compare,
所以这个版本，如果我现在打开我的终端窗口并执行 make compare，

1208
00:59:12,910 --> 00:59:17,337
dot slash compare, and type in "hi" and "hi", now, in fact,
点斜杠 compare，然后输入 "hi" 和 "hi"，现在，事实上，

1209
00:59:17,337 --> 00:59:19,420
they're the same because strcomp is doing the work
它们是相同的，因为 strcomp 正在做

1210
00:59:19,420 --> 00:59:20,920
of comparing them char by char.
逐个字符比较它们的工作。

1211
00:59:20,920 --> 00:59:25,280
And if I do "hi" and "bye", those are now, in fact, different.
如果我输入 "hi" 和 "bye"，它们现在事实上是不同的。

1212
00:59:25,280 --> 00:59:28,990
So we avoided the problem last time for this very reason that simply using
所以我们上次之所以避免了这个问题，正是因为简单地使用

1213
00:59:28,990 --> 00:59:30,790
equals, equals would not have worked.
等于号是行不通的。

1214
00:59:30,790 --> 00:59:31,290
Yes.
没错。

1215
00:59:38,432 --> 00:59:40,384
AUDIENCE: Using those values?
使用这些值？

1216
00:59:40,384 --> 00:59:43,312
Is it like one minus one, or one, two, three,
它像是一减一，还是一、二、三，

1217
00:59:43,312 --> 00:59:44,992
depending how different they are?
取决于它们有多不同？

1218
00:59:44,992 --> 00:59:46,200
SPEAKER 1: Oh, good question.
好的，这个问题问得好。

1219
00:59:46,200 --> 00:59:49,590
So when using strcompare, the documentation
所以在使用 strcompare 函数时，文档

1220
00:59:49,590 --> 00:59:53,807
says that it will return zero, or a positive number, or a negative number.
说明它会返回零，或正数，或负数。

1221
00:59:53,807 --> 00:59:55,390
It doesn't tell you a specific number.
它没有告诉你一个具体的数字。

1222
00:59:55,390 --> 00:59:59,110
So the magnitude of the integer that comes back actually has no meaning.
所以返回的整数的大小实际上没有任何意义。

1223
00:59:59,110 --> 01:00:03,010
It might very well be one, zero, and negative one, but there's no guarantee.
它很可能是 1、0 和 -1，但没有保证。

1224
01:00:03,010 --> 01:00:06,510
And so you can check for equality equals, equals,
所以你可以检查是否等于，等于，

1225
01:00:06,510 --> 01:00:10,050
or you should check for greater than or less
或者你应该检查是否大于或小于

1226
01:00:10,050 --> 01:00:12,340
than, but not specific to a certain number.
于，但不要具体到某个数字。

1227
01:00:12,340 --> 01:00:14,010
So it just gives you relative ordering.
所以它只提供相对顺序。

1228
01:00:14,010 --> 01:00:17,190
It doesn't give you any more detail than that.
它不会提供更多细节。

1229
01:00:17,190 --> 01:00:17,710
All right.
好的。

1230
01:00:17,710 --> 01:00:21,990
So if we were to now take this lesson a step further,
所以如果我们现在把这个教训再进一步，

1231
01:00:21,990 --> 01:00:26,927
just to hammer home this point, whereby these strings s and t must clearly
为了强调这一点，这些字符串 s 和 t 必须清楚地

1232
01:00:26,927 --> 01:00:29,760
live at different addresses, let's actually try to see this in code.
存储在不同的地址，让我们尝试在代码中查看这一点。

1233
01:00:29,760 --> 01:00:31,990
So let me go back to VS Code here.
所以让我回到这里的 VS Code。

1234
01:00:31,990 --> 01:00:34,590
Let me go ahead and just remove all of the conditional code,
让我继续，只删除所有条件代码，

1235
01:00:34,590 --> 01:00:38,910
and instead do something old school, like print out %s backslash n and print
而是做一些老式的事情，比如打印 %s 反斜杠 n 然后打印

1236
01:00:38,910 --> 01:00:39,525
out s.
s。

1237
01:00:39,525 --> 01:00:43,390
Then Let's go ahead and print out %s again, but print out t,
然后让我们继续打印 %s，但打印 t，

1238
01:00:43,390 --> 01:00:46,040
just to see the two strings as being duplicative.
只是为了看到这两个字符串是重复的。

1239
01:00:46,040 --> 01:00:46,720
So here I go.
所以我开始了。

1240
01:00:46,720 --> 01:00:50,652
Make compare dot slash compare, "hi" exclamation point,
Make compare 点斜杠 compare，"hi" 感叹号，



1241
01:00:50,652 --> 01:00:51,610
"hi" exclamation point.
“hi”感叹号。

1242
01:00:51,610 --> 01:00:53,510
And of course, they're actually the same.
当然，它们实际上是相同的。

1243
01:00:53,510 --> 01:00:56,830
But if I actually want to see where s and t are,
但如果我想真正地看到 s 和 t 在哪里，

1244
01:00:56,830 --> 01:00:59,650
I can change the % s to what?
我可以将 %s 更改为？

1245
01:00:59,650 --> 01:01:02,200
%p, %p here.
%p，%p 在这里。

1246
01:01:02,200 --> 01:01:05,020
And I don't need to use an ampersand before the s or the t
我不需要在 s 或 t 前面使用取地址符

1247
01:01:05,020 --> 01:01:06,700
because they are already addresses.
因为它们已经是地址了。

1248
01:01:06,700 --> 01:01:08,480
That was today's big reveal.
这就是今天的重大发现。

1249
01:01:08,480 --> 01:01:12,050
And it turns out that printf is smart enough when you use s,
事实证明，当你使用 s 时，printf 足够聪明，

1250
01:01:12,050 --> 01:01:18,280
and you give it an address of s, or the address in t, to just go there for you.
并且你给它一个 s 的地址，或者 t 中的地址，它会自动为你跳转到那里。

1251
01:01:18,280 --> 01:01:21,025
So printf has been doing all of that for us with %s.
所以 printf 一直在用 %s 为我们做这些。

1252
01:01:21,025 --> 01:01:24,070
But %p is actually going to print out those raw addresses.
但 %p 实际上会打印出这些原始地址。

1253
01:01:24,070 --> 01:01:28,330
So let me do make compare, dot slash compare, "hi" once, "hi" twice.
所以让我执行 make compare，然后 ./compare，“hi” 一次，“hi” 两次。

1254
01:01:28,330 --> 01:01:34,120
And here now, we should see the addresses at which "hi" lives.
现在这里，我们应该看到 “hi” 所处的地址。

1255
01:01:34,120 --> 01:01:37,870
And it's not going to be as simplistic as OX123 and OX456.
而且它不会像 OX123 和 OX456 那样简单。

1256
01:01:37,870 --> 01:01:40,540
But if I go back to my terminal and hit enter,
但如果我回到我的终端并按回车键，

1257
01:01:40,540 --> 01:01:43,480
indeed, I get two different hexadecimal values
确实，我得到了两个不同的十六进制值

1258
01:01:43,480 --> 01:01:46,870
that makes clear that, if I were to naively compare them with equals,
这清楚地表明，如果我天真地用等于号进行比较，

1259
01:01:46,870 --> 01:01:49,450
equals, they're always going to be different,
等于，它们总是会不同的，

1260
01:01:49,450 --> 01:01:51,740
even if I typed in the same words.
即使我输入了相同的词。

1261
01:01:51,740 --> 01:01:54,850
So there's implications now of this, especially if we want
所以现在这里有影响，特别是如果我们想要

1262
01:01:54,850 --> 01:01:56,960
to start changing things in memory.
开始更改内存中的东西。

1263
01:01:56,960 --> 01:02:00,490
So for instance, let me create a new program called copy.c.
例如，让我创建一个名为 copy.c 的新程序。

1264
01:02:00,490 --> 01:02:04,240
And in here, we'll start somewhat similarly with CS5o.h.
在这里，我们将使用 CS5o.h 开始类似的处理。

1265
01:02:04,240 --> 01:02:09,070
We'll start with standard io.h.
我们将从 stdio.h 开始。

1266
01:02:09,070 --> 01:02:13,730
And preemptively, I'm going to go ahead and include string.h, as well.
为了提前准备，我将继续包含 string.h。

1267
01:02:13,730 --> 01:02:16,750
I'm going to declare main as not taking any command line arguments.
我将声明 main 不接受任何命令行参数。

1268
01:02:16,750 --> 01:02:20,050
And this time, I'm just going to get one string s with getstring,
这次，我将使用 getstring 获取一个字符串 s，

1269
01:02:20,050 --> 01:02:22,540
and I'll prompt the user for s.
我将提示用户输入 s。

1270
01:02:22,540 --> 01:02:24,730
And now, let me go ahead and naively say this.
现在，让我天真地说一下。

1271
01:02:24,730 --> 01:02:28,660
Let me give myself a new string called t and just set it equal to s,
让我给自己一个新的名为 t 的字符串，并将其设置为等于 s，

1272
01:02:28,660 --> 01:02:31,672
my instinct being this is how I've copied integers before.
我的直觉是，这就是我之前复制整数的方式。

1273
01:02:31,672 --> 01:02:33,880
This is how I've copied floating point values before.
这就是我之前复制浮点数的方式。

1274
01:02:33,880 --> 01:02:38,800
This surely is how I copy strings, using the assignment operator as usual.
这肯定是我复制字符串的方式，像往常一样使用赋值运算符。

1275
01:02:38,800 --> 01:02:40,810
Let me now for the sake of discussion propose
现在为了讨论起见，我提议

1276
01:02:40,810 --> 01:02:43,480
that I want to capitalize the first letter in t,
我想将 t 中的第一个字母大写，

1277
01:02:43,480 --> 01:02:45,330
but not the first letter in s.
但不要将 s 中的第一个字母大写。

1278
01:02:45,330 --> 01:02:50,590
So logically, based on week two syntax, I'm going to go into the t string,
所以从逻辑上讲，基于第二周的语法，我将进入 t 字符串，

1279
01:02:50,590 --> 01:02:58,180
go to location zero, and set it equal to upper of t bracket zero.
转到位置零，并将其设置为 t 中括号内的第一个字母的大写。

1280
01:02:58,180 --> 01:02:59,980
So recall, we introduced two upper.
还记得我们介绍了两个 upper 函数吗？

1281
01:02:59,980 --> 01:03:02,140
It's just a handy function for capitalizing things.
它只是一个用于将字符大写的便捷函数。

1282
01:03:02,140 --> 01:03:04,510
There's two lower, and there's a bunch of others, as well.
还有两个 lower 函数，以及很多其他的函数。

1283
01:03:04,510 --> 01:03:07,385
I didn't include the header file yet, though, so I'm going to go back
不过，我还没有包含头文件，所以我要回去

1284
01:03:07,385 --> 01:03:08,050
and include--
包含--

1285
01:03:08,050 --> 01:03:10,120
anyone remember where these are?
有人记得这些函数在哪里吗？

1286
01:03:10,120 --> 01:03:11,860
Yeah, ctype.h.
是的，ctype.h。

1287
01:03:11,860 --> 01:03:14,600
And it's fine to look that up in the menu if you ever need it.
如果你需要，可以在菜单中查找。

1288
01:03:14,600 --> 01:03:19,150
So here, I am, a little naively, capitalizing the first letter in t.
所以这里，我有点天真地将 t 中的第一个字母大写。

1289
01:03:19,150 --> 01:03:21,850
Technically speaking, I should check what the length of t
从技术上讲，我应该检查 t 的长度

1290
01:03:21,850 --> 01:03:25,772
is first, because if there's no characters there, if it has zero chars,
首先，因为如果那里没有字符，如果它有零个字符，

1291
01:03:25,772 --> 01:03:26,980
there's nothing to uppercase.
就没有什么可以大写的。

1292
01:03:26,980 --> 01:03:30,190
But for now, I'm going to keep it simple and just blindly do that there.
但现在，我会保持简单，直接盲目地执行。

1293
01:03:30,190 --> 01:03:34,510
Now, let me go ahead and print out with %s the value of s.
现在，让我继续用 %s 打印出 s 的值。

1294
01:03:34,510 --> 01:03:38,080
Now, let me go ahead and print out with %s value of t.
现在，让我继续用 %s 打印出 t 的值。

1295
01:03:38,080 --> 01:03:43,930
And I should see one lowercase s and one capitalized T. All right, here we go.
我应该看到一个小写的 s 和一个大写的 T。好的，我们来试试看。

1296
01:03:43,930 --> 01:03:46,875
Make copy, dot slash copy.
执行 make copy，然后 ./copy。

1297
01:03:46,875 --> 01:03:49,000
And I'm going to deliberately type it in lowercase.
我将故意用小写字母输入。

1298
01:03:49,000 --> 01:03:55,810
"hi" exclamation point, and we should see now they're both capitalized,
“hi”感叹号，现在我们应该看到它们都变成了大写，

1299
01:03:55,810 --> 01:03:57,340
it would seem.
看起来是这样。

1300
01:03:57,340 --> 01:04:00,295
Intuitively, why might that be?
直觉上，为什么会出现这种情况呢？

1301
01:04:02,950 --> 01:04:05,090
Exactly, the addresses are the same.
没错，地址是一样的。

1302
01:04:05,090 --> 01:04:10,030
So if I do use the assignment operator and just do t equals s semicolon,
所以如果我使用赋值运算符，并且只是执行 t 等于 s 分号，

1303
01:04:10,030 --> 01:04:14,950
it's going to take me literally and copy the address in s over to t,
它将从字面上将 s 中的地址复制到 t 中，

1304
01:04:14,950 --> 01:04:17,330
so that effectively, they're pointing at the same thing.
因此，实际上，它们指向同一个东西。

1305
01:04:17,330 --> 01:04:21,000
So if we draw another picture here, for instance, here maybe is s,
所以如果我们在这里再画一张图，例如，这里可能是 s，

1306
01:04:21,000 --> 01:04:23,800
and here maybe is the lowercase "hi" that I first type
这里可能是第一次输入的小写 “hi”

1307
01:04:23,800 --> 01:04:25,270
in down here in memory.
在内存中的下方。

1308
01:04:25,270 --> 01:04:28,660
Maybe that's at OX123 again, and therefore that's what's in s.
也许它再次在 OX123 上，因此这就是 s 中的内容。

1309
01:04:28,660 --> 01:04:33,340
When I then create the variable t by declaring it to be a string,
当我随后声明变量 t 为一个字符串时，

1310
01:04:33,340 --> 01:04:36,160
as well, that gives me another variable here called t.
它也给了我一个名为 t 的变量。

1311
01:04:36,160 --> 01:04:38,665
But I'm just setting it equal to s.
但我只是将它设置为等于 s。

1312
01:04:38,665 --> 01:04:41,710
I'm not calling getstring again in this version of copy.
在这个版本的 copy 中，我没有再次调用 getstring。

1313
01:04:41,710 --> 01:04:43,030
That was in compare.
那是在 compare 中。

1314
01:04:43,030 --> 01:04:46,290
In copy, I'm just literally copying s into t.
在 copy 中，我仅仅是字面上将 s 复制到 t 中。

1315
01:04:46,290 --> 01:04:50,370
So that literally just changes the value to OX123, also.
所以它从字面上将值更改为 OX123。

1316
01:04:50,370 --> 01:04:52,440
And if we abstract away all of these addresses,
如果我们抽象掉所有这些地址，

1317
01:04:52,440 --> 01:04:56,920
that's essentially like s and t both pointing to the same place.
本质上就像 s 和 t 都指向同一个位置。

1318
01:04:56,920 --> 01:05:02,560
So if I use s bracket zero, or t bracket zero, they are one and the same.
所以如果我使用 s 括号中的第一个字母，或者 t 括号中的第一个字母，它们是一样的。

1319
01:05:02,560 --> 01:05:05,220
So when I use t bracket zero to use uppercase,
所以当我使用 t 括号内的第一个字母来使用 uppercase 时，

1320
01:05:05,220 --> 01:05:08,070
it's changing that lowercase h to capital H.
它将小写 h 更改为大写 H。

1321
01:05:08,070 --> 01:05:13,980
But again, both strings, both pointers are pointing at the same value.
但再次强调，这两个字符串，两个指针都指向同一个值。

1322
01:05:13,980 --> 01:05:17,130
And again, this should be even clearer as of today.
而且，从今天开始，这一点应该更加清楚。

1323
01:05:17,130 --> 01:05:21,060
If I go back into VS Code and, indeed, take these training wheels off,
如果我回到 VS Code 中，并且确实去掉了这些辅助轮，

1324
01:05:21,060 --> 01:05:25,950
and treat string as what it is, char star, which indicates that both s and t
并将字符串视为它本来的样子，char *，这表明 s 和 t 都是

1325
01:05:25,950 --> 01:05:29,700
are just addresses, which makes even clearer, syntactically,
地址，从语法上讲，这更加清楚地表明，

1326
01:05:29,700 --> 01:05:33,640
that this is probably the picture that's going on underneath the hood.
这可能是在幕后发生的事情。

1327
01:05:33,640 --> 01:05:35,640
Now, just to make the code a little more robust,
现在，为了使代码更加健壮，

1328
01:05:35,640 --> 01:05:38,190
let me at least be a little careful here.
至少让我在这里小心一点。

1329
01:05:38,190 --> 01:05:44,530
If the string length of t is greater than zero, then and only then,
如果 t 的字符串长度大于零，那么也只有在此时，

1330
01:05:44,530 --> 01:05:48,880
should I really blindly index into the string and go to location zero.
我才应该盲目地索引到字符串中，并转到位置零。

1331
01:05:48,880 --> 01:05:51,310
That doesn't really solve the fundamental problem,
这并不能真正解决根本问题，



1332
01:05:51,310 --> 01:05:54,640
but it at least avoids a situation where maybe the user just hits enter,
但至少它避免了一种情况，即用户可能只是按下了回车键，

1333
01:05:54,640 --> 01:05:56,800
gives me no characters, and I try to blindly
没有给我任何字符，我尝试盲目地

1334
01:05:56,800 --> 01:05:59,180
uppercase something that's not there.
将不存在的东西大写。

1335
01:05:59,180 --> 01:06:00,377
But there's still a bug.
但仍然存在一个错误。

1336
01:06:00,377 --> 01:06:01,210
There's still a bug.
仍然存在一个错误。

1337
01:06:01,210 --> 01:06:03,290
So how do I actually solve this?
那么我该如何解决这个问题呢？

1338
01:06:03,290 --> 01:06:05,260
Well, it turns out we need two other functions
事实证明，我们需要另外两个函数

1339
01:06:05,260 --> 01:06:06,873
that we haven't had occasion to use.
我们还没有机会使用。

1340
01:06:06,873 --> 01:06:09,040
But these are perhaps the most powerful, and they're
但它们可能是最强大的，而且它们

1341
01:06:09,040 --> 01:06:11,860
going to allow us to solve even grander problems next week when
将在下周我们讨论更大型事物，即数据结构时，让我们解决更大的问题。

1342
01:06:11,860 --> 01:06:14,540
we discuss all the more, things called data structures.
我们讨论更大型事物，即数据结构时，让我们解决更大的问题。

1343
01:06:14,540 --> 01:06:19,160
But for now, let's very simply solve this idea of copying a string.
但现在，让我们非常简单地解决这个复制字符串的想法。

1344
01:06:19,160 --> 01:06:24,100
Let me go back into VS Code here, and let me give myself one more header file
让我回到 VS Code 中，再给自己添加一个头文件

1345
01:06:24,100 --> 01:06:26,810
that's called standard lib for standard library.
名为 standard lib，用于标准库。

1346
01:06:26,810 --> 01:06:31,420
So include standard lib dot h, in which both of these functions,
所以包含 standard lib.h，这两个函数都在里面，

1347
01:06:31,420 --> 01:06:33,670
malloc and free, are declared for me.
malloc 和 free，都已为我声明。

1348
01:06:33,670 --> 01:06:37,300
And now, in my code, I'm going to behave a little bit differently here.
现在，在我的代码中，我将在这里稍作更改。

1349
01:06:37,300 --> 01:06:40,900
Clearly, I got into trouble by just blindly copying the addresses.
显然，我只是盲目地复制地址，因此遇到了麻烦。

1350
01:06:40,900 --> 01:06:43,960
What I really want to do when I copy strings, presumably, and then
我想做的，假设，是在我复制字符串，然后

1351
01:06:43,960 --> 01:06:47,530
uppercase one of them, is I want to create
将其中一个大写，我想创建一个

1352
01:06:47,530 --> 01:06:51,160
a duplicate string, a second array that is identical,
一个重复的字符串，一个与之相同的第二个数组，

1353
01:06:51,160 --> 01:06:52,970
but is elsewhere in memory.
但它在内存中的其他位置。

1354
01:06:52,970 --> 01:06:55,520
So the way to do this might be as follows.
所以，可以这样做。

1355
01:06:55,520 --> 01:06:59,470
Instead of just setting t equal to s, I should really
我应该真正调用这个名为 malloc 的新函数，而不是仅仅将 t 设置为 s，

1356
01:06:59,470 --> 01:07:02,050
call this brand new function called malloc,
我应该真正调用这个名为 malloc 的新函数，

1357
01:07:02,050 --> 01:07:06,020
which stands for memory allocate, and it takes a single argument,
它代表内存分配，并且它接受一个参数，

1358
01:07:06,020 --> 01:07:09,010
which is just the number of bytes you would like the operating system
它只是你想让操作系统分配给你的字节数。

1359
01:07:09,010 --> 01:07:10,400
to allocate for you.
分配给你的字节数。

1360
01:07:10,400 --> 01:07:13,700
So whether you're using this on Windows, Mac OS, or Linux in our case,
所以无论你在我们的情况下是在 Windows、Mac OS 还是 Linux 上使用它，

1361
01:07:13,700 --> 01:07:16,060
this is a way I can literally ask the operating system,
这是一种我可以直接向操作系统询问的方法，

1362
01:07:16,060 --> 01:07:19,330
please find for me some number of bytes in the computer's memory
请在计算机内存中为我找到一些字节

1363
01:07:19,330 --> 01:07:21,740
that I can now use for my own purposes.
我现在可以用来做自己的事情。

1364
01:07:21,740 --> 01:07:24,978
So malloc here, I technically need at least three bytes,
所以这里的 malloc，我技术上至少需要 3 个字节，

1365
01:07:24,978 --> 01:07:26,770
but that's not going to be enough because I
但这还不够，因为我

1366
01:07:26,770 --> 01:07:28,490
need a fourth for the null character.
需要第四个字节来存储空字符。

1367
01:07:28,490 --> 01:07:29,560
So I could put four here.
所以我可以在这里放四个字节。

1368
01:07:29,560 --> 01:07:30,340
But that's stupid.
但那很愚蠢。

1369
01:07:30,340 --> 01:07:33,070
I shouldn't just hardcode a number like this we've seen.
我们已经看到，我不应该像这样硬编码一个数字。

1370
01:07:33,070 --> 01:07:38,392
So I could probably do strlen of s to dynamically figure out
所以我可以动态地使用 strlen(s) 来计算出

1371
01:07:38,392 --> 01:07:39,850
how many bytes I want for the copy.
我想要复制多少字节。

1372
01:07:39,850 --> 01:07:42,160
But that, too, is not enough because string length
但这也不够，因为字符串长度

1373
01:07:42,160 --> 01:07:46,630
returns the human readable length, so H-I exclamation point.
返回的是人类可读的长度，所以是 H-I 感叹号。

1374
01:07:46,630 --> 01:07:48,480
So I think I want a plus one in there, too.
所以我想在那里加一个一。

1375
01:07:48,480 --> 01:07:51,188
So that just means get the length of whatever the human typed in,
所以这意味着获取人类输入的长度，

1376
01:07:51,188 --> 01:07:54,810
add one for the null character to make sure that we're not undercounting.
加一，以确保我们没有少算。

1377
01:07:54,810 --> 01:07:56,520
Now, what can I then do?
现在，我该怎么办呢？

1378
01:07:56,520 --> 01:07:59,050
Unfortunately, I need to do a bit of work here.
不幸的是，我需要在这里做一些工作。

1379
01:07:59,050 --> 01:08:02,310
So let me actually go ahead now and do something like this.
所以现在让我实际去做一些类似的事情。

1380
01:08:02,310 --> 01:08:10,740
For int i equals zero, I is less than the string length of s, i plus, plus.
对于 int i 等于 0，i 小于 s 的字符串长度，i 加加。

1381
01:08:10,740 --> 01:08:15,540
And then inside of this loop, I could copy into the ith location of t,
然后在这个循环里面，我可以将 s 的第 i 个位置复制到 t 的第 i 个位置。

1382
01:08:15,540 --> 01:08:17,970
whatever is in the ith location of s.
复制 s 的第 i 个位置的内容。

1383
01:08:17,970 --> 01:08:20,609
Now, this is a little buggy.
现在，这有点小错误。

1384
01:08:20,609 --> 01:08:23,763
One, this is inefficient to keep asking this question.
第一，这在设计上是不高效的，因为不断地问这个问题。

1385
01:08:23,763 --> 01:08:25,680
We talked about this in the context of design.
我们在设计背景下讨论过这个问题。

1386
01:08:25,680 --> 01:08:29,580
I should probably improve this by giving myself a variable like n,
我应该通过给自己一个像 n 这样的变量来改进它，

1387
01:08:29,580 --> 01:08:33,450
set that equal to the string length, and then do i is less than n
将其设置为字符串长度，然后执行 i 小于 n

1388
01:08:33,450 --> 01:08:35,520
again, and again, just so I'm not stupidly
一遍又一遍，这样我就不会愚蠢地

1389
01:08:35,520 --> 01:08:38,580
calling string length four different times, or three different times.
四次或三次调用字符串长度。

1390
01:08:38,580 --> 01:08:42,359
But this, too, is slightly buggy, and this one's very subtle.
但这也有点小错误，而且这个错误很微妙。

1391
01:08:42,359 --> 01:08:47,740
This does not fully copy s into t.
这并没有完全将 s 复制到 t 中。

1392
01:08:47,740 --> 01:08:54,069
Does anyone see the very subtle bug that I've introduced?
有人注意到我引入的这个非常微妙的错误吗？

1393
01:08:54,069 --> 01:08:55,660
Sorry?
抱歉？

1394
01:08:55,660 --> 01:08:58,120
Yeah, I'm forgetting the backslash zero.
是的，我忘记了反斜杠零。

1395
01:08:58,120 --> 01:09:00,340
So even though I'm copying H-I exclamation point,
所以即使我复制了 H-I 感叹号，

1396
01:09:00,340 --> 01:09:04,240
or whatever the human typed in, I need to go one step further deliberately
或者人类输入的任何内容，我需要有意地再走一步

1397
01:09:04,240 --> 01:09:07,180
to make sure I also copy the backslash zero,
以确保我也复制了反斜杠零，

1398
01:09:07,180 --> 01:09:09,250
or at least manually put it in myself.
或者至少手动添加它。

1399
01:09:09,250 --> 01:09:14,215
So I could solve this by, either doing this up to and through n,
所以我可以通过以下方法解决这个问题：要么这样做，直到 n，

1400
01:09:14,215 --> 01:09:17,620
i is less than or equal to n, or I could plus one here.
i 小于或等于 n，或者我可以在此处加 1。

1401
01:09:17,620 --> 01:09:18,859
That, too, would be fine.
这样也可以。

1402
01:09:18,859 --> 01:09:25,510
Or if I really want, I could do this, like t bracket
或者，如果我真的想，我可以这样做，比如 t 括号

1403
01:09:25,510 --> 01:09:27,673
three equals, quote unquote, backslash zero.
三个等于号，引号，反斜杠零。

1404
01:09:27,673 --> 01:09:30,340
But again, I shouldn't get into the habit of hard coding things.
但同样地，我不应该养成硬编码的习惯。

1405
01:09:30,340 --> 01:09:37,029
I could do string length of s, and that would give me the last location in s,
我可以执行 strlen(s)，这会给我 s 的最后一个位置，

1406
01:09:37,029 --> 01:09:38,200
which would also work.
这样也可以。

1407
01:09:38,200 --> 01:09:39,620
But that, too, is stupid.
但这也很愚蠢。

1408
01:09:39,620 --> 01:09:40,540
I might as well--
我也可以

1409
01:09:40,540 --> 01:09:42,250
or just unnecessarily complex.
或者只是不必要的复杂。

1410
01:09:42,250 --> 01:09:44,460
Let's just do this, change one symbol, and boom.
让我们这样做，改变一个符号，然后砰的一声。

1411
01:09:44,460 --> 01:09:49,800
Now we're copying all three, and the fourth character, as well.
现在我们正在复制所有三个字符，以及第四个字符。

1412
01:09:49,800 --> 01:09:52,380
All right, so with this said, let's go ahead now
好的，说了这么多，现在让我们

1413
01:09:52,380 --> 01:09:56,310
and make sure that t is indeed of length at least greater than zero.
确保 t 的长度至少大于 0。

1414
01:09:56,310 --> 01:09:59,830
Then let's go ahead and capitalize t as before and print out the results.
然后让我们像之前一样将 t 大写并打印出结果。

1415
01:09:59,830 --> 01:10:04,212
So let me go ahead and open my terminal window, make copy, dot slash copy,
所以，让我打开我的终端窗口，复制，点斜杠 copy，

1416
01:10:04,212 --> 01:10:06,420
and I'm going to deliberately type "hi" in lowercase.
我要故意用小写输入 "hi"。

1417
01:10:06,420 --> 01:10:10,380
And now we should see disparate s and t.
现在我们应该看到 s 和 t 不同。

1418
01:10:10,380 --> 01:10:14,760
s is now still lowercase, and T is now capitalized.
s 现在仍然是小写，而 T 现在是大写的。

1419
01:10:14,760 --> 01:10:16,980
But why is that exactly?
但为什么正是这样呢？

1420
01:10:16,980 --> 01:10:21,060
Well, let me actually go into, say, my computer's memory
好吧，让我实际进入，比如，我的计算机内存

1421
01:10:21,060 --> 01:10:24,210
again and propose that, if what I had before
再次，并提出，如果我之前拥有的

1422
01:10:24,210 --> 01:10:27,090
was this situation, where s is pointing at this chunk of memory,
是这种情况，s 指向这块内存，

1423
01:10:27,090 --> 01:10:30,660
and t was accidentally pointing in that same chunk of memory, what we really
而 t 意外地指向了同一块内存，我们真正

1424
01:10:30,660 --> 01:10:33,750
want to do is have t point at a new chunk of memory.
想要做的就是让 t 指向一块新的内存。


1425
01:10:33,750 --> 01:10:36,660
And malloc is what gives us this chunk of memory.
而 malloc 就是让我们获得这块内存的工具。

1426
01:10:36,660 --> 01:10:41,490
And then using that for loop, can I copy the H, the I, the exclamation point,
然后使用那个 for 循环，我可以复制 H、I、感叹号，

1427
01:10:41,490 --> 01:10:44,020
and even the backslash zero.
甚至包括反斜杠零。

1428
01:10:44,020 --> 01:10:48,280
So now, this is a little subtle, but malloc is what gives me
现在，这有点微妙，但 malloc 就是给我

1429
01:10:48,280 --> 01:10:50,620
access to this new chunk of memory.
访问这块新内存的方法。

1430
01:10:50,620 --> 01:10:55,060
Malloc takes one argument, the number of bytes that you want it to find for you.
Malloc 接受一个参数，即你想要它为你找到的字节数。

1431
01:10:55,060 --> 01:10:56,020
Take a guess.
猜猜看。

1432
01:10:56,020 --> 01:11:00,970
What value is malloc returning?
Malloc 返回的是什么值？

1433
01:11:00,970 --> 01:11:06,220
Conceptually, it's returning a chunk of memory, but that's kind of handwavy.
从概念上讲，它返回的是一块内存，但这有点含糊。

1434
01:11:06,220 --> 01:11:08,200
What might malloc actually be returning?
Malloc 实际上返回的可能是？

1435
01:11:08,200 --> 01:11:10,675
AUDIENCE: Maybe the pointer to the first character?
听众：可能是指向第一个字符的指针？

1436
01:11:10,675 --> 01:11:11,710
SPEAKER 1: Perfect.
演讲者 1：完美！

1437
01:11:11,710 --> 01:11:17,050
malloc is returning the address of that chunk of memory, not the last address.
Malloc 返回的是那块内存的地址，而不是最后一个地址。

1438
01:11:17,050 --> 01:11:18,220
The first address.
第一个地址。

1439
01:11:18,220 --> 01:11:20,050
And here's a difference with strings.
这里与字符串有所不同。

1440
01:11:20,050 --> 01:11:23,710
This chunk of memory is not magically terminated with null for you.
这块内存不会自动以空字符结尾。

1441
01:11:23,710 --> 01:11:27,580
I had to do that with for loop. malloc, and in turn, your operating system,
我必须使用 for 循环来完成。Malloc，以及你的操作系统，

1442
01:11:27,580 --> 01:11:30,560
does keep track of how big these chunks of memory are.
会跟踪这些内存块的大小。

1443
01:11:30,560 --> 01:11:32,770
So even though it's only returning the address
所以，即使它只返回

1444
01:11:32,770 --> 01:11:35,860
of the first byte of that memory, the operating system
第一个字节的地址，操作系统

1445
01:11:35,860 --> 01:11:39,582
is going to know that it used up four bytes here, four bytes here.
会知道这里用了四个字节，这里用了四个字节。

1446
01:11:39,582 --> 01:11:41,290
And it will keep track of that so that it
它会跟踪这些信息，以便它

1447
01:11:41,290 --> 01:11:43,570
doesn't give you an overlapping address in the future
不会在将来给你一个重叠的地址

1448
01:11:43,570 --> 01:11:44,380
because that would be bad.
因为那样会很糟糕。

1449
01:11:44,380 --> 01:11:45,670
Your data would get corrupted.
你的数据会损坏。

1450
01:11:45,670 --> 01:11:50,500
But you, similarly, have to remember or figure out how many bytes are available
但你同样需要记住或弄清楚还有多少字节可用

1451
01:11:50,500 --> 01:11:51,070
thereafter.
之后。

1452
01:11:51,070 --> 01:11:54,970
It's up to you to manage it, as by putting a null character there
你需要自己管理它，例如通过在里面放入一个空字符

1453
01:11:54,970 --> 01:11:55,970
yourself.
自己完成。

1454
01:11:55,970 --> 01:11:58,480
So if I go back to my code now, let me actually
所以，如果我现在回到我的代码，让我实际

1455
01:11:58,480 --> 01:12:02,090
harden this code just a little bit more as follows,
稍微加强一下这段代码，如下所示，

1456
01:12:02,090 --> 01:12:05,450
whereby I can do this a little better.
这样我就能更好地做到这一点。

1457
01:12:05,450 --> 01:12:10,010
If I go back to VS Code here, it turns out, if something goes wrong
如果我回到这里 VS Code，结果发现，如果出现错误

1458
01:12:10,010 --> 01:12:12,470
and I'm out of memory, maybe I've got an old computer,
而且我的内存不足，也许我的电脑太旧了，

1459
01:12:12,470 --> 01:12:15,732
or maybe I'm typing something way bigger than three characters in,
或者我输入了超过三个字符的文本，

1460
01:12:15,732 --> 01:12:17,690
like three billion characters, and the computer
比如三十亿个字符，而电脑

1461
01:12:17,690 --> 01:12:19,310
might genuinely run out of memory.
可能真的会内存不足。

1462
01:12:19,310 --> 01:12:21,410
I actually should be in the habit of doing this.
我实际上应该养成这样的习惯。

1463
01:12:21,410 --> 01:12:27,320
If t equals, equals a special symbol called null with two Ls,
如果 t 等于等于一个名为 null 的特殊符号，有两个 L，

1464
01:12:27,320 --> 01:12:29,330
and I promised this would eventually exist,
我承诺过这个符号最终会存在，

1465
01:12:29,330 --> 01:12:32,750
I should just return one now, or return two, return negative one,
我应该现在就返回 1，或者返回 2，返回负 1，

1466
01:12:32,750 --> 01:12:37,340
return any value other than zero, and just abort the program early.
返回任何非零值，并提前终止程序。

1467
01:12:37,340 --> 01:12:42,230
That means, if malloc returns null, there's not enough memory available.
这意味着，如果 malloc 返回空，则意味着可用内存不足。

1468
01:12:42,230 --> 01:12:45,260
And it turns out, all this time, I'm going to do one other crazy thing,
结果发现，一直以来，我还要做一件疯狂的事，

1469
01:12:45,260 --> 01:12:47,660
even though we've not expected you to do this thus far.
尽管我们之前没有期望你这样做。

1470
01:12:47,660 --> 01:12:50,180
Technically, when using getstring, getstring,
从技术上讲，当使用 getstring 时，getstring，

1471
01:12:50,180 --> 01:12:53,960
if you read the documentation, the manual, it too can return null.
如果你阅读文档，手册，它也可以返回空。

1472
01:12:53,960 --> 01:12:56,300
Because if you type in a crazy long string,
因为如果你输入一个很长的字符串，

1473
01:12:56,300 --> 01:12:58,340
and the computer can't fit it in its memory,
而电脑无法将其存储在内存中，

1474
01:12:58,340 --> 01:13:00,440
getstring needs to signal that to you somehow.
getstring 需要以某种方式向你发出信号。

1475
01:13:00,440 --> 01:13:05,940
And the documentation actually says that, if getstring returns null,
文档实际上说，如果 getstring 返回空，

1476
01:13:05,940 --> 01:13:08,750
then you too should not trust what's in it.
那你也不应该相信里面的内容。

1477
01:13:08,750 --> 01:13:12,710
You should just exit the program immediately, in this case.
在这种情况下，你应该立即退出程序。

1478
01:13:12,710 --> 01:13:15,648
But there's one other improvement we can make here.
但我们这里还可以进行另一个改进。

1479
01:13:15,648 --> 01:13:18,440
And even though this is making the code seem way longer than it is,
尽管这使得代码看起来比实际长很多，

1480
01:13:18,440 --> 01:13:20,750
most of this I've just added is just error checking,
但我添加的大部分内容都是错误检查，

1481
01:13:20,750 --> 01:13:24,680
just mindless error checking to make sure that I don't treat s as being
只是机械地检查错误，确保我不将 s 视为

1482
01:13:24,680 --> 01:13:27,020
valid, or t as being valid when it isn't.
有效的，或者将 t 视为有效的，而实际上它不是。

1483
01:13:27,020 --> 01:13:28,290
It turns out this is stupid.
结果发现，这很愚蠢。

1484
01:13:28,290 --> 01:13:29,790
I don't need to reinvent this wheel.
我不需要重新发明轮子。

1485
01:13:29,790 --> 01:13:32,900
Certainly, for decades, people have been copying strings, even in C.
当然，几十年来，人们一直在复制字符串，即使是在 C 语言中。

1486
01:13:32,900 --> 01:13:36,350
So it turns out there's another fun function called strcopy, wonderfully
结果发现，还有一个有趣的函数叫做 strcopy，非常棒

1487
01:13:36,350 --> 01:13:39,440
enough, that takes the destination as its first argument,
而且它将目标作为第一个参数，

1488
01:13:39,440 --> 01:13:41,610
the source as its second argument.
源作为第二个参数。

1489
01:13:41,610 --> 01:13:46,500
And that will for me copy s into t, respectively.
它会帮我将 s 复制到 t 中，分别。

1490
01:13:46,500 --> 01:13:51,380
So that does the equivalent of that for loop, including the backslash zero.
所以它等效于那个 for 循环，包括反斜杠零。

1491
01:13:51,380 --> 01:13:55,310
However, there's one other function recall that was on our cheat sheet
但是，还记得我们之前的备忘单上有一个函数

1492
01:13:55,310 --> 01:13:58,100
a moment ago, whereby malloc is accompanied
吗？它就是 malloc，它伴随着

1493
01:13:58,100 --> 01:14:00,110
by one other function called Free.
另一个函数，叫做 Free。

1494
01:14:00,110 --> 01:14:02,090
So Free is the opposite of malloc.
所以 Free 是 malloc 的反向操作。

1495
01:14:02,090 --> 01:14:04,040
When you're done with your computer's memory,
当你不再需要电脑的内存时，

1496
01:14:04,040 --> 01:14:07,070
you're supposed to give it back to Windows, to Mac OS, to Linux
你应该把它还给 Windows、Mac OS 或者 Linux，

1497
01:14:07,070 --> 01:14:09,320
so it can reuse it for something else.
以便它可以将其用于其他用途。

1498
01:14:09,320 --> 01:14:12,350
And frankly, if you've ever been using your computer for hours
坦白地说，如果你曾经连续使用电脑数小时

1499
01:14:12,350 --> 01:14:15,720
on end, days on end, and maybe it's getting slower, and slower,
甚至连续使用数天，可能电脑会变得越来越慢，

1500
01:14:15,720 --> 01:14:18,470
maybe it's Photoshop, maybe it's a really big document, generally,
可能是 Photoshop，也可能是一个很大的文档，一般来说，

1501
01:14:18,470 --> 01:14:20,840
really big files consume lots and lots of memory.
很大的文件会占用很多内存。

1502
01:14:20,840 --> 01:14:24,320
If the humans who wrote that software, be it Photoshop or something else,
如果编写该软件的人，无论是 Photoshop 还是其他软件，

1503
01:14:24,320 --> 01:14:29,150
wrote buggy code and kept using malloc, malloc, malloc, malloc, asking
写了有错误的代码，并不断使用 malloc，malloc，malloc，malloc，请求

1504
01:14:29,150 --> 01:14:32,780
for more and more memory, but they never call the opposite function, Free,
越来越多的内存，但他们从未调用反向函数 Free，

1505
01:14:32,780 --> 01:14:34,820
your computer might actually run out of memory.
你的电脑可能会真的内存不足。

1506
01:14:34,820 --> 01:14:37,130
And typically, the symptom is that it gets so darn
而典型的症状是电脑会变得非常慢，

1507
01:14:37,130 --> 01:14:38,720
slow it becomes annoying to use.
慢到让人厌烦。

1508
01:14:38,720 --> 01:14:42,230
And frankly, the mouse starts moving very slowly, maybe the thing freezes
坦白地说，鼠标开始移动得很慢，可能电脑会完全卡住

1509
01:14:42,230 --> 01:14:43,880
altogether, the computer crashes.
甚至崩溃。

1510
01:14:43,880 --> 01:14:46,080
Bad things happen when you run out of memory.
内存不足时，会发生不好的事情。

1511
01:14:46,080 --> 01:14:48,800
So in my case here, if I go back to VS Code,
所以，在我的例子中，如果我回到 VS Code，

1512
01:14:48,800 --> 01:14:53,300
it's actually on me in this language called C to actually manage
实际上，在这门叫做 C 的语言中，我需要自己管理

1513
01:14:53,300 --> 01:14:57,530
the memory myself so that, when I have called malloc,
内存，以便在我调用 malloc 之后，

1514
01:14:57,530 --> 01:15:00,753
thereafter, I had better free that same memory.
我最好释放相同的内存。

1515
01:15:00,753 --> 01:15:02,420
Now, I don't want to free it right away.
当然，我不想马上释放它。

