1
00:00:00,000 --> 00:00:02,994
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,377 --> 00:01:04,590
DAVID MALAN: All right, this is CS50.
大卫·马兰：好的，这里是 CS50。

3
00:01:04,590 --> 00:01:05,700
And this is week 3.
这是第三周。

4
00:01:05,700 --> 00:01:09,420
And as promised, we thought we'd take a bit of a break on new syntax this week
正如承诺的那样，我们想在这周稍微休息一下新的语法

5
00:01:09,420 --> 00:01:12,300
and focus a lot more on algorithms and implementation
更多地关注算法和实现

6
00:01:12,300 --> 00:01:15,840
thereof because over the past few weeks, besides Scratch, we've now had C.
因为在过去的几周里，除了 Scratch，我们现在还有 C。

7
00:01:15,840 --> 00:01:17,850
And you have a lot of vocabulary now.
现在你们有了很多词汇。

8
00:01:17,850 --> 00:01:20,460
Even if it might not seem yet that you fully
即使现在你们可能还没有完全

9
00:01:20,460 --> 00:01:23,790
grasp all of the functionality of this particular language, with practice,
掌握这种特定语言的所有功能，但随着练习，

10
00:01:23,790 --> 00:01:25,030
it'll get easier and easier.
会越来越容易。

11
00:01:25,030 --> 00:01:28,410
But today, we'd focus instead on ideas and ultimately on this,
但今天，我们将重点关注想法，最终关注的是，

12
00:01:28,410 --> 00:01:32,700
how to think algorithmically, and so to take problems in the real world
如何进行算法思考，以及如何将现实世界中的问题

13
00:01:32,700 --> 00:01:35,550
and try to quantize them in a way that you can map those puzzle
进行量化，以便你们能将那些难题

14
00:01:35,550 --> 00:01:39,210
pieces from week 0 or all of this new syntax from weeks 1 and 2
从第 0 周开始的拼图，或者从第 1 周和第 2 周开始的所有新的语法

15
00:01:39,210 --> 00:01:41,792
on to actually writing code to solve those problems.
映射到实际编写代码来解决这些问题。

16
00:01:41,792 --> 00:01:43,500
To contextualize this, though, we thought
为了说明这一点，我们想

17
00:01:43,500 --> 00:01:46,230
we'd remind you of this here chart from week zero.
提醒你们第零周的这张图表。

18
00:01:46,230 --> 00:01:48,900
And recall that in week zero, we painted this picture where
还记得我们在第零周画了这张图，图中

19
00:01:48,900 --> 00:01:52,320
on the x-axis on the horizontal was the size of the problem.
横坐标表示问题的规模。

20
00:01:52,320 --> 00:01:54,808
And the number of phone book pages increased
电话簿的页数随着

21
00:01:54,808 --> 00:01:56,100
as you went from left to right.
从左到右而增加。

22
00:01:56,100 --> 00:01:59,200
And then on the vertical axis or y-axis, we had time to solve.
然后在纵坐标上，我们有解决问题所需的时间。

23
00:01:59,200 --> 00:02:01,900
So this was like how many seconds, how many page turns,
所以这就像多少秒，多少页翻页，

24
00:02:01,900 --> 00:02:05,140
how many units of measure-- whatever you're using.
多少单位，无论你们使用什么。

25
00:02:05,140 --> 00:02:07,690
We might actually describe the solution there too.
我们实际上也可以在那里描述解决方案。

26
00:02:07,690 --> 00:02:10,660
And the first algorithm we had in week 0 for the phone book
在第 0 周，我们针对电话簿的第一个算法是

27
00:02:10,660 --> 00:02:12,350
was, like, one page at a time.
一次翻一页。

28
00:02:12,350 --> 00:02:14,410
So we plotted it with this 1 to 1 slope.
所以我们用 1:1 的斜率绘制了它。

29
00:02:14,410 --> 00:02:16,990
The second algorithm, we started doing two pages
第二个算法，我们开始一次翻两页

30
00:02:16,990 --> 00:02:19,000
at a time, which did risk a bug.
但这确实存在出现错误的风险。

31
00:02:19,000 --> 00:02:20,680
I might have to double back one page.
我可能需要回退一页。

32
00:02:20,680 --> 00:02:23,120
But it was still going for the most part twice as fast.
但它仍然大部分时间快了两倍。

33
00:02:23,120 --> 00:02:27,100
So it was still a slow but sort of a 2 to 1 slope instead of 1 to 1.
所以它仍然很慢，但斜率是 2:1 而不是 1:1。

34
00:02:27,100 --> 00:02:29,290
But the third and final algorithm, recall,
但第三个也是最后一个算法，还记得

35
00:02:29,290 --> 00:02:31,210
was sort of fundamentally different.
它在本质上是不同的。

36
00:02:31,210 --> 00:02:34,250
And it was this logarithmic curve, so to speak,
它是一个对数曲线，可以这么说，

37
00:02:34,250 --> 00:02:38,435
whereby it kept increasing, increasing, increasing but very, very slowly.
它不断增长，增长，增长，但非常非常慢。

38
00:02:38,435 --> 00:02:40,810
So even if you, like, doubled the size of the phone book,
所以即使你们将电话簿的大小翻倍，

39
00:02:40,810 --> 00:02:44,810
as by having Cambridge and Allston here in Massachusetts merge, no big deal.
就像让马萨诸塞州的剑桥和奥尔斯顿合并一样，没什么大不了的。

40
00:02:44,810 --> 00:02:49,190
It was just one more page turn, not another 500 or another 1,000.
只需要多翻一页，而不是多翻 500 页或 1000 页。

41
00:02:49,190 --> 00:02:54,730
So think back today on that particular idea of how we began to divide
所以今天回忆一下我们如何开始划分这个问题的具体想法

42
00:02:54,730 --> 00:02:55,900
and conquer the problem.
并征服这个问题。

43
00:02:55,900 --> 00:02:59,330
And that sort of gave us a fundamentally better advantage.
这种方法给我们带来了一个本质上更好的优势。

44
00:02:59,330 --> 00:03:02,840
So we thought we'd see if we can apply this lesson learned as follows.
所以我们想看看是否可以将这条经验教训应用到以下情况。

45
00:03:02,840 --> 00:03:06,340
If I were to take, like, attendance today sort of here on stage,
如果今天我要在这舞台上点名，

46
00:03:06,340 --> 00:03:10,870
I could do it old school, like, 1, 2, 3, 4, 5, 6, 7, 8, and so
我可以像老式那样做，像 1、2、3、4、5、6、7、8，然后继续下去，一次一步。

47
00:03:10,870 --> 00:03:13,058
forth, so one step at a time.
一次一步。

48
00:03:13,058 --> 00:03:14,350
I could also double the speed--
我也可以将速度提高一倍

49
00:03:14,350 --> 00:03:18,200
2, 4, 6, 8, 10, 12, 14, 16, and so forth.
2, 4, 6, 8, 10, 12, 14, 16, 等等。

50
00:03:18,200 --> 00:03:20,890
But I dare say we can learn a bit from week zero.
但我想我们可以在第零周学到一些东西。

51
00:03:20,890 --> 00:03:24,040
And if you'll indulge me right in place, could everyone
如果你愿意的话，请大家

52
00:03:24,040 --> 00:03:26,865
stand up and think of the number one.
站起来，想想数字 1。

53
00:03:26,865 --> 00:03:28,990
So right where you are, just stand up if you could.
就在你所在的位置，只要你能站起来就好。

54
00:03:32,650 --> 00:03:33,250
Stand up.
站起来

55
00:03:33,250 --> 00:03:34,872
And think of the number one.
想想数字 1。

56
00:03:34,872 --> 00:03:38,080
So at this point, hopefully, everyone's literally thinking of the number one.
所以，现在，希望大家都在认真地想着数字 1。

57
00:03:38,080 --> 00:03:42,010
And the second step of this algorithm, which I claim ultimately theoretically
而这个算法的第二步，我认为最终从理论上来说

58
00:03:42,010 --> 00:03:45,490
should be much faster than either my one person at a time
应该比我的一个人一次的方法快得多

59
00:03:45,490 --> 00:03:47,740
or two people at a time, step two is this.
或者两个人一次的方法，第二步就是这样。

60
00:03:47,740 --> 00:03:49,240
Pair off with someone standing.
与一个站着的人配对。

61
00:03:49,240 --> 00:03:51,340
And add their number to yours.
把他们的数字加到你的数字上。

62
00:03:51,340 --> 00:03:52,345
And remember the sum.
记住总和。

63
00:03:59,620 --> 00:04:03,400
Person can be in front of, behind, left, or right of you.
这个人可以站在你前面、后面、左边或右边。

64
00:04:06,510 --> 00:04:10,950
All right most likely most everyone in the room assuming you
好的，假设你在房间里，大多数人可能

65
00:04:10,950 --> 00:04:13,620
found someone is thinking of the number two
找到了一个正在想着数字 2 的人

66
00:04:13,620 --> 00:04:16,073
now unless you're sort of an odd person out in the row.
现在，除非你是队伍里比较特别的人。

67
00:04:16,073 --> 00:04:16,740
And that's fine.
这没关系。

68
00:04:16,740 --> 00:04:18,115
If you're still one, that's fine.
如果你还是 1，那也没关系。

69
00:04:18,115 --> 00:04:19,800
But most of you are probably two.
但你们大多数人可能是 2。

70
00:04:19,800 --> 00:04:23,925
Next step is that one of you in those pairs should sit down.
下一步是，你们中的一个人应该坐下。

71
00:04:29,290 --> 00:04:34,210
OK, so many of you tried to sit down as quickly as possible we noticed.
好的，我们注意到，你们很多人试图尽快坐下。

72
00:04:34,210 --> 00:04:37,898
But so next step now, at this point, rather, most of you
但现在，更确切地说，大多数人

73
00:04:37,898 --> 00:04:39,190
are thinking of the number two.
正在想着数字 2。

74
00:04:39,190 --> 00:04:41,023
A few of you are thinking of the number one.
你们中有些人正在想着数字 1。

75
00:04:41,023 --> 00:04:41,710
And that's OK.
这没关系。

76
00:04:41,710 --> 00:04:45,130
The next step, and notice we're about to induce a loop, so the rest of this
下一步，注意我们即将进入循环，所以剩下的步骤

77
00:04:45,130 --> 00:04:49,195
is on you, if still standing, go back to step two.
就靠你了，如果还站着，回到第二步。

78
00:04:53,584 --> 00:04:56,572
[INTERPOSING VOICES]
[声音交叠]

79
00:05:18,030 --> 00:05:20,490
DAVID MALAN: If still standing, notice that this is a loop.
DAVID MALAN：如果还站着，注意这是一个循环。

80
00:05:20,490 --> 00:05:21,270
So keep going.
所以继续。

81
00:05:21,270 --> 00:05:24,914
Keep going if still standing.
如果还站着，继续。

82
00:05:24,914 --> 00:05:27,680
[INTERPOSING VOICES]
[声音交叠]

83
00:05:29,100 --> 00:05:30,990
DAVID MALAN: There?
DAVID MALAN：那里？

84
00:05:30,990 --> 00:05:33,276
How about there?
那里呢？

85
00:05:33,276 --> 00:05:35,702
[INTERPOSING VOICES]
[声音交叠]

86
00:05:35,702 --> 00:05:36,660
DAVID MALAN: That's OK.
DAVID MALAN：没关系。

87
00:05:36,660 --> 00:05:37,570
But now keep going.
但现在继续。

88
00:05:37,570 --> 00:05:38,070
Keep going.
继续。

89
00:05:38,070 --> 00:05:39,900
Keep pairing off, so maybe you two.
继续配对，也许你们两个。

90
00:05:42,610 --> 00:05:45,823
All right, a few more seconds.
好的，再过几秒钟。

91
00:05:45,823 --> 00:05:48,709
[INTERPOSING VOICES]
[声音交叠]

92
00:05:49,922 --> 00:05:51,255
DAVID MALAN: So step two, still.
DAVID MALAN：所以，第二步，继续。

93
00:05:55,810 --> 00:05:57,670
All right, keep pairing if you're standing.
好的，如果你站着，继续配对。

94
00:06:00,595 --> 00:06:03,529
[INTERPOSING VOICES]
[声音交叠]

95
00:06:08,717 --> 00:06:09,675
DAVID MALAN: All right.
DAVID MALAN：好的。

96
00:06:12,420 --> 00:06:16,325
All right, so theoretically, there's only one person standing left.
好的，所以从理论上来说，应该只剩下一个人站着。

97
00:06:16,325 --> 00:06:17,700
But clearly, that's not the case.
但很明显，情况并非如此。

98
00:06:17,700 --> 00:06:18,450
That's fine.
没问题。

99
00:06:18,450 --> 00:06:22,198
I will help with the pairing because some of you are far away.
我会帮助你们配对，因为你们中有些人离得很远。

100
00:06:22,198 --> 00:06:22,740
So let's see.
让我们看看。

101
00:06:22,740 --> 00:06:24,450
What's your number here?
你在这里的号码是多少？

102
00:06:24,450 --> 00:06:25,680
Sorry?
什么？

103
00:06:25,680 --> 00:06:27,620
What's your number?
你的号码是多少？

104
00:06:27,620 --> 00:06:28,120
Eight.
八。

105
00:06:28,120 --> 00:06:29,350
OK, go ahead and sit down.
好的，请坐。

106
00:06:29,350 --> 00:06:30,160
How about in back?
后面怎么样？

107
00:06:30,160 --> 00:06:31,480
What's your number?
你的号码是多少？

108
00:06:31,480 --> 00:06:32,270
46.
46.

109
00:06:32,270 --> 00:06:32,770
Nice.
不错。

110
00:06:32,770 --> 00:06:34,000
OK, go ahead and sit down.
好的，请坐。

111
00:06:34,000 --> 00:06:35,860
Who else is standing?
还有谁站着？

112
00:06:35,860 --> 00:06:38,840
Over here, what's your number?
这边，你的号码是多少？

113
00:06:38,840 --> 00:06:40,490
You're 16?
你是16号？

114
00:06:40,490 --> 00:06:42,350
OK, so go ahead and sit down.
好的，请坐。

115
00:06:42,350 --> 00:06:43,820
And behind you?
你身后呢？

116
00:06:43,820 --> 00:06:44,480
48.
48.

117
00:06:44,480 --> 00:06:46,400
OK, go ahead and sit down.
好的，请坐。

118
00:06:46,400 --> 00:06:48,290
Is anyone still standing?
还有人站着吗？

119
00:06:48,290 --> 00:06:49,400
Yeah?
是吧？

120
00:06:49,400 --> 00:06:50,270
32.
32.

121
00:06:50,270 --> 00:06:50,960
Nice.
不错。

122
00:06:50,960 --> 00:06:53,180
Still standing over here.
这边还有人站着。

123
00:06:53,180 --> 00:06:54,530
43.
43.

124
00:06:54,530 --> 00:06:55,140
OK, nice.
好的，不错。

125
00:06:55,140 --> 00:06:55,640
Sit down.
坐下。

126
00:06:55,640 --> 00:06:56,140
Sit down.
坐下。

127
00:06:56,140 --> 00:06:58,220
And anyone else still standing here?
还有其他人站在这里吗？

128
00:06:58,220 --> 00:06:59,480
22.
22.

129
00:06:59,480 --> 00:07:01,160
Go ahead and sit down.
请坐。

130
00:07:01,160 --> 00:07:03,860
Is anyone still standing and participating?
还有人站着并参与吗？

131
00:07:03,860 --> 00:07:07,400
Yeah, where-- oh, yeah.
是的，在哪里，哦，是的。

132
00:07:07,400 --> 00:07:08,357
16.
16.

133
00:07:08,357 --> 00:07:09,440
OK, go ahead and sit down.
好的，请坐。

134
00:07:09,440 --> 00:07:12,360
Anyone else still standing?
还有人站着吗？

135
00:07:12,360 --> 00:07:14,250
OK, so theoretically, everyone's paired off.
好的，理论上，每个人都配对好了。

136
00:07:14,250 --> 00:07:16,330
You were the last person standing.
你是最后一个人站着。

137
00:07:16,330 --> 00:07:19,257
So when I hit Enter here, having just greased the wheels
所以当我在这里按下回车键，刚刚才润滑了一下齿轮

138
00:07:19,257 --> 00:07:21,090
to do all of the remaining additions myself,
准备自己完成所有剩余的加法，

139
00:07:21,090 --> 00:07:24,810
we should have the total count of people in the room.
我们应该就能得到房间里的人数的总计。

140
00:07:24,810 --> 00:07:27,330
And recognize that unlike my algorithm, which
并且要注意，与我的算法不同，我的算法

141
00:07:27,330 --> 00:07:29,910
would have required pointing at each and every person
需要指着每一个人的

142
00:07:29,910 --> 00:07:33,930
or my second algorithm, which would mean pointing at every two people
或者我的第二个算法，意味着要指着每两个人

143
00:07:33,930 --> 00:07:38,010
twice as fast, theoretically, the algorithm you all just executed,
快两倍，理论上，你们刚刚执行的算法，

144
00:07:38,010 --> 00:07:40,480
I daresay, should've been fundamentally faster.
我敢说，应该更快。

145
00:07:40,480 --> 00:07:40,980
Why?
为什么？

146
00:07:40,980 --> 00:07:43,680
Because no matter how many people in the room-- maybe, like,
因为不管房间里有多少人，可能，比如，

147
00:07:43,680 --> 00:07:45,840
if there were 1,000 people in the room, there
如果房间里有1000人，那就

148
00:07:45,840 --> 00:07:50,280
would then have been 500, just as there would be 500 pages in week zero.
那么，人数就会变成 500，就像第零周有 500 页一样。

149
00:07:50,280 --> 00:07:52,320
Then from 500, there'd be 250--
然后从 500 人开始，就会有 250 个人——

150
00:07:52,320 --> 00:07:53,200
125.
125 个人。

151
00:07:53,200 --> 00:07:53,700
Why?
为什么？

152
00:07:53,700 --> 00:07:55,783
Because on each step of the algorithm, half of you
因为在算法的每一步中，你们中有一半的人

153
00:07:55,783 --> 00:07:59,310
theoretically were sitting down, sitting down, sitting down, dividing
理论上来说，是坐下来，坐下来，坐下来，并解决问题。

154
00:07:59,310 --> 00:08:00,880
and conquering that problem.
并且战胜了那个问题。

155
00:08:00,880 --> 00:08:05,370
So the total number of people in the room as of now according to your count
所以根据你的计算，目前房间里的人数总共

156
00:08:05,370 --> 00:08:08,460
is 231.
是 231 人。

157
00:08:08,460 --> 00:08:11,650
As a backup, though, Carter kindly did it the old-fashioned way,
作为备份，Carter 友善地用老式方法做了这件事，

158
00:08:11,650 --> 00:08:12,760
one person at a time.
一次一个人。

159
00:08:12,760 --> 00:08:16,310
And Carter, the actual number of people in the room is?
Carter，房间里实际的人数是多少？

160
00:08:16,310 --> 00:08:18,070
[LAUGHS]
[笑声]

161
00:08:18,070 --> 00:08:21,220
OK, so our first real world bug to be fair.
好的，公平地说，这是我们遇到的第一个现实世界的错误。

162
00:08:21,220 --> 00:08:23,510
So theoretically, that should have worked.
所以理论上，应该可以实现。

163
00:08:23,510 --> 00:08:26,230
But clearly, we lost some numbers along the way, so a bug
但很明显，我们在过程中遗失了一些数字，所以这是一个错误

164
00:08:26,230 --> 00:08:27,620
that we can fix today.
我们可以今天解决的。

165
00:08:27,620 --> 00:08:31,810
But remember that really, this is just similar in spirit
但请记住，实际上，这只是在精神上类似于

166
00:08:31,810 --> 00:08:34,750
to that algorithm we indeed did in week zero.
我们在第零周做的那个算法。

167
00:08:34,750 --> 00:08:36,532
It's the same as the phone book example.
这与电话簿的例子一样。

168
00:08:36,532 --> 00:08:37,990
It went off the rails in this case.
在这种情况下，它偏离了轨道。

169
00:08:37,990 --> 00:08:41,320
But it's the same idea, ultimately dividing and conquering.
但本质上，它是一样的，最终都是分而治之。

170
00:08:41,320 --> 00:08:44,402
And any time you have this halving, halving, halving,
只要你遇到这种，二分，二分，二分，

171
00:08:44,402 --> 00:08:46,360
there's going to be a logarithm involved there,
就会有对数参与其中，

172
00:08:46,360 --> 00:08:48,152
even if you're a little rusty on your math.
即使你对数学有点生疏。

173
00:08:48,152 --> 00:08:51,220
And that's fundamentally faster than just doing something n times
而且这从根本上来说比直接做某事 n 次

174
00:08:51,220 --> 00:08:55,090
or even n divided by 2 times where n is the number of people in the room
甚至做 n 除以 2 次（n 是房间里的人数）

175
00:08:55,090 --> 00:08:57,980
or in week zero, the number of pages in the phone book.
或者在第零周，电话簿中页面的数量。

176
00:08:57,980 --> 00:09:01,450
So even when you're using your iPhone or Android device later today, like,
所以，即使你今天晚些时候使用你的 iPhone 或 Android 设备，例如，

177
00:09:01,450 --> 00:09:04,750
if you search for a contact using autocomplete,
如果你使用自动完成功能搜索联系人，

178
00:09:04,750 --> 00:09:09,070
it is that so-called divide and conquer algorithm that's
就是那个所谓的“分而治之”算法，

179
00:09:09,070 --> 00:09:10,930
finding people in your address book.
在你的地址簿中找到联系人。

180
00:09:10,930 --> 00:09:13,570
It's not starting top to bottom or bottom up.
它不是从上到下或从下到上开始。

181
00:09:13,570 --> 00:09:15,520
It's probably going roughly to the middle
它可能大致会去到中间

182
00:09:15,520 --> 00:09:19,300
and then doing the top half or the bottom half, repeating again and again.
然后处理上半部分或下半部分，一次又一次地重复。

183
00:09:19,300 --> 00:09:21,040
So these ideas are everywhere.
所以这些想法无处不在。

184
00:09:21,040 --> 00:09:23,340
And hopefully, you end up finding just the one
希望你能最终找到你唯一想要的那个

185
00:09:23,340 --> 00:09:25,090
person you're looking for or in your case,
人，或者在你这种情况中，

186
00:09:25,090 --> 00:09:28,030
the one person last standing who should have theoretically
最后一个站立的人，理论上应该是

187
00:09:28,030 --> 00:09:32,350
had the count of everyone because if each of you started by representing 1,
拥有所有人的计数，因为如果你们每个人一开始代表 1，

188
00:09:32,350 --> 00:09:35,440
effectively handed off your number, handed off your number,
有效地传递了你的数字，传递了你的数字，

189
00:09:35,440 --> 00:09:38,260
handed off your number, it theoretically should have coalesced
传递了你的数字，理论上它应该会汇聚

190
00:09:38,260 --> 00:09:40,090
in that final person standing.
在最后一个站立的人身上。

191
00:09:40,090 --> 00:09:43,730
So let's consider the connection now between this idea
所以现在让我们考虑这个想法

192
00:09:43,730 --> 00:09:47,680
and what we introduced last week, which was this idea of very simple data
与我们上周介绍的内容之间的联系，也就是非常简单的数据的概念

193
00:09:47,680 --> 00:09:52,240
structures in your computer's memory-- like, actually using this memory as
结构存在于你的计算机内存中——就像真正地将内存用作

194
00:09:52,240 --> 00:09:54,700
though it's kind of a grid of bytes.
字节网格。

195
00:09:54,700 --> 00:09:58,190
Each one of these squares, recall, represents 1 byte or 8 bits.
请记住，每个方块代表 1 个字节或 8 个比特。

196
00:09:58,190 --> 00:10:00,250
And we can get rid of the hardware and sort
我们可以摆脱硬件，并排序

197
00:10:00,250 --> 00:10:03,850
of abstract it away as just this grid of memory or this canvas.
将其抽象为这个内存网格或画布。

198
00:10:03,850 --> 00:10:05,680
And then we introduced arrays last week.
然后我们上周引入了数组。

199
00:10:05,680 --> 00:10:08,680
And what was the key definition of an array?
数组的关键定义是什么？

200
00:10:08,680 --> 00:10:11,420
How would you describe an array?
你如何描述数组？

201
00:10:11,420 --> 00:10:14,400
What is it, anyone?
是什么，有人知道吗？

202
00:10:14,400 --> 00:10:15,540
What's an array?
什么是数组？

203
00:10:15,540 --> 00:10:18,180
Yeah, in the middle.
是的，中间那个人。

204
00:10:18,180 --> 00:10:20,720
A collection.
一个集合。

205
00:10:20,720 --> 00:10:21,330
A collection.
一个集合。

206
00:10:21,330 --> 00:10:24,790
And I don't love data types only because in C, it tends to be the same type.
我不喜欢数据类型，只是因为在 C 语言中，它往往是相同的类型。

207
00:10:24,790 --> 00:10:25,790
So a collection of data.
所以，数据的集合。

208
00:10:25,790 --> 00:10:26,450
I do like that.
我喜欢这样。

209
00:10:26,450 --> 00:10:28,370
But there's one other key characteristic.
但还有另一个关键特征。

210
00:10:28,370 --> 00:10:29,670
Do you want to be more precise?
你想更精确一点吗？

211
00:10:29,670 --> 00:10:32,850
It's not just a collection--
它不仅仅是一个集合——

212
00:10:32,850 --> 00:10:35,680
something about where it is.
关于它在哪里。

213
00:10:35,680 --> 00:10:36,880
Potentially strings.
可能是字符串。

214
00:10:36,880 --> 00:10:39,850
But strings are just an example of putting char, char, char, char.
但字符串只是一个例子，就是将 char、char、char、char 放在一起。

215
00:10:39,850 --> 00:10:42,500
It could certainly be integers or floating point values.
它当然可以是整数或浮点数。

216
00:10:42,500 --> 00:10:44,410
Another characteristic?
还有其他特征吗？

217
00:10:44,410 --> 00:10:45,220
Sorry?
你说什么？

218
00:10:45,220 --> 00:10:46,433
It's not necessarily ordered.
它不一定是有序的。

219
00:10:46,433 --> 00:10:48,100
Actually, we'll come back to that today.
实际上，我们今天会回到这个问题。

220
00:10:48,100 --> 00:10:49,340
It could be in any order.
它可以是任何顺序。

221
00:10:49,340 --> 00:10:52,090
And certainly a string isn't necessarily in sorted order.
当然，字符串也不一定是有序的。

222
00:10:52,090 --> 00:10:54,890
It's in whatever the word is.
它就是那个词的顺序。

223
00:10:54,890 --> 00:10:56,450
It's a list in concept.
从概念上来说，它是一个列表。

224
00:10:56,450 --> 00:10:59,750
But there was something key about where we put things in memory.
但是，在我们把东西放在内存中的位置，有一个关键点。

225
00:10:59,750 --> 00:11:01,580
Yeah?
是吧？

226
00:11:01,580 --> 00:11:05,420
Consecutive-- the memory is consecutive, a.k.a., contiguous.
连续的——内存是连续的，也就是相邻的。

227
00:11:05,420 --> 00:11:08,660
An array is important in C because, yes, it's a list of values.
数组在 C 语言中很重要，因为它确实是一个值的列表。

228
00:11:08,660 --> 00:11:10,130
Yes, it's a collection of values.
是的，它是一个值的集合。

229
00:11:10,130 --> 00:11:15,080
But the real key distinction in an array in C is that it's contiguous.
但在 C 语言中，数组的真正关键区别在于它是连续的。

230
00:11:15,080 --> 00:11:19,740
The bytes are back to back to back somewhere in the computer's memory,
字节在计算机内存中的某个地方，挨在一起。

231
00:11:19,740 --> 00:11:23,930
at least for any given data type, be it an int, a float, a bigger string.
至少对于任何给定的数据类型，无论是 int、float 还是更大的字符串。

232
00:11:23,930 --> 00:11:27,140
All of the characters are back to back to back in the computer's memory,
所有字符都紧挨着，在计算机的内存中。

233
00:11:27,140 --> 00:11:30,150
not spread all out, even if you have space elsewhere.
即使你其他地方有空间，它们也不分散。

234
00:11:30,150 --> 00:11:35,190
So with that said, we can actually start to solve problems with that mindset.
所以，我们可以开始用这种思维方式解决问题。

235
00:11:35,190 --> 00:11:39,020
And for instance, if I kind of pare this down to just an abstract array of size
例如，如果我把这缩减成一个抽象的数组，大小

236
00:11:39,020 --> 00:11:42,860
1, 2, 3, 4, 5, 6, 7, for instance, suppose
是 1、2、3、4、5、6、7，例如，假设

237
00:11:42,860 --> 00:11:47,220
that there are these numbers inside of this array of memory.
在这个内存数组中，有这些数字。

238
00:11:47,220 --> 00:11:51,080
So here are seven integers or ints in C. I have in this case
所以这里有七个整数，或 C 语言中的 int，在本例中，

239
00:11:51,080 --> 00:11:55,100
sorted them just to make the numbers pop out as obviously smallest to largest.
我排序了它们，只是为了让数字看起来明显地从小到大排列。

240
00:11:55,100 --> 00:11:58,070
But the catch with C is that if I were to ask you
但 C 语言中的问题是，如果我问你

241
00:11:58,070 --> 00:12:01,650
or if you were to ask the computer through code to find you the number 50,
或者你想要通过代码让计算机找到数字 50，

242
00:12:01,650 --> 00:12:03,390
well, obviously, every human in this room
那么，很明显，房间里的每个人

243
00:12:03,390 --> 00:12:07,800
just found it obviously right there because we kind of have this bird's eye
立即找到了它，因为它就在那里，因为我们有一个鸟瞰的

244
00:12:07,800 --> 00:12:10,500
view of the whole memory at once.
视角，可以一次性看到整个内存。

245
00:12:10,500 --> 00:12:12,990
But the computer ironically does not have
但具有讽刺意味的是，计算机没有

246
00:12:12,990 --> 00:12:15,240
that bird's eye view of its own memory.
它就像一只鸟，只能鸟瞰自己的记忆。

247
00:12:15,240 --> 00:12:18,820
It can only look at each location one at a time.
它一次只能查看一个位置。

248
00:12:18,820 --> 00:12:22,080
So if you really were to do this like a computer, you would kind of have to,
所以如果你真的想像电脑一样做这件事，你必须得...

249
00:12:22,080 --> 00:12:26,040
like, shield your eye and only look at one number at a time from left
就像遮住你的眼睛，一次只看一个数字，从左

250
00:12:26,040 --> 00:12:28,030
to right, from right to left, or in any order
到右，从右到左，或者按任何顺序

251
00:12:28,030 --> 00:12:31,487
in order to find is the 50 actually there.
来找到50是否真的在那里。

252
00:12:31,487 --> 00:12:32,820
You can't just take a step back.
你不能后退一步。

253
00:12:32,820 --> 00:12:34,540
And boom, it pops out at you.
然后，它就会跳出来。

254
00:12:34,540 --> 00:12:37,230
So this is kind of analogous, this array,
所以这有点类似，这个数组，

255
00:12:37,230 --> 00:12:39,690
to being like a set of gym lockers or school
就像是一排健身房的储物柜，或者学校

256
00:12:39,690 --> 00:12:42,828
lockers like this where the doors are actually closed by default.
的储物柜，默认情况下，门都是关着的。

257
00:12:42,828 --> 00:12:43,870
The numbers are in there.
数字都在里面。

258
00:12:43,870 --> 00:12:46,120
But the doors are closed, which is to say the computer
但门是关着的，也就是说，电脑

259
00:12:46,120 --> 00:12:47,562
and we can't actually look.
我们实际上不能看。

260
00:12:47,562 --> 00:12:49,020
So we couldn't find yellow lockers.
所以我们找不到黄色的储物柜。

261
00:12:49,020 --> 00:12:51,010
But we did find red lockers here.
但我们在这里找到了红色的储物柜。

262
00:12:51,010 --> 00:12:53,850
And so I propose that you think of these lockers on the stage
因此，我建议你把舞台上的这些储物柜

263
00:12:53,850 --> 00:12:57,270
here of which there are seven as well as representing an array.
想象成一个数组，它们总共有七个。

264
00:12:57,270 --> 00:13:01,740
And just so we have some terminology, notice that I've labeled these bracket
为了方便理解，请注意我已经给这些括号标了号

265
00:13:01,740 --> 00:13:05,220
0, bracket 1, bracket 2, 3, 4, 5 and 6.
0、括号 1、括号 2、3、4、5 和 6。

266
00:13:05,220 --> 00:13:07,410
And the bracket notation recalls the new syntax
这种括号符号提醒我们上周学到的新语法

267
00:13:07,410 --> 00:13:10,230
from last week that lets you index into--
它允许你在数组中进行索引，也就是...

268
00:13:10,230 --> 00:13:13,450
go to a specific spot inside of an array.
访问数组中的特定位置。

269
00:13:13,450 --> 00:13:15,720
And notice that even though there are seven lockers,
注意，尽管有七个储物柜，

270
00:13:15,720 --> 00:13:17,520
I only counted as high as six.
但我只数到六。

271
00:13:17,520 --> 00:13:20,850
But again, that's just a side effect of our generally counting from 0.
但再次强调，这仅仅是因为我们通常从 0 开始计数。

272
00:13:20,850 --> 00:13:27,330
So 0 through 6 or 0 through n minus 1 because if there are n equal 7 lockers,
所以从 0 到 6，或者从 0 到 n 减 1，因为如果总共有 n 个储物柜，也就是 7 个，

273
00:13:27,330 --> 00:13:28,590
n minus 1 is 6.
n 减 1 就是 6。

274
00:13:28,590 --> 00:13:31,900
So that's the left bound and the right bound respectively.
所以这就是左右边界。

275
00:13:31,900 --> 00:13:37,560
So suppose that we were to use these lockers as representing a problem,
假设我们将这些储物柜看成一个问题，

276
00:13:37,560 --> 00:13:40,320
like we want to find an actual number behind these doors.
比如，我们想找到这些门后面真正的数字。

277
00:13:40,320 --> 00:13:42,820
So this is actually a very common problem in the real world.
这实际上是现实世界中非常常见的问题。

278
00:13:42,820 --> 00:13:46,650
And you and I take for granted every day that big companies like Google
你我每天都理所当然地认为，像谷歌这样的大公司

279
00:13:46,650 --> 00:13:49,110
and Microsoft and others, like, do this for us
以及微软等其他公司，都在为我们做这件事

280
00:13:49,110 --> 00:13:52,920
constantly, not to mention AI doing something similar nowadays,
而且他们一直在做，更不用说现在的 AI 也在做类似的事情，

281
00:13:52,920 --> 00:13:54,360
searching for information.
搜索信息。

282
00:13:54,360 --> 00:13:56,940
And we'll focus on some basics first that
我们首先要关注一些基础知识，这些知识

283
00:13:56,940 --> 00:13:59,542
will lead us to more sophisticated algorithms ultimately.
最终将引导我们了解更复杂的算法。

284
00:13:59,542 --> 00:14:01,500
But all we're going to talk about fundamentally
但从根本上来说，我们讨论的都是

285
00:14:01,500 --> 00:14:05,160
is this same picture from week zero and from week one and from week two
从第一周到第二周，我们一直看到的这个画面

286
00:14:05,160 --> 00:14:07,120
where here is a problem to be solved.
这里有一个需要解决的问题。

287
00:14:07,120 --> 00:14:11,295
So if for instance, the input to this problem is an array of numbers--
例如，这个问题的输入是一个数字数组，

288
00:14:11,295 --> 00:14:12,420
an array of seven numbers--
一个包含七个数字的数组，

289
00:14:12,420 --> 00:14:15,870
I can't see them all at once-- but I'm looking for something like the number
我无法同时看到所有数字，但我正在寻找类似数字

290
00:14:15,870 --> 00:14:16,560
50--
50 的东西，

291
00:14:16,560 --> 00:14:18,540
ultimately, I want to get back out.
最终，我想要得到一个结果。

292
00:14:18,540 --> 00:14:20,280
I claim true or false.
我要得到真或假的结果。

293
00:14:20,280 --> 00:14:21,900
Like, the number 50 is there.
也就是说，数字 50 是否存在。

294
00:14:21,900 --> 00:14:22,740
Or it is not.
或者它不是。

295
00:14:22,740 --> 00:14:25,050
That's one way of thinking about the search problem.
这是一种思考搜索问题的方法。

296
00:14:25,050 --> 00:14:27,390
Find me some piece of data if it's there.
如果数据存在，请找到它。

297
00:14:27,390 --> 00:14:31,060
Otherwise, tell me that it's not-- true or false, respectively.
否则，告诉我它不存在 - 分别为真或假。

298
00:14:31,060 --> 00:14:33,772
So the algorithm inside of this black box,
所以这个黑盒内部的算法，

299
00:14:33,772 --> 00:14:36,480
though, is where we're going to actually have to do some thinking
然而，是我们真正需要思考的地方。

300
00:14:36,480 --> 00:14:41,097
and actually figure out how best to find the number or the data we care about.
并真正弄清楚如何最好地找到我们关心的数字或数据。

301
00:14:41,097 --> 00:14:43,680
And even though we'll use numbers to keep things simple today,
即使我们今天使用数字来简化事物，

302
00:14:43,680 --> 00:14:47,190
you could certainly generalize this to web pages or contacts
你当然可以将其推广到网页或联系人

303
00:14:47,190 --> 00:14:51,450
or any other type of information that are in some computer or database more
或任何其他类型的存储在计算机或数据库中的信息。

304
00:14:51,450 --> 00:14:52,240
generally.
一般来说。

305
00:14:52,240 --> 00:14:56,970
So maybe to keep things interesting, could we
为了保持趣味性，我们可以

306
00:14:56,970 --> 00:14:59,028
get-- how about two volunteers?
找两位志愿者怎么样？

307
00:14:59,028 --> 00:14:59,820
Wow, that was fast.
哇，太快了。

308
00:14:59,820 --> 00:15:02,080
OK, come on down.
好的，请过来。

309
00:15:02,080 --> 00:15:03,630
And how about one other volunteer?
再找一位志愿者怎么样？

310
00:15:03,630 --> 00:15:04,050
I'll go over here.
我到这边去。

311
00:15:04,050 --> 00:15:04,800
OK, how about you?
好的，你呢？

312
00:15:04,800 --> 00:15:06,300
Come on down.
请过来。

313
00:15:06,300 --> 00:15:08,670
Sure, round of applause for our volunteers.
当然，为我们的志愿者鼓掌。

314
00:15:08,670 --> 00:15:10,380
[APPLAUSE]
[鼓掌]

315
00:15:10,380 --> 00:15:13,670
OK, welcome.
好的，欢迎。

316
00:15:13,670 --> 00:15:14,250
Come on over.
请过来。

317
00:15:14,250 --> 00:15:15,875
Do you want to introduce yourself to the group?
你想向大家介绍一下自己吗？

318
00:15:15,875 --> 00:15:16,970
AUDIENCE: [INAUDIBLE].
观众：[听不清]

319
00:15:16,970 --> 00:15:18,760
DAVID MALAN: Like a few seconds is fine.
大卫·马兰：几秒钟就好了。

320
00:15:18,760 --> 00:15:20,155
AUDIENCE: Hi, I'm Sam.
观众：你好，我是萨姆。

321
00:15:20,155 --> 00:15:21,895
I am not a CS concentration.
我不是计算机科学专业的。

322
00:15:21,895 --> 00:15:24,580
DAVID MALAN: [LAUGHS] So what are you?
大卫·马兰：[笑]那你是什么专业呢？

323
00:15:24,580 --> 00:15:25,705
Do you know yet?
你知道了吗？

324
00:15:25,705 --> 00:15:26,830
AUDIENCE: Applied math.
观众：应用数学。

325
00:15:26,830 --> 00:15:27,497
DAVID MALAN: OK.
大卫·马兰：好的。

326
00:15:27,497 --> 00:15:27,997
Nice.
不错。

327
00:15:27,997 --> 00:15:28,720
Nice to meet you.
很高兴认识你。

328
00:15:28,720 --> 00:15:29,140
Welcome.
欢迎。

329
00:15:29,140 --> 00:15:29,640
And?
还有呢？

330
00:15:29,640 --> 00:15:30,910
AUDIENCE: Hi, I'm Louis.
观众：你好，我是路易斯。

331
00:15:30,910 --> 00:15:32,740
I'm from first year, Matthews.
我是一年级生，住在马修斯宿舍。

332
00:15:32,740 --> 00:15:34,705
And I'm going to do Econ with Stats.
我准备学习经济学和统计学。

333
00:15:34,705 --> 00:15:36,690
DAVID MALAN: Oh, you're in Matthews too?
大卫·马兰：哦，你也是住在马修斯宿舍吗？

334
00:15:36,690 --> 00:15:37,190
OK.
好的。

335
00:15:37,190 --> 00:15:40,720
[CHUCKLES] I was in Matthews too, so Matthews South?
[轻笑] 我也住在马修斯宿舍，住在南区吗？

336
00:15:40,720 --> 00:15:41,350
Oh, wow.
哦，哇。

337
00:15:41,350 --> 00:15:42,220
Oh, my god.
我的天啊。

338
00:15:42,220 --> 00:15:43,840
I was room 201.
我住在201号房间。

339
00:15:43,840 --> 00:15:44,986
AUDIENCE: 103.
观众：103号。

340
00:15:44,986 --> 00:15:46,630
DAVID MALAN: Fifth floor--
大卫·马兰：五楼 -

341
00:15:46,630 --> 00:15:48,280
all right, so anyhow.
好吧，总之。

342
00:15:48,280 --> 00:15:50,337
And so we have Louis and your name?
所以我们有路易斯，你的名字呢？

343
00:15:50,337 --> 00:15:50,920
AUDIENCE: Sam.
观众：萨姆。

344
00:15:50,920 --> 00:15:51,460
DAVID MALAN: Sam.
大卫·马兰：萨姆。

345
00:15:51,460 --> 00:15:51,940
Louis and Sam.
路易斯和萨姆。

346
00:15:51,940 --> 00:15:54,550
So Louis and I are going to step off to the side for just a moment because Sam,
所以路易斯和我将退到一旁一会儿，因为萨姆，

347
00:15:54,550 --> 00:15:56,077
we have a problem for you to solve.
我们有一个问题需要你解决。

348
00:15:56,077 --> 00:15:57,910
This feels a little bit like Price Is Right.
这有点像“价格对了”。

349
00:15:57,910 --> 00:16:00,010
But behind you are these seven lockers.
但你身后有这七个储物柜。

350
00:16:00,010 --> 00:16:03,460
And we'd like you to just find us the number 50.
我们希望你找到50号。

351
00:16:03,460 --> 00:16:05,050
That's all the information you get.
这就是你得到的所有信息。

352
00:16:05,050 --> 00:16:08,205
But we'd like you to then explain how you go about finding it.
但我们希望你解释一下你是如何找到它的。

353
00:16:08,205 --> 00:16:10,122
AUDIENCE: Wait, are they in order or anything?
观众：等等，它们是有顺序的吗？

354
00:16:10,122 --> 00:16:12,486
Or [INAUDIBLE] it just kind of [INAUDIBLE]??
还是[听不清]它只是[听不清]？

355
00:16:12,486 --> 00:16:15,540
DAVID MALAN: Find us the number 50.
大卫·马兰：找到50号。

356
00:16:15,540 --> 00:16:17,370
And then tell us how you found it.
然后告诉我们你是怎么找到的。

357
00:16:20,662 --> 00:16:22,745
OK, what was in there, just so the audience knows.
好吧，里面是什么，让观众知道一下。

358
00:16:22,745 --> 00:16:23,620
AUDIENCE: [INAUDIBLE]
观众：[听不清]

359
00:16:23,620 --> 00:16:24,850
DAVID MALAN: Yes.
大卫·马兰：是的。

360
00:16:24,850 --> 00:16:25,550
[LAUGHTER]
[笑声]

361
00:16:25,550 --> 00:16:28,818
AUDIENCE: It was $10, a very, very big $10 bill.
观众：是10美元，一张非常非常大的10美元钞票。

362
00:16:28,818 --> 00:16:29,485
DAVID MALAN: OK.
大卫·马兰：好的。

363
00:16:29,485 --> 00:16:30,423
AUDIENCE: Fake money.
观众：假钱。

364
00:16:30,423 --> 00:16:31,090
DAVID MALAN: OK.
大卫·马兰：好的。

365
00:16:33,925 --> 00:16:39,310
AUDIENCE: That was $100.
观众：那是100美元。

366
00:16:39,310 --> 00:16:42,100
$1.
1美元。

367
00:16:42,100 --> 00:16:43,570
$5.
5美元。

368
00:16:43,570 --> 00:16:45,400
OK, I'm not lucky.
好的，我不走运。

369
00:16:45,400 --> 00:16:46,810
Oh, I found it.
哦，我找到了。

370
00:16:46,810 --> 00:16:47,560
DAVID MALAN: Nice.
大卫·马兰：不错。

371
00:16:47,560 --> 00:16:49,180
Take it out and so people can believe.
拿出来，让大家相信。

372
00:16:49,180 --> 00:16:50,530
All right, wonderful.
好的，太棒了。

373
00:16:50,530 --> 00:16:52,390
So you found the 50.
所以你找到了50号。

374
00:16:52,390 --> 00:16:53,260
[APPLAUSE]
[掌声]

375
00:16:53,260 --> 00:16:55,305
And now if you could explain.
现在如果你能解释一下。

376
00:16:55,305 --> 00:16:55,930
I'll take that.
我接受。

377
00:16:55,930 --> 00:16:58,060
If you could explain, what was your algorithm?
如果你能解释一下，你的算法是什么？

378
00:16:58,060 --> 00:17:00,810
What was the step-by-step approach you took?
你采取的逐步方法是什么？

379
00:17:00,810 --> 00:17:03,490
AUDIENCE: I didn't really have one.
观众：我并没有什么特别的算法。

380
00:17:03,490 --> 00:17:04,720
I just started on one end.
我只是从一端开始。

381
00:17:04,720 --> 00:17:07,450
And I went down because it wasn't in order or anything.
然后我往下走，因为它们没有顺序。

382
00:17:07,450 --> 00:17:09,400
So I just kept going until I found it.
所以我一直往下走，直到找到它。

383
00:17:09,400 --> 00:17:10,720
DAVID MALAN: OK, so that's actually pretty fair.
大卫·马兰：好吧，这其实很公平。

384
00:17:10,720 --> 00:17:12,262
And in fact, let's step forward here.
事实上，让我们继续。

385
00:17:12,262 --> 00:17:14,829
Carter's going to very secretly kind of shuffle the numbers
卡特将非常秘密地以一种特殊的新排列方式打乱这些数字

386
00:17:14,829 --> 00:17:16,880
in a particular new arrangement here.
这里。

387
00:17:16,880 --> 00:17:19,390
And so you really went from right to left.
所以你实际上是从右到左。

388
00:17:19,390 --> 00:17:22,960
And I dare say maybe going from left to right might be equivalent.
我敢说也许从左到右可能是等效的。

389
00:17:22,960 --> 00:17:25,750
But could she have done better?
但她能做得更好吗？

390
00:17:25,750 --> 00:17:29,590
Could she have done better, because that took 1, 2, 3, 4, 5 steps?
她能做得更好吗，因为这花了1、2、3、4、5步？

391
00:17:29,590 --> 00:17:31,970
Could Sam have done better?
萨姆能做得更好吗？

392
00:17:31,970 --> 00:17:32,470
Sure.
当然。

393
00:17:32,470 --> 00:17:35,270
How?
怎么做？

394
00:17:35,270 --> 00:17:36,527
OK, so you got lucky.
好吧，你运气不错。

395
00:17:36,527 --> 00:17:38,360
You could have found the number in one step.
你本可以一步就找到这个数字。

396
00:17:38,360 --> 00:17:40,400
Although, luck isn't really an algorithm.
不过，运气本身并不是一种算法。

397
00:17:40,400 --> 00:17:42,780
It really isn't a step-by-step approach.
它真的不是一个循序渐进的过程。

398
00:17:42,780 --> 00:17:45,053
So another thought?
还有其他想法吗？

399
00:17:45,053 --> 00:17:46,890
AUDIENCE: [INAUDIBLE] dollar bills--
观众：[听不清] 美元钞票 -

400
00:17:46,890 --> 00:17:49,656
sort them in order?
按顺序排列它们？

401
00:17:49,656 --> 00:17:51,270
DAVID MALAN: Oh, interesting.
大卫·马兰：哦，很有趣。

402
00:17:51,270 --> 00:17:54,492
So you could have taken out all of the dollar bills, sorted them,
所以你可以把所有的美元钞票拿出来，把它们排序，

403
00:17:54,492 --> 00:17:57,200
put them back in, and then you probably could have done something
放回去，然后你可能就能做一些

404
00:17:57,200 --> 00:17:59,315
like the divide and conquer approach.
类似于分而治之的方法。

405
00:17:59,315 --> 00:18:00,520
AUDIENCE: I didn't know I was allowed to do that.
观众：我不知道我可以这样做。

406
00:18:00,520 --> 00:18:01,400
DAVID MALAN: No, you weren't allowed to.
大卫·马兰：不，你不能。

407
00:18:01,400 --> 00:18:02,360
So that's fine.
所以没关系。

408
00:18:02,360 --> 00:18:02,810
AUDIENCE: [INAUDIBLE]
观众：[听不清]

409
00:18:02,810 --> 00:18:04,852
DAVID MALAN: But that would be a valid algorithm.
大卫·马兰：但这将是一个有效的算法。

410
00:18:04,852 --> 00:18:07,970
Although, it sounds very inefficient to do all this work just
不过，仅仅为了找到数字 50 就做所有这些工作听起来非常低效，因为在做这些工作的时候，

411
00:18:07,970 --> 00:18:10,128
to find the number 50 because in doing that work,
她已经找到过 50 一次了。

412
00:18:10,128 --> 00:18:11,420
she would've found the 50 once.
但这可能是一个合理的解决方案

413
00:18:11,420 --> 00:18:13,420
But that might actually be a reasonable solution
如果她打算反复搜索，不仅仅搜索 7 个数字

414
00:18:13,420 --> 00:18:17,330
if she plans to search again and again and again, not just for seven numbers
而是可能很多数字。

415
00:18:17,330 --> 00:18:18,560
but maybe a lot of numbers.
也许你确实想在前期投入一些成本，以及所有数据

416
00:18:18,560 --> 00:18:21,690
Maybe you do want to incur some cost up front and all the data
以便更快地找到它。

417
00:18:21,690 --> 00:18:22,910
so as to find it faster.
但让我们更系统地来做这件事。

418
00:18:22,910 --> 00:18:24,320
But let's do this a little more methodically.
我们再稍微偏离一下。

419
00:18:24,320 --> 00:18:25,862
We'll step off to the side once more.
按照惯例，如果你想继续 - 我们需要这个吗？

420
00:18:25,862 --> 00:18:29,120
And just by convention, if you want to go ahead and-- do we need this?
好的。

421
00:18:29,120 --> 00:18:29,660
OK.
观众：明白了。

422
00:18:29,660 --> 00:18:30,368
AUDIENCE: Got it.
好的，我们从左到右。

423
00:18:30,368 --> 00:18:32,390
DAVID MALAN: OK, let's go from left to right.
是的。

424
00:18:32,390 --> 00:18:32,900
Yep.
请继续展示给大家看这些数字，

425
00:18:32,900 --> 00:18:34,858
And go ahead and show everyone the numbers just
以证明这里没有作假。

426
00:18:34,858 --> 00:18:37,430
to prove that there's no funny business here.
观众：20。

427
00:18:37,430 --> 00:18:38,848
AUDIENCE: 20.
大卫·马兰：[笑]

428
00:18:38,848 --> 00:18:41,596
DAVID MALAN: [LAUGHS]
观众：哦，好吧。

429
00:18:41,596 --> 00:18:42,960
AUDIENCE: Oh, OK.
500。

430
00:18:42,960 --> 00:18:44,010
500.
大卫·马兰：不错。

431
00:18:44,010 --> 00:18:44,760
DAVID MALAN: Nice.
观众：10。

432
00:18:48,191 --> 00:18:49,340
AUDIENCE: 10.
大卫·马兰：嗯哼。

433
00:18:49,340 --> 00:18:50,290
DAVID MALAN: Mm-hm.
所以看起来这次也没有排序。

434
00:18:50,290 --> 00:18:54,212
So it doesn't sound like it's sorted, either, this time.
观众：5。

435
00:18:54,212 --> 00:18:54,945
AUDIENCE: Five.
大卫·马兰：不错。

436
00:18:54,945 --> 00:18:58,040
DAVID MALAN: Nice.
还有？

437
00:18:58,040 --> 00:18:59,826
And?
观众：100。

438
00:18:59,826 --> 00:19:00,940
AUDIENCE: 100.
大卫·马兰：哦，太接近了。

439
00:19:00,940 --> 00:19:02,280
DAVID MALAN: Oh, so close.
观众：[听不清]

440
00:19:05,090 --> 00:19:06,057
AUDIENCE: [INAUDIBLE]
我知道。

441
00:19:06,057 --> 00:19:06,890
DAVID MALAN: I know.
我们只是在逗你玩。

442
00:19:06,890 --> 00:19:07,730
Now we're just messing with you.
观众：1。

443
00:19:07,730 --> 00:19:08,230
AUDIENCE: 1.


444
00:19:08,230 --> 00:19:10,904
DAVID MALAN: OK, and lastly?
大卫·马兰：好的，最后一个？

445
00:19:10,904 --> 00:19:12,380
AUDIENCE: [GASPS] 50.
观众：[倒吸一口气] 50。

446
00:19:12,380 --> 00:19:13,670
DAVID MALAN: Very well done.
大卫·马兰：做得很好。

447
00:19:13,670 --> 00:19:15,360
OK, so nicely done.
好的，做得很好。

448
00:19:15,360 --> 00:19:15,860
[APPLAUSE]
[掌声]

449
00:19:15,860 --> 00:19:17,870
And so thank you.
所以谢谢你。

450
00:19:17,870 --> 00:19:20,990
So this is a say whether she goes from left to right or right to left,
所以这是一个说她从左到右还是从右到左，

451
00:19:20,990 --> 00:19:24,080
like, the performance of that algorithm just going linearly
就像，那个算法的性能只是线性地

452
00:19:24,080 --> 00:19:27,170
from side to side really depends on where the number ends up being.
从一侧到另一侧真的取决于数字最终的位置。

453
00:19:27,170 --> 00:19:28,760
And it kind of does boil down to luck.
这确实归结为运气。

454
00:19:28,760 --> 00:19:31,550
And so that was kind of the best you could do because I dare say,
所以那是你能做的最好的，因为我敢说，

455
00:19:31,550 --> 00:19:34,772
had you gone linearly from right to left-- and go ahead to reset--
如果你从右到左线性地走——继续重置——

456
00:19:34,772 --> 00:19:37,730
had you gone from right to left, that time you would have gotten lucky.
如果你从右到左走，那一次你就走运了。

457
00:19:37,730 --> 00:19:40,080
So on average, it might just kind of work out.
所以平均来说，它可能只是奏效。

458
00:19:40,080 --> 00:19:43,070
And so half the time, it takes you maybe half as many steps--
所以有一半的时间，它可能只花费你一半的步骤——

459
00:19:43,070 --> 00:19:45,087
half the number of lockers to find it on average
平均来说，只需要一半的储物柜就能找到它

460
00:19:45,087 --> 00:19:46,670
because sometimes it's in the one end.
因为有时它在一边。

461
00:19:46,670 --> 00:19:47,840
Sometimes it's on the other end.
有时它在另一边。

462
00:19:47,840 --> 00:19:49,620
Sometimes it's smack dab in the middle.
有时它正好在中间。

463
00:19:49,620 --> 00:19:52,490
But we're going to give you the option now,
但现在我们要给你一个选择，

464
00:19:52,490 --> 00:19:54,523
Louis, of knowing that it's sorted.
路易斯，知道它已经排序了。

465
00:19:54,523 --> 00:19:56,690
So we're going to take away the microphone from you.
所以我们要拿走你的麦克风。

466
00:19:56,690 --> 00:19:58,400
But stay on up here with us.
但留在这里和我们在一起。

467
00:19:58,400 --> 00:20:00,710
And you are now given the assumption that the numbers
现在，你被告知这些数字

468
00:20:00,710 --> 00:20:03,860
are this time sorted from smallest to largest, left to right.
这一次是从最小到最大，从左到右排序。

469
00:20:03,860 --> 00:20:08,570
And might you want to take more of a divide and conquer approach here?
你是否想在这里采取更多的分治方法？

470
00:20:08,570 --> 00:20:09,656
Wait a minute.
等一下。

471
00:20:09,656 --> 00:20:10,934
AUDIENCE: [LAUGHS]
观众：[笑]

472
00:20:10,934 --> 00:20:14,450
DAVID MALAN: What might you do as your algorithm, Louis?
大卫·马兰：路易斯，你的算法可能会怎么做？

473
00:20:14,450 --> 00:20:16,700
AUDIENCE: Well, I think I know all the numbers, right?
观众：嗯，我想我知道所有数字，对吧？

474
00:20:16,700 --> 00:20:17,440
It's 1, 5--
它是 1，5——

475
00:20:17,440 --> 00:20:18,482
DAVID MALAN: Oh, damn it.
大卫·马兰：哦，该死。

476
00:20:18,482 --> 00:20:19,610
AUDIENCE: 10, 20, 50.
观众：10，20，50。

477
00:20:19,610 --> 00:20:21,630
DAVID MALAN: OK, so Louis has some memory, as we'll say.
大卫·马兰：好的，我们可以说路易斯有一些记忆。

478
00:20:21,630 --> 00:20:22,130
OK.
好的。

479
00:20:22,130 --> 00:20:24,320
AUDIENCE: But assuming if I didn't have memory.
观众：但假设如果我没有记忆。

480
00:20:24,320 --> 00:20:25,310
DAVID MALAN: OK, assuming if you didn't have
大卫·马兰：好的，假设你没有

481
00:20:25,310 --> 00:20:26,480
memory, where would you start first?
记忆，你会先从哪里开始？

482
00:20:26,480 --> 00:20:27,920
AUDIENCE: I would probably start in the middle.
观众：我可能会从中间开始。

483
00:20:27,920 --> 00:20:28,490
DAVID MALAN: OK, go ahead.
大卫·马兰：好的，继续。

484
00:20:28,490 --> 00:20:29,220
Go in the middle.
去中间。

485
00:20:29,220 --> 00:20:31,505
And what do you see?
你看到了什么？

486
00:20:31,505 --> 00:20:32,283
AUDIENCE: 20.
观众：20。

487
00:20:32,283 --> 00:20:32,950
DAVID MALAN: 20.
大卫·马兰：20。

488
00:20:32,950 --> 00:20:34,505
OK, what does that mean now for you?
好的，现在对你来说意味着什么？

489
00:20:34,505 --> 00:20:37,630
AUDIENCE: So now that means that since4 I know there's some numbers bigger,
观众：所以现在这意味着，既然我知道有一些数字更大，

490
00:20:37,630 --> 00:20:38,390
I'll go to the right.
我会去右边。

491
00:20:38,390 --> 00:20:38,500
DAVID MALAN: Good.
大卫·马兰：很好。

492
00:20:38,500 --> 00:20:40,720
So you can tear the problem in half, so to speak.
所以你可以将问题一分为二，这么说吧。

493
00:20:40,720 --> 00:20:43,690
As per week zero, skip all of the lockers on the left.
就像第零周一样，跳过左边所有的储物柜。

494
00:20:43,690 --> 00:20:45,460
And now go where relative to these three?
现在相对于这三个，你要去哪里？

495
00:20:45,460 --> 00:20:46,540
AUDIENCE: Relative to the middle.
观众：相对于中间。

496
00:20:46,540 --> 00:20:46,720
DAVID MALAN: OK.
大卫·马兰：好的。

497
00:20:46,720 --> 00:20:48,800
AUDIENCE: So maybe [? you ?] don't know what's on the right-hand side.
观众：所以也许你不知道右边是什么。

498
00:20:48,800 --> 00:20:49,765
And so now it's 100.
所以现在是 100。

499
00:20:49,765 --> 00:20:51,070
DAVID MALAN: OK, nice.
大卫·马兰：好的，不错。

500
00:20:51,070 --> 00:20:54,250
AUDIENCE: So the 50 must be between 20 and 100.
观众：所以 50 必须在 20 和 100 之间。

501
00:20:54,250 --> 00:20:56,012
So it must be this one.
所以一定是这个。

502
00:20:56,012 --> 00:20:56,845
DAVID MALAN: Indeed.
大卫·马兰：确实。

503
00:20:56,845 --> 00:21:00,342
So a round of applause for Louis for getting this right this time.
所以让我们为路易斯这次答对了而鼓掌。

504
00:21:00,342 --> 00:21:01,790
[APPLAUSE]
[鼓掌]

505
00:21:01,790 --> 00:21:05,008
We have some lovely parting gifts, since we're using monopoly money.
我们有一些可爱的临别礼物，因为我们使用的是大富翁的钱。

506
00:21:05,008 --> 00:21:06,050
So it's not actual money.
所以这不是真钱。

507
00:21:06,050 --> 00:21:10,610
But this is the Cambridge edition Harvard Square and all for both of you.
但这是剑桥版哈佛广场，给你们两个。

508
00:21:10,610 --> 00:21:11,390
So welcome.
欢迎。

509
00:21:11,390 --> 00:21:12,986
Thank you so much.
非常感谢。

510
00:21:12,986 --> 00:21:17,140
[APPLAUSE]
[鼓掌]

511
00:21:17,140 --> 00:21:19,630
So Louis was actually getting particularly clever there
所以路易斯实际上在那里变得特别聪明

512
00:21:19,630 --> 00:21:21,610
when his first instinct was to just remember
当他第一反应只是记住

513
00:21:21,610 --> 00:21:23,800
what were all the numbers and then sort of deduce
所有的数字，然后推断出来

514
00:21:23,800 --> 00:21:25,600
where the 50 must obviously be.
50 显然必须在哪里。

515
00:21:25,600 --> 00:21:26,440
So that's on us.
所以这算我们。

516
00:21:26,440 --> 00:21:29,050
Like, ideally, we would have completely changed the dollar amount so
理想情况下，我们应该完全改变美元金额，这样

517
00:21:29,050 --> 00:21:30,633
that he couldn't use that information.
他就无法使用这些信息。

518
00:21:30,633 --> 00:21:34,540
But it turns out Louie's instinct there to figure out where the number should
但事实证明，路易斯在那里的直觉，弄清楚数字应该在哪里

519
00:21:34,540 --> 00:21:35,980
be and jump right there--
并直接跳到那里——

520
00:21:35,980 --> 00:21:39,160
index into that exact location-- is actually a technique.
索引到那个确切的位置——实际上是一种技巧。

521
00:21:39,160 --> 00:21:42,760
And it's a technique we'll talk about in future classes
这是一种技巧，我们将在未来的课程中讨论

522
00:21:42,760 --> 00:21:45,280
where you actually do take into account the information
在那里你实际上考虑了信息

523
00:21:45,280 --> 00:21:46,940
and go right where you want.
并直接去你想去的地方。

524
00:21:46,940 --> 00:21:50,230
It's an example of what we'll eventually call hashing, so to speak,
这可以算作我们最终将要称为散列的一个例子，

525
00:21:50,230 --> 00:21:51,940
in a concept called hash tables.
在一个叫做散列表的概念中。

526
00:21:51,940 --> 00:21:54,520
But for now, let's try to formalize the algorithms
但现在，让我们尝试将这两个志愿者的算法形式化

527
00:21:54,520 --> 00:21:58,240
that both of these volunteers kind of intuitively
这两个志愿者直觉地想出来的，第一个和第二个。

528
00:21:58,240 --> 00:22:00,070
came up with, first and second.
第一个和第二个。

529
00:22:00,070 --> 00:22:01,580
And we'll slap some names on them.
我们给他们取一些名字。

530
00:22:01,580 --> 00:22:05,140
So the first, and I've hinted at this, is what we would call linear search.
所以第一个，我暗示过，是我们所说的线性搜索。

531
00:22:05,140 --> 00:22:08,590
Anytime you search from left to right or from right to left,
无论何时你从左到右或从右到左搜索，

532
00:22:08,590 --> 00:22:10,190
it's generally called linear search.
它通常被称为线性搜索。

533
00:22:10,190 --> 00:22:10,690
Why?
为什么？

534
00:22:10,690 --> 00:22:13,482
Because you're kind of walking in a line, no matter which direction
因为你在一条线上行走，无论你朝哪个方向

535
00:22:13,482 --> 00:22:14,080
you're going.
行走。

536
00:22:14,080 --> 00:22:17,390
But now for today's purposes, let's see if we can't truly
但现在为了今天，让我们看看我们是否可以真正地

537
00:22:17,390 --> 00:22:21,440
formalize what our volunteers' algorithms were by translating them,
将我们志愿者的算法形式化，通过翻译它们，

538
00:22:21,440 --> 00:22:24,320
not necessarily to code yet, but pseudocode.
不一定用代码，而是伪代码。

539
00:22:24,320 --> 00:22:28,190
See if we can't map it to English-like syntax that gets the ideas across.
看看我们是否可以将其映射到类似英语的语法，以便表达这些想法。

540
00:22:28,190 --> 00:22:32,220
So I dare say, the first algorithm, even though she went from right to left,
所以我想说，第一个算法，尽管她从右到左，

541
00:22:32,220 --> 00:22:34,460
then from left to right, might look like this.
然后从左到右，可能看起来像这样。

542
00:22:34,460 --> 00:22:39,800
For each door from left to right, she checked if 50 is behind the door
对于从左到右的每一扇门，她检查了 50 是否在门后

543
00:22:39,800 --> 00:22:40,850
as by looking at it.
通过查看它。

544
00:22:40,850 --> 00:22:44,417
If it was behind the door, then she returned true.
如果数字在门后面，她就会返回真值。

545
00:22:44,417 --> 00:22:45,500
Like, yes, this is the 50.
就像，是的，这是数字50。

546
00:22:45,500 --> 00:22:47,583
That didn't happen on the first iteration, though.
不过，这在第一次迭代时没有发生。

547
00:22:47,583 --> 00:22:51,750
So she moved on again and again.
所以她一次又一次地继续寻找。

548
00:22:51,750 --> 00:22:53,660
And now notice the indentation here is just
现在请注意，这里的缩进只是

549
00:22:53,660 --> 00:22:55,670
as important as it was in week zero.
和第零周一样重要。

550
00:22:55,670 --> 00:22:59,180
Notice that only at the very bottom of this algorithm
请注意，只有在这个算法的最底部

551
00:22:59,180 --> 00:23:00,620
do I propose returning false.
我才建议返回假值。

552
00:23:00,620 --> 00:23:03,650
But it's not indented inside of this pseudocode.
但是它并没有在这个伪代码中缩进。

553
00:23:03,650 --> 00:23:04,160
Why?
为什么？

554
00:23:04,160 --> 00:23:06,530
Well, because if I had changed it to be this,
因为如果我把它改成这样，

555
00:23:06,530 --> 00:23:10,740
what would be the logical bug in this version of that algorithm?
在这个版本的算法中，逻辑错误是什么？

556
00:23:10,740 --> 00:23:11,240
Yeah?
是吗？

557
00:23:17,040 --> 00:23:17,730
Exactly.
没错。

558
00:23:17,730 --> 00:23:22,020
If she had opened the first door, found it to be the wrong number if it says
如果她打开了第一扇门，发现它不是正确的数字，如果上面写着

559
00:23:22,020 --> 00:23:24,330
else-- if it's not behind the door, then return false--
否则，如果数字不在门后，就返回假值——

560
00:23:24,330 --> 00:23:26,760
that would erroneously conclude the 50's not there,
这将错误地得出结论，数字50不在那里，

561
00:23:26,760 --> 00:23:29,350
even though it could certainly be among those other doors.
尽管它肯定可能在其他门中。

562
00:23:29,350 --> 00:23:32,370
So this first version of the code where the return false is
所以这段代码的第一个版本，其中返回假值是

563
00:23:32,370 --> 00:23:35,670
sort of left indented, so to speak, and the very last thing
可以说，被留下了缩进，并且是最后一件事情

564
00:23:35,670 --> 00:23:39,690
you do if you don't previously return true, that just
如果你之前没有返回真值，你需要做的事情，就是

565
00:23:39,690 --> 00:23:42,360
makes sure that we're handling all possible cases.
确保我们处理了所有可能的情况。

566
00:23:42,360 --> 00:23:45,060
But let's make this maybe a little more technical.
但是让我们把它变得更加技术化一些。

567
00:23:45,060 --> 00:23:47,580
This is how a computer scientist or a programmer
这就是计算机科学家或程序员

568
00:23:47,580 --> 00:23:49,970
would likely express this instead.
可能会这样表达。

569
00:23:49,970 --> 00:23:52,260
Instead of just drawing it in broad strokes,
而不是仅仅用概括性的笔触来绘制它，

570
00:23:52,260 --> 00:23:56,100
it's actually fine to kind of steal some of the syntax from languages like C
实际上可以从像C这样的语言中借用一些语法

571
00:23:56,100 --> 00:24:01,530
and actually use some of the indices or indexes like 0, 1, 2, 3, 4, 5, 6,
并实际使用一些索引，比如0、1、2、3、4、5、6，

572
00:24:01,530 --> 00:24:04,360
to represent the pieces of data we care about.
来表示我们关心的数据片段。

573
00:24:04,360 --> 00:24:06,150
So this is a little more precise.
所以这更精确一些。

574
00:24:06,150 --> 00:24:12,030
For i-- like a variable i-- from the value 0 to n minus 1,
对于i——就像一个变量i——从值0到n减1，

575
00:24:12,030 --> 00:24:16,390
so in the case of seven doors, this is like saying, for i starting at 0,
所以对于七扇门的情况，这就像是在说，对于从0开始的i，

576
00:24:16,390 --> 00:24:19,280
going up to 6, do the following.
一直到6，执行以下操作。

577
00:24:19,280 --> 00:24:22,730
If the number 50 is behind the doors array--
如果数字50在门的数组后面——

578
00:24:22,730 --> 00:24:27,250
so I'm using array syntax, even though this is technically still pseudocode--
所以我在使用数组语法，即使这在技术上仍然是伪代码——

579
00:24:27,250 --> 00:24:32,720
if the ith location of my doors array has the number 50, return true.
如果我的门数组的第i个位置包含数字50，就返回真值。

580
00:24:32,720 --> 00:24:35,680
Otherwise, if you do that again and again and again--
否则，如果你一遍又一遍地做——

581
00:24:35,680 --> 00:24:39,863
n total times-- and you still don't find it, you want to return false.
总共n次——你仍然没有找到它，你就需要返回假值。

582
00:24:39,863 --> 00:24:40,780
So we introduced this.
所以我们引入了这个。

583
00:24:40,780 --> 00:24:44,590
This is just an example of how you can start to borrow ideas from actual code
这只是一个例子，说明了如何开始从实际代码中借用想法

584
00:24:44,590 --> 00:24:47,890
to paint the picture even more precisely of what
来更精确地描绘你想要你的同事做什么，什么

585
00:24:47,890 --> 00:24:50,200
it is you want a colleague to do, what it
是你想让你的同事做，你的代码

586
00:24:50,200 --> 00:24:53,860
is you want your code to do, ultimately, by sort
最终想让它做，通过某种方式

587
00:24:53,860 --> 00:24:58,720
of borrowing these ideas from code and incorporating it into our pseudocode.
从代码中借用这些想法，并将它们融入我们的伪代码中。

588
00:24:58,720 --> 00:25:03,430
But what about the second algorithm here,
但是这里第二个算法呢，

589
00:25:03,430 --> 00:25:07,930
the second algorithm, whereby he took a divide and conquer approach,
第二个算法，他采用了分而治之的方法，

590
00:25:07,930 --> 00:25:10,660
starting in the middle and then going right and then going left.
从中间开始，然后向右，然后向左。

591
00:25:10,660 --> 00:25:13,077
Well, it turns out this is generally called binary search.
事实证明，这通常被称为二分搜索。

592
00:25:13,077 --> 00:25:15,040
Bi implying two, because you're either going
“二”表示两个，因为你要么

593
00:25:15,040 --> 00:25:17,395
with the left half or the right half again and again.
选择左半部分，要么选择右半部分，一次又一次。

594
00:25:17,395 --> 00:25:20,020
This is literally what we've been talking about since week zero
这正是我们从第一周就开始讨论的

595
00:25:20,020 --> 00:25:21,312
when I searched the phone book.
当我搜索电话簿时。

596
00:25:21,312 --> 00:25:25,450
That too was binary search, dividing and dividing and dividing in half and half.
那也是二分搜索，不断地将范围一分为二。

597
00:25:25,450 --> 00:25:27,850
So if we were to draw some pseudocode for this,
所以，如果我们要为此写一些伪代码，

598
00:25:27,850 --> 00:25:30,250
I would propose that we could do something like this.
我建议我们可以这样做。

599
00:25:30,250 --> 00:25:34,900
If 50 is behind the middle door, then we got lucky.
如果50在中间门后面，那我们很幸运。

600
00:25:34,900 --> 00:25:36,490
Just return true.
直接返回true。

601
00:25:36,490 --> 00:25:40,700
Else if the 50 is less than the value at the middle door--
否则，如果50小于中间门的数值

602
00:25:40,700 --> 00:25:42,430
so if it's smaller than the middle door--
如果它小于中间门

603
00:25:42,430 --> 00:25:43,810
I want to search to the left.
我想搜索左侧。

604
00:25:43,810 --> 00:25:45,580
So I can say search left half.
所以我可以说搜索左半部分。

605
00:25:45,580 --> 00:25:50,330
Else if 50 is greater than the middle door, I want to search to the right.
否则，如果50大于中间门，我想搜索右侧。

606
00:25:50,330 --> 00:25:54,550
And I think that's almost everything, right?
我想这几乎囊括了所有情况，对吧？

607
00:25:54,550 --> 00:25:57,680
Is there a fourth possible case?
还有第四种情况吗？

608
00:25:57,680 --> 00:25:58,715
What else could happen?
还有什么可能发生？

609
00:26:03,130 --> 00:26:03,670
Good.
好。

610
00:26:03,670 --> 00:26:07,720
So taking into account that if there are no doors left or no doors
所以，考虑到如果门已经搜索完，或者一开始就没有门

611
00:26:07,720 --> 00:26:09,830
to begin with, we better handle that case
我们最好处理这种情况

612
00:26:09,830 --> 00:26:11,650
so that we don't induce one of those spinning beach balls,
这样就不会出现电脑卡死的状况，

613
00:26:11,650 --> 00:26:13,540
so that the computer doesn't freeze or crash.
也不会导致电脑崩溃。

614
00:26:13,540 --> 00:26:17,020
There's really four possible scenarios in searching for information.
在搜索信息时，实际上只有四种可能的情况。

615
00:26:17,020 --> 00:26:19,990
It's either in the middle or to the left or to the right.
它要么在中间，要么在左侧，要么在右侧。

616
00:26:19,990 --> 00:26:21,438
Or it's just not there at all.
或者它根本不存在。

617
00:26:21,438 --> 00:26:24,730
And so I sort of slip that in at the end because technically, that's a question
所以，我在最后加入了这个，因为从技术角度来说，这是一个问题

618
00:26:24,730 --> 00:26:28,390
you should ask first because if there's no doors, there's no work to be done.
你应该首先询问，因为如果没有门，就没有工作要做。

619
00:26:28,390 --> 00:26:31,780
But logically, this is the juicy part-- the other three questions
但从逻辑上讲，这是核心部分——另外三个问题

620
00:26:31,780 --> 00:26:33,320
that you might ask yourself.
你可能会问自己。

621
00:26:33,320 --> 00:26:35,860
So this then might be the pseudocode for binary search.
所以，这可能是二分搜索的伪代码。

622
00:26:35,860 --> 00:26:37,398
And we could make it more technical.
我们可以把它做得更专业一些。

623
00:26:37,398 --> 00:26:39,940
And this is where it kind of escalates quickly syntactically.
而这里，它在语法上迅速升级。

624
00:26:39,940 --> 00:26:41,770
But I'm just using the same kind of syntax.
但我只是使用同样的语法。

625
00:26:41,770 --> 00:26:45,190
If doors in my pseudocode represents an array of doors,
如果伪代码中的“门”代表一个门数组，

626
00:26:45,190 --> 00:26:48,550
well, then doors bracket middle is just a pseudocode-like way
那么，括号内的“门”中间，就是一个类似伪代码的方式

627
00:26:48,550 --> 00:26:51,110
of saying go to the middle door in that array.
来说明在那个数组中，指向中间门。

628
00:26:51,110 --> 00:26:55,090
And then notice, else if 50 is less than-- that middle value--
然后请注意，否则，如果50小于中间值

629
00:26:55,090 --> 00:26:59,620
then search doors bracket 0, so the leftmost one--
那么搜索“门”括号0，也就是最左边的那个

630
00:26:59,620 --> 00:27:02,380
through doors middle minus 1.
一直到“门”中间减1。

631
00:27:02,380 --> 00:27:05,780
So you don't need to waste time researching the middle door.
所以，你不需要浪费时间搜索中间门。

632
00:27:05,780 --> 00:27:10,250
So I say middle minus 1 so that I scooch over slightly to the left, so to speak.
所以我说是中间减1，这样说，我稍微向左移动了一点。

633
00:27:10,250 --> 00:27:13,550
Else if 50 is greater than the value at the middle door,
否则，如果50大于中间门的数值，

634
00:27:13,550 --> 00:27:16,700
then you want to search 1 over to the right,
那么你想要搜索右侧的1，

635
00:27:16,700 --> 00:27:21,770
so middle plus 1 among those doors, through the last door, which is not n,
因此，在这些门中，从中间加1开始，一直到最后一个门，这不是n，

636
00:27:21,770 --> 00:27:24,710
because we start counting at 0, but n minus 1.
因为我们从0开始计数，而是n减1。

637
00:27:24,710 --> 00:27:26,460
And the rest of the algorithm is the same.
其余的算法相同。

638
00:27:26,460 --> 00:27:27,918
This is just a little more precise.
这仅仅是更精确了一些。

639
00:27:27,918 --> 00:27:32,450
And I dare say, when writing a program in C or any language,
我敢说，在用 C 语言或任何语言编写程序时，

640
00:27:32,450 --> 00:27:36,200
like, honestly, starting in pseudocode like this will generally make it
说实话，像这样用伪代码开始通常会让它

641
00:27:36,200 --> 00:27:38,370
much easier to write the actual code.
更容易编写实际代码。

642
00:27:38,370 --> 00:27:41,360
So in fact, in this and future problem sets, do get into the habit,
所以实际上，在这个和未来的问题集中，要养成习惯，

643
00:27:41,360 --> 00:27:43,610
especially if you're struggling getting started-- just
特别是如果你在开始时遇到了困难——就

644
00:27:43,610 --> 00:27:45,680
write things out in English and maybe high level
用英文写下来，也许用更高级别的

645
00:27:45,680 --> 00:27:47,120
English a little more like this.
英语，更像这样。

646
00:27:47,120 --> 00:27:51,710
Then as a version two, go in with your keyboard or paper, pencil.
然后作为第二版，使用你的键盘或纸笔。

647
00:27:51,710 --> 00:27:56,240
And make it a little more precise using some code-like syntax.
并使用一些类似代码的语法使其更精确一些。

648
00:27:56,240 --> 00:27:58,430
And then I dare say in version 3, you can now
然后我敢说在第三版中，你现在可以

649
00:27:58,430 --> 00:28:01,460
translate this pretty much verbatim to C code.
几乎逐字逐句地将其翻译成 C 代码。

650
00:28:01,460 --> 00:28:04,040
The only headache is going to be rounding issues
唯一的麻烦是舍入问题

651
00:28:04,040 --> 00:28:06,890
with integers because if you divide an integer and you a fraction,
对于整数，因为如果你除以一个整数，而你又得到一个小数，

652
00:28:06,890 --> 00:28:08,810
it's going to truncate, so all that kind of headache.
它将被截断，所以所有这些都会让人头疼。

653
00:28:08,810 --> 00:28:10,670
But you can work through that by just thinking
但是你可以通过思考来解决这个问题

654
00:28:10,670 --> 00:28:12,440
through what's going to get truncated when
在舍入时，哪些部分会被截断

655
00:28:12,440 --> 00:28:15,630
you round down or up as a solution.
你向上或向下舍入作为解决方案。

656
00:28:15,630 --> 00:28:17,870
Any questions, though, on this pseudocode
关于这个伪代码，有什么问题吗？

657
00:28:17,870 --> 00:28:23,420
for either linear or binary search as we've defined them--
无论是我们定义的线性搜索还是二分搜索——

658
00:28:23,420 --> 00:28:26,340
linear or binary search--
线性搜索或二分搜索——

659
00:28:26,340 --> 00:28:26,840
no?
没有？

660
00:28:26,840 --> 00:28:28,798
All right, well, let's consider then a bit more
好吧，那么让我们再考虑一下

661
00:28:28,798 --> 00:28:33,000
formally a question that we'll come back to in the future in future classes
更正式地讲，这个问题我们将在未来的课程中再回来讨论

662
00:28:33,000 --> 00:28:33,500
as well.
也一样。

663
00:28:33,500 --> 00:28:35,885
What is the running time of these algorithms?
这些算法的运行时间是多少？

664
00:28:35,885 --> 00:28:38,927
What is, that is to say, the efficiency of these algorithms?
也就是说，这些算法的效率如何？

665
00:28:38,927 --> 00:28:41,510
And how do we actually measure the efficiency of an algorithm?
我们如何实际衡量算法的效率？

666
00:28:41,510 --> 00:28:44,017
Is it with a stopwatch or with some other mechanism?
是用秒表还是其他机制？

667
00:28:44,017 --> 00:28:46,100
Well, I propose that we think back to this picture
好吧，我建议我们回过头来看看这幅图

668
00:28:46,100 --> 00:28:50,660
here, whereby this, again, was representative of both the phone book
在这里，这，再次，代表了电话簿

669
00:28:50,660 --> 00:28:54,140
example from week zero and theoretically, bug aside,
第零周的例子，从理论上来说，除了错误之外，

670
00:28:54,140 --> 00:28:57,920
the attendance counting algorithm from earlier today, whereby
今天早些时候的出勤计数算法，其中

671
00:28:57,920 --> 00:29:02,150
this same green line theoretically represents how much time it should have
同一条绿线理论上代表了我们作为团队应该花费多少时间

672
00:29:02,150 --> 00:29:04,380
taken us as a group to count ourselves.
来数我们自己。

673
00:29:04,380 --> 00:29:04,880
Why?
为什么？

674
00:29:04,880 --> 00:29:07,520
Because if maybe another class comes in and doubles
因为如果另一个班级进来，人数翻倍

675
00:29:07,520 --> 00:29:11,280
the size of the number of humans in this room, no big deal.
这个房间里的人数，没什么大不了的。

676
00:29:11,280 --> 00:29:14,960
That's just one more step or one more iteration of the loop
那只是一步或循环的一次迭代

677
00:29:14,960 --> 00:29:17,850
because half of the people would anyway sit down.
因为一半的人都会坐下。

678
00:29:17,850 --> 00:29:22,410
So this green algorithm still represents the faster theoretical algorithm today.
所以这个绿色算法仍然代表了今天理论上更快的算法。

679
00:29:22,410 --> 00:29:26,130
And so recall that we described these things more mathematically as n.
所以，回想一下，我们用数学方法将这些东西描述为 n。

680
00:29:26,130 --> 00:29:29,970
So this was one page at a time or one person at a time.
所以，这是每次一页或每次一个人。

681
00:29:29,970 --> 00:29:33,130
This was two people or two pages at a time.
这是每次两个人或两页。

682
00:29:33,130 --> 00:29:36,480
So it's twice as fast, so if n is the number of people or pages
所以速度快一倍，所以如果 n 是人数或页数

683
00:29:36,480 --> 00:29:38,850
and divided by 2 is the total number of steps.
而除以 2 就是总步数。

684
00:29:38,850 --> 00:29:41,820
And then this one got a little mathy, but log base 2 of n.
然后这个就有点数学了，但它是以 2 为底的对数 n。

685
00:29:41,820 --> 00:29:47,850
And log base 2 of n just means what is the value when you take n and divide it
2 的对数底为n，意思是在你取n并将其除以2 时，得到的值是多少

686
00:29:47,850 --> 00:29:51,360
in two by 2 again and again and again and again
再除以2，再除以2，一直重复下去

687
00:29:51,360 --> 00:29:54,960
until you're left with just one page or one person standing.
直到只剩下一个页面或一个人站着。

688
00:29:54,960 --> 00:29:58,500
But in the world of running times, it turns out that being this precise
但在运行时间的世界里，事实证明，做到如此精确

689
00:29:58,500 --> 00:30:00,390
is not that intellectually interesting.
在智力上并不那么有趣。

690
00:30:00,390 --> 00:30:02,370
And it sort of devolves into lower level math.
它有点退化成了低级别的数学。

691
00:30:02,370 --> 00:30:04,560
It's just not necessary when having discussions
在讨论时，这并不必要

692
00:30:04,560 --> 00:30:07,500
about the efficiency of an algorithm or even code that you've written.
关于算法的效率，甚至是你写的代码的效率。

693
00:30:07,500 --> 00:30:10,020
So generally, a computer scientist, when asked
因此，一般来说，当被问及

694
00:30:10,020 --> 00:30:11,730
what's the running time of your algorithm
你的算法的运行时间

695
00:30:11,730 --> 00:30:13,813
or what's the efficiency of your algorithm or more
或你的算法的效率，或者更多地

696
00:30:13,813 --> 00:30:16,560
generally how good or bad is your algorithm,
一般来说，你的算法有多好或多坏，

697
00:30:16,560 --> 00:30:20,588
they'll talk about it being on the order of some number of steps.
他们会谈论它是某种数量级的步骤。

698
00:30:20,588 --> 00:30:23,130
This is a phrase you'll hear increasingly in computer science
你会越来越多地听到这个词语在计算机科学中

699
00:30:23,130 --> 00:30:25,020
where you can kind of wave your hand at it.
在那里你可以对此挥手。

700
00:30:25,020 --> 00:30:27,600
Like, oh, the lower level details don't matter that much.
就像，哦，低级别的细节并没有那么重要。

701
00:30:27,600 --> 00:30:31,410
All you care about in broad strokes are certain numbers
你关心的只是某些数字的大致范围

702
00:30:31,410 --> 00:30:32,940
that will add up the most.
这些数字加起来最多。

703
00:30:32,940 --> 00:30:35,250
And in fact, when computer scientists talk
事实上，当计算机科学家谈论

704
00:30:35,250 --> 00:30:37,860
about the efficiency of algorithms, they tend
算法的效率时，他们倾向于

705
00:30:37,860 --> 00:30:43,020
to throw away constant factors, so literally, numbers like 2
丢弃常数因子，也就是像2这样的数字

706
00:30:43,020 --> 00:30:46,540
that might be dividing here or a base here.
可能在这里除，或在这里作底数。

707
00:30:46,540 --> 00:30:49,710
So for instance, these two algorithms to a computer scientist
例如，这两个算法对计算机科学家来说

708
00:30:49,710 --> 00:30:50,918
would sort be the same.
应该是一样的。

709
00:30:50,918 --> 00:30:52,710
Like, yeah, it's technically twice as fast.
就像，是的，它技术上快两倍。

710
00:30:52,710 --> 00:30:53,940
But look at the lines.
但看看这些线。

711
00:30:53,940 --> 00:30:57,210
I mean, they're practically the same and this one here too, log base 2-- sure.
我的意思是，它们实际上是一样的，这个也是，2 为底的对数——当然。

712
00:30:57,210 --> 00:31:01,050
But if you remember from math class, you can change the base of any logarithm
但是如果你记得数学课上的内容，你可以很容易地改变任何对数的底

713
00:31:01,050 --> 00:31:03,040
from one number to another pretty easily.
从一个数字到另一个数字。

714
00:31:03,040 --> 00:31:06,120
So ah, let's just generalize it as log of n.
所以，让我们将其概括为 log n。

715
00:31:06,120 --> 00:31:09,390
It doesn't really matter fundamentally what the numbers actually are.
从根本上来说，这些数字的实际值并不重要。

716
00:31:09,390 --> 00:31:14,400
And honestly, if we zoom out slightly so that the y-axis and the x-axis
而且，老实说，如果我们稍微缩小一点，使得 y 轴和 x 轴

717
00:31:14,400 --> 00:31:18,240
get even bigger, honestly, these first two algorithms
变得更大，老实说，这两个算法

718
00:31:18,240 --> 00:31:21,750
really do start to resemble each other closer and closer.
确实开始越来越像彼此了。

719
00:31:21,750 --> 00:31:25,050
And I daresay in your mind's eye, imagine zooming further and further
我敢说，在你的脑海中，想象一下不断地放大

720
00:31:25,050 --> 00:31:26,070
and further out.
和放大。

721
00:31:26,070 --> 00:31:29,850
Like, that red and yellow line are pretty much-- once n is large enough--
就像，那条红线和黄线，一旦 n 足够大，它们基本上

722
00:31:29,850 --> 00:31:31,305
going to be functionally the same.
在功能上将是相同的。

723
00:31:31,305 --> 00:31:33,180
Like, they're practically the same algorithm.
就像，它们实际上是同一个算法。

724
00:31:33,180 --> 00:31:35,700
But this one is still doing amazingly because it's
但这个仍然做得惊人，因为它

725
00:31:35,700 --> 00:31:37,360
a fundamentally different shape.
是一个完全不同的形状。

726
00:31:37,360 --> 00:31:40,320
So this is to say when a computer scientist talks about, thinks
所以，当计算机科学家谈论、思考

727
00:31:40,320 --> 00:31:43,890
about the efficiency of algorithms, we just throw away the constant terms
算法的效率时，我们只是丢弃常数项

728
00:31:43,890 --> 00:31:47,450
that when n gets really large just don't seem to matter as much.
当 n 变得非常大时，这些常数项似乎并不那么重要。

729
00:31:47,450 --> 00:31:49,200
They don't add up as much or fundamentally
它们加起来并不多，也不从根本上

730
00:31:49,200 --> 00:31:51,760
change the picture in a case like this.
改变这种情况下的局面。

731
00:31:51,760 --> 00:31:55,320
So what I'm describing here with this capital letter O has a technical term.
所以，这里我用大写字母 O 描述的东西有一个专业术语。

732
00:31:55,320 --> 00:31:57,810
This is called big O notation.
它被称为大 O 符号。

733
00:31:57,810 --> 00:32:00,180
And this is omnipresent in computer science
这在计算机科学中无处不在

734
00:32:00,180 --> 00:32:02,250
and often rears its head even in programming,
而且它经常出现在编程中，

735
00:32:02,250 --> 00:32:05,617
specifically when talking about the design of some algorithm.
特别是在谈论某些算法的设计时。

736
00:32:05,617 --> 00:32:07,950
And this is a little cheat sheet here on the screen now.
现在屏幕上有个小小的速查表。

737
00:32:07,950 --> 00:32:10,890
Very often, algorithms that you write or you
很多时候，你编写的或使用的算法

738
00:32:10,890 --> 00:32:17,400
use will be describable as being on the order of one of these running times.
可以描述为这些运行时间中的某一种。

739
00:32:17,400 --> 00:32:21,180
So n is just representative of the number of things-- number of people,
所以 n 代表事物数量——人数，

740
00:32:21,180 --> 00:32:22,210
number of pages--
页数——

741
00:32:22,210 --> 00:32:25,830
whatever it is you're actually doing in code.
无论你在代码中实际做什么。

742
00:32:25,830 --> 00:32:30,150
So the mathematical formulas inside of the parentheses
所以括号内的数学公式

743
00:32:30,150 --> 00:32:33,870
describe as a function of the size of that input
描述的是作为输入大小函数的

744
00:32:33,870 --> 00:32:36,360
how fast or slow the algorithm's going to be.
算法运行速度的快慢。

745
00:32:36,360 --> 00:32:40,710
So this algorithm in the middle here, big O of n, so to speak,
所以这里中间这个算法，可以说是大 O 的 n，

746
00:32:40,710 --> 00:32:43,600
means that it takes linear time, in other words.
也就是说，它需要线性时间。

747
00:32:43,600 --> 00:32:44,760
So my first algorithm--
所以我的第一个算法——

748
00:32:44,760 --> 00:32:47,040
1, 2, 3, 4--
1、2、3、4——

749
00:32:47,040 --> 00:32:48,787
or my first algorithm in week zero--
或者我第一周的算法——

750
00:32:48,787 --> 00:32:51,630
1, 2, 3, 4.
1、2、3、4。

751
00:32:51,630 --> 00:32:53,250
That was a linear search.
那是一个线性搜索。

752
00:32:53,250 --> 00:32:56,940
The number of steps it takes is on the order of n because if there's n pages,
它所需要的步骤数量是 n 阶的，因为如果有 n 页，

753
00:32:56,940 --> 00:33:00,065
in the worst case, like, John Harvard's all the way at the end of the phone
在最坏情况下，比如，约翰·哈佛在电话簿的最后面，

754
00:33:00,065 --> 00:33:01,318
book, so it takes me n steps.
所以需要 n 步。

755
00:33:01,318 --> 00:33:04,110
In this case, it's always going to take me n steps to count you all
在这种情况下，总是要花 n 步才能数完你们所有人

756
00:33:04,110 --> 00:33:06,443
because if I want to point at each and every one of you,
因为如果我想指着你们每个人，

757
00:33:06,443 --> 00:33:08,550
that is always going to take me n steps.
这总是需要我 n 步。

758
00:33:08,550 --> 00:33:13,605
So big O represents an upper bound on the number of steps
所以大 O 代表着你可能需要计算的步骤数量的上限

759
00:33:13,605 --> 00:33:14,730
that you might be counting.
你可能会计算的步骤数量。

760
00:33:14,730 --> 00:33:17,760
And so we often use it to consider the worst case and the worst
所以我们经常用它来考虑最坏情况，最坏

761
00:33:17,760 --> 00:33:20,190
case, John Harvard, or whoever might be all the way at the end of the phone
情况，约翰·哈佛，或者任何可能在电话簿最后面的人。

762
00:33:20,190 --> 00:33:20,690
book.
簿。

763
00:33:20,690 --> 00:33:23,240
So that linear search is on the order of n.
所以那个线性搜索是 n 阶的。

764
00:33:23,240 --> 00:33:25,230
But what about n squared?
但是 n 平方呢？

765
00:33:25,230 --> 00:33:27,870
This means n people doing n things.
这意味着 n 个人做 n 件事情。

766
00:33:27,870 --> 00:33:30,590
So for instance, and we won't do this today,
举个例子，我们今天不做这个，

767
00:33:30,590 --> 00:33:33,440
but if we were to ask you again to stand up and shake
但是如果我们再让你们站起来，互相握手，

768
00:33:33,440 --> 00:33:36,140
everyone's hand in the room--
房间里每个人的手——

769
00:33:36,140 --> 00:33:40,340
not good for health nowadays-- but shake everyone's hand in the room,
现在对健康不好——但是要和房间里的每个人握手，

770
00:33:40,340 --> 00:33:42,420
how many handshakes would there be?
会有多少次握手？

771
00:33:42,420 --> 00:33:46,580
Well, if there's n of you and you've got to shake everyone else's hand,
好吧，如果有 n 个人，而且你必须和其他人握手，

772
00:33:46,580 --> 00:33:48,650
that's technically n times n minus 1.
理论上就是 n 乘以 n 减 1。

773
00:33:48,650 --> 00:33:50,030
Let's throw away the minus 1.
我们把减 1 扔掉。

774
00:33:50,030 --> 00:33:53,600
That's n times n or n squared handshakes.
那就是 n 乘以 n 或者 n 平方次握手。

775
00:33:53,600 --> 00:33:54,800
That's a lot of handshakes.
那可真是很多次握手。

776
00:33:54,800 --> 00:33:57,140
And so the running time of shaking everyone's hand
所以，和房间里每个人握手

777
00:33:57,140 --> 00:34:00,860
in the room to introduce yourself would be on the order of n squared.
自我介绍的运行时间将会是 n 平方阶的。

778
00:34:00,860 --> 00:34:04,370
At the other end of the spectrum, the faster end, big O of 1
在光谱的另一端，也就是更快的一端，大 O 的 1

779
00:34:04,370 --> 00:34:07,310
doesn't mean that the algorithm takes literally one step.
并不意味着算法只执行一步。

780
00:34:07,310 --> 00:34:11,040
It could take two steps or three or even 1,000 steps.
它可能需要两步、三步，甚至 1000 步。

781
00:34:11,040 --> 00:34:14,159
But what it means is it's a constant number of steps.
但重要的是，它始终是固定数量的步骤。

782
00:34:14,159 --> 00:34:16,520
So it doesn't matter how many people are in the room,
所以房间里有多少人并不重要，

783
00:34:16,520 --> 00:34:21,320
this describes something taking just one step total
这描述的是一个总共只进行一步的操作

784
00:34:21,320 --> 00:34:23,520
or a constant number of steps total.
或者总共固定数量的步骤。

785
00:34:23,520 --> 00:34:26,610
So for instance, earlier when everyone stood up at the same time,
例如，之前大家同时站起来时，

786
00:34:26,610 --> 00:34:29,412
that was constant time because if we had twice as many people
那就是常数时间，因为如果我们的人数翻倍

787
00:34:29,412 --> 00:34:32,370
come into the room, it's not going to take us twice as long to stand up
进入房间，我们站起来的时间并不会翻倍

788
00:34:32,370 --> 00:34:34,739
if everyone stands up at the same time.
如果大家同时站起来。

789
00:34:34,739 --> 00:34:37,030
That would be a constant time algorithm.
那将是一个常数时间算法。

790
00:34:37,030 --> 00:34:38,290
So this is linear.
所以这是线性的。

791
00:34:38,290 --> 00:34:39,330
This is constant.
这是常数。

792
00:34:39,330 --> 00:34:41,460
If you want to get fancy, this is quadratic.
如果你想变得更复杂，这是二次的。

793
00:34:41,460 --> 00:34:42,960
This is logarithmic.
这是对数的。

794
00:34:42,960 --> 00:34:44,760
And this is n log n.
这是 n log n。

795
00:34:44,760 --> 00:34:48,340
Or there's other fancier terms we can give it as well, but for now,
或者我们也可以用其他更专业的术语来描述它，但现在，

796
00:34:48,340 --> 00:34:53,050
just a common list of running times that we might apply to certain algorithms.
只列出一些我们可能用于特定算法的常见运行时间。

797
00:34:53,050 --> 00:34:56,400
So linear search, I claim, is in big O of n
所以，我认为线性搜索在 O(n) 范围内

798
00:34:56,400 --> 00:34:58,900
because it's going to take in the worst case n steps.
因为它在最坏情况下会进行 n 步。

799
00:34:58,900 --> 00:35:01,490
What about binary search?
那么二分搜索呢？

800
00:35:01,490 --> 00:35:05,870
How many steps does binary search take on the order of
根据图表，二分搜索大约需要多少步

801
00:35:05,870 --> 00:35:07,490
according to this chart?
？

802
00:35:07,490 --> 00:35:07,990
Yeah?
是吗？

803
00:35:07,990 --> 00:35:08,700
AUDIENCE: Log n.
观众：log n。

804
00:35:08,700 --> 00:35:09,630
DAVID MALAN: Log n.
大卫·马兰：log n。

805
00:35:09,630 --> 00:35:14,250
Yeah, because no matter what with binary search, you're dividing in half,
是的，因为无论二分搜索如何，你都在进行二分，

806
00:35:14,250 --> 00:35:15,510
half, half.
二分，二分。

807
00:35:15,510 --> 00:35:19,380
But in the worst case, it might be in the last door you check.
但在最坏情况下，它可能在最后一个检查的门里。

808
00:35:19,380 --> 00:35:21,630
But you only took log n steps to get there.
但你只用了 log n 步才到达那里。

809
00:35:21,630 --> 00:35:23,550
But it still might be the last one you check.
但它仍然可能是你检查的最后一个。

810
00:35:23,550 --> 00:35:26,897
So binary search indeed would be on the order of log n.
因此，二分搜索的确是 log n 级的。

811
00:35:26,897 --> 00:35:28,230
But sometimes, you do get lucky.
但有时，你确实会走运。

812
00:35:28,230 --> 00:35:30,990
And we saw with our volunteers that sometimes you can get lucky
我们从志愿者身上看到，有时你确实会走运

813
00:35:30,990 --> 00:35:32,430
and just find things quicker.
并且能更快地找到东西。

814
00:35:32,430 --> 00:35:35,793
So we don't always want to talk about things in terms of an upper bound,
因此，我们并不总是想用上限来谈论事情，

815
00:35:35,793 --> 00:35:38,460
like how many steps in the worst case might this algorithm take.
比如，在最坏情况下，该算法可能需要多少步。

816
00:35:38,460 --> 00:35:40,860
Sometimes it's useful to know in the best case
有时，了解在最佳情况下

817
00:35:40,860 --> 00:35:43,350
how few steps might an algorithm take.
一个算法可能需要多少步是很有用的。

818
00:35:43,350 --> 00:35:46,170
So for that, we have this capital Greek omega, which
为此，我们有这个大写的希腊字母 Ω，它

819
00:35:46,170 --> 00:35:48,540
is another symbol in computer science.
是计算机科学中的另一个符号。

820
00:35:48,540 --> 00:35:53,872
And whereas big O represents upper bound, omega represents lower bound.
而大 O 代表上限，Ω 代表下限。

821
00:35:53,872 --> 00:35:55,080
And it's the exact same idea.
它指的是完全相同的概念。

822
00:35:55,080 --> 00:35:56,820
It's just a different symbol to represent
只是用不同的符号来表示

823
00:35:56,820 --> 00:35:58,930
a different idea, the opposite, in this case.
不同的概念，在本例中是相反的。

824
00:35:58,930 --> 00:36:00,690
So here's a similar cheat sheet here.
所以这里也有一个类似的速查表。

825
00:36:00,690 --> 00:36:02,670
But when you use the omega symbol, that just
但当你使用 Ω 符号时，它只是

826
00:36:02,670 --> 00:36:07,240
means that this algorithm might take as few as this many steps,
表示该算法可能只需要这些步骤，

827
00:36:07,240 --> 00:36:09,610
for instance, in the very best case.
例如，在最佳情况下。

828
00:36:09,610 --> 00:36:12,640
So by that logic, if I ask about linear search,
所以，根据这个逻辑，如果我询问线性搜索，

829
00:36:12,640 --> 00:36:17,090
our first demonstration with the lockers, let's consider the best case.
我们对储物柜的第一个演示，让我们考虑最佳情况。

830
00:36:17,090 --> 00:36:19,720
How many steps might it take to search n lockers
搜索n个储物柜需要多少步骤

831
00:36:19,720 --> 00:36:21,610
using linear search in the best case?
在最佳情况下，使用线性搜索？

832
00:36:21,610 --> 00:36:22,960
You get lucky.
你很幸运。

833
00:36:22,960 --> 00:36:23,680
So I heard it.
所以我听到了。

834
00:36:23,680 --> 00:36:24,950
Yeah, just one step.
是的，只有一步。

835
00:36:24,950 --> 00:36:29,210
So we could say that linear search is an omega of 1, so to speak.
所以可以说，线性搜索是1的欧米伽，可以这么说。

836
00:36:29,210 --> 00:36:30,880
What about binary search?
二分查找呢？

837
00:36:30,880 --> 00:36:34,150
If you've got n lockers, in the best case, though,
如果你有n个储物柜，在最好的情况下，

838
00:36:34,150 --> 00:36:35,947
how few steps might it take us?
我们需要多少步骤？

839
00:36:35,947 --> 00:36:37,780
Again, one, because we might just get lucky.
同样，一个，因为我们可能只是运气好。

840
00:36:37,780 --> 00:36:40,460
And boom, it happens to be right there in the middle.
然后，它正好在中间。

841
00:36:40,460 --> 00:36:46,000
So you could say that both linear search and binary search are an omega of 1.
所以可以说，线性搜索和二分查找都是1的欧米伽。

842
00:36:46,000 --> 00:36:50,620
Now, by contrast, my attendance algorithm, the first one I proposed--
相比之下，我的考勤算法，我提出的第一个算法——

843
00:36:50,620 --> 00:36:55,822
1, 2, 3, 4, 5, 6, 7, I claimed a moment ago that that's in big O of n
1，2，3，4，5，6，7，我之前说过，它属于大O(n)

844
00:36:55,822 --> 00:36:58,780
because if there's n people in the room, I've got to point at everyone.
因为如果房间里有n个人，我必须指点每个人。

845
00:36:58,780 --> 00:37:00,580
But equivalently, if there's n people in the room
但同样，如果房间里有n个人

846
00:37:00,580 --> 00:37:03,400
and I have to point at everyone, what's the fewest number of steps
我必须指点每个人，最少需要多少步骤

847
00:37:03,400 --> 00:37:08,770
it could take me to take attendance using this linear approach?
我才能用这种线性方法点名？

848
00:37:08,770 --> 00:37:11,730
So still n, right, unless I guess, which is not an algorithm.
所以仍然是n，对吧，除非我猜，但这不算是算法。

849
00:37:11,730 --> 00:37:14,230
Like, unless I guess, I'm not going to get the right answer,
比如，除非我猜，我不会得到正确答案，

850
00:37:14,230 --> 00:37:16,120
so I kind of have to point at everyone.
所以我必须指点每个人。

851
00:37:16,120 --> 00:37:18,210
So in both the best case and the worst case,
所以在最好的情况下和最坏的情况下，

852
00:37:18,210 --> 00:37:20,640
some algorithms still take n steps.
一些算法仍然需要n步。

853
00:37:20,640 --> 00:37:24,300
And for this, we have what we'll call theta notation, whereby
为此，我们有我们称之为θ记法的概念，即

854
00:37:24,300 --> 00:37:28,110
if big O and omega happen to be the same, which is not always the case
如果大O和小ω恰好相同，虽然并非总是如此

855
00:37:28,110 --> 00:37:33,190
but can be, then you can say that algorithm is in theta of such and such.
但可能相同，那么你可以说这个算法属于θ(某个东西)。

856
00:37:33,190 --> 00:37:37,530
So my attendance-taking algorithm, the very first, 1, 2, 3, 4,
所以我的考勤算法，第一个，1，2，3，4，

857
00:37:37,530 --> 00:37:40,020
all the way on up to n would be in theta of n
一直到n，将属于θ(n)

858
00:37:40,020 --> 00:37:42,250
because in both the best case and the worst case,
因为在最好的情况下和最坏的情况下，

859
00:37:42,250 --> 00:37:48,143
it takes the same number of steps as per my big O and omega analysis.
它需要与我的大O和小ω分析相同的步数。

860
00:37:48,143 --> 00:37:51,060
Now, there is a more formal mathematical definition for both of these.
现在，这两个都有更正式的数学定义。

861
00:37:51,060 --> 00:37:52,620
And if you take higher level computer science,
如果你学习更高阶的计算机科学，

862
00:37:52,620 --> 00:37:54,495
you'll go more into the weeds of these ideas.
你会更深入地研究这些概念。

863
00:37:54,495 --> 00:37:56,820
But for now, big O, upper bound.
但目前，大O，上限。

864
00:37:56,820 --> 00:37:59,100
Omega, lower bound.
欧米伽，下限。

865
00:37:59,100 --> 00:38:03,430
Questions on this symbology?
关于这种符号，有什么问题吗？

866
00:38:03,430 --> 00:38:06,920
It'll be a tool in our tool kit.
它将成为我们工具箱中的工具。

867
00:38:06,920 --> 00:38:07,420
No?
没有？

868
00:38:07,420 --> 00:38:14,260
OK, so with that said, let's see how we might translate this to actual code
好的，既然这样，让我们看看如何将它翻译成实际代码

869
00:38:14,260 --> 00:38:17,050
in something that makes sense now using C and not so much
使用C语言，现在用一些有意义的东西，而不仅仅是

870
00:38:17,050 --> 00:38:20,570
new syntax but applications of similar ideas from last time.
新语法，而是上一次类似概念的应用。

871
00:38:20,570 --> 00:38:25,237
So for instance, let me actually go over to search dot C. And in search dot C,
例如，让我实际转到search.c。在search.c中，

872
00:38:25,237 --> 00:38:27,820
I'm going to go ahead and implement the idea of linear search,
我将继续实现线性搜索的理念，

873
00:38:27,820 --> 00:38:29,980
very simply, using integers initially.
非常简单，最初使用整数。

874
00:38:29,980 --> 00:38:34,150
So to do this, let me go ahead and give myself the familiar CS50 dot h
所以要做到这一点，让我继续给自己熟悉的CS50.h

875
00:38:34,150 --> 00:38:36,460
so that I can ask the human what number to search for.
这样我就可以问人类要搜索哪个数字。

876
00:38:36,460 --> 00:38:40,000
Then let me go ahead and include standard io.h
然后让我继续包含stdio.h

877
00:38:40,000 --> 00:38:42,430
so that I can use printf and the like.
这样我就可以使用 printf 等等。

878
00:38:42,430 --> 00:38:45,880
Then I'm going to go ahead and do int main void without any command line
然后，我将继续执行 int main void，不带任何命令行

879
00:38:45,880 --> 00:38:49,130
arguments because I'm not going to need any for this particular demonstration.
参数，因为在这个特定的演示中我不会用到任何参数。

880
00:38:49,130 --> 00:38:50,920
And someone asked about this a while back.
有人之前问过这个问题。

881
00:38:50,920 --> 00:38:53,560
If I want to declare an array of values but I
如果我想声明一个值的数组，但是我

882
00:38:53,560 --> 00:38:57,650
know in advance what the values are, there is a special syntax I can use,
事先知道这些值是什么，我可以使用一种特殊的语法，

883
00:38:57,650 --> 00:38:58,330
which is this.
就是这个。

884
00:38:58,330 --> 00:39:01,480
If I want a whole bunch of numbers but I want those numbers to be stored
如果我想得到一大堆数字，但是我想把这些数字存储

885
00:39:01,480 --> 00:39:04,780
in an array, I can store them in--
在一个数组中，我可以将它们存储在——

886
00:39:04,780 --> 00:39:06,380
using these curly braces.
使用这些花括号。

887
00:39:06,380 --> 00:39:09,582
And I'm going to use the same numbers as the monopoly denominations
我将使用与我们一直在玩的大富翁面额相同的数字

888
00:39:09,582 --> 00:39:10,790
that we've been playing with.
我们一直在玩。

889
00:39:10,790 --> 00:39:12,690
And I'm just going to put them in sort of random order.
我只是要随机地把它们放进去。

890
00:39:12,690 --> 00:39:15,315
But I'm going to deliberately put the 50 all the way at the end
但我故意把 50 放到最后

891
00:39:15,315 --> 00:39:19,430
just so that I know that it's going to try all possible steps, so big O of n,
这样我就知道它会尝试所有可能的步骤，所以是 n 的大 O，

892
00:39:19,430 --> 00:39:20,210
ultimately.
最终。

893
00:39:20,210 --> 00:39:23,180
Now let's go ahead and ask the user for a value n.
现在让我们继续让用户输入一个值 n。

894
00:39:23,180 --> 00:39:24,530
And we'll use get int.
我们将使用 get int。

895
00:39:24,530 --> 00:39:28,520
And just ask the user for a number to search for, be it 50 or something else.
然后，就让用户输入一个要查找的数字，可以是 50 或者其他数字。

896
00:39:28,520 --> 00:39:32,000
And then here's how I might implement in code now linear search,
然后，这就是我现在在代码中实现线性搜索的方法，

897
00:39:32,000 --> 00:39:34,850
translating effectively the pseudocode from last time.
有效地将上一次的伪代码翻译过来。

898
00:39:34,850 --> 00:39:38,090
For int i equals 0.
对于 int i 等于 0。

899
00:39:38,090 --> 00:39:40,940
i is less than 7. i plus plus.
i 小于 7。i 加加。

900
00:39:40,940 --> 00:39:43,670
And then inside of this loop, I can ask a question.
然后在这个循环里面，我可以问一个问题。

901
00:39:43,670 --> 00:39:47,610
If the ith number in the numbers array--
如果 numbers 数组中的第 i 个数字——

902
00:39:47,610 --> 00:39:51,170
so numbers bracket i-- equals, equals the number n
也就是 numbers 中的第 i 个数字—— 等于，等于数字 n

903
00:39:51,170 --> 00:39:55,130
that I care about, well, this is where I could just declare return true
我关心的那个数字，那么，我可以在这个地方直接声明 return true

904
00:39:55,130 --> 00:39:55,930
or return false.
或者 return false。

905
00:39:55,930 --> 00:39:58,430
Here, I'm going to go ahead and just use a printf statement.
这里，我将继续使用一个 printf 语句。

906
00:39:58,430 --> 00:40:01,670
And I'm going to say found, backslash n, just to know visually
我将说 found，反斜杠 n，只是为了视觉上

907
00:40:01,670 --> 00:40:03,110
that I found the number.
知道我找到了这个数字。

908
00:40:03,110 --> 00:40:06,920
And else I might do something like this.
否则我可能会做这样的事。

909
00:40:06,920 --> 00:40:09,080
Else if that's not the case, I'll go ahead
否则，如果情况不是这样，我会继续

910
00:40:09,080 --> 00:40:13,910
and print out not found backslash n.
并打印出 not found 反斜杠 n。

911
00:40:13,910 --> 00:40:16,410
All right, so let me zoom out for just a moment.
好吧，让我稍微放大一点。

912
00:40:16,410 --> 00:40:17,690
Here's all of my code.
这是我所有的代码。

913
00:40:17,690 --> 00:40:25,130
Any concerns with this implementation of what I claim is now linear search?
对这个我声称是线性搜索的实现有任何疑问吗？

914
00:40:25,130 --> 00:40:28,970
Any concerns with what I claim is linear search?
对这个我声称是线性搜索的实现有任何疑问吗？

915
00:40:28,970 --> 00:40:29,885
Yeah?
有吗？

916
00:40:29,885 --> 00:40:32,855
AUDIENCE: [INAUDIBLE]
观众：[听不见]

917
00:40:32,855 --> 00:40:33,950
DAVID MALAN: Exactly.
大卫·马兰：没错。

918
00:40:33,950 --> 00:40:37,917
If I search the first number and it's not found, it's going to say not found.
如果我搜索第一个数字，并且没有找到，它会说没找到。

919
00:40:37,917 --> 00:40:40,500
But it's going to keep saying not found, not found, not found,
但它会一直说没找到，没找到，没找到，

920
00:40:40,500 --> 00:40:41,360
which might be fine.
这可能是可以的。

921
00:40:41,360 --> 00:40:42,402
But it's a little stupid.
但有点傻。

922
00:40:42,402 --> 00:40:44,325
I probably want to know if it's found or not.
我可能想知道它是否找到了。

923
00:40:44,325 --> 00:40:46,700
So I've made that same mistake that I called out earlier.
所以我犯了之前提到的同样的错误。

924
00:40:46,700 --> 00:40:49,700
Like, the else is not the alternative to not finding
比如，else 不是在第一个位置没有找到数字的替代方案。

925
00:40:49,700 --> 00:40:51,570
the number in that first location.
它不是在第一个位置没有找到数字的替代方案。

926
00:40:51,570 --> 00:40:55,890
It's the final decision to make when I haven't actually found the value.
这是在我没有真正找到值的时候要做的最终决定。

927
00:40:55,890 --> 00:40:58,580
So I think what I want to do is get rid of this else clause.
所以我想做的是去掉这个else子句。

928
00:40:58,580 --> 00:41:01,940
And then at the outside of this loop, I think
然后在这个循环的外面，我认为

929
00:41:01,940 --> 00:41:03,770
I want to conclude printf not found.
我想总结一下，printf 没有找到。

930
00:41:03,770 --> 00:41:08,420
But here too there's a new bug that's arisen.
但在这里也出现了一个新的错误。

931
00:41:08,420 --> 00:41:13,310
There's a new bug, even though I fixed the logical error you just described.
虽然我已经修复了您刚才描述的逻辑错误，但仍然存在一个新的错误。

932
00:41:13,310 --> 00:41:15,290
What symptom are we still going to see?
我们还会看到什么症状？

933
00:41:18,290 --> 00:41:20,960
Yeah, now it's going to always print not found,
是的，现在它总是会打印找不到，

934
00:41:20,960 --> 00:41:23,997
even when I have found it because even once I've found it
即使我找到了它，因为即使我找到了它

935
00:41:23,997 --> 00:41:26,330
and I finished going through the array, it's still going
并且我完成了遍历数组，它仍然在

936
00:41:26,330 --> 00:41:27,740
to assume that I got to the bottom.
假设我到达了底部。

937
00:41:27,740 --> 00:41:28,990
And therefore, it's not found.
因此，它没有找到。

938
00:41:28,990 --> 00:41:32,660
So I need to somehow exit out of main prematurely, if you will.
因此，如果可以的话，我需要以某种方式提前退出 main 函数。

939
00:41:32,660 --> 00:41:35,510
And recall that last week, we also introduced the idea
还记得上周我们也介绍了这个概念

940
00:41:35,510 --> 00:41:39,680
that main all this time does actually return a value, an integer.
就是 main 函数实际上一直都在返回一个值，一个整数。

941
00:41:39,680 --> 00:41:42,110
By default, it's secretly been zero.
默认情况下，它一直是秘密的零。

942
00:41:42,110 --> 00:41:46,130
Anytime a program exits, it just returns zero, an exit status of zero.
只要程序退出，它就会返回零，退出状态为零。

943
00:41:46,130 --> 00:41:47,970
But we do now have control over that.
但我们现在可以控制它。

944
00:41:47,970 --> 00:41:51,080
And so a convention in C would be that when
因此，在 C 语言中，约定是，当

945
00:41:51,080 --> 00:41:54,500
you want your main function to end prematurely if so,
您希望您的 main 函数提前结束，如果这样的话，

946
00:41:54,500 --> 00:41:56,587
you can literally just return a value.
您可以直接返回一个值。

947
00:41:56,587 --> 00:41:59,670
And even though this feels a little backwards, this is just the way it is.
虽然这感觉有点倒退，但这就是事实。

948
00:41:59,670 --> 00:42:02,450
You return zero to indicate success.
您返回零表示成功。

949
00:42:02,450 --> 00:42:06,120
And you return any other integer to indicate failure.
您返回任何其他整数表示失败。

950
00:42:06,120 --> 00:42:09,110
So by convention, people go to 1 and then 2 and then 3.
因此，按照惯例，人们会使用 1，然后是 2，然后是 3。

951
00:42:09,110 --> 00:42:11,310
They don't think too hard about what numbers to use.
他们不会过多地考虑使用哪些数字。

952
00:42:11,310 --> 00:42:14,120
But in this case, I'm going to go ahead and return 1
但在这种情况下，我将继续返回 1

953
00:42:14,120 --> 00:42:16,440
if I do get to the bottom of this file.
如果我确实到达了这个文件的底部。

954
00:42:16,440 --> 00:42:21,090
So now if I open back up my terminal window, I run make search.
所以现在，如果我重新打开我的终端窗口，运行 make search。

955
00:42:21,090 --> 00:42:23,267
No syntax errors-- dot slash search.
没有语法错误-- 点斜杠 search。

956
00:42:23,267 --> 00:42:24,850
I'm going to be prompted for a number.
我将被提示输入一个数字。

957
00:42:24,850 --> 00:42:26,683
Let's go ahead and search for the number 50.
让我们继续搜索数字 50。

958
00:42:26,683 --> 00:42:28,650
And I should see found.
我应该看到找到了。

959
00:42:28,650 --> 00:42:31,290
Meanwhile, if I run it again-- dot slash search--
同时，如果我再次运行它-- 点斜杠 search--

960
00:42:31,290 --> 00:42:34,590
I search for the number 13, that should be not found.
我搜索数字 13，它应该找不到。

961
00:42:34,590 --> 00:42:38,850
So I claim that this is now a correct implementation of linear search
所以，我认为这现在是线性搜索的正确实现

962
00:42:38,850 --> 00:42:43,620
that's gone from left to right, looking for a number that may or may not
它从左到右进行，寻找一个可能存在也可能不存在的数字

963
00:42:43,620 --> 00:42:44,310
be there.
在那里。

964
00:42:44,310 --> 00:42:48,420
Any questions on this version of the code here?
关于这段代码有什么问题吗？

965
00:42:48,420 --> 00:42:49,578
Yeah?
对？

966
00:42:49,578 --> 00:42:53,064
AUDIENCE: [INAUDIBLE]
观众： [听不见]

967
00:42:53,064 --> 00:42:55,760
DAVID MALAN: Return zero indicates success
大卫·马兰：返回零表示成功

968
00:42:55,760 --> 00:42:58,250
when doing it from main in particular.
特别是从 main 函数执行时。

969
00:42:58,250 --> 00:43:02,480
And that's backwards only in the sense that generally 0 is false.
这只是因为一般情况下 0 代表假。

970
00:43:02,480 --> 00:43:04,640
And 1 is true.
而 1 代表真。

971
00:43:04,640 --> 00:43:09,272
But the logic here is that if the program works correctly, that's zero.
但这里的逻辑是，如果程序正常工作，那就是零。

972
00:43:09,272 --> 00:43:11,730
But there's an infinite number of things that can go wrong.
但可能出现无限多种错误。

973
00:43:11,730 --> 00:43:15,290
And that's why we need 1 and 2 and 3 and 4 and all the way up.
这就是为什么我们需要 1、2、3、4 以及一直到最大值。

974
00:43:15,290 --> 00:43:17,362
Other questions?
还有其他问题吗？

975
00:43:17,362 --> 00:43:19,842
AUDIENCE: [INAUDIBLE]
观众： [听不见]

976
00:43:19,842 --> 00:43:21,637
DAVID MALAN: Yes.
大卫·马兰：是的。

977
00:43:21,637 --> 00:43:25,533
AUDIENCE: [INAUDIBLE]
观众：[听不清]

978
00:43:25,533 --> 00:43:26,590
DAVID MALAN: Correct.
大卫·马兰：正确。

979
00:43:26,590 --> 00:43:31,270
When you return zero or return any value from main wherever it is in your code,
当你从 main 函数中返回 0 或任何值，无论它在代码中的位置，

980
00:43:31,270 --> 00:43:34,240
the program will effectively terminate right then and there.
程序将立即终止。

981
00:43:34,240 --> 00:43:37,600
No additional code will get executed at the bottom of the function.
函数底部将不会执行任何额外的代码。

982
00:43:37,600 --> 00:43:39,310
You'll effectively exit out.
你将有效地退出。

983
00:43:39,310 --> 00:43:43,240
Just like in a normal function that isn't main, when you return a value,
就像在不是 main 函数的普通函数中一样，当你返回一个值时，

984
00:43:43,240 --> 00:43:46,930
it immediately exits that function and hands back the value.
它会立即退出该函数并返回该值。

985
00:43:46,930 --> 00:43:47,440
Yeah?
是的？

986
00:43:47,440 --> 00:43:49,352
AUDIENCE: [INAUDIBLE]
观众：[听不清]

987
00:43:49,352 --> 00:43:52,020
DAVID MALAN: So return 1 is just me being
大卫·马兰：所以返回 1 只是我

988
00:43:52,020 --> 00:43:56,250
pedantic at this point because I'm frankly not going to really care what
在这个时候过于严格，因为坦白地说，我并不关心

989
00:43:56,250 --> 00:43:58,110
the exit status is of this program.
这个程序的退出状态是什么。

990
00:43:58,110 --> 00:44:03,810
But once I've introduced the idea of manually returning 0 on this line 14
但是，一旦我在第 14 行手动返回 0 的概念，

991
00:44:03,810 --> 00:44:07,470
to indicate success, it stands to reason that I should also
来指示成功，那么有道理的是，我也应该

992
00:44:07,470 --> 00:44:10,510
return a different value when I want to indicate failure.
在我想指示失败时返回一个不同的值。

993
00:44:10,510 --> 00:44:13,038
And so even though this does not functionally
即使这在功能上

994
00:44:13,038 --> 00:44:15,330
change the program-- it will still work-- it will still
不会改变程序——它仍然会工作——它仍然会

995
00:44:15,330 --> 00:44:19,050
print the same things correctly-- it's a lower level detail
正确地打印相同的东西——这是一个更底层的细节

996
00:44:19,050 --> 00:44:22,260
that programmers, teaching assistants, testing software,
程序员、助教、测试软件，

997
00:44:22,260 --> 00:44:24,930
might appreciate, knowing what actually happened
可能会觉得有用，因为他们知道程序底层实际发生了什么

998
00:44:24,930 --> 00:44:28,160
in the program underneath the hood.
。

999
00:44:28,160 --> 00:44:30,660
All right, so what about strings?
好的，那么字符串呢？

1000
00:44:30,660 --> 00:44:32,660
So it turns out with strings, we're going
事实证明，对于字符串，我们将

1001
00:44:32,660 --> 00:44:35,790
to have to think a little harder about how best to do this.
不得不更认真地考虑如何才能做到这一点。

1002
00:44:35,790 --> 00:44:37,530
So let me actually go ahead and do this.
所以，让我实际操作一下。

1003
00:44:37,530 --> 00:44:41,240
Let me go ahead and get rid of much of this code but transition
让我把大部分代码去掉，但要转到

1004
00:44:41,240 --> 00:44:44,420
to a different type of array, this time an array of strings.
一种不同的数组类型，这次是字符串数组。

1005
00:44:44,420 --> 00:44:47,570
And I'm going to call the array strings itself plural, just to make clear
我将把这个数组称为字符串本身的复数，只是为了清楚地表明

1006
00:44:47,570 --> 00:44:48,985
what's in it instead of numbers.
它里面是什么，而不是数字。

1007
00:44:48,985 --> 00:44:51,110
I'm going to use the square bracket notation, which
我将使用方括号表示法，它

1008
00:44:51,110 --> 00:44:54,235
just means I don't know at the moment how many elements it's going to have.
只是意味着我现在不知道它将有多少个元素。

1009
00:44:54,235 --> 00:44:56,030
But the compiler can figure it out for me.
但是编译器可以帮我弄明白。

1010
00:44:56,030 --> 00:44:58,910
And in the spirit of Monopoly, let's go ahead in our curly braces,
秉承大富翁的精神，让我们在花括号中，

1011
00:44:58,910 --> 00:45:00,440
do something like this.
做一些这样的事情。

1012
00:45:00,440 --> 00:45:03,200
Battleship is going to be one of the strings.
战舰将是其中一个字符串。

1013
00:45:03,200 --> 00:45:05,390
Boot is going to be another.
靴子将是另一个。

1014
00:45:05,390 --> 00:45:07,160
Cannon is going to be a third.
大炮将是第三个。

1015
00:45:07,160 --> 00:45:09,140
Iron is going to be the fourth.
铁将是第四个。

1016
00:45:09,140 --> 00:45:11,510
Thimble-- and if you've ever played Monopoly,
顶针——如果你玩过大富翁，

1017
00:45:11,510 --> 00:45:14,610
you know where these are coming from-- and top hat, for instance.
你就知道这些东西是从哪里来的——例如，还有帽子。

1018
00:45:14,610 --> 00:45:17,510
So this gives me 1, 2, 3, 4, 5, 6.
所以，这给了我 1、2、3、4、5、6。

1019
00:45:17,510 --> 00:45:19,148
I could write the number 6 here.
我可以在这里写数字 6。

1020
00:45:19,148 --> 00:45:20,690
And the compiler would appreciate it.
编译器会感激的。

1021
00:45:20,690 --> 00:45:21,607
But it doesn't matter.
但这并不重要。

1022
00:45:21,607 --> 00:45:25,280
The compiler can figure it out on its own just based on the number of commas.
编译器可以根据逗号的数量自行判断。

1023
00:45:25,280 --> 00:45:28,440
And this also ensures that I don't write one number to the left
这也确保我不会在左边写一个数字，

1024
00:45:28,440 --> 00:45:30,130
and then miscount on the right.
然后在右边算错。

1025
00:45:30,130 --> 00:45:32,890
So omitting it is probably in everyone's benefit.
所以省略它可能对每个人都有利。

1026
00:45:32,890 --> 00:45:33,840
Now let's do this.
现在让我们这样做。

1027
00:45:33,840 --> 00:45:38,340
Let's ask the user for a string using get string instead of get int
让我们使用 get string 而不是 get int 来询问用户一个字符串。

1028
00:45:38,340 --> 00:45:40,650
for some string to search for.
用于搜索某些字符串。

1029
00:45:40,650 --> 00:45:42,660
Then let's go ahead and do the exact same thing.
然后让我们继续做完全相同的事情。

1030
00:45:42,660 --> 00:45:46,620
For i int i equals 0.
对于 i int i 等于 0。

1031
00:45:46,620 --> 00:45:50,670
i is less than 6, which is technically a magic number.
i 小于 6，在技术上是一个神奇数字。

1032
00:45:50,670 --> 00:45:53,070
But let's focus on the searching algorithm for now.
但让我们暂时关注搜索算法。

1033
00:45:53,070 --> 00:45:54,330
i plus plus.
i 加加。

1034
00:45:54,330 --> 00:45:56,850
And then inside of this loop, let's do this.
然后在这个循环内，让我们这样做。

1035
00:45:56,850 --> 00:46:04,980
If strings bracket i equals equals, s, then let's go ahead
如果字符串中括号内的 i 等于 s，那么让我们继续

1036
00:46:04,980 --> 00:46:08,100
and print out just as before, quote, unquote, found-- backslash n--
并像以前一样打印出来，引号，引号，已找到——反斜杠 n——

1037
00:46:08,100 --> 00:46:10,125
and proactively return zero this time.
并主动返回零。

1038
00:46:10,125 --> 00:46:12,000
And if we don't find it anywhere in the loop,
如果我们在循环中任何地方都没有找到它，

1039
00:46:12,000 --> 00:46:14,280
let's go ahead and return 1 at the very bottom,
让我们继续并在最底部返回 1，

1040
00:46:14,280 --> 00:46:17,820
before which we will print not found backslash n.
在此之前，我们将打印未找到反斜杠 n。

1041
00:46:17,820 --> 00:46:20,670
So it's the exact same logic at the moment,
所以现在逻辑完全相同，

1042
00:46:20,670 --> 00:46:23,530
even though I've changed my ints to strings.
即使我已经将我的整数更改为字符串。

1043
00:46:23,530 --> 00:46:25,950
Let me go ahead and open up my terminal window now.
现在让我打开我的终端窗口。

1044
00:46:25,950 --> 00:46:30,810
Do make search again and see, OK, so far, so good.
再次进行搜索并查看，好的，到目前为止，一切顺利。

1045
00:46:30,810 --> 00:46:33,780
Let me now go ahead and do dot slash search.
现在让我继续执行点斜杠搜索。

1046
00:46:33,780 --> 00:46:37,470
And let's go ahead and search for-- how about top hat.
让我们继续搜索——怎么样，顶帽子。

1047
00:46:37,470 --> 00:46:39,653
So we should see found.
所以我们应该看到已找到。

1048
00:46:39,653 --> 00:46:40,415
Huh.
嗯。

1049
00:46:40,415 --> 00:46:41,290
All right, not found.
好的，未找到。

1050
00:46:41,290 --> 00:46:43,332
All right, well, let's do dot slash search again.
好的，好吧，让我们再次执行点斜杠搜索。

1051
00:46:43,332 --> 00:46:44,320
How about thimble?
怎么样，顶针？

1052
00:46:44,320 --> 00:46:47,380
Maybe it's because it's just two words.
也许是因为它只是两个词。

1053
00:46:47,380 --> 00:46:50,110
No, thimble's not found, either.
不，顶针也没有找到。

1054
00:46:50,110 --> 00:46:53,230
Dot slash search-- let's search for the first one, battleship.
点斜杠搜索——让我们搜索第一个，战舰。

1055
00:46:53,230 --> 00:46:55,240
Enter-- still not found.
回车——仍然没有找到。

1056
00:46:55,240 --> 00:46:57,280
Let's search for something else like cat.
让我们搜索其他东西，比如猫。

1057
00:46:57,280 --> 00:46:58,600
Not found.
未找到。

1058
00:46:58,600 --> 00:47:03,550
What is going on because I'm pretty sure the logic is exactly the same?
到底发生了什么，因为我确信逻辑完全相同？

1059
00:47:03,550 --> 00:47:09,010
Well, it turns out in C, this line here, currently line 11,
好吧，事实证明在 C 中，这里这行，当前第 11 行，

1060
00:47:09,010 --> 00:47:11,350
is not how you compare strings.
这不是你比较字符串的方式。

1061
00:47:11,350 --> 00:47:15,670
If you want to compare strings in C, you don't do it like you did integers.
如果你想在 C 中比较字符串，你不能像比较整数那样做。

1062
00:47:15,670 --> 00:47:17,920
You actually need another technique altogether.
你实际上需要另一种完全不同的技术。

1063
00:47:17,920 --> 00:47:21,070
And for that, we're going to need to revisit one of our friends, which
为此，我们需要重新审视我们的一个朋友，即

1064
00:47:21,070 --> 00:47:24,610
is string.h, which is one of the header files for the string library
string.h，它是字符串库的头文件之一

1065
00:47:24,610 --> 00:47:27,610
that we introduced last week that has in addition to functions
我们在上周介绍过，它除了函数外

1066
00:47:27,610 --> 00:47:31,390
like strlen, which gives you the length of a string, it also gives us,
比如 strlen，它可以给出字符串的长度，它还给我们，

1067
00:47:31,390 --> 00:47:34,330
as per the documentation here, another function that we'll
根据这里的文档，另一个我们将

1068
00:47:34,330 --> 00:47:38,830
start to find useful here, succinctly named strcmp, for string compare.
在这里开始发现有用的，简洁地命名为 strcmp，用于字符串比较。

1069
00:47:38,830 --> 00:47:44,750
And string compare will actually tell us if two strings are the same or not.
字符串比较实际上会告诉我们两个字符串是否相同。

1070
00:47:44,750 --> 00:47:46,200
It will indeed compare them.
它确实会比较它们。

1071
00:47:46,200 --> 00:47:49,970
And if I use this now, let me go back to my code
如果我现在使用它，让我回到我的代码

1072
00:47:49,970 --> 00:47:53,990
here and see what I might do differently if I go back into my code here
这里看看如果我回到我的代码这里，我可能会做些什么不同的事情。

1073
00:47:53,990 --> 00:47:55,160
and change this value.
并且更改此值。

1074
00:47:55,160 --> 00:47:59,570
Instead of using strings bracket i equals, equals s, let's do str compare.
与其使用字符串方括号 i 等于，等于 s，不如使用 str compare。

1075
00:47:59,570 --> 00:48:01,190
And I read the documentation earlier.
我之前已经阅读过文档了。

1076
00:48:01,190 --> 00:48:04,640
So I know that it takes two arguments, the first and the second string
所以我知道它需要两个参数，第一个和第二个字符串

1077
00:48:04,640 --> 00:48:09,500
that you want to compare, so strings bracket i and then s,
你想要比较的，所以是字符串方括号 i 然后是 s，

1078
00:48:09,500 --> 00:48:12,290
which is the string that the human typed in.
也就是人类输入的字符串。

1079
00:48:12,290 --> 00:48:15,680
But somewhat weirdly, what I want to check for
但有点奇怪的是，我想检查的是

1080
00:48:15,680 --> 00:48:19,220
is that str compare returns zero.
str compare 返回 0。

1081
00:48:19,220 --> 00:48:24,950
So if str compare when given two strings is input, strings bracket i and s,
所以如果 str compare 在给出两个字符串时，输入的是字符串方括号 i 和 s，

1082
00:48:24,950 --> 00:48:30,750
returns an integer 0, that actually means the strings are the same.
返回一个整数 0，实际上意味着字符串是相同的。

1083
00:48:30,750 --> 00:48:31,500
So let's try this.
所以让我们试试这个。

1084
00:48:31,500 --> 00:48:33,020
Let me do make search again.
让我再次执行 make search。

1085
00:48:33,020 --> 00:48:33,890
Huh.
嗯。

1086
00:48:33,890 --> 00:48:36,410
What did I do wrong here?
我这里做错了什么？

1087
00:48:36,410 --> 00:48:39,200
A whole bunch of errors popped out.
一堆错误弹出来了。

1088
00:48:39,200 --> 00:48:40,100
What did I do wrong?
我做错了什么？

1089
00:48:40,100 --> 00:48:41,530
Yeah?
是吗？

1090
00:48:41,530 --> 00:48:44,510
Yeah, so I didn't include the very header file we're talking about.
是的，所以我没有包含我们正在讨论的头文件。

1091
00:48:44,510 --> 00:48:46,270
So again, it doesn't necessarily mean a logical error.
所以再次强调，这并不一定意味着逻辑错误。

1092
00:48:46,270 --> 00:48:47,920
It just means a stupid error on my part.
这只意味着我犯了一个愚蠢的错误。

1093
00:48:47,920 --> 00:48:49,670
I didn't actually include the header file.
我实际上并没有包含头文件。

1094
00:48:49,670 --> 00:48:51,340
So let me go back and actually do that.
所以让我回去做一下。

1095
00:48:51,340 --> 00:48:54,280
Up at the top in addition to cs50.h and standard io,
在顶部，除了 cs50.h 和标准输入之外，

1096
00:48:54,280 --> 00:48:56,890
let's also include string.h.
我们也包含 string.h。

1097
00:48:56,890 --> 00:48:59,290
Let me clear my terminal and do make search again.
让我清空终端并再次执行 make search。

1098
00:48:59,290 --> 00:49:00,340
Crossing my fingers.
祈祷吧。

1099
00:49:00,340 --> 00:49:01,390
That time it worked.
这次它成功了。

1100
00:49:01,390 --> 00:49:06,040
And now if I do dot slash search and search for top hat like before,
现在如果我执行 ./search 然后像之前一样搜索 top hat，

1101
00:49:06,040 --> 00:49:08,500
now, thankfully, it is, in fact, found.
现在，感谢上帝，它确实被找到了。

1102
00:49:08,500 --> 00:49:12,340
If I do it once more and search for battleship, now it's, in fact, found.
如果我再次执行并搜索 battleship，现在它确实被找到了。

1103
00:49:12,340 --> 00:49:15,520
If I do it once more and search for cat, which should not be in there,
如果我再次执行并搜索 cat，它不应该出现在那里，

1104
00:49:15,520 --> 00:49:17,870
that is not, in fact, found.
它确实没有被找到。

1105
00:49:17,870 --> 00:49:21,050
So now just intuitively, even if you've never done this before,
所以现在直观地，即使你以前从未做过这个，

1106
00:49:21,050 --> 00:49:25,450
why might it be valuable for this function called strcmp
为什么这个叫做 strcmp 的函数

1107
00:49:25,450 --> 00:49:30,370
to return zero if the strings are equal as opposed
如果字符串相等就返回 0，而不是

1108
00:49:30,370 --> 00:49:34,060
to a simple Boolean like true or false, which might have been your intuition?
一个简单的布尔值，比如真或假，这可能就是你的直觉？

1109
00:49:34,060 --> 00:49:40,540
When you compare two strings, what are the possible takeaways
当你比较两个字符串时，你可能会从比较两个字符串中得到哪些可能的结论？

1110
00:49:40,540 --> 00:49:43,270
you might have from comparing two strings?
你可能从比较两个字符串中得到哪些可能的结论？

1111
00:49:43,270 --> 00:49:45,790
It's not just that they're equal or not.
不仅仅是它们是否相等。

1112
00:49:45,790 --> 00:49:47,970
AUDIENCE: [INAUDIBLE]
观众： [听不清]

1113
00:49:47,970 --> 00:49:51,170
DAVID MALAN: OK, so maybe if the ASCII values are the same, that
大卫·马兰：好的，所以也许如果 ASCII 值相同，

1114
00:49:51,170 --> 00:49:53,150
might imply, indeed, literal equality.
可能会暗示，实际上，是字面上的相等。

1115
00:49:53,150 --> 00:49:54,720
But something else.
但还有其他东西。

1116
00:49:54,720 --> 00:49:58,044
AUDIENCE: [INAUDIBLE] about how similar these things are [INAUDIBLE]..
观众： [听不清] 关于这些东西有多相似 [听不清]..

1117
00:49:58,044 --> 00:49:59,020
DAVID MALAN: Ah, nice.
大卫·马兰：啊，不错。

1118
00:49:59,020 --> 00:50:00,940
Like, you and I in English, certainly, are very much
就像你我一样，在英语中，当然，我们非常

1119
00:50:00,940 --> 00:50:02,982
in the habit of sorting information, whether it's
习惯于对信息进行排序，无论是

1120
00:50:02,982 --> 00:50:06,490
in a dictionary, in our contacts, in a phone book, in any such technology.
在字典里，在我们的联系人中，在电话簿里，在任何此类技术中。

1121
00:50:06,490 --> 00:50:11,140
And so it's often useful to be able to know, does this string equal another?
所以，通常能够知道这个字符串是否等于另一个字符串是很有用的。

1122
00:50:11,140 --> 00:50:11,740
Sure.
好的。

1123
00:50:11,740 --> 00:50:15,760
But does this string come before another alphabetically or maybe
但是这个字符串在字母顺序上是在另一个之前还是之后呢？

1124
00:50:15,760 --> 00:50:17,620
after another alphabetically?
或者在另一个之后呢？

1125
00:50:17,620 --> 00:50:20,680
So sometimes, you want functions to give you back three answers.
所以有时，你希望函数能够返回三个答案。

1126
00:50:20,680 --> 00:50:24,550
But equals, equals alone can only give you true or false, yes or no.
但是等于，仅仅等于只能给你真或假，是或否。

1127
00:50:24,550 --> 00:50:27,040
And that might not be useful enough when you're
这可能在你试图解决一些与字符串相关的难题时不够用。

1128
00:50:27,040 --> 00:50:29,200
trying to solve some problem involving strings.
当你试图解决一些与字符串相关的难题时。

1129
00:50:29,200 --> 00:50:34,280
So it turns out str compare actually compares the two strings for equality
事实证明，str compare 实际上比较了两个字符串的相等性

1130
00:50:34,280 --> 00:50:38,470
but also for what's called, playfully, ASCII-betical order.
但也比较了所谓的，开玩笑地说，ASCII-betical 顺序。

1131
00:50:38,470 --> 00:50:41,590
So not alphabetical order, per se, but ASCII-betical order
所以不是严格意义上的字母顺序，而是 ASCII-betical 顺序。

1132
00:50:41,590 --> 00:50:44,680
where it actually compares the integer values of the letters.
它实际上比较了字母的整数值。

1133
00:50:44,680 --> 00:50:46,450
So if you're comparing the letter A, It's
所以如果你要比较字母 A，它

1134
00:50:46,450 --> 00:50:51,250
going to compare 65 against some other letter's integer value-- hence
将比较 65 与其他字母的整数值，因此

1135
00:50:51,250 --> 00:50:52,880
ASCII-betical value.
ASCII-betical 值。

1136
00:50:52,880 --> 00:50:54,790
So we're not doing any form of sorting here.
所以我们这里没有进行任何形式的排序。

1137
00:50:54,790 --> 00:50:56,110
So it's sort of immaterial.
所以它有点无关紧要。

1138
00:50:56,110 --> 00:50:59,000
But as per the documentation, I do know that str compare
但是根据文档，我确实知道 str compare

1139
00:50:59,000 --> 00:51:01,880
returns zero if two strings are equal.
如果两个字符串相等，则返回零。

1140
00:51:01,880 --> 00:51:06,230
And a little teaser for next week, it turns out when I was only using equals,
下周的小剧透，事实证明，当我只使用等于时，

1141
00:51:06,230 --> 00:51:09,400
equals to compare strings bracket i and s,
等于来比较字符串括号 i 和 s，

1142
00:51:09,400 --> 00:51:13,350
I was not comparing the strings in the way that you might have thought.
我没有按照你可能认为的方式比较字符串。

1143
00:51:13,350 --> 00:51:18,087
And if you have programmed in Java or Python before, equals, equals
如果你以前用 Java 或 Python 编程过，等于，等于

1144
00:51:18,087 --> 00:51:20,420
is actually doing something different in those languages
实际上在这些语言中做着不同的事情

1145
00:51:20,420 --> 00:51:23,130
than it is actually doing in C. But more on that next week.
而不是它在 C 中实际做的事情。但更多内容下周再说。

1146
00:51:23,130 --> 00:51:26,600
For now, just take on faith that str compare is indeed
现在，就相信 str compare 确实是

1147
00:51:26,600 --> 00:51:29,010
how you compare two strings.
比较两个字符串的方式。

1148
00:51:29,010 --> 00:51:33,080
So let's actually put this into play with some actual additional code.
所以让我们实际用一些实际的额外代码来演示一下。

1149
00:51:33,080 --> 00:51:37,940
Let me propose that we implement a very simplistic phone book, for instance.
例如，我建议我们实现一个非常简单的电话簿。

1150
00:51:37,940 --> 00:51:40,640
Let me go ahead and implement here--
让我在这里实现一下

1151
00:51:40,640 --> 00:51:42,110
how about in a new file.
在一个新文件中。

1152
00:51:42,110 --> 00:51:46,550
Instead of search dot C, let's actually do phone book dot c.
而不是 search dot C，让我们实际做 phone book dot c。

1153
00:51:46,550 --> 00:51:50,510
And in this phone book, I'm going to go ahead and include the same header file,
在这个电话簿中，我将继续包含相同的头文件，

1154
00:51:50,510 --> 00:51:52,730
so cs50.h, so I can get input--
所以是 cs50.h，这样我就可以获得输入

1155
00:51:52,730 --> 00:51:55,310
standard io.h, so I can use printf--
standard io.h，这样我就可以使用 printf

1156
00:51:55,310 --> 00:51:58,070
string.h so that I can use str compare.
string.h，这样我就可以使用 str compare。

1157
00:51:58,070 --> 00:52:02,250
Let me give myself a main function again without command line arguments for now.
让我再次给自己一个 main 函数，现在还没有命令行参数。

1158
00:52:02,250 --> 00:52:05,150
And let me go ahead now and store a proper phone book, which
让我现在继续存储一个完整的电话簿，它

1159
00:52:05,150 --> 00:52:07,800
has some names and some actual numbers.
有一些名字和一些实际的号码。

1160
00:52:07,800 --> 00:52:09,320
So let's store the names first.
所以让我们先存储姓名。

1161
00:52:09,320 --> 00:52:12,560
So string-- names is going to be the name of my array.
所以字符串，names 将是我的数组的名称。

1162
00:52:12,560 --> 00:52:14,580
And let's go ahead and store Carter's name,
让我们继续存储 Carter 的姓名，

1163
00:52:14,580 --> 00:52:18,260
how about my name, and maybe John Harvard for phone book throwback.
我的名字怎么样，还有也许是 John Harvard，作为电话簿的怀旧之情。

1164
00:52:18,260 --> 00:52:22,640
Then let's go ahead and give me another array called numbers wherein I'll put
然后让我们继续给我另一个叫做 numbers 的数组，我将在其中放入

1165
00:52:22,640 --> 00:52:27,560
our phone number, so 617-495-1000 for Carter--
我们的电话号码，所以 Carter 是 617-495-1000

1166
00:52:27,560 --> 00:52:32,060
617-495-1000 for me-- technically, directory assistance here.
我的是 617-495-1000，技术上来说，这里是电话信息台。

1167
00:52:32,060 --> 00:52:34,160
And then for John, we'll give him an actual one.
然后对于 John，我们会给他一个真实的号码。

1168
00:52:34,160 --> 00:52:40,100
So it's actually going to be 949-468-2750.
所以实际上应该是 949-468-2750。

1169
00:52:40,100 --> 00:52:42,380
You're welcome to text or call John when you want.
欢迎你在需要的时候给 John 发短信或打电话。

1170
00:52:42,380 --> 00:52:43,070
Whoops.
哎呀。

1171
00:52:43,070 --> 00:52:46,130
And just for good measure, let's go ahead and put our country codes
为了保险起见，让我们加上国家代码

1172
00:52:46,130 --> 00:52:50,990
in here plus 1, even though at the end of the day, these are strings.
在里面加上 1，即使最终这些都是字符串。

1173
00:52:50,990 --> 00:52:54,320
So indeed notice I'm not using an integer for these values.
所以确实注意我并没有用整数来表示这些值。

1174
00:52:54,320 --> 00:52:56,510
I kind of sort of should.
我应该这样做。

1175
00:52:56,510 --> 00:52:59,270
But here's where data types in C and programming more
但这就是 C 语言和编程中数据类型可能会误导你的地方。

1176
00:52:59,270 --> 00:53:01,280
generally might sometimes mislead you.
一般情况下可能会让你误解。

1177
00:53:01,280 --> 00:53:04,100
Even though we call it, obviously, a phone number.
即使我们很明显地称之为电话号码。

1178
00:53:04,100 --> 00:53:08,210
It's probably best to represent it generally as strings, in fact,
事实上，最好用字符串来表示它，

1179
00:53:08,210 --> 00:53:12,110
so that you can have the pluses-- you can have the dashes so that it doesn't
这样你就可以有加号，也可以有减号，这样它就不会

1180
00:53:12,110 --> 00:53:14,030
get too big and overflow an integer.
变得太大而溢出整数。

1181
00:53:14,030 --> 00:53:16,340
Maybe it's an international number for which there's even more digits.
也许它是一个国际号码，有更多位数。

1182
00:53:16,340 --> 00:53:18,120
You don't want to risk overflowing a value.
你不想冒险让值溢出。

1183
00:53:18,120 --> 00:53:20,120
And in general, the rule of thumb in programming
一般来说，编程中的经验法则是

1184
00:53:20,120 --> 00:53:22,940
is even if in English we call something a number,
即使我们在英语中称某事物为数字，

1185
00:53:22,940 --> 00:53:26,600
if you wouldn't do math on it ever, you should probably be storing it
如果你永远不会对它进行数学运算，你应该把它存储为

1186
00:53:26,600 --> 00:53:29,060
as a string, not as an integer.
字符串而不是整数。

1187
00:53:29,060 --> 00:53:33,060
And it makes no logical sense to do math on phone numbers, per se.
严格来说，对电话号码进行数学运算没有任何逻辑意义。

1188
00:53:33,060 --> 00:53:35,570
So those are best instinctively left as strings.
所以最好直觉地将它们保留为字符串。

1189
00:53:35,570 --> 00:53:37,850
And in this case, even more simply, this ensures
在这种情况下，更简单地说，这确保了

1190
00:53:37,850 --> 00:53:41,630
that we have pluses and dashes stored inside of the string.
我们有加号和减号存储在字符串中。

1191
00:53:41,630 --> 00:53:46,490
All right, so now that I have these two arrays in parallel, if you will.
好的，所以现在我有这两个并行的数组，如果你愿意的话。

1192
00:53:46,490 --> 00:53:49,040
Like, I'm assuming that Carter's name is first.
比如，我假设 Carter 的名字排在第一位。

1193
00:53:49,040 --> 00:53:50,180
So his number is first.
所以他的号码排在第一位。

1194
00:53:50,180 --> 00:53:51,230
David's name is second.
David 的名字排在第二位。

1195
00:53:51,230 --> 00:53:52,850
So his number is second.
所以他的号码排在第二位。

1196
00:53:52,850 --> 00:53:54,810
John's is third and thus third.
John 的排在第三位，所以他的号码也排在第三位。

1197
00:53:54,810 --> 00:53:56,060
So let's actually search this.
所以让我们实际搜索一下。

1198
00:53:56,060 --> 00:53:58,010
Let's ask the user for--
让我们询问用户

1199
00:53:58,010 --> 00:54:01,340
how about a name using get string.
使用 get string 输入一个名字。

1200
00:54:01,340 --> 00:54:03,950
And this will be a name to search for in the phone book
这将是一个要在电话簿中搜索的名字

1201
00:54:03,950 --> 00:54:05,420
just like we did in week zero.
就像我们在第 0 周做的那样。

1202
00:54:05,420 --> 00:54:09,290
Let's do for int i equals 0, i less than 3.
让我们执行 for int i 等于 0，i 小于 3。

1203
00:54:09,290 --> 00:54:10,738
Again, the 3 is bad practice.
再说一次，3 是一个不好的做法。

1204
00:54:10,738 --> 00:54:12,530
I should probably store that in a constant.
我应该把它存储在一个常量中。

1205
00:54:12,530 --> 00:54:15,950
But let's keep the focus for today on the algorithm alone--
但是让我们今天的重点放在算法本身

1206
00:54:15,950 --> 00:54:17,330
i plus, plus.
i 加加。

1207
00:54:17,330 --> 00:54:20,240
Then in here, let's do if--
然后在这里，让我们做 if

1208
00:54:20,240 --> 00:54:27,800
how about names bracket i equals, equals name typed in.
名字中括号 i 等于，等于用户输入的名字。

1209
00:54:27,800 --> 00:54:28,550
But wait a minute.
等等。

1210
00:54:28,550 --> 00:54:30,320
I'm screwing this up again.
我又搞砸了。

1211
00:54:30,320 --> 00:54:32,270
What should I be using here?
我应该在这里使用什么？

1212
00:54:32,270 --> 00:54:37,340
str compare again-- so let's do str compare, names bracket i comma,
再次使用 str compare，所以让我们执行 str compare，名字中括号 i 逗号

1213
00:54:37,340 --> 00:54:38,930
name, which came from the user.
名字，来自用户。

1214
00:54:38,930 --> 00:54:42,770
And if that return value is zero, then let's go ahead
如果返回值为零，那么让我们继续

1215
00:54:42,770 --> 00:54:45,830
and print out, just like before, found backslash n.
打印出来，就像之前一样，找到反斜杠 n。

1216
00:54:45,830 --> 00:54:46,580
But you know what?
但是你知道吗？

1217
00:54:46,580 --> 00:54:48,170
We can do something more interesting.
我们可以做一些更有趣的事情。

1218
00:54:48,170 --> 00:54:49,670
Let's actually print out the number.
让我们实际打印出这个号码。

1219
00:54:49,670 --> 00:54:51,260
So I didn't just find something.
所以我不仅找到了东西。

1220
00:54:51,260 --> 00:54:52,550
I found the name.
我找到了姓名。

1221
00:54:52,550 --> 00:54:55,710
So let's actually plug in that person's corresponding number.
所以让我们实际将该人的相应号码填入。

1222
00:54:55,710 --> 00:54:57,900
So now it's a more useful phonebook or contacts app
所以现在它是一个更有用的电话簿或通讯录应用程序

1223
00:54:57,900 --> 00:55:00,060
where I'm going to show the human not just found
在那里我将向人们展示的不只是找到

1224
00:55:00,060 --> 00:55:02,430
but found this specific number.
而是找到了这个特定的号码。

1225
00:55:02,430 --> 00:55:06,010
Then I'm going to go ahead as before and return 0 to indicate success.
然后我会像以前一样继续前进，返回 0 来表示成功。

1226
00:55:06,010 --> 00:55:09,538
And if we get all the way down here, I'm going to go ahead and say not found
如果我们一直走到这里，我会继续说没找到

1227
00:55:09,538 --> 00:55:12,330
and not print out any number because I obviously haven't found one,
并且不打印任何号码，因为我显然没有找到，

1228
00:55:12,330 --> 00:55:15,880
and return one by convention to indicate failure.
并且按照惯例返回 1 来表示失败。

1229
00:55:15,880 --> 00:55:17,890
So let me open my terminal window.
所以让我打开我的终端窗口。

1230
00:55:17,890 --> 00:55:20,340
Let me do make phone book-- enter.
让我做 make phone book-- 然后输入。

1231
00:55:20,340 --> 00:55:23,010
So far, so good-- dot slash phone book.
到目前为止，一切顺利-- dot slash phone book。

1232
00:55:23,010 --> 00:55:25,080
Let's search for Carter--
让我们搜索 Carter--

1233
00:55:25,080 --> 00:55:27,060
enter-- found his number.
输入-- 找到了他的号码。

1234
00:55:27,060 --> 00:55:27,840
Let's do it again.
让我们再做一次。

1235
00:55:27,840 --> 00:55:28,757
Dot slash phone book--
Dot slash phone book--

1236
00:55:28,757 --> 00:55:30,030
David-- found it.
David-- 找到了。

1237
00:55:30,030 --> 00:55:32,490
Let's do it one more time for John--
让我们再为 John 做一次--

1238
00:55:32,490 --> 00:55:33,240
found it.
找到了。

1239
00:55:33,240 --> 00:55:38,160
And just for good measure, let's do one other here like Eli--
为了保险起见，让我们再做另一个，比如 Eli--

1240
00:55:38,160 --> 00:55:40,920
enter-- not found in this case.
输入-- 在这种情况下没有找到。

1241
00:55:40,920 --> 00:55:43,710
All right, so it seems to be working based on this example here.
好吧，从这里这个例子来看，似乎工作正常。

1242
00:55:43,710 --> 00:55:48,630
But now we've actually implemented the idea of, like, a proper phone book.
但是现在我们实际上已经实现了，比如，一个真正的电话簿的概念。

1243
00:55:48,630 --> 00:55:51,510
But does any aspect of the design of this code,
但是，这段代码的任何设计方面，

1244
00:55:51,510 --> 00:55:54,060
even if you've never programmed before CS50,
即使你之前从未在 CS50 中进行过编程，

1245
00:55:54,060 --> 00:55:58,120
does anything rub you wrong about how we're storing our data--
我们的数据存储方式是否让你觉得有什么不对劲--

1246
00:55:58,120 --> 00:56:02,690
the phone book itself-- these names and numbers?
电话簿本身-- 这些姓名和号码？

1247
00:56:02,690 --> 00:56:04,220
Does anything rub you the wrong way?
有什么让你觉得不对劲吗？

1248
00:56:04,220 --> 00:56:06,008
Yeah, in back.
是的，在后面。

1249
00:56:06,008 --> 00:56:09,326
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1250
00:56:11,222 --> 00:56:13,320
DAVID MALAN: Yeah, really good observation.
大卫·马兰：是的，非常好的观察。

1251
00:56:13,320 --> 00:56:15,510
I'm separating the names and the numbers,
我将姓名和号码分开，

1252
00:56:15,510 --> 00:56:17,775
which indeed, it looks a little bit weird.
的确，这看起来有点奇怪。

1253
00:56:17,775 --> 00:56:20,650
And there's actually this technical term in the world of programming,
在编程世界里，实际上有一个技术术语，

1254
00:56:20,650 --> 00:56:22,088
which is code smell, where, like--
那就是代码味道，就像--

1255
00:56:22,088 --> 00:56:25,380
[SNIFFING]---- something smells a little off about this code in the sense that,
[闻闻]---- 这段代码有点奇怪，从某种意义上来说，

1256
00:56:25,380 --> 00:56:27,270
like, this probably doesn't end well, right?
比如，这可能不会以好的方式结束，对吧？

1257
00:56:27,270 --> 00:56:31,438
If I add a fourth name, a fourth number, a fifth name, a fiftieth name
如果我添加第四个姓名，第四个号码，第五个姓名，第五十个姓名

1258
00:56:31,438 --> 00:56:33,480
and number, like, at some point, they're probably
和号码，比如，在某个时刻，它们可能

1259
00:56:33,480 --> 00:56:34,813
going to get out of sync, right?
会不同步，对吧？

1260
00:56:34,813 --> 00:56:37,110
So, like, there's something awry about this design
所以，就像，这个设计有点问题

1261
00:56:37,110 --> 00:56:39,870
that I shouldn't decouple the names from the numbers.
我不应该将姓名和号码分开。

1262
00:56:39,870 --> 00:56:42,300
So something kind of smells about this code, so to speak.
所以，可以说，这段代码有点味道。

1263
00:56:42,300 --> 00:56:44,760
And any time you perceive that in your code,
而且无论何时你感觉到你的代码中出现这种情况，

1264
00:56:44,760 --> 00:56:48,150
it's probably an opportunity to go about improving it somehow.
这可能是一个改进代码的机会。

1265
00:56:48,150 --> 00:56:50,893
But to do that, we actually need another tool in the toolkit.
但要做到这一点，我们实际上需要工具箱中的另一个工具。

1266
00:56:50,893 --> 00:56:53,560
And that is, again, this term that I've used a couple of times--
而且，这又是我多次使用过的术语--

1266
00:56:50,893 --> 00:56:53,560
And that is, again, this term that I've used a couple of times--
再说一次，就是我之前提过几次的这个词——

1267
00:56:53,560 --> 00:56:54,367
data structures.
数据结构。

1268
00:56:54,367 --> 00:56:56,700
Like, arrays have been the first of our data structures.
比如，数组是我们数据结构中的第一个。

1269
00:56:56,700 --> 00:56:57,783
And they're so simplistic.
它们非常简单。

1270
00:56:57,783 --> 00:57:01,110
It just means storing things back to back to back contiguously in memory.
它只是意味着在内存中连续地将事物存储在一起。

1271
00:57:01,110 --> 00:57:03,300
But it turns out C--
但事实证明 C——

1272
00:57:03,300 --> 00:57:06,660
and a little bit of new syntax-- but it's not a lot of new syntax today--
以及一些新的语法，虽然今天我们不会学太多新的语法——

1273
00:57:06,660 --> 00:57:09,060
a little bit of new syntax today will allow
今天学习一些新的语法将允许我们

1274
00:57:09,060 --> 00:57:13,710
us to create our own data structures, our own types of variables,
创建我们自己的数据结构，我们自己的变量类型，

1275
00:57:13,710 --> 00:57:16,330
largely using syntax we've seen thus far.
主要使用我们迄今为止所见过的语法。

1276
00:57:16,330 --> 00:57:19,230
So to do this, let me propose that in order
因此，为了做到这一点，我建议为了

1277
00:57:19,230 --> 00:57:22,980
to represent a person in a phone book-- well, let's
在电话簿中表示一个人，我们不妨

1278
00:57:22,980 --> 00:57:26,250
not just implement them as a list of names and a list of numbers.
不要仅仅将它们实现为一个姓名列表和一个号码列表。

1279
00:57:26,250 --> 00:57:30,660
Wouldn't it be nice if C had a data type actually called person?
如果 C 语言实际上有一个叫做“person”的数据类型，那岂不是很棒？

1280
00:57:30,660 --> 00:57:34,560
Because if it did, then I could go about creating an array called--
因为如果存在，那么我就可以创建一个名为——

1281
00:57:34,560 --> 00:57:36,690
using the pluralized form-- people--
使用复数形式——people——

1282
00:57:36,690 --> 00:57:40,470
containing my people in my phone book.
包含我电话簿里的每个人。

1283
00:57:40,470 --> 00:57:44,070
And maybe a person has both a name and a number.
也许一个人同时拥有姓名和号码。

1284
00:57:44,070 --> 00:57:46,690
And therefore, we can kind of keep everything together.
因此，我们能够将所有信息整合在一起。

1285
00:57:46,690 --> 00:57:47,740
So how can I do this?
那么，我该怎么做呢？

1286
00:57:47,740 --> 00:57:48,960
Well, what is a person?
好吧，什么是人呢？

1287
00:57:48,960 --> 00:57:52,350
Well, a person, really, in this story is a person has a name.
嗯，在故事中，一个人的确是拥有名字的。

1288
00:57:52,350 --> 00:57:53,730
And a person has a number.
而且一个拥有电话号码。

1289
00:57:53,730 --> 00:57:58,500
So can we create a new data type that maybe has both of these together?
所以，我们可以创建一个新的数据类型，它可以将这两者结合在一起吗？

1290
00:57:58,500 --> 00:58:02,280
Well, we actually can by using one piece of new syntax
事实上，我们可以通过使用一个新的语法来做到这一点

1291
00:58:02,280 --> 00:58:05,100
today, which is just this here.
就是这里。

1292
00:58:05,100 --> 00:58:09,395
Using what's called a struct, we can create our own data structure
使用名为“struct”的结构体，我们可以创建我们自己的数据结构

1293
00:58:09,395 --> 00:58:11,020
that actually has some structure in it.
它实际上具有某种结构。

1294
00:58:11,020 --> 00:58:13,150
It's not just one thing like a string or an int.
它不仅仅像字符串或整数那样只是一个东西。

1295
00:58:13,150 --> 00:58:14,320
Maybe it's two strings.
也许是两个字符串。

1296
00:58:14,320 --> 00:58:15,190
Maybe it's two ints.
也许是两个整数。

1297
00:58:15,190 --> 00:58:16,210
Maybe it's one of each.
也许是一个字符串和一个整数。

1298
00:58:16,210 --> 00:58:21,380
So a structure can be a variable that contains any number of other variables,
因此，结构体可以是一个包含任意数量其他变量的变量，

1299
00:58:21,380 --> 00:58:22,060
so to speak.
这么说吧。

1300
00:58:22,060 --> 00:58:24,310
And typedef is a cryptic keyword that just
而 typedef 是一个神秘的关键字，它只是

1301
00:58:24,310 --> 00:58:28,630
means define the following type-- invent the following data type for me.
意味着定义以下类型——为我创建以下数据类型。

1302
00:58:28,630 --> 00:58:30,320
And the syntax is a little weird.
语法有点奇怪。

1303
00:58:30,320 --> 00:58:32,620
But you say typedef struct curly brace.
但你应该说 typedef struct 大括号。

1304
00:58:32,620 --> 00:58:35,410
Inside of the curly braces, you put all of the types
在大括号内，你放置所有你想与这个新的数据类型关联的变量类型。

1305
00:58:35,410 --> 00:58:38,090
of variables you want to associate with this new data type.
在大括号之后，你创建你想赋予它的名称。

1306
00:58:38,090 --> 00:58:40,660
And then after the curly brace, you invent the name
这将创建一个名为“person”的新数据类型，

1307
00:58:40,660 --> 00:58:41,830
that you want to give it.
即使几十年

1308
00:58:41,830 --> 00:58:45,550
And this will create a new data type in C called person,
之前在 C 语言被创建出来的时候，

1309
00:58:45,550 --> 00:58:47,830
even though no one thought of this decades
人们都没有想过要创建像“person”这样的数据类型，

1310
00:58:47,830 --> 00:58:52,670
ago when C was created alongside of the ints and the floats and so forth.
当时 C 语言只是创建了整数和浮点数等等。

1311
00:58:52,670 --> 00:58:55,220
So how can I actually use this?
那么，我该如何使用它呢？

1312
00:58:55,220 --> 00:58:58,330
Well, it turns out that once you have this building
结果证明，一旦你有了这个创建你自己的数据结构的

1313
00:58:58,330 --> 00:59:03,190
block of creating your very own data structures, I can go back into my code
模块，我就可以回到我的代码中。

1314
00:59:03,190 --> 00:59:06,340
and improve it as follows in direct response to your concern
并根据您的关注进行改进，如下所示

1315
00:59:06,340 --> 00:59:10,752
about it seeming not ideal that we're decoupling the names and the numbers.
关于我们分离姓名和号码似乎并不理想。

1316
00:59:10,752 --> 00:59:13,210
Now, it's going to look a little more complicated at first.
现在，它看起来会更复杂一些。

1317
00:59:13,210 --> 00:59:15,320
But it will scale better over time.
但随着时间的推移，它将变得更易于扩展。

1318
00:59:15,320 --> 00:59:17,380
So within my code here, I'm going to go ahead
因此，在我这里代码中，我将继续

1319
00:59:17,380 --> 00:59:21,020
and essentially type out exactly that same data type.
并基本上完全写出相同的数据类型。

1320
00:59:21,020 --> 00:59:27,460
So define a structure that has inside of it a string called name and a string
因此，定义一个结构，其中包含一个名为“name”的字符串和一个名为“number”的字符串

1321
00:59:27,460 --> 00:59:28,300
called number.
叫做数字。

1322
00:59:28,300 --> 00:59:30,700
And let's call this thing a person.
我们称之为一个人。

1323
00:59:30,700 --> 00:59:34,270
So these new lines copied and pasted from the slide a moment ago just
所以，片刻前从幻灯片中复制和粘贴的这些新行，

1324
00:59:34,270 --> 00:59:36,370
invent the data type called person.
发明了名为“person”的数据类型。

1325
00:59:36,370 --> 00:59:39,010
So the only thing we need today is the syntax via which
因此，我们今天唯一需要的是语法，通过它

1326
00:59:39,010 --> 00:59:43,610
we can set a person's name and number-- like, how can we access those values.
我们可以设置一个人的姓名和号码--比如，我们如何访问这些值。

1327
00:59:43,610 --> 00:59:47,920
So to do this, I'm going to go ahead and erase the hard-coded arrays
所以，为了做到这一点，我将继续删除之前硬编码的数组

1328
00:59:47,920 --> 00:59:49,250
that I had before.
之前我有的。

1329
00:59:49,250 --> 00:59:53,740
And I'm going to give myself one array of type person called people
我将给自己一个名为“people”的“person”类型数组

1330
00:59:53,740 --> 00:59:55,610
with room for three people.
有三个人的空间。

1331
00:59:55,610 --> 00:59:57,490
So this seems like a bit of a mouthful.
所以，这听起来有点拗口。

1332
00:59:57,490 --> 00:59:59,560
But the new data type is called person.
但新的数据类型被称为“person”。

1333
00:59:59,560 --> 01:00:02,048
The array name is called people, which in English is weird.
数组名称叫“people”，这在英语中很奇怪。

1334
01:00:02,048 --> 01:00:04,840
I mean, it could call it persons to make it a little more parallel.
我的意思是，它可以称之为“persons”，使其更加平行。

1335
01:00:04,840 --> 01:00:06,520
But we call them people, generally.
但我们通常称他们为“people”。

1336
01:00:06,520 --> 01:00:09,880
And I want three such people in my phone book.
我想要在我的电话簿中拥有三个这样的人。

1337
01:00:09,880 --> 01:00:12,670
Now, how do I actually initialize those people?
现在，我该如何实际初始化这些人呢？

1338
01:00:12,670 --> 01:00:16,030
Well, previously, I did something like this-- names, bracket, 0.
好吧，之前，我做了一些类似于这样的事情--“names”，方括号，“0”。

1339
01:00:16,030 --> 01:00:18,520
And then I did numbers, bracket, 0.
然后，我做了“numbers”，方括号，“0”。

1340
01:00:18,520 --> 01:00:20,080
Well, it's a similar idea.
好吧，这是一个类似的想法。

1341
01:00:20,080 --> 01:00:22,630
I do people, bracket, 0.
我做“people”，方括号，“0”。

1342
01:00:22,630 --> 01:00:27,490
But if I want to set this person's name, the one new piece of syntax today
但如果我想设置这个人的名字，今天新的一段语法

1343
01:00:27,490 --> 01:00:32,290
is a period, a literal dot operator, that says go inside of this person
是一个句点，一个字面上的点运算符，它表示进入这个人内部

1344
01:00:32,290 --> 01:00:36,400
and access their name field or their name attribute.
并访问他们的姓名字段或姓名属性。

1345
01:00:36,400 --> 01:00:39,190
And set it equal to, quote, unquote, "Carter."
并将其设置为，引号，“Carter”。

1346
01:00:39,190 --> 01:00:41,800
Then go into that same person.
然后进入同一个人。

1347
01:00:41,800 --> 01:00:43,660
But go into their number field.
但进入他们的号码字段。

1348
01:00:43,660 --> 01:00:48,368
And set that equal to plus 1, 617-495-1000.
并将其设置为加1，617-495-1000。

1349
01:00:48,368 --> 01:00:50,410
Then-- and I'll just separate it with white space
然后--我将用空格将其分隔开

1350
01:00:50,410 --> 01:00:53,500
for readability-- go into people bracket 1.
为了易读性--进入“people”方括号“1”。

1351
01:00:53,500 --> 01:00:56,170
Set their name into mine, David.
将他们的名字设置为我的名字，“David”。

1352
01:00:56,170 --> 01:00:58,390
Let's go into people bracket 1 number.
让我们进入“people”方括号“1”的“number”。

1353
01:00:58,390 --> 01:01:02,000
Set that equal to the same, since we're both available through the directory,
将其设置为相同，因为我们俩都可以通过目录访问，

1354
01:01:02,000 --> 01:01:04,720
so 617-495-1000.
所以是617-495-1000。

1355
01:01:04,720 --> 01:01:10,390
And then lastly, let's go ahead and do people bracket 2 dot name equals,
最后，让我们继续执行“people”方括号“2”点“name”等于

1356
01:01:10,390 --> 01:01:15,210
quote, unquote, "John," and then people bracket 2 dot number equals, quote,
引号，“John”，然后“people”方括号“2”点“number”等于，引号

1357
01:01:15,210 --> 01:01:21,646
unquote, "plus 1, 949-468-2750--
引号，“加1，949-468-2750--

1358
01:01:21,646 --> 01:01:23,548
let me fix my dash--
让我修正我的连字符--

1359
01:01:23,548 --> 01:01:24,850
semicolon.
分号。

1360
01:01:24,850 --> 01:01:29,010
And now I think I can mostly keep the rest of the code the same
现在我认为我可以将大部分代码保持原样

1361
01:01:29,010 --> 01:01:31,500
because if I'm searching for this person's name,
因为如果我要搜索这个人的名字，

1362
01:01:31,500 --> 01:01:35,160
I think the only thing I want to change is this because I don't have a names
我认为唯一要更改的是这部分，因为我不再有names

1363
01:01:35,160 --> 01:01:36,300
array anymore.
数组了。

1364
01:01:36,300 --> 01:01:40,440
So what should I change this highlighted phrase to in order
所以，为了搜索第i个人的姓名，我应该将这个高亮显示的短语更改为

1365
01:01:40,440 --> 01:01:44,930
to search the ith person's name?
什么？

1366
01:01:44,930 --> 01:01:45,800
What should this be?
这应该是什么？

1367
01:01:45,800 --> 01:01:47,870
Yeah?
对吗？

1368
01:01:47,870 --> 01:01:51,470
People bracket i dash name because the whole point of this loop
people[i].name，因为这个循环的全部目的是

1369
01:01:51,470 --> 01:01:54,330
is to iterate over each of these people one at a time.
一次迭代一个地遍历这些人。

1370
01:01:54,330 --> 01:01:57,950
So people bracket i gives me the ith person-- first [INAUDIBLE] people 0,
所以，people[i]给了我第i个人——第一个（无法识别）people 0，

1371
01:01:57,950 --> 01:01:59,060
people 1, people 2.
people 1，people 2。

1372
01:01:59,060 --> 01:02:01,880
But if on each iteration, I want to check that person's name
但是，如果在每次迭代中，我想检查该人的姓名

1373
01:02:01,880 --> 01:02:04,010
and compare it against whatever the human typed in,
并将其与用户输入的内容进行比较，

1374
01:02:04,010 --> 01:02:05,700
now I can do exactly that.
我现在就可以做到。

1375
01:02:05,700 --> 01:02:12,350
But I have to change the output to be people bracket i dot number,
但我必须将输出更改为people[i].number，

1376
01:02:12,350 --> 01:02:13,560
in this case.
在这种情况下。

1377
01:02:13,560 --> 01:02:15,838
So I've added a little bit of complexity.
所以，我增加了一些复杂性。

1378
01:02:15,838 --> 01:02:19,130
And granted, this is not going to be the way long term you create a phone book.
当然，从长远来看，这并不是创建电话簿的方式。

1379
01:02:19,130 --> 01:02:21,660
Odds are, we're going to get the phone book with a loop of some sort.
很有可能，我们会使用某种循环来获取电话簿。

1380
01:02:21,660 --> 01:02:24,702
We're going to use a constant, so I know how many people I have room for.
我们将使用一个常量，这样我就知道可以容纳多少人。

1381
01:02:24,702 --> 01:02:27,440
For demonstration sake, I'm just typing everything out manually.
为了演示，我正在手动输入所有内容。

1382
01:02:27,440 --> 01:02:30,660
But I think logically now, we've achieved the same thing.
但我认为现在逻辑上我们已经实现了相同的功能。

1383
01:02:30,660 --> 01:02:33,050
So let me do make phone book for this new version--
所以，让我为这个新版本创建phone book——

1384
01:02:33,050 --> 01:02:35,180
no syntax errors-- dot slash phone book.
没有语法错误——./phone book。

1385
01:02:35,180 --> 01:02:36,770
Let's search for Carter-- enter.
我们搜索Carter——回车。

1386
01:02:36,770 --> 01:02:38,210
And there indeed is his number.
他的号码确实在那里。

1387
01:02:38,210 --> 01:02:39,710
Let's go ahead and search for David.
让我们继续搜索David。

1388
01:02:39,710 --> 01:02:40,860
There's my number.
我的号码在那里。

1389
01:02:40,860 --> 01:02:42,470
And lastly, let's search for John--
最后，我们搜索John——

1390
01:02:42,470 --> 01:02:42,970
his number.
他的号码。

1391
01:02:42,970 --> 01:02:45,387
And again, we'll search for someone we know is not there--
再一次，我们搜索一个我们知道不存在的人——

1392
01:02:45,387 --> 01:02:46,130
Eli.
Eli。

1393
01:02:46,130 --> 01:02:47,840
And Eli is not found.
Eli没有找到。

1394
01:02:47,840 --> 01:02:52,160
So what we've done is try to solve this problem of introducing a brand new data
所以，我们所做的是尝试解决引入一个全新的数据的问题

1395
01:02:52,160 --> 01:02:57,560
type that allows us to represent this custom data that you and I just
类型，这种类型允许我们表示您和我在

1396
01:02:57,560 --> 01:02:58,220
created.
创建的自定义数据。

1397
01:02:58,220 --> 01:03:02,100
And that is by using the struct keyword to cluster these things together
而实现方法是使用struct关键字将这些东西聚合在一起

1398
01:03:02,100 --> 01:03:05,960
and the typedef keyword to give it a brand new name that we might like.
并使用typedef关键字为它赋予一个新的我们喜欢的名字。

1399
01:03:05,960 --> 01:03:08,330
Now, as an aside, when it comes to styling your code,
另外，在代码风格方面，

1400
01:03:08,330 --> 01:03:11,430
you'll actually see that style50 and similar tools will actually
您实际上会发现，style50和类似的工具实际上会

1401
01:03:11,430 --> 01:03:14,610
put the name of the data type on the same line as the closing curly brace,
将数据类型的名称放在与闭合大括号相同的行上，

1402
01:03:14,610 --> 01:03:15,900
just sort of a curiosity.
只是好奇心而已。

1403
01:03:15,900 --> 01:03:16,523
That's fine.
这没问题。

1404
01:03:16,523 --> 01:03:18,690
Even though I wrote it the first way for consistency
即使我为了与Scratch和我们之前的示例保持一致而以第一种方式编写，

1405
01:03:18,690 --> 01:03:23,530
with Scratch and our prior examples, this is the right way in styling it.
但这是正确的方式。

1406
01:03:23,530 --> 01:03:26,470
Any questions now on this data type?
现在对这个数据类型有任何问题吗？

1407
01:03:26,470 --> 01:03:26,970
Yeah?
有吗？

1408
01:03:29,675 --> 01:03:33,042
AUDIENCE: [INAUDIBLE]
观众：[无法识别]

1409
01:03:34,966 --> 01:03:36,980
DAVID MALAN: The question is, do you have
DAVID MALAN：问题是，您是否

1410
01:03:36,980 --> 01:03:39,590
to assign both the name and the number when creating a person?
在创建一个人时，必须同时分配姓名和号码吗？

1411
01:03:39,590 --> 01:03:42,410
Or can you only get away with assigning one of them?
或者您只能分配其中一个？

1412
01:03:42,410 --> 01:03:43,200
You can.
你可以。

1413
01:03:43,200 --> 01:03:46,200
But that's going to be one of those so-called garbage values, typically.
但这通常将成为所谓的垃圾值之一。

1414
01:03:46,200 --> 01:03:48,800
And so there's just going to be some bogus data there.
因此，那里将有一些虚假的数据。

1415
01:03:48,800 --> 01:03:53,270
And unless you are so careful as to never touch that field thereafter,
除非你非常小心，以后再也不碰那个字段，

1416
01:03:53,270 --> 01:03:56,630
you probably run the risk of some kind of bug, even a crash in your code,
你很可能会遇到某种错误，甚至代码崩溃，

1417
01:03:56,630 --> 01:03:59,330
if you try to access that value later, even though you've never
如果你稍后尝试访问该值，即使你从未

1418
01:03:59,330 --> 01:03:59,960
initialized it.
初始化过它。

1419
01:03:59,960 --> 01:04:01,100
So yes, it's possible.
所以，是的，这是可能的。

1420
01:04:01,100 --> 01:04:02,520
But no, do not do that.
但是，不，不要这样做。

1421
01:04:02,520 --> 01:04:05,020
Other questions?
还有其他问题吗？

1422
01:04:05,020 --> 01:04:05,890
No?
没有？

1423
01:04:05,890 --> 01:04:08,470
All right, well, now that we have the ability
好吧，现在我们有了能力

1424
01:04:08,470 --> 01:04:11,570
to sort of represent more interesting structures, up until now,
来表示更有趣的结构，到目前为止，

1425
01:04:11,570 --> 01:04:14,350
we've sort of assumed that in order to get to binary search,
我们一直假设，为了进行二分查找，

1426
01:04:14,350 --> 01:04:16,990
we have a phone book that someone already sorted for us.
我们有一本电话簿，有人已经为我们排序了。

1427
01:04:16,990 --> 01:04:19,540
For our second demonstration with our volunteers,
对于我们与志愿者的第二次演示，

1428
01:04:19,540 --> 01:04:21,820
we assumed that someone, Carter in that case,
我们假设有人，在这种情况下是 Carter，

1429
01:04:21,820 --> 01:04:24,010
had already sorted the information for us.
已经为我们排序了信息。

1430
01:04:24,010 --> 01:04:26,050
It was proposed by the audience that, well,
观众提出了，嗯，

1431
01:04:26,050 --> 01:04:29,770
what if we sort the information first and then go find the number 50?
如果我们先对信息进行排序，然后再去查找数字 50 会怎样？

1432
01:04:29,770 --> 01:04:33,580
That invited the question even early on-- well, how expensive is it to sort?
这在早期就引发了一个问题——嗯，排序的成本有多高？

1433
01:04:33,580 --> 01:04:38,170
How much time and money and inefficiency do Google and Microsoft and others
谷歌、微软和其他公司花了多少时间、金钱和效率

1434
01:04:38,170 --> 01:04:41,590
spend to keep their data and our data sorted?
来保持他们的数据和我们的数据排序？

1435
01:04:41,590 --> 01:04:43,840
Well, let's consider what the problem really is.
好吧，让我们考虑一下这个问题的本质。

1436
01:04:43,840 --> 01:04:47,380
If this is how we represent any problem, the unsorted data
如果这就是我们表示任何问题的方式，未排序的数据

1437
01:04:47,380 --> 01:04:50,770
that we might consume by typing things in randomly to a search engine
我们可能通过在搜索引擎中随机输入内容来消费这些数据

1438
01:04:50,770 --> 01:04:54,430
or crawling the internet or just adding context in any old order to our phone
或抓取互联网，或只是以任何顺序将上下文添加到我们的电话中

1439
01:04:54,430 --> 01:04:55,840
is arguably unsorted.
可以说是未排序的。

1440
01:04:55,840 --> 01:04:58,060
It's certainly not alphabetically sorted by default.
它肯定不是默认按字母顺序排序的。

1441
01:04:58,060 --> 01:04:59,650
But we want to get it sorted.
但我们想要对它进行排序。

1442
01:04:59,650 --> 01:05:02,860
And so somewhere in here in this black box, we need a set of algorithms
因此，在这个黑盒子里面的某个地方，我们需要一组算法

1443
01:05:02,860 --> 01:05:05,130
for actually sorting information as well.
来对信息进行排序。

1444
01:05:05,130 --> 01:05:09,080
For instance, if we have these integers here unsorted--
例如，如果我们有这些未排序的整数——

1445
01:05:09,080 --> 01:05:14,130
72541603-- effectively random, the problem of sorting, of course,
72541603——实际上是随机的，当然，排序问题

1446
01:05:14,130 --> 01:05:18,050
is to turn it into 01234567 instead.
就是要把它变成 01234567。

1447
01:05:18,050 --> 01:05:20,100
And there's a bunch of different ways to do this.
有很多不同的方法可以做到这一点。

1448
01:05:20,100 --> 01:05:22,730
But before we do that, I think it's probably time for some brownies.
但在我们进行之前，我认为可能是吃布朗尼的时候了。

1449
01:05:22,730 --> 01:05:24,605
So let's go ahead and take a 10-minute break.
所以让我们休息 10 分钟。

1450
01:05:24,605 --> 01:05:26,570
And we'll see you in 10.
10 分钟后见。

1451
01:05:26,570 --> 01:05:28,040
All right, we are back.
好的，我们回来了。

1452
01:05:28,040 --> 01:05:30,470
And where we left off was this cliffhanger.
我们上次结束的地方是这个悬念。

1453
01:05:30,470 --> 01:05:32,060
We've got some unsorted numbers.
我们有一些未排序的数字。

1454
01:05:32,060 --> 01:05:33,380
We want to make them sorted.
我们想要对它们进行排序。

1455
01:05:33,380 --> 01:05:34,430
How do we do this?
我们该如何做到呢？

1456
01:05:34,430 --> 01:05:37,250
And at the risk of one too many volunteers,
冒着志愿者太多的风险，

1457
01:05:37,250 --> 01:05:39,680
could we get eight more volunteers?
我们可以再找八个志愿者吗？

1458
01:05:39,680 --> 01:05:41,840
Wow, OK, overwhelming.
哇，好的，太多了。

1459
01:05:41,840 --> 01:05:45,110
OK, how about 1, 2, 3, 4.
好的，1、2、3、4 怎么样？

1460
01:05:45,110 --> 01:05:46,250
How about all three of you?
你们三位怎么样？

1461
01:05:46,250 --> 01:05:51,290
OK, 5, 6, 7--
好的，5、6、7——

1462
01:05:51,290 --> 01:05:51,950
OK, 8.
好的，8。

1463
01:05:51,950 --> 01:05:52,460
Come on.
来吧。

1464
01:05:52,460 --> 01:05:54,120
All right, one from each section--
好的，每个部分选一个人——

1465
01:05:54,120 --> 01:05:56,244
all right, come on down.
好的，请下来。

1466
01:05:56,244 --> 01:06:00,073
[INTERPOSING VOICES]
[声音交叠]

1467
01:06:00,073 --> 01:06:01,615
DAVID MALAN: All right, come on down.
大卫·马兰：好的，请下来。

1468
01:06:05,410 --> 01:06:06,100
Thank you.
谢谢。

1469
01:06:06,100 --> 01:06:10,695
And if you all could grab a number here.
请你们每个人从这里拿一个数字。

1470
01:06:10,695 --> 01:06:11,320
So you'll be 7.
所以你就是7号。

1471
01:06:11,320 --> 01:06:13,220
Stand on the left there if you could.
如果你能的话，请站在左边。

1472
01:06:13,220 --> 01:06:14,470
All right, you'll be number 2.
好的，你就是2号。

1473
01:06:14,470 --> 01:06:17,590
Stand to his left.
站在他的左边。

1474
01:06:17,590 --> 01:06:20,020
OK, keep coming.
好的，继续来。

1475
01:06:20,020 --> 01:06:21,910
OK, yeah.
好的，没错。

1476
01:06:21,910 --> 01:06:24,380
OK, here we go.
好的，开始吧。

1477
01:06:24,380 --> 01:06:26,530
There you go.
好了。

1478
01:06:26,530 --> 01:06:28,210
OK, [INAUDIBLE] 0 and 3.
好的，[听不清] 0和3。

1479
01:06:28,210 --> 01:06:31,810
OK, so let's just make sure they match what we've got there.
好的，让我们确保这些数字与我们之前得到的一致。

1480
01:06:31,810 --> 01:06:32,810
Good so far.
目前为止都很好。

1481
01:06:32,810 --> 01:06:36,313
OK, so we have eight volunteers here, an array of volunteers, if you would.
好的，我们这里有8名志愿者，一排志愿者，如果你愿意这么说的话。

1482
01:06:36,313 --> 01:06:38,230
This time, we've used eight rather than seven.
这次，我们用了8个人而不是7个人。

1483
01:06:38,230 --> 01:06:41,840
We deliberately had seven lockers just so that the divide by 2 math
我们故意设置了7个储物柜，这样除以2的计算

1484
01:06:41,840 --> 01:06:42,340
worked out.
就能算出来。

1485
01:06:42,340 --> 01:06:44,890
That was very deliberate that there was always a [INAUDIBLE] a middle,
这是刻意安排的，因为始终有一个[听不清] 中间，

1486
01:06:44,890 --> 01:06:45,682
a middle, a middle.
中间，中间。

1487
01:06:45,682 --> 01:06:48,682
In this case, it doesn't matter because we're going to focus on sorting.
在这种情况下，这并不重要，因为我们要专注于排序。

1488
01:06:48,682 --> 01:06:51,130
But first, how about some introductions from each group?
但首先，每个小组都介绍一下自己吧？

1489
01:06:51,130 --> 01:06:52,520
AUDIENCE: I'm Rebecca.
观众：我是丽贝卡。

1490
01:06:52,520 --> 01:06:53,962
I'm a first year in Pennypacker.
我是一年级学生，在佩妮帕克学院。

1491
01:06:53,962 --> 01:06:56,170
And I'm thinking about studying environmental science
我正在考虑学习环境科学

1492
01:06:56,170 --> 01:06:57,410
and public policy.
和公共政策。

1493
01:06:57,410 --> 01:06:57,910
[CHEERING]
[欢呼]

1494
01:06:57,910 --> 01:06:59,240
DAVID MALAN: Nice.
大卫·马兰：不错。

1495
01:06:59,240 --> 01:07:00,100
[APPLAUSE]
[鼓掌]

1496
01:07:00,100 --> 01:07:02,420
AUDIENCE: I'm [? Mariella. ?] I'm also in Pennypacker.
观众：我是[？马里埃拉？]，我也在佩妮帕克学院。

1497
01:07:02,420 --> 01:07:03,170
I'm a first year.
我是一年级学生。

1498
01:07:03,170 --> 01:07:05,020
And I'm thinking of studying bioengineering.
我正在考虑学习生物工程。

1499
01:07:05,020 --> 01:07:06,565
DAVID MALAN: Wonderful.
大卫·马兰：太棒了。

1500
01:07:06,565 --> 01:07:09,440
AUDIENCE: My name's [? Haron ?] [? Li. ?] I'm a freshman in Matthews.
观众：我叫[？哈伦？] [？李？]，我是马修学院的大一新生。

1501
01:07:09,440 --> 01:07:11,015
I'm planning on studying applied mathematics.
我打算学习应用数学。

1502
01:07:11,015 --> 01:07:12,290
DAVID MALAN: Nice-- Matthews.
大卫·马兰：不错——马修学院。

1503
01:07:12,290 --> 01:07:13,910
AUDIENCE: My name is Emily.
观众：我叫艾米丽。

1504
01:07:13,910 --> 01:07:15,140
I'm a first year in Canada.
我是一年级学生，在加拿大学院。

1505
01:07:15,140 --> 01:07:17,470
And I'm still deciding what to study.
我还在决定学什么。

1506
01:07:17,470 --> 01:07:18,220
DAVID MALAN: Fair.
大卫·马兰：说得有道理。

1507
01:07:18,220 --> 01:07:21,020
AUDIENCE: My name's [? Tanai. ?] I'm a first year from Toronto.
观众：我叫[？塔奈？]，我是多伦多来的大一新生。

1508
01:07:21,020 --> 01:07:23,315
And I'm planning on studying ECON and CS.
我打算学习经济学和计算机科学。

1509
01:07:23,315 --> 01:07:24,110
DAVID MALAN: Nice.
大卫·马兰：不错。

1510
01:07:24,110 --> 01:07:26,030
AUDIENCE: My name is Teddy.
观众：我叫泰迪。

1511
01:07:26,030 --> 01:07:27,320
I'm a first year in Hurlbut.
我是一年级学生，在赫尔伯特学院。

1512
01:07:27,320 --> 01:07:30,320
And I'm planning on concentrating in computer science with linguistics.
我打算主修计算机科学和语言学。

1513
01:07:30,320 --> 01:07:31,070
DAVID MALAN: Nice.
大卫·马兰：不错。

1514
01:07:31,070 --> 01:07:32,000
AUDIENCE: Yeah!
观众：是的！

1515
01:07:32,000 --> 01:07:32,750
DAVID MALAN: Nice.
大卫·马兰：不错。

1516
01:07:32,750 --> 01:07:33,690
[APPLAUSE]
[掌声]

1517
01:07:33,690 --> 01:07:36,470
AUDIENCE: My name's [? Lenny. ?] I'm a first year in Matthews.
观众：我叫[？莱尼？]，我是一年级学生，在马修斯学院。

1518
01:07:36,470 --> 01:07:39,300
And I'm planning on concentrating in gov and CS.
我打算主修政府和计算机科学。

1519
01:07:39,300 --> 01:07:40,220
DAVID MALAN: Ah, nice.
大卫·马兰：啊，不错。

1520
01:07:40,220 --> 01:07:40,565
[CHEERING]
[欢呼]

1521
01:07:40,565 --> 01:07:41,037
[APPLAUSE]
[掌声]

1522
01:07:41,037 --> 01:07:41,537
And?
还有呢？

1523
01:07:41,537 --> 01:07:42,740
AUDIENCE: My name is Eli.
观众：我叫伊莱。

1524
01:07:42,740 --> 01:07:44,023
I'm a first year in Hollis.
我是一年级学生，在霍利斯学院。

1525
01:07:44,023 --> 01:07:45,440
And I plan on concentrating in CS.
我打算主修计算机科学。

1526
01:07:45,440 --> 01:07:47,540
DAVID MALAN: Eli, we keep looking for you today.
大卫·马兰：伊莱，我们今天一直在找你。

1527
01:07:47,540 --> 01:07:49,962
OK, so if you guys could scooch a little bit this way just
好的，如果你们能稍微往这边挪动一下，

1528
01:07:49,962 --> 01:07:51,170
to be a little more centered.
这样更居中一些。

1529
01:07:51,170 --> 01:07:54,750
Notice that this array of volunteers is entirely unsorted.
注意，这组志愿者完全没有排序。

1530
01:07:54,750 --> 01:07:56,960
So we thought we'd do three passes at this.
所以我们想对此进行三次操作。

1531
01:07:56,960 --> 01:08:00,135
Could you all sort yourselves from smallest to largest?
你们能从最小到最大给自己排序吗？

1532
01:08:00,135 --> 01:08:00,635
Go.
开始。

1533
01:08:06,420 --> 01:08:08,190
All right, that was very good.
好的，这做得很好。

1534
01:08:08,190 --> 01:08:09,420
So yes, so, sure.
所以，是的，当然。

1535
01:08:09,420 --> 01:08:10,003
OK.
好的。

1536
01:08:10,003 --> 01:08:10,503
[CHEERING]
[欢呼]

1537
01:08:10,503 --> 01:08:12,920
[APPLAUSE]
[掌声]

1538
01:08:12,920 --> 01:08:14,420
And let's see.
我们来看看。

1539
01:08:14,420 --> 01:08:17,603
What was your algorithm?
你的算法是什么？

1540
01:08:17,603 --> 01:08:19,520
AUDIENCE: I just kind of found the person that
观众：我只是找到了那个

1541
01:08:19,520 --> 01:08:21,260
was, like, one lower or one higher.
比我低一个或高一个的人。

1542
01:08:21,260 --> 01:08:22,560
So I looked at him.
所以我看着他。

1543
01:08:22,560 --> 01:08:23,060
He had 2.
他拿的是2。

1544
01:08:23,060 --> 01:08:24,500
So I knew I had to be on his left.
所以我明白我得站在他的左边。

1545
01:08:24,500 --> 01:08:25,729
And then she had 3.
然后她拿的是3。

1546
01:08:25,729 --> 01:08:27,410
So I told her to come to my right.
所以我叫她到我右边。

1547
01:08:27,410 --> 01:08:28,467
And then I knew he had 5.
然后我知道他拿的是5。

1548
01:08:28,467 --> 01:08:30,050
DAVID MALAN: OK, nice-- pretty clever.
大卫·马兰：好的，不错，很聪明。

1549
01:08:30,050 --> 01:08:31,640
And how about your algorithm?
你的算法呢？

1550
01:08:31,640 --> 01:08:34,935
AUDIENCE: Same thing-- looked for the number that was lower and higher
观众：一样，我找到了比我低和高的数字

1551
01:08:34,935 --> 01:08:35,810
and found the middle.
然后找到了中间的那个。

1552
01:08:35,810 --> 01:08:38,029
DAVID MALAN: OK, interesting, because I think from the outside view,
大卫·马兰：好的，很有趣，因为我认为从外部视角来看，

1553
01:08:38,029 --> 01:08:39,638
it all seemed very organic.
这一切看起来都很自然。

1554
01:08:39,638 --> 01:08:42,180
And things just kind of worked themselves out, which is fine.
事情就这么自然而然地解决了，这很好。

1555
01:08:42,180 --> 01:08:44,930
But I dare say what you guys did was probably a little hard for me
但我敢说，你们做的事情可能对我来说有点难

1556
01:08:44,930 --> 01:08:46,410
to translate into code.
翻译成代码。

1557
01:08:46,410 --> 01:08:48,560
So let me propose that we take two passes at this.
所以，我建议我们对此进行两次操作。

1558
01:08:48,560 --> 01:08:51,380
If you could reset yourselves to be in that order from left
如果你能回到原来的顺序，从左

1559
01:08:51,380 --> 01:08:54,920
to right, which is just the exact same sequence, just so that we're
到右，也就是完全相同的顺序，这样我们就能

1560
01:08:54,920 --> 01:08:58,310
starting from the same point each time.
每次都从同一个点开始。

1561
01:08:58,310 --> 01:08:59,630
[INAUDIBLE]
[听不清]

1562
01:08:59,630 --> 01:09:00,319
Very good.
非常好。

1563
01:09:00,319 --> 01:09:02,120
All right, so let me propose this.
好的，我来提议一下。

1564
01:09:02,120 --> 01:09:04,470
We can approach sorting in a couple of different ways.
我们可以用几种不同的方法来进行排序。

1565
01:09:04,470 --> 01:09:05,720
But it needs to be methodical.
但需要有条理。

1566
01:09:05,720 --> 01:09:09,600
Like, it needs to translate ideally to pseudocode and eventually code.
例如，它需要理想地转换为伪代码，最终转换为代码。

1567
01:09:09,600 --> 01:09:12,810
So as much as we can quantize things to be step by step,
因此，我们尽可能地将事情量化成一步一步的步骤，

1568
01:09:12,810 --> 01:09:15,100
I think the better this will scale overall,
我认为这样做能使整体规模更大，

1569
01:09:15,100 --> 01:09:19,020
especially when there's not eight people but maybe there's 80 people or 800.
尤其是在不是八个人，而是八个人或八百人的情况下。

1570
01:09:19,020 --> 01:09:22,020
Because I dare say that if we had everyone in the room sort themselves--
因为我敢说，如果我们让房间里的每个人自己排序，

1571
01:09:22,020 --> 01:09:23,580
if they were all handling a number--
如果他们都处理一个数字，

1572
01:09:23,580 --> 01:09:26,062
like, that probably wouldn't have worked out very well.
这样可能不会很有效。

1573
01:09:26,062 --> 01:09:29,229
It probably would have taken forever because there's just so much more data.
这可能要花费很长时间，因为数据量要多得多。

1574
01:09:29,229 --> 01:09:30,700
So let's be a little more methodical.
所以让我们更有条理一些。

1575
01:09:30,700 --> 01:09:33,283
So for instance, I don't have a bird's eye view of the numbers
例如，我没有一个鸟瞰的视角去看这些数字，

1576
01:09:33,283 --> 01:09:35,130
just as before because even though we don't
就像之前一样，尽管我们没有

1577
01:09:35,130 --> 01:09:38,460
have doors in front of our volunteers, they're effectively lockers too.
在志愿者前面设置了门，但他们实际上也是储物柜。

1578
01:09:38,460 --> 01:09:42,040
And the computer or the human in my case can only look at one door at a time.
而电脑或像我一样的人一次只能看一个门。

1579
01:09:42,040 --> 01:09:44,880
So if I want to find the smallest number and put it
所以，如果我想找到最小的数字并把它

1580
01:09:44,880 --> 01:09:46,830
where it should go on the left, I can't just
放到它应该在左边的地方，我不能仅仅

1581
01:09:46,830 --> 01:09:49,500
take a step back and be like, OK, obviously, there's the one.
后退一步说，好吧，显然，这里有一个。

1582
01:09:49,500 --> 01:09:51,010
I have to do it more methodically.
我必须更有条理地做这件事。

1583
01:09:51,010 --> 01:09:52,350
So I'm going to check here--
所以我要检查一下这里 -

1584
01:09:52,350 --> 01:09:52,890
7.
7。

1585
01:09:52,890 --> 01:09:55,320
At the moment, this is actually the smallest number I've seen.
目前，这是我见过的最小的数字。

1586
01:09:55,320 --> 01:09:56,945
So I'm going to make mental note of it.
所以我要把它记在心里。

1587
01:09:56,945 --> 01:09:58,230
OK, 2 I see now.
好的，我现在看到的是 2。

1588
01:09:58,230 --> 01:10:01,140
I can forget about the 7 because 2 is clearly smaller.
我可以忘记 7，因为 2 显然更小。

1589
01:10:01,140 --> 01:10:02,850
5-- I don't need to remember it.
5 - 我不需要记住它。

1590
01:10:02,850 --> 01:10:04,200
4-- I don't need to remember it.
4 - 我不需要记住它。

1591
01:10:04,200 --> 01:10:06,330
1-- OK, that's clearly smaller.
1 - 好的，这显然更小。

1592
01:10:06,330 --> 01:10:08,560
Have I found my smallest number?
我已经找到最小的数字了吗？

1593
01:10:08,560 --> 01:10:10,337
Not even because there actually is a 0.
还没有，因为实际上有一个 0。

1594
01:10:10,337 --> 01:10:11,920
So I should go through the whole list.
所以我要遍历整个列表。

1595
01:10:11,920 --> 01:10:14,905
But I will remember that my smallest element is now 1.
但我会记住，我现在的最小元素是 1。

1596
01:10:14,905 --> 01:10:18,190
6 is not smaller-- oh, 0 is smaller, so I'll remember this.
6 不比它小 - 哦，0 比它小，所以我会记住它。

1597
01:10:18,190 --> 01:10:19,400
3 is not smaller.
3 不比它小。

1598
01:10:19,400 --> 01:10:21,790
And so now, our volunteer for 0-- what was your name?
现在，0 的志愿者 - 你叫什么名字？

1599
01:10:21,790 --> 01:10:22,707
AUDIENCE: [INAUDIBLE].
观众：[听不清]

1600
01:10:22,707 --> 01:10:26,120
DAVID MALAN: Mariana, and where should we put you clearly?
DAVID MALAN：玛丽安娜，我们应该把你放到哪里？

1601
01:10:26,120 --> 01:10:26,665
So there.
放在那里。

1602
01:10:26,665 --> 01:10:27,790
But what's your name again?
但你叫什么名字？

1603
01:10:27,790 --> 01:10:28,665
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1604
01:10:28,665 --> 01:10:30,010
DAVID MALAN: Eli's in the way.
DAVID MALAN：伊莱挡路了。

1605
01:10:30,010 --> 01:10:31,745
So we could have Mary Ellen?
所以我们可以让玛丽·艾伦来？

1606
01:10:31,745 --> 01:10:32,620
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1607
01:10:32,620 --> 01:10:35,860
DAVID MALAN: [? Mariella ?] just go to the right of Eli.
DAVID MALAN：[玛丽埃拉？] 就在伊莱的右边。

1608
01:10:35,860 --> 01:10:37,390
But that's kind of cheating, right?
但这样有点作弊，对吧？

1609
01:10:37,390 --> 01:10:40,570
Because if this is an array, recall that they are contiguous.
因为如果这是一个数组，请记住它们是连续的。

1610
01:10:40,570 --> 01:10:43,578
But there could be other stuff in memory to the left and to the right.
但内存中可能有其他东西在左边和右边。

1611
01:10:43,578 --> 01:10:44,620
So that's not quite fair.
所以这不太公平。

1612
01:10:44,620 --> 01:10:47,110
We can't just have the luxury of putting things wherever we want.
我们不能仅仅享受把东西放在任何我们想要的地方的奢侈。

1613
01:10:47,110 --> 01:10:49,120
But Eli, you're not even in the right order, anyway.
但埃利，无论如何你甚至没有排在正确的位置。

1614
01:10:49,120 --> 01:10:50,620
So why don't we just swap you two.
所以我们为什么不交换你们两个呢？

1615
01:10:50,620 --> 01:10:52,720
So [? Mariella ?] and Eli swap.
所以 [？玛丽埃拉？] 和埃利交换。

1616
01:10:52,720 --> 01:10:55,780
But now I've taken one bite out of this problem.
但现在我已经从这个问题中啃下一口了。

1617
01:10:55,780 --> 01:10:57,910
I've coincidentally made it a little better
我无意中让它变得好了一点

1618
01:10:57,910 --> 01:11:00,760
by moving Eli closer to where he is.
通过将埃利移近他的位置。

1619
01:11:00,760 --> 01:11:01,510
But you know what?
但你知道吗？

1620
01:11:01,510 --> 01:11:02,830
He was in a random location, anyway.
无论如何，他在一个随机的位置。

1621
01:11:02,830 --> 01:11:05,372
So I don't think I made the problem any worse, fundamentally.
所以我不认为我从根本上使问题变得更糟。

1622
01:11:05,372 --> 01:11:06,820
Now I can do this again.
现在我可以再做一次。

1623
01:11:06,820 --> 01:11:08,870
And I can shave a little bit of time off of it
我也可以节省一点时间

1624
01:11:08,870 --> 01:11:11,600
because I don't need to revisit [? Mariella ?] because if she
因为我不需要再去看 [？玛丽埃拉？] 因为如果她

1625
01:11:11,600 --> 01:11:14,300
was the smaller and I've already selected her from the array,
是最小的，我已经从数组中选中了她，

1626
01:11:14,300 --> 01:11:17,600
I can just move on and take one fewer bites this time around.
我可以直接继续，这次少啃一口。

1627
01:11:17,600 --> 01:11:20,930
So 2 is the smallest number, not 5, not 4.
所以 2 是最小的数字，不是 5，也不是 4。

1628
01:11:20,930 --> 01:11:22,620
OK, 1 is the smallest number.
好的，1 是最小的数字。

1629
01:11:22,620 --> 01:11:27,320
So I'm going to remember that as with a mental variable- 6, 7, 3.
所以我将用一个心理变量来记住它 - 6, 7, 3。

1630
01:11:27,320 --> 01:11:28,430
OK, 1 is the smallest.
好的，1 是最小的。

1631
01:11:28,430 --> 01:11:29,930
So let me select number 1.
所以让我选择数字 1。

1632
01:11:29,930 --> 01:11:32,270
And we're going to have to evict you, which
我们必须把你赶出去，这

1633
01:11:32,270 --> 01:11:34,080
is making the problem slightly worse.
使问题稍微变得更糟。

1634
01:11:34,080 --> 01:11:35,780
But I think it'll average out.
但我认为这会平均出来。

1635
01:11:35,780 --> 01:11:38,490
And now 0 and 1 are in the right place.
现在 0 和 1 在正确的位置了。

1636
01:11:38,490 --> 01:11:40,160
So now let me do this again but faster.
所以现在让我再做一次，但要快一点。

1637
01:11:40,160 --> 01:11:42,230
So 5-- OK, 4--
所以 5 - 好的，4 -

1638
01:11:42,230 --> 01:11:43,340
2 is the smallest--
2 是最小的 -

1639
01:11:43,340 --> 01:11:44,630
6, 7, 3.
6, 7, 3。

1640
01:11:44,630 --> 01:11:48,110
OK, 2, let's put you where you belong, evicting 5.
好的，2，让我们把你放在你该在的地方，赶走 5。

1641
01:11:48,110 --> 01:11:50,900
Now I can skip all three of these volunteers.
现在我可以跳过这三个志愿者。

1642
01:11:50,900 --> 01:11:52,080
OK, 4, is the smallest.
好的，4 是最小的。

1643
01:11:52,080 --> 01:11:52,580
Nope.
不是。

1644
01:11:52,580 --> 01:11:52,910
Nope.
不是。

1645
01:11:52,910 --> 01:11:53,120
Nope.
不是。

1646
01:11:53,120 --> 01:11:54,200
3, you're the smallest.
3，你是最小的。

1647
01:11:54,200 --> 01:11:55,880
Let me evict 4.
让我赶走 4。

1648
01:11:55,880 --> 01:11:59,330
All right, and now let me move in front of these volunteers.
好的，现在让我走到这些志愿者前面。

1649
01:11:59,330 --> 01:12:02,250
5, 6, 7, 4, come on back.
5，6，7，4，回来。

1650
01:12:02,250 --> 01:12:04,910
All right, and now let's select 6, 7, 5.
好的，现在让我们选择 6，7，5。

1651
01:12:04,910 --> 01:12:07,140
OK, come on back.
好的，回来。

1652
01:12:07,140 --> 01:12:08,340
Oh, no, no cheating, Eli.
哦，不，不作弊，埃利。

1653
01:12:08,340 --> 01:12:09,630
OK, and then let's see.
好的，然后让我们看看。

1654
01:12:09,630 --> 01:12:13,020
5, 7, 6-- OK, 6, come on back.
5，7，6 - 好的，6，回来。

1655
01:12:13,020 --> 01:12:14,250
OK, now you have to move.
好的，现在你必须移动。

1656
01:12:14,250 --> 01:12:18,847
OK, and now we've selected in turn all of the numbers from left to right.
好的，现在我们已经依次从左到右选择了所有数字。

1657
01:12:18,847 --> 01:12:20,430
And even though that did feel slower--
尽管这感觉有点慢 -

1658
01:12:20,430 --> 01:12:22,890
I was doing it a little more verbally as I stepped through it--
我在一步一步地做的时候，用更多的话语来表达它 -

1659
01:12:22,890 --> 01:12:25,510
but I dare say we could translate that probably more to code.
但我敢说我们可能可以将它更多地翻译成代码。

1660
01:12:25,510 --> 01:12:26,010
Why?
为什么？

1661
01:12:26,010 --> 01:12:27,690
Because there's a lot of, like, looping through it
因为有很多像循环遍历之类的

1662
01:12:27,690 --> 01:12:30,270
and probably a lot of conditionals just asking the question,
而且可能有很多条件语句只是在问这个问题

1663
01:12:30,270 --> 01:12:34,800
is this number smaller than this one or conversely greater than this other one.
这个数字是否小于这个数字，或者反过来是否大于另一个数字。

1664
01:12:34,800 --> 01:12:36,520
All right, let's do this one more time.
好了，我们再做一次。

1665
01:12:36,520 --> 01:12:41,010
If you guys could reset yourselves to this ordering.
如果你们能将自己重置为这个顺序。

1666
01:12:41,010 --> 01:12:46,720
All right, so we again have 72541603.
好了，我们再次得到72541603。

1667
01:12:46,720 --> 01:12:47,220
Good.
好的。

1668
01:12:47,220 --> 01:12:48,480
So how about this?
那么这个怎么样？

1669
01:12:48,480 --> 01:12:50,550
I liked the intuition that they originally
我喜欢他们最初的直觉

1670
01:12:50,550 --> 01:12:53,520
had, funny enough, whereby they just kind of organically
有，很有趣，他们只是自然而然地

1671
01:12:53,520 --> 01:12:55,570
looked to the person to the left and to the right
看了一下左边和右边的人

1672
01:12:55,570 --> 01:12:56,820
and kind of fixed the problem.
并试图解决问题。

1673
01:12:56,820 --> 01:12:59,970
So if they were out of order, they just kind of swapped locally adjacent
所以如果它们是乱序的，他们只是在本地交换了相邻的

1674
01:12:59,970 --> 01:13:00,610
to each other.
彼此。

1675
01:13:00,610 --> 01:13:01,500
So let's try this.
所以让我们试试这个。

1676
01:13:01,500 --> 01:13:03,670
So 7 and 2, you're clearly out of order.
所以7和2，你们显然是乱序的。

1677
01:13:03,670 --> 01:13:05,340
So let's swap just you two.
所以让我们只交换你们两个。

1678
01:13:05,340 --> 01:13:06,870
7 and 5, you're out of order.
7和5，你们是乱序的。

1679
01:13:06,870 --> 01:13:08,190
Let's swap you two.
让我们交换你们两个。

1680
01:13:08,190 --> 01:13:10,290
7 and 4, let's swap you two.
7和4，让我们交换你们两个。

1681
01:13:10,290 --> 01:13:12,390
7 and 1, let's swap you two.
7和1，让我们交换你们两个。

1682
01:13:12,390 --> 01:13:15,360
7 and 6, let's swap you two.
7和6，让我们交换你们两个。

1683
01:13:15,360 --> 01:13:17,220
7 and 0, swap you two.
7和0，交换你们两个。

1684
01:13:17,220 --> 01:13:18,900
7 and 3, swap you two.
7和3，交换你们两个。

1685
01:13:18,900 --> 01:13:20,620
OK, that was a lot of swapping.
好吧，交换了很多次。

1686
01:13:20,620 --> 01:13:22,560
But notice what happened.
但请注意发生了什么。

1687
01:13:22,560 --> 01:13:23,790
I'm not done, clearly.
我显然还没完成。

1688
01:13:23,790 --> 01:13:24,780
It's not sorted yet.
它还没有排序。

1689
01:13:24,780 --> 01:13:26,230
But I have improved the situation.
但我已经改善了情况。

1690
01:13:26,230 --> 01:13:26,730
How?
怎么？

1691
01:13:26,730 --> 01:13:29,910
Who is now definitely in the right place?
现在谁肯定是在正确的位置？

1692
01:13:29,910 --> 01:13:34,510
So, 7-- or Eli has wonderfully bubbled all the way up to the top of the list,
所以，7——或者说Eli已经神奇地冒泡到列表的顶部了，

1693
01:13:34,510 --> 01:13:35,170
so to speak.
可以这么说。

1694
01:13:35,170 --> 01:13:37,030
Now I can actually skip him moving forward.
现在我实际上可以跳过他继续前进。

1695
01:13:37,030 --> 01:13:38,820
So that takes one bite out of the problem.
所以这消除了问题的一部分。

1696
01:13:38,820 --> 01:13:39,653
Let's do this again.
让我们再做一次。

1697
01:13:39,653 --> 01:13:40,440
2 and 5 are OK.
2和5没问题。

1698
01:13:40,440 --> 01:13:42,285
5 and 4, let's swap.
5和4，让我们交换。

1699
01:13:42,285 --> 01:13:43,020
No, over there.
不，在那边。

1700
01:13:43,020 --> 01:13:45,150
[LAUGHS] Thank you.
[笑] 谢谢。

1701
01:13:45,150 --> 01:13:46,950
5 and 1, let's swap.
5和1，让我们交换。

1702
01:13:46,950 --> 01:13:48,420
5 and 6 are good.
5和6没问题。

1703
01:13:48,420 --> 01:13:50,220
6 and 0, let's swap.
6和0，让我们交换。

1704
01:13:50,220 --> 01:13:52,158
6 and 3, let's swap.
6和3，让我们交换。

1705
01:13:52,158 --> 01:13:53,700
And we don't have to worry about Eli.
我们不必担心Eli。

1706
01:13:53,700 --> 01:13:54,720
And now, what's your name again?
现在，你叫什么名字来着？

1707
01:13:54,720 --> 01:13:54,960
AUDIENCE: [? Haron. ?]
观众：[？哈伦。？]

1708
01:13:54,960 --> 01:13:57,700
DAVID MALAN: [? Haron-- ?] we don't have to worry about him either as well.
戴维·马兰：[？哈伦——？] 我们也不必担心他。

1709
01:13:57,700 --> 01:13:59,283
So now I can go back to the beginning.
所以现在我可以回到开头。

1710
01:13:59,283 --> 01:14:02,460
And even though it feels like I'm going back and forth a lot,
虽然感觉我在来回很多次，

1711
01:14:02,460 --> 01:14:05,257
that's OK because the problem's still getting better and better.
没关系，因为问题越来越好了。

1712
01:14:05,257 --> 01:14:06,840
I'm taking a bite out of it each time.
我每次都解决一部分。

1713
01:14:06,840 --> 01:14:07,770
2 and 4 are good.
2 和 4 很好。

1714
01:14:07,770 --> 01:14:10,140
4 and 1, let's swap.
4 和 1，我们交换一下。

1715
01:14:10,140 --> 01:14:11,130
4 and 5 are good.
4 和 5 很好。

1716
01:14:11,130 --> 01:14:12,420
5 and 0, swap.
5 和 0，交换一下。

1717
01:14:12,420 --> 01:14:13,950
5 and 3, swap.
5 和 3，交换一下。

1718
01:14:13,950 --> 01:14:15,750
And now these three are in the right place.
现在这三个数字放在正确的位置了。

1719
01:14:15,750 --> 01:14:16,500
Let's do it again.
我们再来一次。

1720
01:14:16,500 --> 01:14:17,670
2 and 1-- ah, here we go.
2 和 1，啊，我们开始了。

1721
01:14:17,670 --> 01:14:18,330
Let's swap.
我们交换一下。

1722
01:14:18,330 --> 01:14:19,200
2 and 4 are OK.
2 和 4 很好。

1723
01:14:19,200 --> 01:14:20,670
4 and 0, swap.
4 和 0，交换一下。

1724
01:14:20,670 --> 01:14:22,110
4 and 3, swap.
4 和 3，交换一下。

1725
01:14:22,110 --> 01:14:23,820
Now, these four are OK.
现在，这四个数字都很好。

1726
01:14:23,820 --> 01:14:24,990
1 and 2, you're good.
1 和 2，你们很好。

1727
01:14:24,990 --> 01:14:26,280
2 and 0, swap.
2 和 0，交换一下。

1728
01:14:26,280 --> 01:14:27,840
2 and 3, you're good.
2 和 3，你们很好。

1729
01:14:27,840 --> 01:14:28,530
You're good.
你们很好。

1730
01:14:28,530 --> 01:14:30,790
OK, now 1 and 0, swap--
好了，现在 1 和 0，交换一下。

1731
01:14:30,790 --> 01:14:33,190
1 and 2 and now 0 and 1.
1 和 2，现在 0 和 1。

1732
01:14:33,190 --> 01:14:36,027
A round of applause if we could for our volunteers.
让我们为我们的志愿者们鼓掌吧。

1733
01:14:36,027 --> 01:14:37,338
[APPLAUSE]
[鼓掌声]

1734
01:14:37,338 --> 01:14:38,622
[CHEERING]
[欢呼声]

1735
01:14:38,622 --> 01:14:40,830
So if you want to put your numbers on the tray there,
所以如果你想把你的数字放在那个托盘上，

1736
01:14:40,830 --> 01:14:44,820
we have some lovely Super Mario Oreos today, which
我们今天有美味的超级马里奥奥利奥饼干，这可能

1737
01:14:44,820 --> 01:14:46,650
maybe drives a lot of the volunteerism.
促进了很多志愿行为。

1738
01:14:46,650 --> 01:14:48,930
But here we go.
但我们开始了。

1739
01:14:48,930 --> 01:14:51,180
Thank you all so much.
非常感谢大家。

1740
01:14:51,180 --> 01:14:54,060
And maybe, Carter, if you can help with the reset?
也许，卡特，你能帮忙重置一下？

1741
01:14:54,060 --> 01:14:56,020
All right, here we go.
好了，我们开始了。

1742
01:14:56,020 --> 01:14:57,840
[INAUDIBLE] yes, all set.
[听不见]是的，都准备好了。

1743
01:14:57,840 --> 01:14:58,740
Thank you very much.
非常感谢。

1744
01:14:58,740 --> 01:14:59,430
Thank you.
谢谢。

1745
01:14:59,430 --> 01:15:02,340
Thank you, guys.
谢谢，伙计们。

1746
01:15:02,340 --> 01:15:04,290
Thank you, yes.
谢谢，是的。

1747
01:15:04,290 --> 01:15:08,880
To recap, let's actually formalize a little more algorithmically
回顾一下，让我们用更算法的方式正式化一下

1748
01:15:08,880 --> 01:15:09,573
what we did.
我们所做的。

1749
01:15:09,573 --> 01:15:11,490
And I deliberately kind of orchestrated things
我故意安排了一些事情

1750
01:15:11,490 --> 01:15:14,280
there to show two fundamentally different approaches, one
在那里展示两种截然不同的方法，一种

1751
01:15:14,280 --> 01:15:18,210
where I kind of selected the element I wanted again and again
我一遍又一遍地选择我想要的元素

1752
01:15:18,210 --> 01:15:19,770
on the basis of how small it was.
根据它的尺寸大小。

1753
01:15:19,770 --> 01:15:22,210
I looked for the smallest, then the next smallest, and so forth.
我找到了最小的，然后是下一个最小的，依此类推。

1754
01:15:22,210 --> 01:15:24,335
The second time around, I took a different approach
第二次，我采用了不同的方法

1755
01:15:24,335 --> 01:15:26,010
by just fixing local problems.
仅仅解决局部问题。

1756
01:15:26,010 --> 01:15:28,710
But I did it again and again and again until I
但我一遍又一遍地做，直到我

1757
01:15:28,710 --> 01:15:30,408
fixed all of the minor problems.
解决了所有的小问题。

1758
01:15:30,408 --> 01:15:32,700
And frankly, what they did organically at the beginning
坦率地说，他们一开始自然而然地做的事情

1759
01:15:32,700 --> 01:15:36,167
was probably closer to the second algorithm than the first,
可能更接近于第二种算法而不是第一种算法，

1760
01:15:36,167 --> 01:15:39,250
even though I'm not sure they would write down the same pseudocode for it.
尽管我不确定他们会为它写下相同的伪代码。

1761
01:15:39,250 --> 01:15:43,510
The first algorithm we executed is actually called selection sort.
我们执行的第一个算法实际上称为选择排序。

1762
01:15:43,510 --> 01:15:46,060
And I deliberately used that vernacular of selecting
我故意使用了这种选择的方式

1763
01:15:46,060 --> 01:15:50,590
the smallest element again and again to evoke this name of the algorithm.
反复选择最小的元素来唤起这个算法的名称。

1764
01:15:50,590 --> 01:15:54,460
So for instance, when we had these numbers here initially unsorted,
例如，当我们最初没有对这些数字进行排序时，

1765
01:15:54,460 --> 01:15:58,900
I kept looking again and again and again for the smallest element.
我一遍又一遍地寻找最小的元素。

1766
01:15:58,900 --> 01:16:02,380
And I don't know a priori what the smallest number is until I
而且我事先不知道最小的数字是什么，直到我

1767
01:16:02,380 --> 01:16:04,510
go through the list at least once.
至少遍历列表一次。

1768
01:16:04,510 --> 01:16:06,190
Then I can pluck out the 0.
然后我可以选出 0。

1769
01:16:06,190 --> 01:16:10,360
I then go through the list a second time to pluck out the 1, a third time
然后我第二次遍历列表来选出 1，第三次

1770
01:16:10,360 --> 01:16:11,560
to pluck out the 2.
选出 2。

1771
01:16:11,560 --> 01:16:14,380
Now, this assumes that I don't have an infinite amount of memory
现在，这假设我没有无限的内存

1772
01:16:14,380 --> 01:16:17,920
because even though I kept repeating myself looking for the next smallest
因为即使我不断重复自己寻找下一个最小的

1773
01:16:17,920 --> 01:16:20,800
element, next smallest element, I propose that I only
元素，下一个最小的元素，我建议我仅仅

1774
01:16:20,800 --> 01:16:25,060
keep track of one number at a time, one variable in my mind, which
一次跟踪一个数字，我脑海中一个变量，它

1775
01:16:25,060 --> 01:16:28,330
was the smallest element I have seen thus far.
是我迄今为止见过的最小元素。

1776
01:16:28,330 --> 01:16:32,080
If I used more memory, I could probably remember from the first pass
如果我使用更多内存，我可能会从第一次遍历中记住

1777
01:16:32,080 --> 01:16:33,580
where the 2 is, where the 3 is.
2 在哪里，3 在哪里。

1778
01:16:33,580 --> 01:16:34,955
But that's a different algorithm.
但那是不同的算法。

1779
01:16:34,955 --> 01:16:37,180
And it would take more space, more memory.
并且它会占用更多空间，更多内存。

1780
01:16:37,180 --> 01:16:41,390
I was confining myself to just one variable in my approach.
我在方法中只限制自己使用一个变量。

1781
01:16:41,390 --> 01:16:44,800
So here might be the pseudocode for what we'd call selection
所以这里可能是我们称之为选择排序的伪代码

1782
01:16:44,800 --> 01:16:48,490
sort, the very first algorithm that we all did together, not organically,
排序，我们大家一起做的第一个算法，不是自发的，

1783
01:16:48,490 --> 01:16:50,350
but more methodically as a group.
而是更有条理地作为团队。

1784
01:16:50,350 --> 01:16:54,220
I would propose that we use some syntax from C when we talk about the loop
我建议我们在谈论循环时使用 C 中的一些语法

1785
01:16:54,220 --> 01:16:57,790
and say for i from 0 to n minus 1.
并说从 0 到 n 减 1 的 i。

1786
01:16:57,790 --> 01:16:58,600
Now, why is that?
现在，为什么这样？

1787
01:16:58,600 --> 01:17:02,980
Well, if there were n people or 8, 0 through 7
嗯，如果有 n 个人或 8 个人，从 0 到 7

1788
01:17:02,980 --> 01:17:07,040
are the indexes or indices of those humans on stage from left to right.
是这些站在舞台上的人从左到右的索引。

1789
01:17:07,040 --> 01:17:08,620
So what did I have myself do?
所以我自己做了什么？

1790
01:17:08,620 --> 01:17:15,190
Find the smallest number between numbers bracket i and numbers bracket
在数字括号 i 和数字括号之间找到最小的数字

1791
01:17:15,190 --> 01:17:16,390
n minus 1.
n 减 1。

1792
01:17:16,390 --> 01:17:20,710
So when the loop starts at 0, this is literally
所以当循环从 0 开始时，这实际上是

1793
01:17:20,710 --> 01:17:25,750
saying between numbers bracket 0 and numbers bracket n minus 1.
说在数字括号 0 和数字括号 n 减 1 之间。

1794
01:17:25,750 --> 01:17:30,490
So from the far left to the far right, find me the smallest number.
所以从最左边到最右边，找到最小的数字。

1795
01:17:30,490 --> 01:17:34,300
Then swap that number with numbers bracket i.
然后将该数字与数字括号 i 交换。

1796
01:17:34,300 --> 01:17:36,880
So that's why we evicted the person all the way
所以这就是为什么我们第一次将那个人赶到最右边或最左边的原因，

1797
01:17:36,880 --> 01:17:39,970
over to the right or your left the very first time,
然后是下一个人，下一个人，等等。

1798
01:17:39,970 --> 01:17:42,650
and then the next person, and the next person, and so forth.
所以这是一个让我们来回移动的算法，来回移动，

1799
01:17:42,650 --> 01:17:46,990
So this is an algorithm that has us go back and forth, back and forth,
迭代地选择最小的元素。

1800
01:17:46,990 --> 01:17:49,250
iteratively selecting the smallest element.
所以如果我们现在将其推广，而不是从 8 个人推广到 n 个人，

1801
01:17:49,250 --> 01:17:53,980
So if we generalize this now, not away from eight people to, like, n people,
你可以将它们视为表示一个数组，也称为

1802
01:17:53,980 --> 01:17:56,800
you can think of them as representing an array, a.k.a.
像这样的门，最左边的门是 0，最右边的门是 n 减 1，

1803
01:17:56,800 --> 01:18:01,180
doors like this where the leftmost one is 0, the rightmost one is n minus 1,
倒数第二个是 n 减 2，依此类推，如果我们不知道或不关心

1804
01:18:01,180 --> 01:18:04,540
second to last is n minus 2, and so forth if we don't know or care
n 的具体值。

1805
01:18:04,540 --> 01:18:06,250
what n specifically is.
。

1806
01:18:06,250 --> 01:18:11,980
So how many total steps does selection sort perhaps take?
那么选择排序可能需要多少步呢？

1807
01:18:11,980 --> 01:18:13,930
And let's make this a little more real here.
让我们在这里更现实一点。

1808
01:18:13,930 --> 01:18:17,990
Let me actually open up, for instance, a quick visualization here.
让我在这里打开一个快速的可视化，例如。

1809
01:18:17,990 --> 01:18:19,930
And on the screen here, you'll just see now
现在你将在屏幕上看到

1810
01:18:19,930 --> 01:18:24,070
an artist's rendition of an array of values whereby tall purple bars
艺术家对一组值的渲染，其中高紫色条

1811
01:18:24,070 --> 01:18:25,390
represent big integers.
代表大的整数。

1812
01:18:25,390 --> 01:18:28,310
And short purple bars represent small integers.
短的紫色条代表小的整数。

1813
01:18:28,310 --> 01:18:31,690
So the idea of any sorting algorithm here as visualized
因此，任何排序算法的思路在这里被可视化

1814
01:18:31,690 --> 01:18:34,600
is to get the small bars on the left and the big bars on the right.
是将小的条放在左边，大的条放在右边。

1815
01:18:34,600 --> 01:18:36,550
And this is a nice handy tool that lets you play around
这是一个很好的工具，可以让你玩弄

1816
01:18:36,550 --> 01:18:37,700
with different algorithms.
不同的算法。

1817
01:18:37,700 --> 01:18:39,970
So here is selection sort that I've just clicked.
所以这里是我刚刚点击的选择排序。

1818
01:18:39,970 --> 01:18:42,760
In pink again and again is the equivalent
粉红色不断出现，相当于

1819
01:18:42,760 --> 01:18:46,210
of me walking through the volunteers looking for the next smallest element.
我走过志愿者，寻找下一个最小的元素。

1820
01:18:46,210 --> 01:18:50,260
And as soon as I found them, I swapped them into their leftmost location,
我一找到它们，就把它们交换到最左边的位置，

1821
01:18:50,260 --> 01:18:54,250
evicting whoever's there in order to gradually sort
驱逐任何在那里的人，以便逐步排序

1822
01:18:54,250 --> 01:18:56,480
this list from left to right.
这个列表从左到右。

1823
01:18:56,480 --> 01:19:00,400
And so as you can see here, it holds very briefly in pink
所以在这里你可以看到，它非常短暂地用粉红色显示

1824
01:19:00,400 --> 01:19:03,250
whatever the currently smallest element it has found is.
它找到的当前最小元素是什么。

1825
01:19:03,250 --> 01:19:05,830
That's the analog of, like, me pointing to my head
这类似于我指着我的头

1826
01:19:05,830 --> 01:19:09,940
whereby it's constantly comparing, comparing, comparing,
它不断地比较、比较、比较，

1827
01:19:09,940 --> 01:19:12,423
looking for the next smallest element.
寻找下一个最小的元素。

1828
01:19:12,423 --> 01:19:15,340
Now, I'm kind of stalling because I'm running out of intelligent words
现在，我有点停顿，因为我快没有聪明的词了

1829
01:19:15,340 --> 01:19:15,840
to say.
可以说。

1830
01:19:15,840 --> 01:19:18,190
But that is to say, this algorithm feels kind of slow.
但这就是说，这个算法感觉有点慢。

1831
01:19:18,190 --> 01:19:20,590
Like, it seems to be doing a lot of work.
就像，它似乎在做很多工作。

1832
01:19:20,590 --> 01:19:23,170
Where is the work coming in?
工作是从哪里来的？

1833
01:19:23,170 --> 01:19:26,060
Like, what is it doing a lot of specifically?
就像，它具体做了很多什么？

1834
01:19:26,060 --> 01:19:27,118
Yeah?
对吧？

1835
01:19:27,118 --> 01:19:29,410
Yeah, it keeps going back and forth and back and forth.
是的，它不断地来回移动。

1836
01:19:29,410 --> 01:19:31,090
And even though it's shaving a little bit of time,
即使它节省了一点时间，

1837
01:19:31,090 --> 01:19:33,670
right, because it doesn't have to stupidly go all the way back
对，因为它不必愚蠢地一直回到

1838
01:19:33,670 --> 01:19:35,920
to the beginning, and I was saving myself a few steps,
开头，我节省了一些步骤，

1839
01:19:35,920 --> 01:19:38,680
like, it's a lot of cyclicity again and again and again.
就像，它有很多循环，一遍又一遍。

1840
01:19:38,680 --> 01:19:41,500
And put another way, it's a lot of comparisons again and again.
换句话说，它做了很多比较，一遍又一遍。

1841
01:19:41,500 --> 01:19:44,560
And some of those comparisons you're doing multiple times
而且你多次进行了一些比较

1842
01:19:44,560 --> 01:19:47,890
because I only remembered one element at a time in my head.
因为我一次只能记住一个元素。

1843
01:19:47,890 --> 01:19:50,950
So I have to kind of remind myself on every pass which
所以我必须在每次传递时提醒自己哪一个

1844
01:19:50,950 --> 01:19:52,640
is smallest, which is smallest.
是最小的，哪个是最小的。

1845
01:19:52,640 --> 01:19:57,760
So this invites the question how fast or how slow or equivalently
所以这引发了一个问题，像冒泡排序这样东西有多快或多慢，或者等效地

1846
01:19:57,760 --> 01:20:02,350
how efficient or inefficient is something like bubble--
有多有效或多无效

1847
01:20:02,350 --> 01:20:03,400
selection sort.
选择排序。

1848
01:20:03,400 --> 01:20:07,790
Well, let's actually consider how we could analyze this as follows.
好吧，让我们实际考虑一下如何分析它，如下所示。

1849
01:20:07,790 --> 01:20:12,790
So if we have n numbers that we want to sort,
所以如果我们有 n 个数字要排序，

1850
01:20:12,790 --> 01:20:15,730
how many comparisons do we do the first time?
我们第一次做了多少次比较？

1851
01:20:15,730 --> 01:20:19,280
Well, if there's n numbers, you can only make n minus 1 comparisons.
好吧，如果有 n 个数字，你只能进行 n 减 1 次比较。

1852
01:20:19,280 --> 01:20:19,780
Why?
为什么？

1853
01:20:19,780 --> 01:20:21,550
Because if we have eight people here and we
因为如果我们这里有八个人，然后我们

1854
01:20:21,550 --> 01:20:23,440
started with whoever's all the way over here,
从最右边的人开始，

1855
01:20:23,440 --> 01:20:27,890
we compare this person against seven others-- n minus 1 if n is 8.
我们会将这个人与另外七个人比较——如果 n 等于 8，那么就是 n 减 1。

1856
01:20:27,890 --> 01:20:32,000
So the first pass through the list, I made n minus 1 comparisons.
所以在第一次遍历列表时，我进行了 n 减 1 次比较。

1857
01:20:32,000 --> 01:20:34,950
But that put the smallest number 0 in place.
但这把最小的数字 0 放到了正确的位置。

1858
01:20:34,950 --> 01:20:37,547
The second time I walked across our eight volunteers,
第二次遍历八位志愿者时，

1859
01:20:37,547 --> 01:20:39,380
I didn't need to walk in front of all eight.
我不需要在所有八个人面前走。

1860
01:20:39,380 --> 01:20:41,630
I could shave off a little bit and do seven of them,
我可以少走一些，只走七个人，

1861
01:20:41,630 --> 01:20:43,460
then six, then five, then four.
然后六个，然后五个，然后四个。

1862
01:20:43,460 --> 01:20:45,710
So if I were to write this out roughly mathematically,
所以如果我要用数学语言来表达这个过程，

1863
01:20:45,710 --> 01:20:50,630
I could do this-- n minus 1 plus n minus 2 plus n minus 3 plus
我可以这样做——n 减 1 加 n 减 2 加 n 减 3 加

1864
01:20:50,630 --> 01:20:54,020
dot, dot, dot, all the way down to my very last comparison
以此类推，一直到最后一个比较

1865
01:20:54,020 --> 01:20:55,260
at the end of the list.
在列表的末尾。

1866
01:20:55,260 --> 01:20:57,320
Now, this is the kind of thing that typically in high school
现在，这是一种你在高中

1867
01:20:57,320 --> 01:20:59,612
you'd look at the back of the math book or physics book
会翻到数学书或物理书后面的

1868
01:20:59,612 --> 01:21:02,960
that's got a little cheat sheet for all of the formulas that add up.
公式小抄来查找这些加起来的公式。

1869
01:21:02,960 --> 01:21:07,160
This series here, let me just stipulate, adds up to this-- n times
这个系列，我在这里声明一下，加起来等于这个——n 乘以

1870
01:21:07,160 --> 01:21:09,260
n minus 1 divided by 2.
n 减 1 除以 2。

1871
01:21:09,260 --> 01:21:12,770
So no matter what n is, this formula captures that series,
所以无论 n 是多少，这个公式都能够表达这个系列，

1872
01:21:12,770 --> 01:21:14,760
that summation of all of those values.
所有这些值的总和。

1873
01:21:14,760 --> 01:21:18,830
So that is how many steps I took again and again
所以这就是我在实现选择排序时，对八个人进行的比较的次数。

1874
01:21:18,830 --> 01:21:22,070
and again when implementing selection sort for eight people.
一次又一次，反复进行的操作。

1875
01:21:22,070 --> 01:21:24,000
So of course, let's multiply this out.
当然，让我们把它展开。

1876
01:21:24,000 --> 01:21:27,013
So this is like n squared minus n all divided by 2.
所以它就像 n 平方减 n，再除以 2。

1877
01:21:27,013 --> 01:21:28,430
Let's do it out a little bit more.
让我们再算一下。

1878
01:21:28,430 --> 01:21:31,610
That's n squared divided by 2 minus n over 2.
那就是 n 平方除以 2，减去 n 除以 2。

1879
01:21:31,610 --> 01:21:34,913
And now we're back into the territory of running times.
现在我们又回到了运行时间这个话题。

1880
01:21:34,913 --> 01:21:36,830
Like, how many steps does this algorithm take?
比如，这个算法需要多少步？

1881
01:21:36,830 --> 01:21:39,080
How many comparisons are we making?
我们在进行多少次比较？

1882
01:21:39,080 --> 01:21:42,950
Now, n squared seems like the biggest term.
现在，n 平方看起来是最大的项。

1883
01:21:42,950 --> 01:21:44,250
It's the dominant term.
它是主导项。

1884
01:21:44,250 --> 01:21:48,110
In other words, as n gets large-- not eight but 80 or 800
也就是说，当 n 越来越大——不是 8，而是 80 或者 800

1885
01:21:48,110 --> 01:21:53,000
or 8,000 or 8 million-- squaring that is going to make a way bigger difference
或者 8000 或者 800 万——把这个数平方会产生一个更大的差异

1886
01:21:53,000 --> 01:21:55,880
than just doing, like, n divided by 2 and subtracting that off.
比仅仅将 n 除以 2 然后减去它要大得多。

1887
01:21:55,880 --> 01:21:59,300
Similarly, just dividing even this quadratic formula by 2,
同样，即使是将这个二次方程除以 2，

1888
01:21:59,300 --> 01:22:01,460
like, yes, it's going to halve it literally.
确实，它会将其减半。

1889
01:22:01,460 --> 01:22:03,410
But that's kind of a drop in the bucket.
但这只是一小部分。

1890
01:22:03,410 --> 01:22:05,930
As n gets larger and larger and larger, it's
随着 n 越来越大，它

1891
01:22:05,930 --> 01:22:07,650
still going to be a crazy big number.
仍然是一个非常大的数字。

1892
01:22:07,650 --> 01:22:11,000
So computer scientists would typically wrap this in some big O notation
所以计算机科学家通常会用大 O 表示法来表示这个公式

1893
01:22:11,000 --> 01:22:16,070
and say, OK, OK, selection sort is on the order of n squared.
然后说，好的，好的，选择排序的时间复杂度是 n 平方。

1894
01:22:16,070 --> 01:22:17,502
That's not a precise measurement.
这不是一个精确的测量。

1895
01:22:17,502 --> 01:22:19,460
But it's on the order of n squared because it's
但它是 n 平方级别的，因为它是

1896
01:22:19,460 --> 01:22:23,480
making so many darn comparisons, not unlike everyone shaking everyone else's
进行了非常多的比较，就像我之前说的，每个人都互相握手一样。

1897
01:22:23,480 --> 01:22:25,470
hand like I proposed verbally earlier.
这需要很多工作才能完成。

1898
01:22:25,470 --> 01:22:27,300
It's a lot of work to get that done.
选择排序的步骤数是 n 平方级别。

1899
01:22:27,300 --> 01:22:30,170
So selection sort is on the order of n squared steps.
所以选择排序的步骤数是 n 平方级别。

1900
01:22:30,170 --> 01:22:31,967
And that's kind of a slow one.
这是一种比较慢的排序方式。

1901
01:22:31,967 --> 01:22:33,800
That's what was at the top of my cheat sheet
这是我在我作弊小抄的顶部写的东西

1902
01:22:33,800 --> 01:22:37,232
earlier when I proposed a ranking of some common running times.
之前我建议对一些常见运行时间进行排名时。

1903
01:22:37,232 --> 01:22:38,690
There's an infinite number of them.
它们的数量是无限的。

1904
01:22:38,690 --> 01:22:40,380
But those are some of the common ones.
但那些是比较常见的。

1905
01:22:40,380 --> 01:22:42,920
So can we do actually better?
所以我们实际上可以做得更好吗？

1906
01:22:42,920 --> 01:22:47,330
Well, if bubble sort then is in big O--
好吧，如果冒泡排序是在大O中-

1907
01:22:47,330 --> 01:22:47,840
sorry.
抱歉。

1908
01:22:47,840 --> 01:22:49,010
Sorry-- spoiler.
抱歉 - 剧透了。

1909
01:22:49,010 --> 01:22:52,610
If selection sort is in the order of n squared,
如果选择排序是n平方级的，

1910
01:22:52,610 --> 01:22:55,420
could we maybe get lucky sometimes?
我们可能有时候会幸运吗？

1911
01:22:55,420 --> 01:22:58,285
Like, with selection sort, what would the best case scenario be?
比如，对于选择排序，最佳情况是什么？

1912
01:22:58,285 --> 01:23:00,910
Well, the best case would be, like, everyone is already sorted,
好吧，最佳情况是，比如，所有元素都已经排序，

1913
01:23:00,910 --> 01:23:02,020
0 through 7.
从0到7。

1914
01:23:02,020 --> 01:23:03,250
And we just get lucky.
而我们只是幸运。

1915
01:23:03,250 --> 01:23:05,820
But does bubble sort--
但冒泡排序-

1916
01:23:05,820 --> 01:23:10,580
[SIGHS]---- does selection sort appreciate that?
[叹气]---- 选择排序会对此感到高兴吗？

1917
01:23:10,580 --> 01:23:14,590
Does selection sort take into account whether the list is already sorted?
选择排序会考虑列表是否已经排序吗？

1918
01:23:14,590 --> 01:23:18,280
Not necessarily, because if you look at the pseudocode even,
不一定，因为即使你查看伪代码，

1919
01:23:18,280 --> 01:23:22,480
there's no special conditional in here that says, if it's already sorted,
这里没有特殊的条件语句说，如果它已经排序，

1920
01:23:22,480 --> 01:23:23,620
exit early.
就提前退出。

1921
01:23:23,620 --> 01:23:27,010
It's just going to blindly do this this many times.
它只是会盲目地做这些事情这么多次。

1922
01:23:27,010 --> 01:23:30,380
And you can actually see pseudocode-wise the n squared.
你实际上可以在伪代码中看到n平方。

1923
01:23:30,380 --> 01:23:33,850
Notice that this line of pseudocode here is essentially telling me to do what?
注意，这里这行伪代码本质上是在告诉我做什么？

1924
01:23:33,850 --> 01:23:37,450
Do something n times from 0 to n minus 1,
从0到n减1，做n次事情，

1925
01:23:37,450 --> 01:23:40,720
or equivalently, if you prefer the real world, from 1 to n.
或者等效地，如果你更喜欢现实世界，从1到n。

1926
01:23:40,720 --> 01:23:42,710
That's n times total.
总共n次。

1927
01:23:42,710 --> 01:23:44,797
But what are you doing inside of this loop?
但在这个循环中，你在做什么？

1928
01:23:44,797 --> 01:23:46,630
Well, every time you're inside of this loop,
好吧，每次你在这个循环中，

1929
01:23:46,630 --> 01:23:49,720
you're looking for the smallest element, looking for the smallest element.
你都在寻找最小的元素，寻找最小的元素。

1930
01:23:49,720 --> 01:23:51,790
And that might take you as many as n steps.
这可能需要你最多n步。

1931
01:23:51,790 --> 01:23:55,000
So another way to think about the running time of this algorithm
所以，另一种思考这个算法运行时间的思路是

1932
01:23:55,000 --> 01:23:58,540
selection sort is this loop is telling you to do something n times.
选择排序，这个循环在告诉你做n次事情。

1933
01:23:58,540 --> 01:24:02,230
This line is telling you to do something n times as well.
这行代码也告诉你做n次事情。

1934
01:24:02,230 --> 01:24:04,630
And that's roughly n times n or n squared.
所以，大约是n乘以n，也就是n平方。

1935
01:24:04,630 --> 01:24:05,630
It's not precise.
它并不精确。

1936
01:24:05,630 --> 01:24:07,390
But it's on the order of n squared.
但它是n平方级的。

1937
01:24:07,390 --> 01:24:11,090
Unfortunately, if you're just blindly doing that much work always,
不幸的是，如果你总是盲目地做那么多工作，

1938
01:24:11,090 --> 01:24:14,240
even if you have any number of doors, this
即使你有任意数量的门，这

1939
01:24:14,240 --> 01:24:19,800
is going to end up being in omega of n squared as well,
最终也会是n平方级的omega，

1940
01:24:19,800 --> 01:24:23,130
because even in the best case where all of the numbers are already sorted,
因为即使在所有数字都已经排序的最佳情况下，

1941
01:24:23,130 --> 01:24:26,580
there is nothing about the algorithm called selection sort or even
关于叫做选择排序的算法，或者甚至

1942
01:24:26,580 --> 01:24:29,850
my implementation thereof that would have said, wait a minute-- like, I'm
我的实现，它会说，等等 - 我好像

1943
01:24:29,850 --> 01:24:31,980
done, and exit prematurely.
完成了，并且提前退出。

1944
01:24:31,980 --> 01:24:35,760
So selection sort is in big O of and omega
所以选择排序是在大O和omega中

1945
01:24:35,760 --> 01:24:39,420
of n squared as we've designed it.
是n平方级的，就像我们设计的那样。

1946
01:24:39,420 --> 01:24:42,988
And by coincidence, because those boundaries are the same,
而且巧合的是，因为这些边界是相同的，

1947
01:24:42,988 --> 01:24:45,030
you can also say that it's in theta of n squared.
你也可以说它是在n平方的theta中。

1948
01:24:45,030 --> 01:24:49,170
No matter what, you're going to spend n squared steps or n squared comparisons.
无论如何，你都将花费n平方步或n平方比较。

1949
01:24:49,170 --> 01:24:53,100
But that second algorithm that I keep teasing called bubble sort,
但是我一直在戏弄的第二个算法叫做冒泡排序，

1950
01:24:53,100 --> 01:24:55,808
and I deliberately used the word bubble in my description of what
我故意在描述中使用“冒泡”这个词

1951
01:24:55,808 --> 01:24:58,433
was happening because Eli, I think was our first volunteer, who
正在发生的事情，因为我认为埃利是我们第一个志愿者，他

1952
01:24:58,433 --> 01:25:01,140
kind of bubbled his way up all the way to the end of the list.
一路冒泡到列表的末尾。

1953
01:25:01,140 --> 01:25:05,302
Then number 6 did, then 5, then 4, then 3, then 2, then 1.
然后数字 6 冒泡了，然后是 5，然后是 4，然后是 3，然后是 2，然后是 1。

1954
01:25:05,302 --> 01:25:07,260
All of the numbers kind of bubbled their way up
所有数字都像冒泡一样向上移动

1955
01:25:07,260 --> 01:25:09,000
being the bigger values to the right.
成为更大的值在右侧。

1956
01:25:09,000 --> 01:25:11,790
So bubble sort just does something again and again
所以冒泡排序只是反复做一件事

1957
01:25:11,790 --> 01:25:15,060
by comparing adjacencies, comparing, comparing, comparing.
通过比较相邻元素，比较、比较、比较。

1958
01:25:15,060 --> 01:25:17,810
And then it does it again and again and again.
然后它反复做。

1959
01:25:17,810 --> 01:25:19,180
So let's analyze bubble sort.
所以让我们来分析冒泡排序。

1960
01:25:19,180 --> 01:25:22,750
If, for instance, this was the original array that we tried sorting before--
例如，这是我们之前尝试排序的原始数组--

1961
01:25:22,750 --> 01:25:24,100
same exact numbers--
完全相同的数字--

1962
01:25:24,100 --> 01:25:28,330
I was doing things like flipping the 7 and the 2, and then the 7 and the 5,
我做的事情就像交换 7 和 2，然后交换 7 和 5，

1963
01:25:28,330 --> 01:25:29,770
and then the 7 and the 4.
然后交换 7 和 4。

1964
01:25:29,770 --> 01:25:34,360
But that would only fix minimally one number.
但这只能最小程度地修复一个数字。

1965
01:25:34,360 --> 01:25:37,120
I then had to repeat again and again and again.
然后我不得不反复重复。

1966
01:25:37,120 --> 01:25:39,290
So that one too felt like it was taking some time.
所以那个也感觉很耗时。

1967
01:25:39,290 --> 01:25:41,560
So here's one way of thinking about bubble sort.
所以这里有一种思考冒泡排序的方法。

1968
01:25:41,560 --> 01:25:43,660
Bubble sort pseudocode could say this.
冒泡排序伪代码可以这样说。

1969
01:25:43,660 --> 01:25:45,790
Repeat the following n times.
重复以下操作 n 次。

1970
01:25:45,790 --> 01:25:48,700
And that's why I kept going through the list again and again--
这就是为什么我一直反复遍历列表--

1971
01:25:48,700 --> 01:25:53,473
for i from 0 to n minus 2.
从 i=0 到 n-2。

1972
01:25:53,473 --> 01:25:56,140
Now, this is a little weird, but we'll get back to this-- from i
现在，这有点奇怪，但我们会回头讨论这个-- 从 i

1973
01:25:56,140 --> 01:25:57,820
from 0 to n minus 2.
从 0 到 n-2。

1974
01:25:57,820 --> 01:26:02,380
If the number at location i and the number at location i plus 1
如果位置 i 处的数字和位置 i+1 处的数字

1975
01:26:02,380 --> 01:26:05,140
are out of order, swap them.
乱序，则交换它们。

1976
01:26:05,140 --> 01:26:08,140
And then just repeat, repeat, repeat.
然后重复、重复、重复。

1977
01:26:08,140 --> 01:26:11,470
But we've never seen n minus 2 in pseudocode before.
但我们以前从未在伪代码中见过 n-2。

1978
01:26:11,470 --> 01:26:14,830
Why is it n minus 2 and not the usual n minus 1?
为什么是 n-2 而不是通常的 n-1？

1979
01:26:14,830 --> 01:26:16,086
Yeah?
是的？

1980
01:26:16,086 --> 01:26:20,370
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1981
01:26:20,370 --> 01:26:22,770
DAVID MALAN: Exactly, because we're taking a number
大卫·马兰：没错，因为我们正在取一个数字

1982
01:26:22,770 --> 01:26:24,250
and comparing it to the next one.
并将其与下一个数字进行比较。

1983
01:26:24,250 --> 01:26:26,370
So you better not go all the way to the end
所以你最好不要一直走到最后

1984
01:26:26,370 --> 01:26:29,245
and expect there to be a next one at the end of the list.
并期望在列表的末尾有一个下一个数字。

1985
01:26:29,245 --> 01:26:31,620
So if we use these same numbers here, even though they're
所以如果我们在这里使用相同的数字，即使它们

1986
01:26:31,620 --> 01:26:34,350
in a different order, if this is location 0,
顺序不同，如果这是位置 0，

1987
01:26:34,350 --> 01:26:38,280
and this is location n minus 1 always, if you think
并且这是位置 n-1，如果你认为

1988
01:26:38,280 --> 01:26:42,480
of i as being my left hand, it's pointing from 0 to 1 to 2 to 3
i 是我的左手，它从 0 指向 1 指向 2 指向 3

1989
01:26:42,480 --> 01:26:44,910
to 4 to 5 to 6 to 7.
指向 4 指向 5 指向 6 指向 7。

1990
01:26:44,910 --> 01:26:47,430
If you get to the end, you don't want to look at i plus 1
如果你到了最后，你不想去看 i+1

1991
01:26:47,430 --> 01:26:49,555
because that's pointing to no man's land over here.
因为那指向了这里无人区。

1992
01:26:49,555 --> 01:26:51,960
And you can't go beyond the boundaries of your array.
而且你不能超出你的数组边界。

1993
01:26:51,960 --> 01:26:55,012
But n minus 2 would be the second to last element, as you know.
但是 n-2 将是倒数第二个元素，如你所知。

1994
01:26:55,012 --> 01:26:56,970
And that makes sure that my left hand and right
这样就可以确保我的左手和右手

1995
01:26:56,970 --> 01:26:59,070
hand stay within the boundaries of the array
手保持在数组边界内

1996
01:26:59,070 --> 01:27:02,777
if left hand represents i and right hand represents i plus 1.
如果左手代表 i，右手代表 i+1。

1997
01:27:02,777 --> 01:27:04,860
So it's just to make sure we don't screw up and go
所以只是为了确保我们不会搞砸并进入

1998
01:27:04,860 --> 01:27:06,930
too far past the boundary of the array.
超出数组范围太远。

1999
01:27:06,930 --> 01:27:10,920
But as implemented here, this too does not take into account whether or not
但正如这里实现的，这也忽略了数组是否

2000
01:27:10,920 --> 01:27:13,620
the array is already sorted.
已经排序。

2001
01:27:13,620 --> 01:27:16,087
So technically, we can actually do this n minus 1 times
因此从技术上讲，我们可以实际进行 n 减 1 次

2002
01:27:16,087 --> 01:27:17,670
because the last one you get for free.
因为最后一个是免费的。

2003
01:27:17,670 --> 01:27:19,020
It ends up being in place.
它最终会到位。

2004
01:27:19,020 --> 01:27:22,060
But even still, let's do a quick analysis here.
但即使如此，让我们在这里快速分析一下。

2005
01:27:22,060 --> 01:27:27,100
If we've got n doors in total from 0 on up to n minus 1,
如果我们总共有 n 个门，从 0 到 n 减 1，

2006
01:27:27,100 --> 01:27:30,520
bubble sort's analysis looks a little bit like this.
冒泡排序的分析看起来有点像这样。

2007
01:27:30,520 --> 01:27:35,228
Do the following-- n minus 1 times n minus 1 times.
执行以下操作——n 减 1 次乘以 n 减 1 次。

2008
01:27:35,228 --> 01:27:36,520
Well, how did we get from that?
好吧，我们是怎么从那里得到的？

2009
01:27:36,520 --> 01:27:38,020
Let me back up to the pseudocode.
让我回到伪代码。

2010
01:27:38,020 --> 01:27:40,750
If this is the pseudocode as I originally put it,
如果这是我最初写的伪代码，

2011
01:27:40,750 --> 01:27:42,580
I then propose verbally a refinement.
然后我口头上提出一个改进。

2012
01:27:42,580 --> 01:27:45,580
You don't need to repeat yourself n times again and again because again,
你不需要一遍又一遍地重复自己 n 次，因为再一次，

2013
01:27:45,580 --> 01:27:46,915
the last one bubbles up.
最后一个冒上来。

2014
01:27:46,915 --> 01:27:49,660
But by process of elimination, it's in the right place.
但通过排除法，它在正确的位置。

2015
01:27:49,660 --> 01:27:52,390
So you can think of it as just n minus 1 times.
所以你可以把它想象成只是 n 减 1 次。

2016
01:27:52,390 --> 01:27:57,910
How many times can you compare i and i plus 1?
你可以比较 i 和 i 加 1 多少次？

2017
01:27:57,910 --> 01:28:01,270
Well, you're iterating from 0 to n minus 2.
好吧，你正在从 0 到 n 减 2 迭代。

2018
01:28:01,270 --> 01:28:03,370
And this is where the math is going to get weird.
而这正是数学变得奇怪的地方。

2019
01:28:03,370 --> 01:28:06,500
But that is n minus 1 steps also.
但那也是 n 减 1 步。

2020
01:28:06,500 --> 01:28:07,000
Why?
为什么？

2021
01:28:07,000 --> 01:28:09,940
Because if you do it in the real world starting at one,
因为如果你在现实世界中从一开始做，

2022
01:28:09,940 --> 01:28:13,300
this is saying from i from 1 to n minus 1.
也就是说从 i 从 1 到 n 减 1。

2023
01:28:13,300 --> 01:28:15,460
And then maybe it pops a little more obviously.
然后它可能更明显地弹出。

2024
01:28:15,460 --> 01:28:18,400
This inner loop is repeating n minus 1 times.
这个内循环重复了 n 减 1 次。

2025
01:28:18,400 --> 01:28:20,830
So outer loop says do the following n minus 1 times.
所以外循环表示执行以下操作 n 减 1 次。

2026
01:28:20,830 --> 01:28:23,620
Inner loop says do this now n minus 1 times.
内循环表示现在执行此操作 n 减 1 次。

2027
01:28:23,620 --> 01:28:27,010
Mathematically, then, that's n minus 1 times n minus 1.
因此，从数学上讲，那是 n 减 1 乘以 n 减 1。

2028
01:28:27,010 --> 01:28:28,550
Now we've got our old FOIL method.
现在我们有了我们的旧 FOIL 方法。

2029
01:28:28,550 --> 01:28:31,780
So n squared minus n minus n plus 1.
所以 n 平方减 n 减 n 加 1。

2030
01:28:31,780 --> 01:28:35,440
Combine like terms gives us n squared minus 2n plus 1.
合并同类项，我们得到 n 平方减 2n 加 1。

2031
01:28:35,440 --> 01:28:37,600
But now let's think like a computer scientist.
但现在让我们像计算机科学家一样思考。

2032
01:28:37,600 --> 01:28:41,710
When n gets really large, we definitely don't care about the plus 1.
当 n 变得非常大时，我们绝对不在乎加 1。

2033
01:28:41,710 --> 01:28:45,640
When n gets really large, we probably don't even care about the minus 2n.
当 n 变得非常大时，我们可能甚至不在乎减 2n。

2034
01:28:45,640 --> 01:28:48,580
It will make a mathematical difference but a drop in the bucket
当 n 达到数百万或数十亿时，它会产生数学上的差异，但只是一滴水

2035
01:28:48,580 --> 01:28:50,860
once n gets to be in the millions or billions.
。

2036
01:28:50,860 --> 01:28:54,770
So this would be on the order of what, similarly?
那么这将类似于什么数量级？

2037
01:28:54,770 --> 01:28:56,730
On the order of n squared as well.
也是 n 平方数量级。

2038
01:28:56,730 --> 01:28:59,840
So algorithmically, and actually, we'll use a different term
所以从算法上来说，实际上，我们将使用一个不同的术语

2039
01:28:59,840 --> 01:29:03,770
now-- asymptotically-- asymptotic notation is the fancy term
现在——渐近地——渐近表示法是描述大 O、Ω 和 Θ 表示法的专业术语

2040
01:29:03,770 --> 01:29:08,960
to describe big O and omega and theta notation-- asymptotically bubble
——渐近地，冒泡

2041
01:29:08,960 --> 01:29:12,530
sort is, quote, unquote, "the same" as selection sort
排序，打个引号，“相同”于选择排序

2042
01:29:12,530 --> 01:29:13,760
in terms of its upper bound.
就其上界而言。

2043
01:29:13,760 --> 01:29:15,812
It's not 100% exactly the same.
它并不完全相同。

2044
01:29:15,812 --> 01:29:19,020
If we get into the weeds of the math, there are obviously different formulas.
如果我们深入数学的细节，显然会有不同的公式。

2045
01:29:19,020 --> 01:29:22,462
But when n gets really large and you plot the pictures on a chart,
但当 n 变得非常大，并且你在图表上绘制这些图片时，

2046
01:29:22,462 --> 01:29:24,920
they're going to look almost the same because they're going
它们看起来几乎是一样的，因为它们正在

2047
01:29:24,920 --> 01:29:27,060
to be fundamentally the same shape.
本质上是相同的形状。

2048
01:29:27,060 --> 01:29:33,380
So in our cheat sheet here, bubble sort now is in big O of n squared.
因此，在我们这里的速查表中，冒泡排序现在是 n 平方的 O(n^2)。

2049
01:29:33,380 --> 01:29:36,600
But let me propose that we make an improvement.
但我建议我们改进一下。

2050
01:29:36,600 --> 01:29:38,720
Here's our pseudocode earlier.
这是我们之前的伪代码。

2051
01:29:38,720 --> 01:29:43,430
When might it make sense to abort bubble sort early?
什么时候提前中止冒泡排序是有意义的？

2052
01:29:43,430 --> 01:29:47,780
Like, when could you logically conclude that I do not need
比如，什么时候你可以逻辑地得出结论，我不需要

2053
01:29:47,780 --> 01:29:51,975
to make another pass again and again?
一遍又一遍地进行另一个循环？

2054
01:29:51,975 --> 01:29:54,600
And remember what I did from left to right over our volunteers.
还记得我从左到右对志愿者做了什么吗？

2055
01:29:54,600 --> 01:29:57,510
I was comparing, comparing, comparing, comparing and maybe swapping
我一直在比较、比较、比较、比较，也许还在交换

2056
01:29:57,510 --> 01:29:59,200
people who were out of order.
顺序不对的人。

2057
01:29:59,200 --> 01:30:03,980
So what could I do to short circuit this?
所以，我能做些什么来简化这个过程呢？

2058
01:30:03,980 --> 01:30:04,855
AUDIENCE: [INAUDIBLE]
观众： [听不见]

2059
01:30:04,855 --> 01:30:05,950
DAVID MALAN: Perfect.
大卫·马兰： 太棒了。

2060
01:30:05,950 --> 01:30:10,060
If I compare through the whole list left to right and I make no swaps,
如果我从左到右比较整个列表，并且没有交换，

2061
01:30:10,060 --> 01:30:12,808
it stands to reason that they're already ordered.
那么很有道理，它们已经是有序的了。

2062
01:30:12,808 --> 01:30:14,350
Otherwise, I would have swapped them.
否则，我会交换它们。

2063
01:30:14,350 --> 01:30:17,923
And therefore, I would be crazy to do that again and again and again.
因此，我一遍又一遍地这样做简直是疯了。

2064
01:30:17,923 --> 01:30:20,090
Because if I didn't swap them the first time around,
因为如果我第一次没有交换它们，

2065
01:30:20,090 --> 01:30:22,757
why would I swap them the second time around if no one's moving.
如果没有人移动，为什么我要在第二次交换它们呢？

2066
01:30:22,757 --> 01:30:25,280
So I can terminate the algorithm early.
所以我可以提前终止算法。

2067
01:30:25,280 --> 01:30:27,550
So in pseudocode, I could say something like this.
因此，在伪代码中，我可以这样说。

2068
01:30:27,550 --> 01:30:29,920
If no swaps, quit.
如果没有任何交换，退出。

2069
01:30:29,920 --> 01:30:31,940
And I can do that inside of the inner loop.
我可以在内循环中做到这一点。

2070
01:30:31,940 --> 01:30:35,560
So once I make a pass through the people and I say, hm, did I make any swaps?
所以，一旦我遍历了这些人，然后我说，嗯，我做了任何交换吗？

2071
01:30:35,560 --> 01:30:38,320
If no, just quit because they're not going
如果没有，那就退出，因为它们不会

2072
01:30:38,320 --> 01:30:41,260
to move any further if they didn't just move already.
如果它们没有移动，就不会再移动了。

2073
01:30:41,260 --> 01:30:45,040
So bubble sort then might arguably be an omega of what?
那么，冒泡排序可以说是一个什么级别的 omega 呢？

2074
01:30:45,040 --> 01:30:51,130
In the best case, how few steps could we get away with with bubble sort?
在最好的情况下，我们使用冒泡排序可以减少到多少步？

2075
01:30:51,130 --> 01:30:52,330
OK, it's not one.
好的，不是一步。

2076
01:30:52,330 --> 01:30:53,490
But it is n.
但它是 n。

2077
01:30:53,490 --> 01:30:54,160
Why?
为什么？

2078
01:30:54,160 --> 01:30:56,980
Because I minimally need to go through the whole list to decide,
因为我至少需要遍历整个列表才能决定，

2079
01:30:56,980 --> 01:30:58,240
did I make any swaps.
我是否做了任何交换。

2080
01:30:58,240 --> 01:31:03,010
And logically-- and this will come up a lot in the analysis of algorithms--
从逻辑上讲 - 这在算法分析中经常出现 -

2081
01:31:03,010 --> 01:31:07,780
any question like, is this list sorted, cannot possibly take only one step
像这样的问题，这个列表是否已排序，不可能只用一步

2082
01:31:07,780 --> 01:31:09,040
if you've got n elements.
如果你有 n 个元素。

2083
01:31:09,040 --> 01:31:09,310
Why?
为什么？

2084
01:31:09,310 --> 01:31:10,727
Because then you're just guessing.
因为这样你就只是在猜测。

2085
01:31:10,727 --> 01:31:14,560
Like, if you don't at least take the time to look at every element,
就像，如果你至少没有花时间看一下每个元素，

2086
01:31:14,560 --> 01:31:17,710
how in the world can you conclude logically that they're sorted or not?
你怎么能逻辑地得出结论，它们是否已排序呢？

2087
01:31:17,710 --> 01:31:21,290
Like, you minimally have to meet us halfway and check every element.
就像，你至少必须满足我们一半的要求，并检查每个元素。

2088
01:31:21,290 --> 01:31:24,338
So it's minimally in omega of n.
所以它至少是 n 级别的 omega。

2089
01:31:24,338 --> 01:31:27,130
Constant time wouldn't even give you time to look at the whole list
如果存在 n 个元素，常数时间甚至不会给你时间查看整个列表。

2090
01:31:27,130 --> 01:31:28,190
if there's n elements.
如果存在 n 个元素。

2091
01:31:28,190 --> 01:31:29,500
So that's the intuition there.
所以这就是直觉。

2092
01:31:29,500 --> 01:31:32,042
So we can't say anything about theta notation for bubble sort
所以我们无法对冒泡排序的 theta 符号做任何判断。

2093
01:31:32,042 --> 01:31:34,000
because it's different, upper and lower bounds.
因为它们不同，有上限和下限。

2094
01:31:34,000 --> 01:31:39,850
But we seem to have done better asymptotically than selection sort.
但我们似乎在渐进方面比选择排序做得更好。

2095
01:31:39,850 --> 01:31:41,530
In the worst case, they're just as bad.
在最坏的情况下，它们一样糟糕。

2096
01:31:41,530 --> 01:31:42,530
They're super slow.
它们超级慢。

2097
01:31:42,530 --> 01:31:45,310
But in the best case, bubble sort with that tweak--
但在最好的情况下，带有那个调整的冒泡排序--

2098
01:31:45,310 --> 01:31:48,550
that conditional about swapping-- might actually be faster for us.
关于交换的条件判断--可能实际上对我们来说更快。

2099
01:31:48,550 --> 01:31:52,940
And you'd want Google, Microsoft, your phone, to use that kind of algorithm.
你会希望 Google、微软、你的手机，使用这种算法。

2100
01:31:52,940 --> 01:31:55,280
Let me go back to the sorting demonstration earlier.
让我回到之前排序演示。

2101
01:31:55,280 --> 01:31:57,380
Let me re-randomize the array.
让我重新随机化数组。

2102
01:31:57,380 --> 01:31:58,820
Small bars is small number.
小条代表小数字。

2103
01:31:58,820 --> 01:31:59,990
Big bars is big number.
大条代表大数字。

2104
01:31:59,990 --> 01:32:02,030
And let me click bubble sort this time.
这次让我点击冒泡排序。

2105
01:32:02,030 --> 01:32:04,970
And you'll see again, the pink represents comparisons.
你会再次看到，粉色代表比较。

2106
01:32:04,970 --> 01:32:08,400
But now the comparisons are always adjacent from left to right.
但现在比较始终是相邻的，从左到右。

2107
01:32:08,400 --> 01:32:12,360
So this is pretty much doing with more bars what I did with eight people here.
所以这基本上就是用更多条，做我在八个人身上做的事情。

2108
01:32:12,360 --> 01:32:15,950
And you'll see that the biggest elements, Eli
你会看到最大的元素，Eli

2109
01:32:15,950 --> 01:32:18,260
being the first one of the humans, bubbled up
作为第一个，冒泡到最右边

2110
01:32:18,260 --> 01:32:21,470
all the way to the right, followed by the next largest, next largest,
最右边，然后是下一个最大的，再下一个最大的，

2111
01:32:21,470 --> 01:32:22,490
next largest.
下一个最大的。

2112
01:32:22,490 --> 01:32:25,700
But here again you can visually see.
但在这里，你又能直观地看到。

2113
01:32:25,700 --> 01:32:28,490
And with the number of words I'm using to kind of stall here,
我用这么多词来拖延时间，

2114
01:32:28,490 --> 01:32:31,100
you can [? hear ?] that this is kind of slow
你能感觉到这很慢

2115
01:32:31,100 --> 01:32:34,618
because you're doing a lot of comparisons again and again and again.
因为你在不断地进行比较。

2116
01:32:34,618 --> 01:32:35,910
And you're making improvements.
而且你在不断改进。

2117
01:32:35,910 --> 01:32:37,618
So you're taking bites out of the problem
所以你一步步解决问题

2118
01:32:37,618 --> 01:32:40,897
but really only one bite at a time.
但一次只解决一小部分。

2119
01:32:40,897 --> 01:32:43,480
So I kind of feel this is going to be like holding in a sneeze
所以我觉得这就像憋着打喷嚏一样

2120
01:32:43,480 --> 01:32:44,560
if we don't finish this.
如果我们不完成它。

2121
01:32:44,560 --> 01:32:47,410
So I feel like we should give you emotional closure
所以我觉得我们应该给你一个情绪上的结束

2122
01:32:47,410 --> 01:32:49,930
with getting this to finish.
让它完成。

2123
01:32:49,930 --> 01:32:53,020
Any questions in the meantime because there's going to be no surprise.
在此期间有任何问题吗，因为不会有惊喜。

2124
01:32:53,020 --> 01:32:54,830
It's going to be sorted.
它将被排序。

2125
01:32:54,830 --> 01:32:57,580
This is bubble sort.
这就是冒泡排序。

2126
01:32:57,580 --> 01:32:58,570
No?
没有？

2127
01:32:58,570 --> 01:33:00,040
All right, we're almost there.
好了，我们快到了。

2128
01:33:00,040 --> 01:33:02,800
It's going faster because the list is effectively getting shorter.
它越来越快，因为列表实际上越来越短了。

2129
01:33:02,800 --> 01:33:08,350
And-- oh, OK, so that then was bubble sort.
然后，这就是冒泡排序。

2130
01:33:08,350 --> 01:33:12,920
But both of these, I claim now, are actually pretty inefficient.
但我现在声称，这两种方法实际上效率很低。

2131
01:33:12,920 --> 01:33:13,780
They're pretty slow.
它们很慢。

2132
01:33:13,780 --> 01:33:16,330
And my god, that was only eight humans on the stage.
我的天，舞台上只有八个人。

2133
01:33:16,330 --> 01:33:19,540
That was only, like, what, 40 or 50 bars on the screen.
那只是，屏幕上大概只有 40 或 50 根条。

2134
01:33:19,540 --> 01:33:23,320
What if we start talking about hundreds or thousands or millions of inputs?
如果我们开始讨论数百、数千甚至数百万个输入呢？

2135
01:33:23,320 --> 01:33:25,690
Like, those algorithms are probably going to take crazy
这些算法可能需要疯狂的

2136
01:33:25,690 --> 01:33:28,220
long because n squared gets really big.
时间，因为 n 平方变得非常大。

2137
01:33:28,220 --> 01:33:30,440
So can we do better than n squared?
所以，我们可以做得比 n 平方更好吗？

2138
01:33:30,440 --> 01:33:31,330
Well, we can.
当然可以。

2139
01:33:31,330 --> 01:33:35,170
But let me propose that we introduce a new problem-solving technique
但我想提议我们引入一种新的解决问题的技巧

2140
01:33:35,170 --> 01:33:38,320
that we've actually been using already, just not by name.
我们实际上一直在使用它，只是没有用名字。

2141
01:33:38,320 --> 01:33:42,700
In programming and in mathematics, there's this idea of recursion.
在编程和数学中，有一个叫做递归的概念。

2142
01:33:42,700 --> 01:33:48,280
And recursion is a description for a function that calls itself.
递归是对一个函数调用自身的描述。

2143
01:33:48,280 --> 01:33:51,460
A function that calls itself is recursive.
一个调用自身的函数就是递归的。

2144
01:33:51,460 --> 01:33:52,895
So what do we mean by this?
我们所说的这指的是什么呢？

2145
01:33:52,895 --> 01:33:54,520
Well, we've actually seen this already.
事实上，我们已经看到过这种现象。

2146
01:33:54,520 --> 01:33:58,810
Here's the same pseudocode for binary search earlier.
这里就是之前二分查找的伪代码。

2147
01:33:58,810 --> 01:34:01,180
And binary search-- bi implying two-- went
而二分查找（bi 指的是两个）则会

2148
01:34:01,180 --> 01:34:05,070
either left or right or left or right, halving each time.
要么往左要么往右，要么往左要么往右，每次都将范围缩减一半。

2149
01:34:05,070 --> 01:34:06,950
So that was the division and conquering.
所以这就是分治法。

2150
01:34:06,950 --> 01:34:08,570
So this is the same pseudocode.
所以这就是同样的伪代码。

2151
01:34:08,570 --> 01:34:12,080
But notice that in my pseudocode earlier,
但是请注意，在我之前的伪代码中，

2152
01:34:12,080 --> 01:34:16,710
I literally used the keyword search inside of my definition of search.
我在 search 的定义中直接使用了 search 这个关键字。

2153
01:34:16,710 --> 01:34:19,550
So this is sort of one of those, like, circular definitions.
所以这有点像循环定义。

2154
01:34:19,550 --> 01:34:21,590
Like, if this is a search algorithm, how am I
就像，如果这是一个搜索算法，那我怎么

2155
01:34:21,590 --> 01:34:24,860
getting away with using the word search in the definition of search?
在 search 的定义中使用 search 这个词却没事？

2156
01:34:24,860 --> 01:34:27,110
It's kind of when you get reprimanded for using a word
这就像你因为用某个词

2157
01:34:27,110 --> 01:34:28,850
to define a vocabulary word.
来解释一个词汇而受到批评。

2158
01:34:28,850 --> 01:34:32,960
This is kind of like that because this algorithm is calling itself.
这和那有点像，因为这个算法正在调用自身。

2159
01:34:32,960 --> 01:34:35,700
This search function is calling itself.
这个 search 函数正在调用自身。

2160
01:34:35,700 --> 01:34:38,300
Now, normally, if you were to have a function call itself,
通常情况下，如果你让一个函数调用自身，

2161
01:34:38,300 --> 01:34:41,750
call itself, call itself, call itself, it would just do that infinitely.
调用自身，调用自身，调用自身，它会无限循环下去。

2162
01:34:41,750 --> 01:34:43,550
And presumably, it would go on forever.
可以想见，它会永远执行下去。

2163
01:34:43,550 --> 01:34:45,350
Or the program or computer would probably
或者程序或计算机可能会

2164
01:34:45,350 --> 01:34:48,517
crash because out of memory or something like that-- more on that next week.
崩溃，因为内存不足或者类似原因——下周我们将详细讲解。

2165
01:34:48,517 --> 01:34:50,780
But there's a key detail, a key characteristic
但有一个关键细节，一个关键特征

2166
01:34:50,780 --> 01:34:54,770
about this algorithm that makes sure that doing the same thing again
关于这个算法，它确保重复执行同一件事

2167
01:34:54,770 --> 01:34:56,690
and again is not crazy.
不会陷入死循环。

2168
01:34:56,690 --> 01:34:59,630
It's actually going to lead us to a solution.
实际上，它将引领我们找到解决方案。

2169
01:34:59,630 --> 01:35:02,720
Even though I'm using search here or search here,
尽管我在这里或这里使用了 search，

2170
01:35:02,720 --> 01:35:08,742
what's happening to the size of the problem for each of these lines?
每执行一行，问题规模发生了什么变化？

2171
01:35:08,742 --> 01:35:09,450
What's happening?
发生了什么？

2172
01:35:09,450 --> 01:35:10,290
Yeah?
是吗？

2173
01:35:10,290 --> 01:35:11,610
It's being cut in half.
它被缩减了一半。

2174
01:35:11,610 --> 01:35:15,420
So even though I'm doing the exact same thing algorithmically again and again,
所以即使我在算法上重复做着完全相同的事，

2175
01:35:15,420 --> 01:35:18,930
I'm doing it on a smaller, smaller, smaller input--
但我是在越来越小的输入上执行——

2176
01:35:18,930 --> 01:35:21,820
fewer, fewer, fewer doors-- fewer, fewer, fewer people.
越来越少的门——越来越少的人。

2177
01:35:21,820 --> 01:35:23,820
And so even though I'm doing it again and again,
所以尽管我不断重复执行，

2178
01:35:23,820 --> 01:35:26,760
so long as I have this so-called base case, as we'll call it,
只要我拥有这种所谓的基线情况，就像我们通常所说的，

2179
01:35:26,760 --> 01:35:29,700
that just makes sure if there's no doors-- you're done--
它确保当没有门时——你完成了——

2180
01:35:29,700 --> 01:35:34,710
I can break out of what would otherwise be an infinite loop of sorts.
我可以跳出本该是无限循环的状态。

2181
01:35:34,710 --> 01:35:37,525
All right, so those two lines we've already kind of seen.
好了，这两行我们已经看到过了。

2182
01:35:37,525 --> 01:35:39,150
And actually, we saw this in week zero.
事实上，我们在第一周就看到过它。

2183
01:35:39,150 --> 01:35:42,510
So this is the pseudocode for the phone book example from week zero.
所以这是第一周电话簿示例的伪代码。

2184
01:35:42,510 --> 01:35:45,300
And you might recall that we had these lines of code here.
你可能还记得我们这里有这些代码行。

2185
01:35:45,300 --> 01:35:48,420
And this is very procedural or iterative where I literally
这非常过程化或迭代化，因为我明确地

2186
01:35:48,420 --> 01:35:49,872
told you go back to line 3.
告诉你要回到第 3 行。

2187
01:35:49,872 --> 01:35:52,330
And we did that today when we took attendance, so to speak.
我们在今天点名时就做了这件事，可以这么说。

2188
01:35:52,330 --> 01:35:55,860
With that third algorithm, you went back to step 2 again and again.
在第三种算法中，你不断地回到步骤 2。

2189
01:35:55,860 --> 01:35:58,000
That's a very iterative loop-based approach.
这是一种非常迭代的基于循环的方法。

2190
01:35:58,000 --> 01:35:58,750
But you know what?
但你知道吗？

2191
01:35:58,750 --> 01:36:00,840
I could be a little more clever here too in week zero.
在第一周，我也可以在这里聪明一点。

2192
01:36:00,840 --> 01:36:03,210
We just didn't want to get too far ahead of ourselves.
我们只是不想过早地领先自己。

2193
01:36:03,210 --> 01:36:07,410
Let me actually change these highlighted lines to be more, succinctly,
让我实际更改这些突出显示的行，使其更简洁，

2194
01:36:07,410 --> 01:36:10,150
search left half book, search right half of book.
搜索左半本书，搜索右半本书。

2195
01:36:10,150 --> 01:36:11,620
I can now tighten the code up.
我现在可以压缩代码了。

2196
01:36:11,620 --> 01:36:13,270
So it's kind of a shorter algorithm.
所以这是一种更短的算法。

2197
01:36:13,270 --> 01:36:14,860
But it's the exact same idea.
但它完全相同。

2198
01:36:14,860 --> 01:36:20,570
But on week zero, I very methodically told you what I want you to do next.
但在第一周，我非常有条理地告诉了你接下来要做什么。

2199
01:36:20,570 --> 01:36:22,900
But here, I'm sort of recognizing that, wait a minute,
但在这里，我意识到，等等，

2200
01:36:22,900 --> 01:36:25,660
I just spent the past six lines telling you how to search.
我刚刚花了六行告诉你如何搜索。

2201
01:36:25,660 --> 01:36:27,220
So go do more of that.
所以继续做。

2202
01:36:27,220 --> 01:36:29,180
You have all of the logic you need.
你拥有你需要的所有逻辑。

2203
01:36:29,180 --> 01:36:33,280
So this too is recursive in the sense that if this is a search algorithm,
所以这也从某种意义上说是递归的，如果这是一个搜索算法，

2204
01:36:33,280 --> 01:36:36,610
the search algorithm is using a search algorithm inside of it.
搜索算法在内部使用了一个搜索算法。

2205
01:36:36,610 --> 01:36:39,430
But here too, the phone book was getting divided and divided
但在这里，电话簿也被分割和分割，

2206
01:36:39,430 --> 01:36:42,160
and divided in half again and again.
并一再分成两半。

2207
01:36:42,160 --> 01:36:45,370
So recursion doesn't just describe mathematical formulas.
所以递归不仅仅描述数学公式。

2208
01:36:45,370 --> 01:36:49,077
It doesn't just describe pseudocode or code-- even physical structures.
它不仅仅描述伪代码或代码——甚至物理结构。

2209
01:36:49,077 --> 01:36:51,410
So we deliberately brought back these bricks here today,
所以我们今天特意带回了这些砖块，

2210
01:36:51,410 --> 01:36:54,040
which are reminiscent, of course, from Mario and Super Mario Brothers.
它们当然让人想起马里奥和超级马里奥兄弟。

2211
01:36:54,040 --> 01:36:56,695
That pyramid, especially if we get rid of the distractions
那个金字塔，特别是如果我们摆脱干扰，

2212
01:36:56,695 --> 01:36:58,570
of the ground and the mountains and so forth,
来自地面和山脉等等，

2213
01:36:58,570 --> 01:37:01,810
is itself recursive as a structure.
它本身就是一个递归的结构。

2214
01:37:01,810 --> 01:37:02,920
Now, why is that?
现在，为什么呢？

2215
01:37:02,920 --> 01:37:05,440
Well, here you can kind of play verbal games.
好吧，在这里你可以玩文字游戏。

2216
01:37:05,440 --> 01:37:07,930
If this is a pyramid of height 4--
如果这是一个高度为 4 的金字塔——

2217
01:37:07,930 --> 01:37:11,092
and ask the question, well, what is that-- what is a pyramid of height 4--
并问问题，好吧，那是什么——高度为 4 的金字塔是什么——

2218
01:37:11,092 --> 01:37:13,300
I could kind of be difficult and say, well, it's just
我可能会很固执地说，好吧，它只是

2219
01:37:13,300 --> 01:37:16,270
a pyramid of height 3 plus 1 other row.
一个高度为 3 的金字塔加上另一排。

2220
01:37:16,270 --> 01:37:18,310
All right, well, what's a pyramid of height 3?
好吧，高度为 3 的金字塔是什么？

2221
01:37:18,310 --> 01:37:21,185
You could be difficult and say, well, it's just a pyramid of height 2
你可以很固执地说，好吧，它只是一个高度为 2 的金字塔

2222
01:37:21,185 --> 01:37:22,060
plus 1 more row.
加上一排。

2223
01:37:22,060 --> 01:37:23,290
What's a pyramid of height 2?
高度为 2 的金字塔是什么？

2224
01:37:23,290 --> 01:37:27,363
Well, it's this plus 1 more row.
好吧，它是这个加上一排。

2225
01:37:27,363 --> 01:37:28,780
I might have skipped a step there.
我可能跳过了一步。

2226
01:37:28,780 --> 01:37:30,010
What's a pyramid of height 2?
高度为 2 的金字塔是什么？

2227
01:37:30,010 --> 01:37:33,130
Well, it's a pyramid of height 1 plus 1 more row.
好吧，它是一个高度为 1 的金字塔加上一排。

2228
01:37:33,130 --> 01:37:34,900
What's a pyramid of height 1?
高度为 1 的金字塔是什么？

2229
01:37:34,900 --> 01:37:37,240
Well, it's nothing plus 1 more row.
好吧，它是一排加上一排。

2230
01:37:37,240 --> 01:37:39,638
Or at this point, you can just say it's a single brick.
或者在这一点上，你可以直接说它是一块砖。

2231
01:37:39,638 --> 01:37:42,430
You can have a base case that just says, like, the buck stops here.
你可以有一个基本情况，它只是说，就像，这里就到此为止了。

2232
01:37:42,430 --> 01:37:43,722
Stop asking me these questions.
别再问我这些问题了。

2233
01:37:43,722 --> 01:37:48,140
I can special case or hard code my answer to the very tiniest of problems.
我可以对最小的问题进行特殊情况处理或硬编码我的答案。

2234
01:37:48,140 --> 01:37:50,740
So even those bricks then are sort of--
所以，即使这些砖块——

2235
01:37:50,740 --> 01:37:52,622
the pyramid is recursively defined.
金字塔是递归定义的。

2236
01:37:52,622 --> 01:37:54,580
And we can actually implement this even in code
我们实际上甚至可以在代码中实现这一点。

2237
01:37:54,580 --> 01:37:57,080
if we want in a couple of different ways to make this clear.
如果我们想用几种不同的方法来使这一点变得清晰。

2238
01:37:57,080 --> 01:37:59,690
So let me go back over to VS Code here.
所以让我回到 VS Code 这里。

2239
01:37:59,690 --> 01:38:03,760
And let me propose that we do one old-school iterative example with
让我提议我们用一个老式的迭代例子。

2240
01:38:03,760 --> 01:38:04,510
this--
这个

2241
01:38:04,510 --> 01:38:06,190
code iteration dot C.
code iteration.c。

2242
01:38:06,190 --> 01:38:09,040
And iteration just means to loop again and again.
迭代只是意味着反复循环。

2243
01:38:09,040 --> 01:38:11,000
An iteration is a pass through the code.
迭代是指遍历代码。

2244
01:38:11,000 --> 01:38:13,430
And let me go ahead and whip this up as follows.
让我继续按照如下步骤进行操作。

2245
01:38:13,430 --> 01:38:15,730
Let's include the CS50 library.
让我们包含 CS50 库。

2246
01:38:15,730 --> 01:38:18,850
So we have our get int function.
所以我们有了 get int 函数。

2247
01:38:18,850 --> 01:38:21,790
Let's include standard io so that we have printf.
让我们包含 stdio，这样我们就可以使用 printf 了。

2248
01:38:21,790 --> 01:38:27,650
Let's go ahead and create main with no command line arguments today.
让我们继续创建没有命令行参数的 main 函数。

2249
01:38:27,650 --> 01:38:30,430
Let's go ahead and create a variable of type int set
让我们继续创建一个 int 类型的变量，并将其

2250
01:38:30,430 --> 01:38:33,070
equal to the return value of get int asking
设置为 get int 函数的返回值，该函数会询问

2251
01:38:33,070 --> 01:38:35,230
the user for the height of the pyramid.
用户金字塔的高度。

2252
01:38:35,230 --> 01:38:37,480
And then let me assume for the sake of discussion
然后让我们为了讨论的方便假设

2253
01:38:37,480 --> 01:38:41,290
that there is a function now that will draw a pyramid of that height.
现在有一个函数可以绘制一个指定高度的金字塔。

2254
01:38:41,290 --> 01:38:44,810
All right, now let's actually implement that function as a helper function,
好的，现在让我们实际实现这个函数作为辅助函数。

2255
01:38:44,810 --> 01:38:45,500
so to speak.
可以这么说。

2256
01:38:45,500 --> 01:38:49,270
So if I have a function called draw, it's going to clearly take an integer.
所以如果我有一个名为 draw 的函数，它显然会接收一个整数。

2257
01:38:49,270 --> 01:38:51,670
And I'll call it, maybe, n as input.
我将把它命名为 n 作为输入。

2258
01:38:51,670 --> 01:38:53,600
And it doesn't need to return anything.
它不需要返回任何东西。

2259
01:38:53,600 --> 01:38:55,120
So I'm going to say that this is a void function.
所以我要说这是一个 void 函数。

2260
01:38:55,120 --> 01:38:56,203
It doesn't return a value.
它不返回值。

2261
01:38:56,203 --> 01:38:59,030
It just has a side effect of printing bricks on the screen.
它只是在屏幕上打印砖块的副作用。

2262
01:38:59,030 --> 01:39:02,050
How can I go about doing a pyramid of height n?
我怎样才能构建一个高度为 n 的金字塔呢？

2263
01:39:02,050 --> 01:39:07,120
Well, I'm going to do this one, which looks like this-- one at a time,
好吧，我将按顺序进行，看起来像这样 - 一次一个。

2264
01:39:07,120 --> 01:39:09,430
then two, then three, then four.
然后是两个，然后是三个，然后是四个。

2265
01:39:09,430 --> 01:39:11,210
And this is a little easier, for instance,
这有点容易，例如，

2266
01:39:11,210 --> 01:39:14,380
than problem set one, which had the pyramid flipped around the other way.
比问题集一容易，问题集一的金字塔是反过来的。

2267
01:39:14,380 --> 01:39:16,480
So this one's a little easier to do deliberately.
所以这个更容易刻意地完成。

2268
01:39:16,480 --> 01:39:21,250
So if I go back to my code, I could say something like this-- for int i gets 0.
所以如果我回到我的代码，我可以这样说 - 对于 int i 获取 0。

2269
01:39:21,250 --> 01:39:24,610
i is less than, let's say, n, which is the height--
i 小于，比如说，n，也就是高度 -

2270
01:39:24,610 --> 01:39:25,810
i plus, plus.
i 加加。

2271
01:39:25,810 --> 01:39:30,280
That's going to essentially iterate over every row of the pyramid top to bottom.
这基本上会从上到下迭代金字塔的每一行。

2272
01:39:30,280 --> 01:39:31,480
This might feel similar--
这可能感觉类似 -

2273
01:39:31,480 --> 01:39:33,700
reminiscent-- to problem set one.
让人想起 - 问题集一。

2274
01:39:33,700 --> 01:39:36,280
Then in my inner loop, I'm going to do four.
然后在我的内循环中，我将进行四次操作。

2275
01:39:36,280 --> 01:39:38,200
int j gets 0.
int j 获取 0。

2276
01:39:38,200 --> 01:39:42,682
j is less than i plus 1 j plus, plus.
j 小于 i 加 1 j 加加。

2277
01:39:42,682 --> 01:39:44,390
And we'll see why this works in a moment.
我们稍后会看到为什么这样做有效。

2278
01:39:44,390 --> 01:39:47,800
And then let's go ahead and print out a single hash, no new line.
然后让我们继续打印一个单独的哈希符号，不换行。

2279
01:39:47,800 --> 01:39:52,660
But at the very bottom of this row, let's print out just a new line
但是在这一行的最底部，让我们只打印一个换行符

2280
01:39:52,660 --> 01:39:54,850
to move the cursor down a line.
将光标向下移动一行。

2281
01:39:54,850 --> 01:39:56,050
Now, I'm not done yet.
现在，我还没有完成。

2282
01:39:56,050 --> 01:39:57,760
Let me hide my terminal for a second.
让我隐藏一下我的终端。

2283
01:39:57,760 --> 01:39:58,940
I need the prototype.
我需要原型。

2284
01:39:58,940 --> 01:40:02,720
So I'm going to copy this, paste it up here with a semicolon.
所以我要复制它，把它粘贴到这里，并添加一个分号。

2285
01:40:02,720 --> 01:40:05,300
And I think now the code is correct.
我想现在代码是正确的。

2286
01:40:05,300 --> 01:40:06,430
Now, why is this correct?
现在，为什么这是正确的？

2287
01:40:06,430 --> 01:40:11,160
Because on my outer loop, I'm iterating n times starting at 0.
因为在我的外循环中，我从 0 开始迭代 n 次。

2288
01:40:11,160 --> 01:40:15,900
My inner loop-- realize I want to have at least one hash,
我的内循环 - 意识到我至少想要一个井号，

2289
01:40:15,900 --> 01:40:18,480
then two, then three, then four.
然后是两个，然后是三个，然后是四个。

2290
01:40:18,480 --> 01:40:20,970
So I can't start my number of hashes at 0.
所以我的井号数量不能从 0 开始。

2291
01:40:20,970 --> 01:40:26,910
And that's why I'm doing j all the way up to i plus 1 so that when i is 0,
这就是为什么我要一直将 j 做到 i 加 1，这样当 i 等于 0 时，

2292
01:40:26,910 --> 01:40:30,390
I'm actually still printing one hash, and then two hashes, and then three.
我实际上仍然会打印一个井号，然后是两个井号，然后是三个。

2293
01:40:30,390 --> 01:40:32,670
Otherwise, I would start with 0, which is not my goal.
否则，我会从 0 开始，这不是我的目标。

2294
01:40:32,670 --> 01:40:35,700
Let me go in and do make iteration to compile this--
让我进去并进行迭代以编译这个 -

2295
01:40:35,700 --> 01:40:37,350
dot slash iteration.
点斜杠迭代。

2296
01:40:37,350 --> 01:40:39,600
And let me go ahead and make my terminal bigger--
让我继续把我的终端弄得更大 -

2297
01:40:39,600 --> 01:40:40,650
enter.
输入。

2298
01:40:40,650 --> 01:40:42,660
The height will be, for instance, 4.
例如，高度将是 4。

2299
01:40:42,660 --> 01:40:45,660
And indeed, it's not quite to scale because these are a little more
实际上，它没有完全按比例，因为这些更

2300
01:40:45,660 --> 01:40:47,550
vertical than they are horizontal.
垂直而不是水平。

2301
01:40:47,550 --> 01:40:49,440
But it essentially looks like that pyramid.
但它本质上看起来像那个金字塔。

2302
01:40:49,440 --> 01:40:50,910
And I can do this even larger.
我甚至可以做到更大。

2303
01:40:50,910 --> 01:40:52,930
Let's do this again after clearing my screen.
让我们在清除屏幕后再次这样做。

2304
01:40:52,930 --> 01:40:54,210
Let's do like 10 of these.
让我们做 10 个这样的。

2305
01:40:54,210 --> 01:40:55,300
And it gets bigger.
它变得更大。

2306
01:40:55,300 --> 01:40:56,750
Let's do, like, 50 of these.
让我们做 50 个这样的。

2307
01:40:56,750 --> 01:40:57,750
And it gets even bigger.
它变得更大。

2308
01:40:57,750 --> 01:40:59,167
It doesn't even fit on the screen.
它甚至不适合屏幕。

2309
01:40:59,167 --> 01:40:59,730
But it works.
但它有效。

2310
01:40:59,730 --> 01:41:02,648
And that's an iterative approach, 100% correct,
这是一种迭代方法，100% 正确，

2311
01:41:02,648 --> 01:41:05,190
and similar to what you might have done already for something
类似于你可能已经为某些东西做的事情

2312
01:41:05,190 --> 01:41:08,130
like week zero or week one.
比如第零周或第一周。

2313
01:41:08,130 --> 01:41:10,390
But it turns out if we leverage recursion,
但事实证明，如果我们利用递归，

2314
01:41:10,390 --> 01:41:12,650
we can be a little more clever, in fact.
实际上，我们可以更聪明一点。

2315
01:41:12,650 --> 01:41:13,880
Let me go ahead and do this.
让我继续这样做。

2316
01:41:13,880 --> 01:41:15,600
Let me minimize my terminal window.
让我最小化我的终端窗口。

2317
01:41:15,600 --> 01:41:17,990
And let me go back into my code here.
让我回到这里我的代码。

2318
01:41:17,990 --> 01:41:23,800
And let me propose to implement the exact same program recursively instead.
让我建议改为递归地实现完全相同的程序。

2319
01:41:23,800 --> 01:41:27,710
And let me go ahead and do this.
让我继续这样做。

2320
01:41:27,710 --> 01:41:31,030
I'm going to leave main--
我要离开主程序 -

2321
01:41:31,030 --> 01:41:34,060
let's see-- exactly as is.
让我们看看 - 正如它所是。

2322
01:41:34,060 --> 01:41:39,410
And I'm going to go ahead and change my draw function to work as follows.
我要继续改变我的绘制函数以按如下方式工作。

2323
01:41:39,410 --> 01:41:41,860
Let me delete all of these loops because loops are sort
让我删除所有这些循环，因为循环是一种

2324
01:41:41,860 --> 01:41:43,750
of an indication of using iteration.
使用迭代的指示。

2325
01:41:43,750 --> 01:41:45,550
And I'm instead going to do this.
我将改为这样做。

2326
01:41:45,550 --> 01:41:49,030
What is a pyramid of height 4?
什么是高度为 4 的金字塔？

2327
01:41:49,030 --> 01:41:52,210
I said it's a pyramid of height 3 plus 1 more row.
我说它是一个高度为 3 的金字塔，加上一行。

2328
01:41:52,210 --> 01:41:53,740
So let's take that literally.
所以让我们按照字面意思理解。

2329
01:41:53,740 --> 01:41:56,950
If a pyramid of height n needs to be drawn,
如果需要绘制高度为 n 的金字塔，

2330
01:41:56,950 --> 01:42:01,270
let's first draw a pyramid of n minus 1.
让我们先绘制一个高度为 n 减 1 的金字塔。

2331
01:42:01,270 --> 01:42:04,150
And then how do I go about drawing one more row?
然后我如何绘制另一行？

2332
01:42:04,150 --> 01:42:05,870
Well, this, I can use a bit of iteration.
好吧，这个我可以使用一点迭代。

2333
01:42:05,870 --> 01:42:08,710
But I don't need a doubly-nested loop anymore.
但我不再需要双重嵌套循环。

2334
01:42:08,710 --> 01:42:13,750
I can set i equal to 0, i less than n, i plus, plus.
我可以将 i 设置为 0，i 小于 n，i 加加。

2335
01:42:13,750 --> 01:42:16,300
And this block of code is simply going to print
这块代码将简单地打印

2336
01:42:16,300 --> 01:42:23,590
one simple row of hashes again and again followed by a new line just
仅仅是一行简单的哈希符号，一遍又一遍地重复，然后是一个新行

2337
01:42:23,590 --> 01:42:25,070
to move the cursor down.
以便将光标向下移动。

2338
01:42:25,070 --> 01:42:27,040
So notice this line here.
所以请注意这里这行代码。

2339
01:42:27,040 --> 01:42:33,880
And I'll add some comments-- print pyramid of height n minus 1,
我会添加一些注释——打印高度为 n-1 的金字塔，

2340
01:42:33,880 --> 01:42:35,990
print one more row.
再打印一行。

2341
01:42:35,990 --> 01:42:39,680
So I'm kind of taking a bite out of the problem by printing one row.
所以，我通过打印一行代码来解决问题。

2342
01:42:39,680 --> 01:42:44,230
But I'm deferring to, weirdly, myself, to print the rest of the pyramid.
但我却将打印剩余金字塔的任务推迟了，有点奇怪，是我自己来完成。

2343
01:42:44,230 --> 01:42:47,800
Now I'm going to go ahead and try compiling this-- make--
现在，我将尝试编译这段代码——make——

2344
01:42:47,800 --> 01:42:48,340
oh.
哦。

2345
01:42:48,340 --> 01:42:49,940
And this is no longer iteration.
现在它不再是迭代了。

2346
01:42:49,940 --> 01:42:53,920
So I'm actually going to do this-- code recursion dot c.
所以我实际上会这样做——code recursion.c。

2347
01:42:53,920 --> 01:42:56,437
I'm going to paste that same code into this new version,
我会将相同的代码粘贴到这个新版本中，

2348
01:42:56,437 --> 01:42:59,020
just so we have a different file without breaking the old one.
这样我们就可以拥有一个不同的文件，而不会破坏旧文件。

2349
01:42:59,020 --> 01:43:01,960
And now I'm going to do make recursion.
现在我将执行 make recursion。

2350
01:43:01,960 --> 01:43:03,250
All right, interesting.
好的，有趣。

2351
01:43:03,250 --> 01:43:05,710
So Clang is yelling at me with this error.
所以，Clang 正在用这个错误对我大喊大叫。

2352
01:43:05,710 --> 01:43:08,810
All paths through this function will call itself.
这个函数的所有路径都会调用自身。

2353
01:43:08,810 --> 01:43:11,590
So Clang is actually smart enough to notice in my code
所以，Clang 实际上足够聪明，能够在我的代码中注意到

2354
01:43:11,590 --> 01:43:14,920
that no matter what, the draw function is going to call the draw function.
无论如何，draw 函数都会调用 draw 函数。

2355
01:43:14,920 --> 01:43:16,840
And the draw function is going to call the draw function.
draw 函数将调用 draw 函数。

2356
01:43:16,840 --> 01:43:19,173
And the draw function's going to call the draw function.
draw 函数将调用 draw 函数。

2357
01:43:19,173 --> 01:43:23,230
Now, to be fair, n, the input to draw, is getting smaller and smaller.
公平地说，n 作为 draw 函数的输入，正在越来越小。

2358
01:43:23,230 --> 01:43:25,990
But what's going to happen eventually to the input of draw
但最终，draw 函数的输入会发生什么情况

2359
01:43:25,990 --> 01:43:28,870
as I've written this code right now?
正如我现在编写的代码那样？

2360
01:43:28,870 --> 01:43:30,040
Yeah, in the back?
是啊，在后面？

2361
01:43:30,040 --> 01:43:32,722
AUDIENCE: [INAUDIBLE]
观众：[听不清]

2362
01:43:32,722 --> 01:43:33,800
DAVID MALAN: Exactly.
大卫·马兰：没错。

2363
01:43:33,800 --> 01:43:35,900
Remember that integers are signed by default.
请记住，默认情况下整数是有符号的。

2364
01:43:35,900 --> 01:43:38,550
They can be both positive or 0 or negative.
它们可以是正数、0 或负数。

2365
01:43:38,550 --> 01:43:41,330
And so here, if I just keep blindly subtracting 1,
因此，在这里，如果我不断地盲目地减去 1，

2366
01:43:41,330 --> 01:43:44,930
it's going to do that seemingly forever until I technically underflow.
它看起来将永远这样做，直到我技术性地溢出。

2367
01:43:44,930 --> 01:43:47,970
But that's going to be like 2 billion rows of pyramids later.
但那将在 20 亿行金字塔之后。

2368
01:43:47,970 --> 01:43:51,660
So I think what I actually need to do is something like this.
我认为我实际上需要做的事情是这样的。

2369
01:43:51,660 --> 01:43:56,900
I need to ask the question, if n equals 0--
我需要问一个问题，如果 n 等于 0——

2370
01:43:56,900 --> 01:44:00,710
or heck, just to be super safe, let's say if n is less than or equal to 0,
或者，为了绝对安全，我们假设 n 小于或等于 0，

2371
01:44:00,710 --> 01:44:04,010
just to make sure it never goes negative, let's just go ahead
为了确保它永远不会变成负数，让我们继续

2372
01:44:04,010 --> 01:44:06,540
and return without doing anything.
并返回而不做任何操作。

2373
01:44:06,540 --> 01:44:10,130
So I'm going to comment this as, like, if nothing to draw, well, then
所以我将对此进行注释，例如，如果没有任何内容要绘制，那么

2374
01:44:10,130 --> 01:44:11,780
don't blindly call draw again.
不要再次盲目地调用 draw 函数。

2375
01:44:11,780 --> 01:44:13,380
So this is that so-called base case.
所以，这就是所谓的基线情况。

2376
01:44:13,380 --> 01:44:16,490
This is analogous to saying, like, if John Harvard not in phone book
这类似于说，例如，如果约翰·哈佛不在电话簿中

2377
01:44:16,490 --> 01:44:22,410
or if no lockers or doors left, then just exit or return in this case.
或者如果没有剩下的储物柜或门，那么在这种情况下就退出或返回。

2378
01:44:22,410 --> 01:44:27,050
So now I'll never call draw a negative number of times
所以，现在我永远不会负数次调用 draw 函数

2379
01:44:27,050 --> 01:44:28,370
or zero number of times.
或零次。

2380
01:44:28,370 --> 01:44:30,990
I will only do it so long as n is positive.
我只会这样做，只要 n 是正数。

2381
01:44:30,990 --> 01:44:36,420
So now if I make my terminal bigger, make recursion again does compile fine.
所以现在，如果我让我的终端更大，再次执行 make recursion，它就可以正常编译。

2382
01:44:36,420 --> 01:44:39,630
Dot slash recursion-- let's do the same input for.
./recursion——让我们对它使用相同的输入。

2383
01:44:39,630 --> 01:44:42,840
And I get the exact same number of bricks.
我得到了相同数量的砖块。

2384
01:44:42,840 --> 01:44:45,540
Let's go ahead and do it again with maybe 10.
让我们再试一次，也许用 10 块砖。

2385
01:44:45,540 --> 01:44:46,890
That seems to work too.
看起来也可以。

2386
01:44:46,890 --> 01:44:48,510
Let's do it again with 50.
让我们再试一次，用 50 块砖。

2387
01:44:48,510 --> 01:44:49,503
That seems to work too.
看起来也可以。

2388
01:44:49,503 --> 01:44:50,670
And I can go a little crazy.
我可以有点疯狂。

2389
01:44:50,670 --> 01:44:52,320
I can do, like, 5,000.
我可以做，比如，5000 块砖。

2390
01:44:52,320 --> 01:44:53,500
This is still going to work.
这仍然会起作用。

2391
01:44:53,500 --> 01:44:55,210
It's just not going to fit on my screen.
只是不会在我的屏幕上显示。

2392
01:44:55,210 --> 01:44:59,073
But it is doing a valiant attempt to print all of those out.
但它正在尽力打印出所有这些。

2393
01:44:59,073 --> 01:45:00,990
Now, it turns out that could get us in trouble
现在，事实证明这可能会给我们带来麻烦

2394
01:45:00,990 --> 01:45:05,790
if we start poking around in the-- now, maybe not 5,000 but 500,000 or 5
如果我们开始在里面戳来戳去，现在，也许不是 5000 块，而是 50 万块或者 5

2395
01:45:05,790 --> 01:45:07,020
million or beyond.
百万块或更多。

2396
01:45:07,020 --> 01:45:11,050
But for now, we'll just assume that this is just a slow process at that.
但现在，我们假设这只是一个缓慢的过程。

2397
01:45:11,050 --> 01:45:14,340
But if we go back to the goal, which was to print this thing here,
但如果我们回到目标，即打印这个东西，

2398
01:45:14,340 --> 01:45:17,760
this too is a recursive structure that we're just now translating
这也是一个递归结构，我们现在正在将

2399
01:45:17,760 --> 01:45:19,623
the ideas of recursive code to.
递归代码的理念转换为。

2400
01:45:19,623 --> 01:45:21,540
And actually, if you've never discovered this,
实际上，如果你从未发现过这一点，

2401
01:45:21,540 --> 01:45:23,790
we would be remiss in not doing this for you.
我们不应该为你做这件事。

2402
01:45:23,790 --> 01:45:27,840
If I go into a browser here.
如果我进入这里的浏览器。

2403
01:45:27,840 --> 01:45:30,540
And suppose that I'm not using any AI fancy technology.
假设我没有使用任何人工智能技术。

2404
01:45:30,540 --> 01:45:32,070
I'm just going to Google.com.
我只是要访问 Google.com。

2405
01:45:32,070 --> 01:45:35,730
And I search for recursion because I'm curious to see what it means.
我搜索递归，因为我好奇地想知道它的含义。

2406
01:45:35,730 --> 01:45:39,650
Google for years has had this little Easter egg for computer scientists.
多年来，谷歌一直为计算机科学家准备了这个小彩蛋。

2407
01:45:43,940 --> 01:45:45,680
It's not a typo.
这不是错字。

2408
01:45:45,680 --> 01:45:46,180
Get it?
明白了吗？

2409
01:45:46,180 --> 01:45:47,690
Ha, ha, kind of funny.
哈哈，有点好笑。

2410
01:45:47,690 --> 01:45:48,190
Yeah?
是吗？

2411
01:45:48,190 --> 01:45:49,540
OK, like, see?
好吧，就像，看到了吗？

2412
01:45:49,540 --> 01:45:52,070
Recursion-- so if you click recursion, OK, now we're
递归，所以如果你点击递归，好的，现在我们

2413
01:45:52,070 --> 01:45:53,320
in night mode for some reason.
出于某种原因处于夜间模式。

2414
01:45:53,320 --> 01:45:57,620
But OK, like, so it just does this endlessly.
但好的，就像，所以它只是无休止地这样做。

2415
01:45:57,620 --> 01:46:00,410
OK, so programmers with too much free time or too much
好的，所以那些有太多空闲时间或太多

2416
01:46:00,410 --> 01:46:02,560
control over Google's own servers to do that.
控制权的程序员可以对谷歌自己的服务器做这些。

2417
01:46:02,560 --> 01:46:05,060
So it turns out, yes, if you search for recursion on Google,
所以事实证明，是的，如果你在 Google 上搜索递归，

2418
01:46:05,060 --> 01:46:07,560
this is a long-standing Easter egg in this case.
这在这种情况下是一个长期存在的彩蛋。

2419
01:46:07,560 --> 01:46:09,410
But the point of introducing recursion is
但介绍递归的目的是

2420
01:46:09,410 --> 01:46:12,830
that, one, it's actually going to be a very powerful problem-solving technique
那就是，首先，它实际上将是一种非常强大的问题解决技术

2421
01:46:12,830 --> 01:46:15,770
because honestly, it, one, we've seen in pseudocode already,
因为坦率地说，我们已经看到了伪代码，

2422
01:46:15,770 --> 01:46:18,920
it kind of tightens up the amount of code or the amount of lines
它在一定程度上缩短了代码量或行数

2423
01:46:18,920 --> 01:46:20,900
that you need to write to convey an algorithm.
你需要编写来表达算法。

2424
01:46:20,900 --> 01:46:22,912
And two, it will actually allow us to solve
其次，它实际上将允许我们解决

2425
01:46:22,912 --> 01:46:24,620
problems in a fundamentally different way
以一种根本不同的方式解决问题

2426
01:46:24,620 --> 01:46:27,540
by using computer's memory in an interesting way.
通过以一种有趣的方式使用计算机的内存。

2427
01:46:27,540 --> 01:46:31,220
And so toward that end, we wanted to introduce one final sort today, which
因此，为了这个目的，我们今天想介绍最后一种排序，即

2428
01:46:31,220 --> 01:46:34,520
we won't use humans to demonstrate but just numbers instead, namely
我们不会用人类来演示，而是用数字来演示，即

2429
01:46:34,520 --> 01:46:35,990
something called merge sort.
一种叫做归并排序的东西。

2430
01:46:35,990 --> 01:46:40,790
And merge sort is an algorithm for sorting n numbers that I claim
归并排序是一种对 n 个数字进行排序的算法，我认为

2431
01:46:40,790 --> 01:46:43,430
is going to be better than selection sort and bubble sort.
它将比选择排序和冒泡排序更好。

2432
01:46:43,430 --> 01:46:46,010
It's got to be better because that n squared was killing us.
它必须更好，因为 n 平方正在杀死我们。

2433
01:46:46,010 --> 01:46:48,540
We want to get something lower than n squared.
我们想要得到比n平方更低的复杂度。

2434
01:46:48,540 --> 01:46:51,960
So merge sort's pseudocode essentially looks like this.
所以归并排序的伪代码本质上是这样的。

2435
01:46:51,960 --> 01:46:53,540
And this is it.
就是这样。

2436
01:46:53,540 --> 01:46:58,460
Merge sort says, if you've got n numbers or an array of numbers,
归并排序说，如果你有n个数字或一个数字数组，

2437
01:46:58,460 --> 01:47:01,430
sort the left half of them, sort the right half of them.
对它们左半部分进行排序，对它们右半部分进行排序。

2438
01:47:01,430 --> 01:47:03,412
And then merge the sorted halves.
然后合并排序后的两半。

2439
01:47:03,412 --> 01:47:05,370
And we'll see what this means in just a moment.
我们马上就会看到这意味着什么。

2440
01:47:05,370 --> 01:47:07,280
But if there's only one number, just quit.
但如果只有一个数字，就退出。

2441
01:47:07,280 --> 01:47:09,920
So this is my base case because this is recursive.
所以这是我的基本情况，因为它是递归的。

2442
01:47:09,920 --> 01:47:12,440
Because if this is a sorting algorithm called merge sort,
因为如果这是一个名为归并排序的排序算法，

2443
01:47:12,440 --> 01:47:15,685
I'm kind of cheating by using the verb sort in the sorting algorithm.
我在排序算法中使用动词“排序”有点作弊。

2444
01:47:15,685 --> 01:47:17,060
But that just makes it recursive.
但这只是使它递归。

2445
01:47:17,060 --> 01:47:18,330
It doesn't make it wrong.
这并不意味着它错了。

2446
01:47:18,330 --> 01:47:19,730
So what do I mean by merging?
那么，我所说的合并是什么意思呢？

2447
01:47:19,730 --> 01:47:25,522
Just to make this clear, here among these numbers are two lists of size 4.
为了更清楚地说明，这里，在这组数字中，有两个大小为4的列表。

2448
01:47:25,522 --> 01:47:27,980
And I'm going to scooch them over to the left and the right
我将它们向左和向右移动

2449
01:47:27,980 --> 01:47:32,540
just to make clear that on the left is one half that is sorted--
只是为了更清楚地说明，左侧是已经排序的一半——

2450
01:47:32,540 --> 01:47:35,270
1346 from smallest to largest.
从最小到最大依次为1346。

2451
01:47:35,270 --> 01:47:40,460
On the right is a second half that's also sorted 0257.
右侧是第二部分，也已经排序了，为0257。

2452
01:47:40,460 --> 01:47:42,980
So for the sake of discussion, suppose that I'm
为了讨论，假设我正在

2453
01:47:42,980 --> 01:47:46,070
partway through this algorithm called merge sort.
进行这个名为归并排序的算法。

2454
01:47:46,070 --> 01:47:48,380
And I've sorted the left half already, clearly.
我已经对左半部分进行了排序，很明显。

2455
01:47:48,380 --> 01:47:50,570
I've sorted the right half already, clearly.
我已经对右半部分进行了排序，很明显。

2456
01:47:50,570 --> 01:47:52,790
Now I need to merge the sorted halves.
现在我需要合并排序后的两半。

2457
01:47:52,790 --> 01:47:54,270
What do we mean by that?
这意味着什么呢？

2458
01:47:54,270 --> 01:47:57,710
Well, that means to essentially, conceptually,
嗯，这意味着本质上，从概念上讲，

2459
01:47:57,710 --> 01:48:00,350
point your left hand at the first at the left half.
将你的左手指向左侧的第一部分。

2460
01:48:00,350 --> 01:48:02,540
Point your right hand at the right half.
将你的右手指向右侧的部分。

2461
01:48:02,540 --> 01:48:05,450
And then decide which of these numbers should come first
然后决定这些数字中哪个应该排在最前面

2462
01:48:05,450 --> 01:48:08,990
in order to merge or kind of stitch these two lists together
以便将这两个列表合并或缝合在一起

2463
01:48:08,990 --> 01:48:09,980
in sorted order.
以排序顺序。

2464
01:48:09,980 --> 01:48:11,180
Well, which is smaller?
哪一个更小？

2465
01:48:11,180 --> 01:48:12,350
Obviously, 0.
显然，是0。

2466
01:48:12,350 --> 01:48:16,460
So that last step, merge sorted halves, would have me take this number
所以最后一步，合并排序后的两半，会让我取这个数字

2467
01:48:16,460 --> 01:48:19,490
and put it in an extra empty array up here.
把它放在这里一个额外的空数组中。

2468
01:48:19,490 --> 01:48:22,250
Now I move my right hand to the next number in the right half.
现在我将我的右手移动到右侧的下一个数字。

2469
01:48:22,250 --> 01:48:23,870
And I compare the 1 and the 2.
我比较了1和2。

2470
01:48:23,870 --> 01:48:25,440
Obviously, 1 comes next.
显然，1是下一个。

2471
01:48:25,440 --> 01:48:27,140
So I put this now up here.
所以我把它放在这里。

2472
01:48:27,140 --> 01:48:28,880
Now I compare the 3 and the 2.
现在我比较了3和2。

2473
01:48:28,880 --> 01:48:30,450
Obviously, the 2 comes next.
显然，2是下一个。

2474
01:48:30,450 --> 01:48:32,180
And so I put this up here--
所以我把它放在这里——

2475
01:48:32,180 --> 01:48:34,670
3 and 5-- obviously, 3--
3和5——显然，是3——

2476
01:48:34,670 --> 01:48:40,350
4 and 5-- obviously, 4--
4和5——显然，是4——

2477
01:48:40,350 --> 01:48:43,620
6 and 5-- obviously, 5--
6和5——显然，是5——

2478
01:48:43,620 --> 01:48:46,800
and 6 and 7-- obviously, 6.
以及6和7——显然，是6。

2479
01:48:46,800 --> 01:48:50,550
And I didn't leave quite enough room for 7, perhaps, and lastly, 7.
我可能没有留出足够的空间来放置7，最后是7。

2480
01:48:50,550 --> 01:48:53,838
So that's all we mean by merging two lists together.
这就是我们所说的合并两个列表的意思。

2481
01:48:53,838 --> 01:48:56,130
If they're already sorted, you just kind of stitch them
如果它们已经排序，你只需将它们缝合

2482
01:48:56,130 --> 01:48:59,280
together by plucking from one or the other the next number
在一起，通过从一个或另一个中取出下一个数字。

2483
01:48:59,280 --> 01:49:00,280
that you actually want.
你真正想要的。

2484
01:49:00,280 --> 01:49:00,872
And that's it.
就是这样。

2485
01:49:00,872 --> 01:49:03,330
And even though I picked up partway through this algorithm,
即使我在这个算法进行到一半的时候才开始了解它，

2486
01:49:03,330 --> 01:49:05,370
those three steps alone would seem to work.
这三个步骤本身就足以运作。

2487
01:49:05,370 --> 01:49:08,310
So long as you can sort the left half and sort the right half,
只要你能将左半部分排序，并将右半部分排序，

2488
01:49:08,310 --> 01:49:10,543
you can surely then merge the sorted halves.
你就可以将排序好的两半合并在一起。

2489
01:49:10,543 --> 01:49:13,710
Now I'll go ahead and do this digitally rather than use the physical numbers
现在，我将用数字方式进行操作，而不是使用物理数字

2490
01:49:13,710 --> 01:49:16,377
because clearly, it's a little involved moving them up and down.
因为很明显，上下移动它们会比较麻烦。

2491
01:49:16,377 --> 01:49:19,650
But this rack here, this shelving, essentially
但是这个架子，这个货架，本质上

2492
01:49:19,650 --> 01:49:22,753
represents one array with maybe a second array here.
代表了一个数组，也许这里还有一个数组。

2493
01:49:22,753 --> 01:49:25,170
And heck, if I really want it, a third and a fourth array.
如果我真的需要，还可以有第三个和第四个数组。

2494
01:49:25,170 --> 01:49:27,660
It turns out that with selection sort and bubble sort,
事实证明，对于选择排序和冒泡排序，

2495
01:49:27,660 --> 01:49:30,120
we've really been tying our hands because I only
我们一直束手束脚，因为我只有

2496
01:49:30,120 --> 01:49:33,450
allowed myself a constant amount of memory, just one variable in my head,
允许自己使用固定数量的内存，在我的脑海中只有一个变量，

2497
01:49:33,450 --> 01:49:35,640
for instance, with selection sort that let me keep
例如，使用选择排序，它让我可以跟踪

2498
01:49:35,640 --> 01:49:37,662
track of who was the smallest element.
哪个是最小的元素。

2499
01:49:37,662 --> 01:49:40,120
And when we did bubble sort, the only number I kept in mind
当我们进行冒泡排序时，我唯一记住的数字

2500
01:49:40,120 --> 01:49:42,460
was i, like i and i plus 1.
是 i，比如 i 和 i 加 1。

2501
01:49:42,460 --> 01:49:44,650
I didn't allow myself any additional memory.
我没有允许自己使用任何额外的内存。

2502
01:49:44,650 --> 01:49:47,740
But it turns out in programming and in CS, you
但事实证明，在编程和计算机科学中，你

2503
01:49:47,740 --> 01:49:50,480
can trade off one resource for another.
可以将一种资源换成另一种资源。

2504
01:49:50,480 --> 01:49:53,410
So if you want to spend less time solving a problem,
所以，如果你想花更少的时间解决问题，

2505
01:49:53,410 --> 01:49:55,150
you've got to throw space at it.
你必须投入空间。

2506
01:49:55,150 --> 01:49:57,460
You've got to spend more space, spend more money,
你必须花更多空间，花更多钱，

2507
01:49:57,460 --> 01:50:00,650
in order to give yourself more space to reduce your time.
以便给自己更多空间来减少时间。

2508
01:50:00,650 --> 01:50:04,120
Conversely, if you're fine with things being slow in terms of time,
反之，如果你对时间上的缓慢没有意见，

2509
01:50:04,120 --> 01:50:06,400
then you can get away with very little space.
那么你就可以用很少的空间。

2510
01:50:06,400 --> 01:50:08,950
So it's kind of like this balance whereby
所以这有点像一种平衡，即

2511
01:50:08,950 --> 01:50:11,710
you have to decide which is more important to you, which
你必须决定哪一个对你更重要，哪一个

2512
01:50:11,710 --> 01:50:15,350
is more expensive for you, or the like.
对你来说更昂贵，或者类似的情况。

2513
01:50:15,350 --> 01:50:20,780
So let's go ahead then and consider exactly this algorithm as follows.
那么，让我们继续考虑这个算法，如下所示。

2514
01:50:20,780 --> 01:50:25,580
So suppose that these are the numbers in question.
假设这些是要排序的数字。

2515
01:50:25,580 --> 01:50:26,770
So here is our array.
这是我们的数组。

2516
01:50:26,770 --> 01:50:27,820
It's clearly unsorted.
很明显，它没有排序。

2517
01:50:27,820 --> 01:50:29,140
I'd like to sort this.
我想对它进行排序。

2518
01:50:29,140 --> 01:50:30,340
I could use selection sort.
我可以使用选择排序。

2519
01:50:30,340 --> 01:50:33,130
But selection sort was not great because it's big O of n squared.
但选择排序并不理想，因为它的时间复杂度为 O(n^2)。

2520
01:50:33,130 --> 01:50:36,227
And it's omega of n squared, so sort of damned if you do.
而且它的时间复杂度下界也是 O(n^2)，所以说，无论做什么都会被限制。

2521
01:50:36,227 --> 01:50:37,060
Damned if you don't.
不做也是一样。

2522
01:50:37,060 --> 01:50:38,630
Bubble sort was a little better.
冒泡排序稍微好一点。

2523
01:50:38,630 --> 01:50:39,963
It was still big O of n squared.
它的时间复杂度仍然是 O(n^2)。

2524
01:50:39,963 --> 01:50:42,380
But sometimes, we could get lucky and shave some time off.
但有时，我们可能会很幸运，能够节省一些时间。

2525
01:50:42,380 --> 01:50:44,680
So it was omega of only n.
所以它的时间复杂度下界只有 O(n)。

2526
01:50:44,680 --> 01:50:47,170
Let's see if merge sort is fundamentally better.
让我们看看归并排序是否本质上更好。

2527
01:50:47,170 --> 01:50:51,385
And let's do so by trying to reduce the number of comparisons-- no more looping
让我们通过减少比较次数来实现——不再进行循环

2528
01:50:51,385 --> 01:50:54,010
back and forth and back and forth and back and forth endlessly.
反复循环，永无止境。

2529
01:50:54,010 --> 01:50:58,210
So here's how we can draw inspiration from the idea of recursion and divide
所以，我们可以从递归和分治思想中汲取灵感，

2530
01:50:58,210 --> 01:51:00,160
and conquer as per week zero.
正如第一周所讲的那样。

2531
01:51:00,160 --> 01:51:02,980
Let's first think of these numbers as indeed in an array
让我们首先将这些数字视为确实存在于一个数组中

2532
01:51:02,980 --> 01:51:04,810
contiguously from left to right.
从左到右连续排列。

2533
01:51:04,810 --> 01:51:08,590
Let's then go ahead and sort the left half.
然后，让我们继续对左半部分进行排序。

2534
01:51:08,590 --> 01:51:10,750
Because again, the pseudocode that you have
因为再一次，你所拥有的伪代码

2535
01:51:10,750 --> 01:51:14,470
to remember throughout this whole algorithm has just three real steps.
在整个算法中需要记住的只有三个实际步骤。

2536
01:51:14,470 --> 01:51:15,670
Sort the left half.
对左半部分进行排序。

2537
01:51:15,670 --> 01:51:16,930
Sort the right half.
对右半部分进行排序。

2538
01:51:16,930 --> 01:51:18,160
Merge the sorted halves.
合并排序后的两半。

2539
01:51:18,160 --> 01:51:19,540
And then this is sort of a one-off thing.
然后，这是一个一次性的东西。

2540
01:51:19,540 --> 01:51:20,350
But it's important.
但它很重要。

2541
01:51:20,350 --> 01:51:21,555
But this is the juicy part.
但这是最精彩的部分。

2542
01:51:21,555 --> 01:51:22,180
Sort left half.
对左半部分进行排序。

2543
01:51:22,180 --> 01:51:22,847
Sort right half.
对右半部分进行排序。

2544
01:51:22,847 --> 01:51:24,070
Merge the sorted halves.
合并排序后的两半。

2545
01:51:24,070 --> 01:51:27,310
So if we go back to this array on the top shelf, here's the original array.
所以如果我们回到最上面架子上的这个数组，这是原始数组。

2546
01:51:27,310 --> 01:51:29,320
Let's go ahead and sort the left half.
让我们继续对左半部分进行排序。

2547
01:51:29,320 --> 01:51:32,600
And I'm going to do so by sort of stealing some more memory,
我会通过窃取更多内存来完成，

2548
01:51:32,600 --> 01:51:36,160
so I can sort of work on a second shelf with just these numbers.
这样我就可以在第二层架子上只用这些数字进行操作了。

2549
01:51:36,160 --> 01:51:39,730
So 6341 is now an array of size 4, essentially.
所以6341本质上现在是一个大小为4的数组。

2550
01:51:39,730 --> 01:51:42,070
How do I sort an array of size 4?
我如何对一个大小为4的数组进行排序？

2551
01:51:42,070 --> 01:51:44,395
Well, I've got an algorithm for that-- selection sort.
嗯，我有一个算法——选择排序。

2552
01:51:44,395 --> 01:51:45,520
But we decided that's slow.
但我们决定它太慢了。

2553
01:51:45,520 --> 01:51:46,780
Bubble sort-- that's slow.
冒泡排序——那太慢了。

2554
01:51:46,780 --> 01:51:47,500
Wait a minute.
等等。

2555
01:51:47,500 --> 01:51:49,300
I'm in the middle of defining merge sort.
我正在定义归并排序。

2556
01:51:49,300 --> 01:51:52,570
Let's recursively use the same algorithm by just
让我们递归地使用相同的算法，只需

2557
01:51:52,570 --> 01:51:55,130
sorting the left half of the left half.
对左半部分的左半部分进行排序。

2558
01:51:55,130 --> 01:51:58,335
So if you've got an array of size 4, it's only three steps to solve it.
所以如果你有一个大小为4的数组，只需要三个步骤就可以解决它。

2559
01:51:58,335 --> 01:51:58,960
Sort left half.
对左半部分进行排序。

2560
01:51:58,960 --> 01:51:59,710
Sort right half.
对右半部分进行排序。

2561
01:51:59,710 --> 01:52:00,400
Merge.
合并。

2562
01:52:00,400 --> 01:52:01,540
So let's do that.
所以让我们来做吧。

2563
01:52:01,540 --> 01:52:03,490
Let's sort the left half.
让我们对左半部分进行排序。

2564
01:52:03,490 --> 01:52:04,300
OK, wait a minute.
好的，等等。

2565
01:52:04,300 --> 01:52:06,728
How do you sort an array of size 2?
你如何对一个大小为2的数组进行排序？

2566
01:52:06,728 --> 01:52:08,020
I've got an algorithm for that.
我有一个算法。

2567
01:52:08,020 --> 01:52:08,710
Sort the left half.
对左半部分进行排序。

2568
01:52:08,710 --> 01:52:09,543
Sort the right half.
对右半部分进行排序。

2569
01:52:09,543 --> 01:52:10,870
Merge the two halves.
合并这两个部分。

2570
01:52:10,870 --> 01:52:14,110
All right, let's sort the left half.
好的，让我们对左半部分进行排序。

2571
01:52:14,110 --> 01:52:15,070
What now?
现在呢？

2572
01:52:15,070 --> 01:52:17,020
So 6 is a list of size 1.
所以6是一个大小为1的列表。

2573
01:52:17,020 --> 01:52:19,580
What was that special base case then?
那么，那个特殊的基本情况是什么？

2574
01:52:19,580 --> 01:52:21,500
So it was quit or just return.
所以它是退出或返回。

2575
01:52:21,500 --> 01:52:22,530
Like, I'm already done.
就像，我已经完成了。

2576
01:52:22,530 --> 01:52:26,510
So this list of size 1 is sort of weirdly already sorted.
所以这个大小为1的列表以一种奇怪的方式已经被排序了。

2577
01:52:26,510 --> 01:52:27,920
So I'm making progress.
所以我正在取得进展。

2578
01:52:27,920 --> 01:52:31,070
Meanwhile, what's the next step after sorting this left half?
同时，对左半部分排序后的下一步是什么？

2579
01:52:31,070 --> 01:52:32,720
Sort the right half.
对右半部分进行排序。

2580
01:52:32,720 --> 01:52:33,710
Done.
完成了。

2581
01:52:33,710 --> 01:52:35,060
This is already sorted.
这些已经排好序了。

2582
01:52:35,060 --> 01:52:36,170
But here's the magic.
但这里有魔法。

2583
01:52:36,170 --> 01:52:38,810
What's the third step for these numbers?
这些数字的第三步是什么？

2584
01:52:38,810 --> 01:52:39,310
Merge them.
合并它们。

2585
01:52:39,310 --> 01:52:41,310
So this is like the left hand, right hand thing.
所以这就像左手、右手一样。

2586
01:52:41,310 --> 01:52:42,260
Which one comes first?
哪个先来？

2587
01:52:42,260 --> 01:52:45,380
Obviously, 3 and then 6.
显然，先来 3 然后是 6。

2588
01:52:45,380 --> 01:52:50,638
And now we are making progress because now the list of size 2 is sorted.
现在我们正在取得进展，因为现在长度为 2 的列表已经排好序了。

2589
01:52:50,638 --> 01:52:51,680
So what have I just done?
所以，我刚才做了什么？

2590
01:52:51,680 --> 01:52:56,400
I've just finished sorting the left half of the left half.
我刚刚完成了对左侧一半的左侧一半的排序。

2591
01:52:56,400 --> 01:53:01,890
So after I've sorted the left half, what comes next if you rewind in time?
所以，在我对左侧一半排序后，如果你倒回时间，下一步是什么？

2592
01:53:01,890 --> 01:53:04,870
Sort the right half of that left half.
对左侧一半的右侧一半进行排序。

2593
01:53:04,870 --> 01:53:06,900
So now I take the right half.
现在我取右侧一半。

2594
01:53:06,900 --> 01:53:09,330
And how do I sort this right half of size 2?
我如何对长度为 2 的右侧一半进行排序？

2595
01:53:09,330 --> 01:53:10,920
Well, sort its left half.
好吧，对它的左侧一半进行排序。

2596
01:53:10,920 --> 01:53:11,610
Done.
完成了。

2597
01:53:11,610 --> 01:53:12,870
Sort its right half.
对它的右侧一半进行排序。

2598
01:53:12,870 --> 01:53:13,560
Done.
完成了。

2599
01:53:13,560 --> 01:53:15,180
Now merge them together.
现在将它们合并在一起。

2600
01:53:15,180 --> 01:53:17,880
And obviously, the 1 comes first, then the 4.
显然，1 先来，然后是 4。

2601
01:53:17,880 --> 01:53:19,110
Now where are we?
现在我们在哪里？

2602
01:53:19,110 --> 01:53:22,080
We're at the point in the story where we have a left left half
我们现在处于故事中的一个点，那里有一个左侧的左侧一半

2603
01:53:22,080 --> 01:53:26,040
sorted and a right left half sorted.
已经排好序，还有一个右侧的左侧一半已经排好序。

2604
01:53:26,040 --> 01:53:28,890
So what comes next now narratively?
那么，从叙述的角度来看，下一步是什么？

2605
01:53:28,890 --> 01:53:35,333
Merge the two together, so left hand, right hand, so 1346.
将两者合并在一起，所以左手、右手，所以 1346。

2606
01:53:35,333 --> 01:53:36,750
And where are we now in the story?
现在我们在故事中的什么位置？

2607
01:53:36,750 --> 01:53:41,220
We're sort of at the beginning because I've now sorted the left half.
我们现在处于故事的开头，因为我已经对左侧一半进行了排序。

2608
01:53:41,220 --> 01:53:43,320
And you recall the demo I did physically, this
你还记得我之前做的物理演示，这个

2609
01:53:43,320 --> 01:53:46,830
is how I had the left half was already sorted on the second shelf.
就是我在第二层架子上已经对左侧一半进行了排序的方式。

2610
01:53:46,830 --> 01:53:50,550
But now that I've sorted the left half of the original array, what's
但是，现在我已经对原始数组的左侧一半进行了排序，那么

2611
01:53:50,550 --> 01:53:53,580
the original second step?
原始的第二步是什么？

2612
01:53:53,580 --> 01:53:54,820
Sort the right half.
对右侧一半进行排序。

2613
01:53:54,820 --> 01:53:55,900
So it's the same idea.
所以，它是一样的想法。

2614
01:53:55,900 --> 01:53:57,780
So I'm borrowing some extra memory here.
所以，我在这里借用了一些额外的内存。

2615
01:53:57,780 --> 01:53:59,370
And now I've got an array of size 4.
现在我得到一个长度为 4 的数组。

2616
01:53:59,370 --> 01:54:00,870
How do I sort an array of size 4?
我如何对一个长度为 4 的数组进行排序？

2617
01:54:00,870 --> 01:54:02,010
Sort the left half.
对左侧一半进行排序。

2618
01:54:02,010 --> 01:54:03,900
All right, how do I sort an array of size 2?
好的，我如何对一个长度为 2 的数组进行排序？

2619
01:54:03,900 --> 01:54:05,190
Sort the left half.
对左侧一半进行排序。

2620
01:54:05,190 --> 01:54:06,000
Done.
完成了。

2621
01:54:06,000 --> 01:54:07,230
Sort the right half.
对右侧一半进行排序。

2622
01:54:07,230 --> 01:54:08,040
Done.
完成了。

2623
01:54:08,040 --> 01:54:08,670
Now what?
现在怎么办？

2624
01:54:08,670 --> 01:54:09,990
Merge the two together.
将两者合并在一起。

2625
01:54:09,990 --> 01:54:12,090
And of course, it's 2 and 5.
当然，是 2 和 5。

2626
01:54:12,090 --> 01:54:13,080
Now what do I do?
现在我该怎么办？

2627
01:54:13,080 --> 01:54:16,300
I've sorted the left half of the right half.
我已经对右侧一半的左侧一半进行了排序。

2628
01:54:16,300 --> 01:54:19,830
So now I sort the right half of the right half.
所以，现在我需要对右侧一半的右侧一半进行排序。

2629
01:54:19,830 --> 01:54:21,600
How do I sort a list of size 2?
我如何对长度为 2 的列表进行排序？

2630
01:54:21,600 --> 01:54:22,680
Well, sort the left half.
好吧，对左侧一半进行排序。

2631
01:54:22,680 --> 01:54:23,100
Done.
好了。

2632
01:54:23,100 --> 01:54:23,940
Sort the right half.
对右半部分排序。

2633
01:54:23,940 --> 01:54:24,600
Done.
好了。

2634
01:54:24,600 --> 01:54:27,540
Merge them together-- 0 and 7.
把它们合并在一起——0 和 7。

2635
01:54:27,540 --> 01:54:29,100
Where am I in the story?
我在故事中的什么位置？

2636
01:54:29,100 --> 01:54:33,610
I've sorted the left half and the right half of the original right half.
我已经对左侧部分和原始右侧部分的右侧部分进行了排序。

2637
01:54:33,610 --> 01:54:34,980
So I merge these two together--
所以，我把这两个合并在一起——

2638
01:54:34,980 --> 01:54:38,730
0 and then 2 and then 5 and then 7.
0，然后是 2，然后是 5，然后是 7。

2639
01:54:38,730 --> 01:54:39,360
Whew.
呼。

2640
01:54:39,360 --> 01:54:40,230
Where are we?
我们现在在哪里？

2641
01:54:40,230 --> 01:54:43,080
We're at exactly the point in the story where we had the numbers
我们现在正处在故事中的一个点，在那里我们有这些数字

2642
01:54:43,080 --> 01:54:44,670
originally on the second shelf.
最初在第二层架子上。

2643
01:54:44,670 --> 01:54:48,790
We had a list that's sorted on the left, a list that's sorted on the right.
我们有一个左侧排序的列表，一个右侧排序的列表。

2644
01:54:48,790 --> 01:54:52,840
And what I demoed physically was merging those two together.
我实际演示的是将这两个合并在一起。

2645
01:54:52,840 --> 01:54:54,100
So what happens now?
那么现在会发生什么呢？

2646
01:54:54,100 --> 01:55:00,130
01234567.
01234567。

2647
01:55:00,130 --> 01:55:04,030
And it seems kind of magical and kind of weird in that I kind of cheated.
这看起来有点神奇，也有一点奇怪，因为我有点作弊了。

2648
01:55:04,030 --> 01:55:05,427
And when I had these leaves--
当我拥有这些叶子——

2649
01:55:05,427 --> 01:55:07,510
these leaf nodes, so to speak-- these singletons--
这些叶子节点，你可以这么说——这些单一元素——

2650
01:55:07,510 --> 01:55:08,648
I was, like, sorted.
我已经排序好了。

2651
01:55:08,648 --> 01:55:09,940
I wasn't really doing anything.
我实际上没有做什么。

2652
01:55:09,940 --> 01:55:12,700
But it's that merging that seems to really be doing
但正是这种合并，似乎真正起到了

2653
01:55:12,700 --> 01:55:15,350
the magic of sorting things for us.
为我们对事物进行排序的魔力。

2654
01:55:15,350 --> 01:55:17,380
So that felt like a mouthful.
所以这感觉有点拗口。

2655
01:55:17,380 --> 01:55:19,300
And recursion in general is the kind of thing
而递归总体来说，就是那种会

2656
01:55:19,300 --> 01:55:21,440
that will, like, bend your brain a little bit.
让你稍微想一想的东西。

2657
01:55:21,440 --> 01:55:23,565
And if that went over your head, like, that's fine.
如果这让你摸不着头脑，那也没关系。

2658
01:55:23,565 --> 01:55:25,600
It takes time and time and time and practice.
需要时间，时间，时间，以及练习。

2659
01:55:25,600 --> 01:55:30,550
But what there was not a lot of with this algorithm was again and again
但这个算法中很少出现的是，一次又一次

2660
01:55:30,550 --> 01:55:31,960
and again and again.
一次又一次。

2661
01:55:31,960 --> 01:55:35,080
I was kind of only doing things once.
我实际上只做了一次。

2662
01:55:35,080 --> 01:55:38,150
And then once I fixed a number, I moved on to the next.
然后，一旦我固定了一个数字，我就继续下一个。

2663
01:55:38,150 --> 01:55:40,630
And that's sort of the essence of this algorithm here.
这就是这个算法的本质。

2664
01:55:40,630 --> 01:55:43,480
If it helps you to see it in another visual way,
如果你希望从另一个视觉角度来看，

2665
01:55:43,480 --> 01:55:46,300
let me go back to our previous visualization here.
让我回到我们之前的可视化界面。

2666
01:55:46,300 --> 01:55:48,790
Let me re-randomize the array and click merge sort.
让我重新随机化数组，然后点击合并排序。

2667
01:55:48,790 --> 01:55:51,670
And this time, notice that merge sort is using more space.
这次请注意，合并排序使用了更多空间。

2668
01:55:51,670 --> 01:55:54,970
Technically, I was using 1, 2, 3 shelves.
从技术上讲，我使用了 1、2、3 层架子。

2669
01:55:54,970 --> 01:55:57,400
But you can actually be slightly more intelligent about it
但你实际上可以稍微聪明一点

2670
01:55:57,400 --> 01:56:00,220
and actually just go back and forth and back and forth between two shelves
实际上只需在两层架子之间来回移动

2671
01:56:00,220 --> 01:56:01,390
just to save a little space.
以节省一些空间。

2672
01:56:01,390 --> 01:56:03,320
So you're still using twice as much space.
所以你仍然使用了两倍的空间。

2673
01:56:03,320 --> 01:56:06,190
But you don't need four times as much space as the diagrams
但你不需要四倍于图表

2674
01:56:06,190 --> 01:56:07,670
or as the shelves might imply.
或者架子可能暗示的空间。

2675
01:56:07,670 --> 01:56:09,040
So here is merge sort.
所以这是合并排序。

2676
01:56:09,040 --> 01:56:13,000
And you'll notice that we're sort of working in halves-- sometimes
你会注意到我们是在一半一半地进行——有时

2677
01:56:13,000 --> 01:56:15,070
big halves, sometimes smaller halves.
是大块，有时是小块。

2678
01:56:15,070 --> 01:56:18,370
But you can see as the two halves are merged,
但你可以看到，随着两部分合并，

2679
01:56:18,370 --> 01:56:20,660
things seem to happen very quickly.
事情似乎很快就发生了。

2680
01:56:20,660 --> 01:56:23,860
And so notice that this is the same number of bars as before.
所以请注意，这与之前的条形图数量相同。

2681
01:56:23,860 --> 01:56:25,630
But that was way faster, right?
但是快多了，对吧？

2682
01:56:25,630 --> 01:56:29,050
I don't need to stall nearly as much as I have in the past.
我不需要像过去那样拖延那么多了。

2683
01:56:29,050 --> 01:56:30,260
So why is that?
所以为什么呢？

2684
01:56:30,260 --> 01:56:33,340
Well, if we go back to the diagram in question,
好吧，如果我们回到问题中的图表，

2685
01:56:33,340 --> 01:56:35,210
here's the array that's already sorted.
这里是有序的数组。

2686
01:56:35,210 --> 01:56:38,440
And if we consider now exactly how much work is done,
现在如果我们考虑到底做了多少工作，

2687
01:56:38,440 --> 01:56:41,980
I'll stipulate already it's not n squared. n squared was slow.
我再说一次，它不是n平方。n平方很慢。

2688
01:56:41,980 --> 01:56:44,480
And merge sort is actually much better than that.
而归并排序实际上比那好得多。

2689
01:56:44,480 --> 01:56:46,340
Let's see how much better it is.
让我们看看它有多好。

2690
01:56:46,340 --> 01:56:48,070
So here is the original list--
所以这里是原始列表——

2691
01:56:48,070 --> 01:56:50,740
63415270.
63415270。

2692
01:56:50,740 --> 01:56:54,160
And here are all of the remnants of that algorithm, all of the states
这里都是该算法的所有残留物，所有我们曾经处于的状态

2693
01:56:54,160 --> 01:56:57,520
that we were in at some point-- sort of leaving a whole bunch of breadcrumbs.
我们在某个时间点都曾经处在这个状态——就像留下了一堆面包屑。

2694
01:56:57,520 --> 01:57:01,300
How many pieces of work did I do?
我做了多少工作？

2695
01:57:01,300 --> 01:57:08,810
Well, like, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
嗯，比如，1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17，18，19，

2696
01:57:08,810 --> 01:57:11,470
20, 21, 22, 23, 24.
20，21，22，23，24。

2697
01:57:11,470 --> 01:57:15,370
So I moved things around, like, 24 times, it seems.
所以，我好像移动了24次。

2698
01:57:15,370 --> 01:57:17,830
And how do I actually reason about that?
我该如何推论呢？

2699
01:57:17,830 --> 01:57:19,040
Well, these are the numbers.
好吧，这些是数字。

2700
01:57:19,040 --> 01:57:21,070
This is like my temporary workspace here.
这里就像我的临时工作区。

2701
01:57:21,070 --> 01:57:22,447
And 24 is the literal number.
而24就是字面上的数字。

2702
01:57:22,447 --> 01:57:25,030
But let's see if we can't do things a little more generically.
但让我们看看是否能更通用地做一些事情。

2703
01:57:25,030 --> 01:57:27,790
Log base 2 of n, recall, is what refers to anything
回想一下，以2为底的对数n指的是任何东西

2704
01:57:27,790 --> 01:57:30,492
that we're doing in half-- dividing, dividing, dividing.
我们正在做的一半——分割，分割，分割。

2705
01:57:30,492 --> 01:57:32,200
And that's kind of what I was doing here.
这就是我在这里做的事情。

2706
01:57:32,200 --> 01:57:36,850
I took a list of size 8-- divide it into two of size 4, then four of size 2,
我拿了一个长度为8的列表——把它分成两个长度为4的列表，然后四个长度为2的列表，

2707
01:57:36,850 --> 01:57:38,320
then eight of size 1.
然后八个长度为1的列表。

2708
01:57:38,320 --> 01:57:41,950
Well, how many times can you do this if you start with eight numbers?
好吧，如果你从八个数字开始，你能做多少次呢？

2709
01:57:41,950 --> 01:57:43,600
Well, that's log base 2 of 8.
好吧，那就是以2为底的对数8。

2710
01:57:43,600 --> 01:57:46,990
And if we do some fancy math, that's just log base 2 of 2 to the third.
如果我们做一些复杂的数学运算，它只是以2为底的2的三次方对数。

2711
01:57:46,990 --> 01:57:49,520
And remember, the base and the number here can cancel out.
记住，这里底数和数字可以抵消。

2712
01:57:49,520 --> 01:57:50,710
So that's actually 3.
所以实际上是3。

2713
01:57:50,710 --> 01:57:55,450
So log base 2 of 8 is 3, which means that's how many times you
所以以2为底的对数8是3，这意味着这就是你

2714
01:57:55,450 --> 01:57:59,800
can divide a problem of size 8 in half, in half, in half.
可以将一个长度为8的问题分成两半，再分成两半，再分成两半。

2715
01:57:59,800 --> 01:58:03,760
But every time we did that per this chart, I had to take the numbers
但是根据这张图表，我们每次这样做的时候，我都必须取数字

2716
01:58:03,760 --> 01:58:06,620
and merge them together, merge them together, merge them together.
并把它们合并起来，合并起来，合并起来。

2717
01:58:06,620 --> 01:58:12,010
And so on every row of this postmortem of the algorithm,
因此，在这个算法事后分析的每一行，

2718
01:58:12,010 --> 01:58:16,270
there are n steps, n steps, n steps.
都有n步，n步，n步。

2719
01:58:16,270 --> 01:58:19,660
So laterally, there's n steps because I had to merge all of those things
所以，水平方向上，有n步，因为我必须把所有这些东西

2720
01:58:19,660 --> 01:58:20,570
back together.
合并在一起。

2721
01:58:20,570 --> 01:58:23,140
But what is the height of these yellow remnants?
但是这些黄色残留物的高度是多少呢？

2722
01:58:23,140 --> 01:58:26,650
Well, it's 3, which is log base 2 of 8, which is 3.
好吧，它是3，也就是以2为底的对数8，也就是3。

2723
01:58:26,650 --> 01:58:32,110
So this is technically three times 8, ergo 24 steps.
所以，从技术上讲，它是3乘以8，也就是24步。

2724
01:58:32,110 --> 01:58:39,350
But more generally, this is log n height and n width, so to speak.
但是更一般地来说，我们可以称它为对数n高度和n宽度。

2725
01:58:39,350 --> 01:58:41,770
So the total running time I claim is actually
所以，我声称总运行时间实际上是

2726
01:58:41,770 --> 01:58:46,332
n log n, which it's OK if that doesn't quite gel immediately in your mind,
n log n，如果你没有立刻理解，那也没关系，

2727
01:58:46,332 --> 01:58:48,040
especially if you're rusty on algorithms.
尤其是如果你对算法不熟悉。

2728
01:58:48,040 --> 01:58:51,230
But and we can throw away the base because that's just a constant factor
但是我们可以抛弃底数，因为它只是一个常数因子。

2729
01:58:51,230 --> 01:58:54,770
and with a wave of our hand when we talk about big O notation, merge sort,
当我们谈论大O表示法时，我们挥手示意，并说归并排序，

2730
01:58:54,770 --> 01:59:01,070
I claim is in big O of n log n-- that is, n times log n.
我断言它处于n log n 的大O中，也就是n乘以log n。

2731
01:59:01,070 --> 01:59:05,360
Unfortunately, it is also in omega of n log
不幸的是，它也处于n log 的Ω中

2732
01:59:05,360 --> 01:59:09,680
n, which means that, frankly, bubble sort might sometimes outperform it,
n，这意味着，坦率地说，冒泡排序有时可能比它表现更好，

2733
01:59:09,680 --> 01:59:14,600
at least when the inputs are already sorted or certainly relatively small.
至少当输入已经排序或相对较小时。

2734
01:59:14,600 --> 01:59:16,790
But that's probably OK because in general,
但这可能没关系，因为一般来说，

2735
01:59:16,790 --> 01:59:18,920
data that we're sorting probably isn't very sorted.
我们正在排序的数据可能并没有很好地排序。

2736
01:59:18,920 --> 01:59:20,810
And honestly, we could even half merge sort
老实说，我们甚至可以将归并排序减半

2737
01:59:20,810 --> 01:59:24,500
to just do one pass to check initially, is the whole thing sorted,
只需要进行一次遍历，最初检查整个数据是否排序，

2738
01:59:24,500 --> 01:59:26,212
and then maybe terminate early.
然后可以提前终止。

2739
01:59:26,212 --> 01:59:29,420
So we can maybe massage the algorithm a little better to be a little smarter.
因此，我们可以稍微修改一下算法，让它更聪明一些。

2740
01:59:29,420 --> 01:59:34,240
But fundamentally, merge sort is in theta of n log n,
但从根本上说，归并排序处于n log n 的θ中，

2741
01:59:34,240 --> 01:59:35,240
is how you would say it.
这就是你的说法。

2742
01:59:35,240 --> 01:59:38,210
It's on the order of n times log n steps.
它的阶数是n乘以log n步。

2743
01:59:38,210 --> 01:59:42,950
Now, in terms of that chart, it's strictly higher than linear.
现在，就图表而言，它严格高于线性。

2744
01:59:42,950 --> 01:59:47,550
But it's strictly lower than quadratic-- n and n squared, respectively.
但它严格低于二次函数——分别为n和n平方。

2745
01:59:47,550 --> 01:59:49,530
So it clearly seems to be faster.
所以它显然看起来更快。

2746
01:59:49,530 --> 01:59:51,170
So it's not as good as linear search.
所以它不如线性搜索好。

2747
01:59:51,170 --> 01:59:53,212
And it's definitely not as good as binary search.
而且它肯定不如二分查找好。

2748
01:59:53,212 --> 01:59:58,140
But it's way better than selection sort or bubble sort actually were.
但它比选择排序或冒泡排序要好得多。

2749
01:59:58,140 --> 02:00:00,680
So with that said, we thought we'd conclude
因此，我们想在结尾

2750
02:00:00,680 --> 02:00:03,140
by showing you a final film that's just about
向你展示一部仅关于

2751
02:00:03,140 --> 02:00:08,000
a minute long that compares these actual algorithms and shows them as follows.
一分钟长的电影，它比较了这些实际的算法，并以如下方式展示它们。

2752
02:00:08,000 --> 02:00:12,230
You'll see on the top, the middle, and the bottom, three different algorithms.
你会看到在顶部、中间和底部，三种不同的算法。

2753
02:00:12,230 --> 02:00:14,570
On the top, you will see selection sort.
在顶部，你会看到选择排序。

2754
02:00:14,570 --> 02:00:16,850
On the bottom, you will see bubble sort.
在底部，你会看到冒泡排序。

2755
02:00:16,850 --> 02:00:23,450
And in the middle, you will see and hear an appreciation of what n log n is--
在中间，你会看到并听到对n log n的欣赏——

2756
02:00:23,450 --> 02:00:25,680
a.k.a., merge sort today.
也就是今天的归并排序。

2757
02:00:25,680 --> 02:00:28,200
So if we could dim the lights dramatically,
所以如果我们能将灯光调暗，

2758
02:00:28,200 --> 02:00:31,471
this is n log n vis a vis n squared.
这是n log n与n平方对比。

2759
02:00:31,471 --> 02:00:32,138
[VIDEO PLAYBACK]
[视频播放]

2760
02:00:32,138 --> 02:00:35,126
[MUSIC PLAYING]
[音乐播放]

2761
02:01:37,837 --> 02:01:38,420
[END PLAYBACK]
[播放结束]

2762
02:01:38,420 --> 02:01:40,090
All right, that's it for CS50.
好了，CS50 就到这里。

2763
02:01:40,090 --> 02:01:41,620
We'll see you next time.
我们下次再见。

2764
02:01:41,620 --> 02:01:42,520
[APPLAUSE]
[鼓掌]

2765
02:01:42,520 --> 02:01:45,570
[MUSIC PLAYING]
[音乐播放]
