1
00:00:00,000 --> 00:00:03,493
[INTRIGUING MUSIC]
[引人入胜的音乐]

2
00:01:01,377 --> 00:01:06,220
DAVID MALAN: All right, so this is CS50.
大卫·马兰：好的，这是CS50。

3
00:01:06,220 --> 00:01:09,310
And this is week 1, zero index, so to speak.
这是第一周，从零开始，可以这么说。

4
00:01:09,310 --> 00:01:12,890
And it's not every day that you can say that you've learned a new language,
你并不每天都能说你学会了一门新语言，

5
00:01:12,890 --> 00:01:14,260
but today is that day.
但今天就是那一天。

6
00:01:14,260 --> 00:01:18,010
Today, we explore a more traditional and older language called C.
今天，我们将探索一门更传统和更古老的语言，叫做C。

7
00:01:18,010 --> 00:01:22,450
And rest assured that even if what you're about to see-- no pun intended--
请放心，即使你即将看到的东西，没有双关语的意思，

8
00:01:22,450 --> 00:01:25,420
looks very cryptic, very unusual, particularly if you're
看起来非常神秘，非常不寻常，特别是如果你

9
00:01:25,420 --> 00:01:28,967
among those less comfortable, cling to the ideas from last week,
是那些不太舒服的人，坚持上周的想法，

10
00:01:28,967 --> 00:01:32,050
week zero, wherein we talked about some of those fundamentals of functions
第零周，我们谈了一些关于函数的基本知识

11
00:01:32,050 --> 00:01:35,230
and loops and conditionals, all of which are coming back today.
循环和条件语句，今天都会回来。

12
00:01:35,230 --> 00:01:37,815
Indeed, whereas last week, and with problem set 0,
事实上，上周，还有问题集0，

13
00:01:37,815 --> 00:01:39,940
we focused on learning how to program with Scratch,
我们专注于学习如何用Scratch编程，

14
00:01:39,940 --> 00:01:44,770
which, again, you might have played with as a younger student days back.
同样，你可能在小时候就玩过它。

15
00:01:44,770 --> 00:01:46,870
Today, we focus on C instead.
今天，我们将专注于C语言。

16
00:01:46,870 --> 00:01:50,260
But along the way, we're going to focus, as always, frankly,
但在此过程中，我们将像往常一样，坦率地说，

17
00:01:50,260 --> 00:01:51,850
on learning how to solve problems.
专注于学习如何解决问题。

18
00:01:51,850 --> 00:01:54,820
But among the goals for today and really on an entire class like this
但今天以及像这样的一整门课的目标之一

19
00:01:54,820 --> 00:01:58,610
is just to give you week after week all the more tools for your toolkit,
就是每周给你更多工具，

20
00:01:58,610 --> 00:02:00,680
so to speak, via which to do exactly that.
可以这么说，通过这些工具，就可以做到这一点。

21
00:02:00,680 --> 00:02:03,860
So for instance today, we'll learn how to solve problems all the more
所以比如今天，我们将学习如何更好地解决问题

22
00:02:03,860 --> 00:02:06,420
so with functions, as per last week.
用函数，就像上周一样。

23
00:02:06,420 --> 00:02:07,910
We'll do the same with variables.
我们也会用变量做同样的事情。

24
00:02:07,910 --> 00:02:10,789
We'll do the same with conditionals, with loops, and with more.
我们也会用条件语句、循环以及更多内容做同样的事情。

25
00:02:10,789 --> 00:02:13,190
But we'll also learn at the end of today's class
但我们也会在今天的课程结束时学习

26
00:02:13,190 --> 00:02:14,970
really how not to solve problems.
如何解决不了问题。

27
00:02:14,970 --> 00:02:18,410
It turns out as powerful as Macs, PCs, cell phones are nowadays,
事实证明，如今的Mac、PC、手机再强大，

28
00:02:18,410 --> 00:02:21,890
there's actually certain things that they can't do very well
它们也有一些事情做得不好

29
00:02:21,890 --> 00:02:24,650
and information they can't represent very well.
也有一些信息它们无法很好地表示。

30
00:02:24,650 --> 00:02:28,760
And that actually leads to a lot of real-world problems, both past
这实际上会导致很多现实世界的问题，无论是过去

31
00:02:28,760 --> 00:02:29,940
and surely future.
还是未来。

32
00:02:29,940 --> 00:02:33,540
So more on what we're not going to be able to do with programming before
所以我们将在编程方面无法做到的事情，

33
00:02:33,540 --> 00:02:34,040
long.
过不了多久就会了解。

34
00:02:34,040 --> 00:02:36,600
But beyond that, let's come back to this picture here.
但除此之外，让我们回到这张图片。

35
00:02:36,600 --> 00:02:38,900
So this was the very first program that I wrote,
这是我写的第一个程序，

36
00:02:38,900 --> 00:02:40,880
that you wrote presumably in some form.
你可能也写过类似的程序。

37
00:02:40,880 --> 00:02:43,400
And all it does is say "Hello, world."
它所做的就是说“你好，世界”。

38
00:02:43,400 --> 00:02:47,660
But as promised, today, this puzzle piece, or these puzzle pieces together,
但正如承诺的那样，今天，这块拼图，或者这些拼图加起来，

39
00:02:47,660 --> 00:02:50,880
are going to very quickly start to look more like this.
会很快开始变得更像这样。

40
00:02:50,880 --> 00:02:54,295
And I've deliberately color coded it in a way so that the text on the screen
我故意用颜色编码，让屏幕上的文本

41
00:02:54,295 --> 00:02:55,920
now kind of resembles the puzzle piece.
看起来有点像拼图。

42
00:02:55,920 --> 00:02:59,540
So if I go back, notice that we had this, when green flag clicked puzzle
所以如果我后退，你会注意到，我们有这个，当绿色旗帜被点击时，这个拼图

43
00:02:59,540 --> 00:03:02,780
piece, mostly in yellow with the green flag, that sort of kicks off
大部分是黄色的，上面有绿色的旗帜，它启动了

44
00:03:02,780 --> 00:03:04,550
the whole process once you actually click
整个过程，当你实际上点击

45
00:03:04,550 --> 00:03:07,640
the button at top right of Scratch's user interface.
Scratch用户界面右上角的按钮。

46
00:03:07,640 --> 00:03:11,990
And then there's the purple block which actually is the verb, the action,
然后是紫色的块，它实际上是动词，动作，

47
00:03:11,990 --> 00:03:13,620
the function that does something.
执行某些操作的函数。

48
00:03:13,620 --> 00:03:16,820
So if I bring us back over to what we're about to see today,
所以如果我们回到我们今天将要看到的，

49
00:03:16,820 --> 00:03:20,477
there's going to be some boilerplate, so to speak, some orange text here
将会有一些模板，可以这么说，屏幕上有一些橙色的文本

50
00:03:20,477 --> 00:03:23,060
on the screen that for now you just type and take for granted,
屏幕上，你现在只需输入并默认接受，

51
00:03:23,060 --> 00:03:25,430
like you need to write your code like that.
就像你需要那样写代码。

52
00:03:25,430 --> 00:03:27,435
But more interesting is going to be the purple.
但更有趣的是紫色。

53
00:03:27,435 --> 00:03:29,810
And we're going to see today that the function previously
而我们今天将会看到，之前

54
00:03:29,810 --> 00:03:34,430
called "say" in Scratch is now called "printf" in this language called C.
在Scratch中被称为“say”的函数现在在这门叫做C的语言中被称为“printf”。

55
00:03:34,430 --> 00:03:37,520
But in white here, you'll see similar text to our white oval
但这里用白色，你会看到与上周的白椭圆相似的文本，

56
00:03:37,520 --> 00:03:40,550
last week, whereby that's where user input, like your input
那里是用户输入，就像你的输入

57
00:03:40,550 --> 00:03:42,277
as the programmer, can actually go.
作为程序员，实际上可以去的地方。

58
00:03:42,277 --> 00:03:43,610
So there's a lot of distraction.
所以有很多干扰。

59
00:03:43,610 --> 00:03:44,930
And honestly, it's these kinds of things that
说实话，正是这些事情

60
00:03:44,930 --> 00:03:47,180
tend to distract and get frustrating early on when
在学习编程初期容易让人分心和沮丧。

61
00:03:47,180 --> 00:03:48,780
learning to code for the first time.
第一次学习编程。

62
00:03:48,780 --> 00:03:52,170
But the ideas, most importantly, are going to be the same.
但最重要的想法会是一样的。

63
00:03:52,170 --> 00:03:54,060
So how are we going to go about using this.
那么我们该如何使用它呢？

64
00:03:54,060 --> 00:03:55,910
Well, it turns out, like last week, you're
事实证明，就像上周一样，你

65
00:03:55,910 --> 00:03:58,190
going to start writing something called source code.
将开始编写一些叫做源代码的东西。

66
00:03:58,190 --> 00:04:01,280
So code as we know it, quote, unquote, is more technically called
所以我们所知道的代码，可以这么说，更技术地称为

67
00:04:01,280 --> 00:04:02,060
"source code."
“源代码”。

68
00:04:02,060 --> 00:04:04,460
That's what you and I as humans actually write.
那是我们人类实际编写的。

69
00:04:04,460 --> 00:04:07,350
And indeed it might look a little something like we just saw.
它确实可能看起来有点像我们刚刚看到的。

70
00:04:07,350 --> 00:04:11,090
But unfortunately, computers only speak this, binary--
但不幸的是，计算机只能识别这种语言，二进制，

71
00:04:11,090 --> 00:04:15,660
zeros and ones-- more properly known as machine code, in other words,
零和一，更确切地说，是机器码，换句话说，

72
00:04:15,660 --> 00:04:19,550
those same patterns of zeros and ones last week, someone guessed,
上周，有人猜到，这些相同的零和一的模式，

73
00:04:19,550 --> 00:04:23,090
print out "hello, world" on the screen because one of those patterns
在屏幕上打印出“hello, world”，因为其中一个模式

74
00:04:23,090 --> 00:04:27,570
is an H. Another pattern is an E, an L, and L, and an O, and so forth.
是一个H。另一个模式是E，L，L，O，等等。

75
00:04:27,570 --> 00:04:31,880
And then other patterns of those zeros and ones are commands or instructions
然后，那些零和一的其他模式是命令或指令

76
00:04:31,880 --> 00:04:37,280
to the computer that literally say, show H-E-L-L-O comma "world" on the screen.
对计算机来说，它们实际上就是说，在屏幕上显示H-E-L-L-O逗号“world”。

77
00:04:37,280 --> 00:04:40,520
But machine code would not be nearly as much fun
但机器码写起来远没有那么有趣

78
00:04:40,520 --> 00:04:43,070
to write if it were indeed in zeros and ones.
如果它确实是用零和一写的。

79
00:04:43,070 --> 00:04:45,080
Entirely for us, ideally, you and I are going
完全是为了我们，理想情况下，你和我都将

80
00:04:45,080 --> 00:04:49,100
to write source code, which conceptually is sort of up here, high level.
编写源代码，从概念上讲，它在更高层次。

81
00:04:49,100 --> 00:04:52,790
But we're going to need a program to convert it to the lower-level machine
但我们需要一个程序把它转换成更低级的机器

82
00:04:52,790 --> 00:04:56,240
code so that we don't spend our lives actually having to read and write
代码，这样我们就不必花费一生去读写

83
00:04:56,240 --> 00:04:59,000
zeros and ones, which back in the day, kind of in yesteryear,
零和一，在过去，在往昔，

84
00:04:59,000 --> 00:05:01,160
you kind of did with things called punch cards
你用一种叫做打孔卡的东西来做

85
00:05:01,160 --> 00:05:03,050
and holes on physical sheets of paper.
以及物理纸张上的孔。

86
00:05:03,050 --> 00:05:06,440
We're beyond that because after years and years of innovation,
我们已经超越了这一点，因为经过多年的创新，

87
00:05:06,440 --> 00:05:09,462
folks have given us higher-level languages instead.
人们给了我们更高级的语言。

88
00:05:09,462 --> 00:05:11,420
So here's what we're going to need to do today.
所以今天我们需要做的是：

89
00:05:11,420 --> 00:05:14,900
If at the end of the day you and I are writing source code
如果我们最终编写源代码

90
00:05:14,900 --> 00:05:18,260
but we want machine code as output, we need something
但我们想要机器码作为输出，我们需要一些东西

91
00:05:18,260 --> 00:05:21,900
in the middle that's going to convert that source code to machine code.
在中间，它将把源代码转换为机器代码。

92
00:05:21,900 --> 00:05:23,900
You and I are not going to have to learn or talk
你我都不需要再学习或谈论

93
00:05:23,900 --> 00:05:25,672
about really any more zeros and ones.
任何关于 0 和 1 的东西了。

94
00:05:25,672 --> 00:05:28,880
And the type of program we're going to start using today and introduce you to
我们今天将开始使用并向大家介绍的一种程序类型

95
00:05:28,880 --> 00:05:30,080
is called a compiler.
叫做编译器。

96
00:05:30,080 --> 00:05:34,130
So a compiler is a program that translates one language to another.
所以编译器是一个将一种语言翻译成另一种语言的程序。

97
00:05:34,130 --> 00:05:35,720
And it can be any two languages.
这两种语言可以是任何两种语言。

98
00:05:35,720 --> 00:05:39,770
But today, and often, we'll talk about it in the context of source code
但今天，通常我们会从源代码的角度来谈论它

99
00:05:39,770 --> 00:05:40,890
to machine code.
到机器代码。

100
00:05:40,890 --> 00:05:45,325
So this is Apple or Google or Microsoft or folks from other companies
所以这是苹果、谷歌、微软或其他公司的员工

101
00:05:45,325 --> 00:05:48,200
or even volunteers who have written software that do this conversion.
甚至还有志愿者编写了进行这种转换的软件。

102
00:05:48,200 --> 00:05:51,230
You and I are essentially going to download a free compiler
你我基本上要下载一个免费的编译器

103
00:05:51,230 --> 00:05:55,040
and use it to actually get our computer to understand the source
并用它来让我们的计算机真正理解源

104
00:05:55,040 --> 00:05:58,595
code that you and I write in these higher-level languages.
你我用这些高级语言编写的代码。

105
00:05:58,595 --> 00:05:59,970
So where are we going to do that?
那我们要在哪里做呢？

106
00:05:59,970 --> 00:06:01,845
Well, we could actually give you instructions
嗯，我们可以给你一些指令

107
00:06:01,845 --> 00:06:05,340
and you could download the appropriate free open-source software
你可以下载相应的免费开源软件

108
00:06:05,340 --> 00:06:06,607
onto your own Mac or PC.
到你的 Mac 或 PC 上。

109
00:06:06,607 --> 00:06:09,690
The reality is that creates so many technical support headaches because we
现实情况是，这会造成很多技术支持上的麻烦，因为我们

110
00:06:09,690 --> 00:06:11,280
all have slightly different computers.
每个人都有略微不同的电脑。

111
00:06:11,280 --> 00:06:14,640
We all have slightly different versions of Windows or macOS or Linux
我们每个人都有略微不同的 Windows、macOS 或 Linux 版本

112
00:06:14,640 --> 00:06:15,840
or other operating systems.
或其他操作系统。

113
00:06:15,840 --> 00:06:19,260
And that, too, tends to be a distraction at the beginning of any course
而且这也会成为任何课程开始时的干扰

114
00:06:19,260 --> 00:06:20,730
like this or learning programming.
比如这个课程或学习编程。

115
00:06:20,730 --> 00:06:22,680
So we're going to use the cloud instead.
所以我们打算使用云。

116
00:06:22,680 --> 00:06:28,530
We're going to use a URL of the form https://cs50.dev.
我们将使用 https://cs50.dev 形式的网址。

117
00:06:28,530 --> 00:06:32,040
And what this will do for you is put inside of your browser window
它会为你做的事情是在你的浏览器窗口内

118
00:06:32,040 --> 00:06:36,390
absolutely everything you need for the course, but it's going to use software,
放置你上这门课所需的一切，但它会使用软件，

119
00:06:36,390 --> 00:06:39,810
software called Visual Studio code, otherwise known as VS Code,
名为 Visual Studio Code 的软件，也称为 VS Code，

120
00:06:39,810 --> 00:06:41,730
that's actually free itself.
本身也是免费的。

121
00:06:41,730 --> 00:06:43,200
It's very popular in industry.
它在业界非常流行。

122
00:06:43,200 --> 00:06:45,420
It's what "real" programmers use every day.
这是“真正的”程序员每天使用的工具。

123
00:06:45,420 --> 00:06:47,560
But it's a cloud-based version thereof.
但它是一个基于云的版本。

124
00:06:47,560 --> 00:06:50,250
And so everything will just work for you out of the box.
所以一切都会为你开箱即用。

125
00:06:50,250 --> 00:06:52,530
But toward the end of CS50, the goal is going
但在 CS50 结束时，目标是

126
00:06:52,530 --> 00:06:55,200
to be to get you off of CS50's infrastructure,
让你离开 CS50 的基础设施，

127
00:06:55,200 --> 00:06:59,040
to get you to download this freely available software onto your own Mac
让你下载这个免费提供的软件到你的 Mac 上

128
00:06:59,040 --> 00:07:02,170
or PC if you so choose so that those training wheels, so to speak,
或者如果你选择的话，也可以下载到你的 PC 上，这样那些所谓的辅助轮

129
00:07:02,170 --> 00:07:02,840
can come off.
就可以取下来了。

130
00:07:02,840 --> 00:07:05,170
And then even if you never take another class again,
然后即使你再也不上其他课了，

131
00:07:05,170 --> 00:07:07,780
you don't need any class's infrastructure moving forward.
你也不需要任何课程的基础设施来继续前进。

132
00:07:07,780 --> 00:07:10,960
You'll have everything you want and need on your own Mac or PC.
你将在自己的 Mac 或 PC 上拥有你想要和需要的一切。

133
00:07:10,960 --> 00:07:13,250
But for now, it'll save us a bit of time.
但现在，这会为我们节省一些时间。

134
00:07:13,250 --> 00:07:16,750
So in just a bit, I'm going to go to that URL myself on my computer.
所以过一会儿，我将在自己的电脑上访问这个网址。

135
00:07:16,750 --> 00:07:19,552
And I and you will see a user interface that
我和你将会看到一个用户界面，

136
00:07:19,552 --> 00:07:21,010
looks a little something like this.
看起来有点像这样。

137
00:07:21,010 --> 00:07:23,170
The colors might be different based on your settings.
颜色可能会根据你的设置有所不同。

138
00:07:23,170 --> 00:07:24,800
Fonts might be different, and so forth.
字体也可能不同，等等。

139
00:07:24,800 --> 00:07:27,590
But in general, it consists of a few different regions.
但总的来说，它由几个不同的区域组成。

140
00:07:27,590 --> 00:07:31,750
So over here at the top is where we are going to start writing code today.
所以这里上面是我们今天将开始编写代码的地方。

141
00:07:31,750 --> 00:07:34,930
So it's a tabbed interface like any number of programs nowadays.
所以它是一个带标签的界面，就像如今许多程序一样。

142
00:07:34,930 --> 00:07:38,058
And this is that same C code we saw a moment ago.
而这是我们刚才看到的相同的 C 代码。

143
00:07:38,058 --> 00:07:40,600
So this is where, in a moment, I'm going to start to type it.
所以这里就是我过一会儿将开始输入的地方。

144
00:07:40,600 --> 00:07:43,330
Over here at the bottom is what we're going to call
这里底部是我们即将要称作

145
00:07:43,330 --> 00:07:45,438
a terminal window, or a console.
终端窗口或控制台。

146
00:07:45,438 --> 00:07:47,980
And the terminal window is where we're going to type commands
而终端窗口就是我们用来输入命令的地方

147
00:07:47,980 --> 00:07:50,500
for compiling our code, for running our code.
用来编译我们的代码，用来运行我们的代码。

148
00:07:50,500 --> 00:07:54,860
And we'll see today a contrast between a graphical-user interface,
今天我们将看到图形用户界面

149
00:07:54,860 --> 00:07:57,370
or GUI, which has menus and icons and things
即 GUI 之间的一个对比，GUI 有菜单、图标和一些东西

150
00:07:57,370 --> 00:08:01,270
you click and are very familiar with, versus a command-line interface,
你可以点击它们，你对此非常熟悉，与命令行界面

151
00:08:01,270 --> 00:08:02,200
or CLI.
即 CLI 之间的对比。

152
00:08:02,200 --> 00:08:04,270
And so we're using both of these together.
所以我们一起使用这两个东西。

153
00:08:04,270 --> 00:08:08,007
And command-line interface just means, down here, you only use your keyboard.
命令行界面只是意味着，在这里，你只能使用键盘。

154
00:08:08,007 --> 00:08:10,340
You can click, click, click if you want with your mouse.
你可以用鼠标点击、点击、点击，如果你愿意的话。

155
00:08:10,340 --> 00:08:13,423
It's not going to generally do much because a command-line interface takes
它通常不会做太多，因为命令行界面会接收

156
00:08:13,423 --> 00:08:14,540
commands at the keyboard.
键盘输入的命令。

157
00:08:14,540 --> 00:08:16,840
So in a weird sense, it's going to feel like taking
所以从某种奇怪的角度来说，这会让人感觉像是

158
00:08:16,840 --> 00:08:20,620
a step backwards from the Macs, the PCs, the iPhones, and Android phones we all
从我们每个人使用的 Mac、PC、iPhone 和安卓手机后退了一步，这些手机都是非常图形化的。

159
00:08:20,620 --> 00:08:22,660
have, which are very graphical.
这些手机都是非常图形化的。

160
00:08:22,660 --> 00:08:26,120
But it turns out, once you become a "computer" person or a programmer,
但事实证明，一旦你成为一个“电脑”人或程序员，

161
00:08:26,120 --> 00:08:29,680
you can be a lot more productive, a lot more efficient, I dare say,
你可能会变得更有生产力，更高效，我敢说，

162
00:08:29,680 --> 00:08:31,990
by learning to harness the command-line interface
通过学习驾驭命令行界面

163
00:08:31,990 --> 00:08:35,169
and using both types of interfaces for what each is good at.
并根据每种界面的优点来使用它们。

164
00:08:35,169 --> 00:08:36,730
So more on that in just a bit.
所以我们过一会儿会更多地谈论这个。

165
00:08:36,730 --> 00:08:41,289
Over here at left, you're going to see soon a folder interface like Mac OS
这里左边，你会很快看到一个类似 Mac OS 的文件夹界面

166
00:08:41,289 --> 00:08:45,010
or Windows where any of the files or folders we create in CS50
或 Windows，我们在 CS50 中创建的任何文件或文件夹

167
00:08:45,010 --> 00:08:46,310
are going to end up, as well.
也都会出现在这里。

168
00:08:46,310 --> 00:08:47,990
So it gives you the best of both worlds.
所以它提供了两全其美的选择。

169
00:08:47,990 --> 00:08:51,310
You can point and click on the left, or you can type commands at the bottom,
你可以点击左边，或者在底部输入命令，

170
00:08:51,310 --> 00:08:52,420
as we'll soon see.
正如我们很快就会看到的那样。

171
00:08:52,420 --> 00:08:54,670
And then along here is the so-called activity bar,
然后这里就是所谓的活动栏，

172
00:08:54,670 --> 00:08:58,500
where there's just VS Code-specific features but also CS50-specific
那里有一些 VS Code 特定的功能，但也有 CS50 特定的

173
00:08:58,500 --> 00:08:59,000
features.
功能。

174
00:08:59,000 --> 00:09:01,420
And if you're in your own version of CS50.dev,
如果你在自己的 CS50.dev 版本中，

175
00:09:01,420 --> 00:09:03,580
you click through in the dot dot dot menu
你可以在点、点、点菜单中点击

176
00:09:03,580 --> 00:09:05,320
or zoom out so you can see everything.
或者缩小，以便你能看到所有东西。

177
00:09:05,320 --> 00:09:08,530
You'll see CS50's own rubber duck, virtually speaking,
你会看到 CS50 自己的橡皮鸭，虚拟地说，

178
00:09:08,530 --> 00:09:10,870
that will be there throughout the course to answer
它将在整个课程中陪伴你，来回答

179
00:09:10,870 --> 00:09:13,460
any and all of your questions, as well.
你所有的问题。

180
00:09:13,460 --> 00:09:15,190
So more on that soon, too.
所以我们很快也会更多地谈论这个。

181
00:09:15,190 --> 00:09:18,040
So here's the code that I propose that we write first,
所以这里就是我建议我们首先编写的代码，

182
00:09:18,040 --> 00:09:21,800
just like we wrote our very first Scratch program to say "hello, world."
就像我们编写了第一个 Scratch 程序来输出“hello, world.”一样。

183
00:09:21,800 --> 00:09:23,650
So let's go ahead and do exactly this.
所以让我们继续做 exactly this。

184
00:09:23,650 --> 00:09:25,870
I'm going to switch over to this screen here,
我将切换到这里的这个屏幕，

185
00:09:25,870 --> 00:09:29,980
where I've already logged into CS50.dev on my computer.
我已经在电脑上登录了 CS50.dev。

186
00:09:29,980 --> 00:09:33,760
And just to keep the focus on the code, I've hidden the activity bar.
为了让大家专注于代码，我已经隐藏了活动栏。

187
00:09:33,760 --> 00:09:36,140
I've hidden the File Explorer, so to speak.
也就是说，我已经隐藏了文件资源管理器。

188
00:09:36,140 --> 00:09:39,740
So you're seeing here the area where all of my tabs are about to go
所以你们现在看到的是，所有标签即将出现的地方，

189
00:09:39,740 --> 00:09:42,490
and the terminal window, where all of my commands are going to go.
还有终端窗口，所有命令都将在这里执行。

190
00:09:42,490 --> 00:09:44,710
But I've just simplified the UI to keep our focus
不过我仅仅简化了界面，以便让大家专注于

191
00:09:44,710 --> 00:09:46,910
on the interesting parts for now.
目前有趣的部分。

192
00:09:46,910 --> 00:09:53,140
So how do I go about actually writing and compiling and running some code?
那么，我该如何实际编写、编译和运行一些代码呢？

193
00:09:53,140 --> 00:09:55,690
Well, the teaser is going to be these three steps.
好吧，这三个步骤将会是预告。

194
00:09:55,690 --> 00:09:58,510
One of these is a command called, aptly, Code.
其中一个命令恰当地叫做“Code”。

195
00:09:58,510 --> 00:10:02,260
And Code is just going to let me to open or create a new file,
而“Code”命令可以让我打开或创建新文件，

196
00:10:02,260 --> 00:10:03,930
like a file called "hello.c."
例如，名为“hello.c”的文件。

197
00:10:03,930 --> 00:10:06,960
Make is going to be, for now, my compiler that
“Make”命令目前将是我的编译器，它

198
00:10:06,960 --> 00:10:11,280
allows me to make the program, that is convert source code into machine
允许我创建程序，也就是将源代码转换为机器

199
00:10:11,280 --> 00:10:13,710
code, so from C to zeros and ones.
代码，也就是将 C 代码转换为 0 和 1。

200
00:10:13,710 --> 00:10:15,570
And then weirdly, but we'll soon see why,
然后奇怪的是，不过我们很快就会知道原因，

201
00:10:15,570 --> 00:10:19,810
./hello is going to be the command to run my actual code,
"./hello”命令将用于运行我的实际代码，

202
00:10:19,810 --> 00:10:23,760
so the textual equivalent of like double-clicking on a Mac or a PC icon
这相当于在 Mac 或 PC 上双击图标，

203
00:10:23,760 --> 00:10:25,890
or tapping an icon on your phone.
或者在手机上点击图标。

204
00:10:25,890 --> 00:10:26,670
So that's it.
就是这样。

205
00:10:26,670 --> 00:10:30,810
These three commands are going to allow me to write, to compile, and to run
这三个命令可以让我编写、编译和运行

206
00:10:30,810 --> 00:10:32,070
code ultimately.
代码。

207
00:10:32,070 --> 00:10:33,340
So let's go ahead and do that.
所以让我们开始动手吧。

208
00:10:33,340 --> 00:10:35,170
I'm back in my VS Code interface.
我回到了 VS Code 界面。

209
00:10:35,170 --> 00:10:39,000
I'm going to go ahead and run "code hello.c."
我将运行“code hello.c”命令。

210
00:10:39,000 --> 00:10:40,900
And notice a couple of details here.
请注意这里的一些细节。

211
00:10:40,900 --> 00:10:44,790
So one, there's this weird dollar sign, which has nothing to do with currency,
首先，这个奇怪的美元符号与货币无关，

212
00:10:44,790 --> 00:10:48,000
but it's just a common convention in the programming world
它只是编程领域中的一个常见约定，

213
00:10:48,000 --> 00:10:50,520
to represent your prompt.
用来代表你的提示符。

214
00:10:50,520 --> 00:10:53,190
So if a TF, if I ever say, go to your prompt,
所以如果助教，如果我曾经说过，去你的提示符那里，

215
00:10:53,190 --> 00:10:55,170
we really mean, go to your terminal window.
我们的意思实际上是，去你的终端窗口。

216
00:10:55,170 --> 00:10:56,100
Go to the dollar sign.
去美元符号那里。

217
00:10:56,100 --> 00:10:58,285
And the dollar sign is where you type the command.
美元符号是你在那里输入命令的地方。

218
00:10:58,285 --> 00:11:01,160
Sometimes it's a different symbol, but a dollar sign is conventional.
有时它会是不同的符号，但美元符号是传统的。

219
00:11:01,160 --> 00:11:03,950
Now that I've typed "code" space "hello.c,"
现在我已经输入了“code”空格“hello.c”，

220
00:11:03,950 --> 00:11:05,450
I'm going to go ahead and hit Enter.
我将按下 Enter 键。

221
00:11:05,450 --> 00:11:07,158
And maybe not surprisingly, this gives me
也许并不意外，这给了我

222
00:11:07,158 --> 00:11:10,850
a brand new tab, a new file if you will, called "hello.c."
一个全新的标签，如果你愿意的话，一个名为“hello.c”的新文件。

223
00:11:10,850 --> 00:11:15,290
And just like Word documents have their own file extension, like DOC, DOCX,
就像 Word 文档有自己的文件扩展名，比如 DOC、DOCX，

224
00:11:15,290 --> 00:11:22,050
and Excel files have .XLSX and PDFs have .PDF and GIFs have .GIF and so forth,
而 Excel 文件有 .XLSX，PDF 文件有 .PDF，GIF 文件有 .GIF 等等，

225
00:11:22,050 --> 00:11:26,780
so do C files have a file extension by convention that is .C.
C 文件也按照惯例有一个文件扩展名，即 .C。

226
00:11:26,780 --> 00:11:28,350
Now, a couple of minor points.
现在，几点小细节。

227
00:11:28,350 --> 00:11:30,710
Notice that, by convention, I'm almost always
请注意，按照惯例，我几乎总是

228
00:11:30,710 --> 00:11:32,630
going to name my files in lowercase.
使用小写字母命名我的文件。

229
00:11:32,630 --> 00:11:36,440
By convention, I'm never going to use spaces in my file names.
按照惯例，我永远不会在文件名中使用空格。

230
00:11:36,440 --> 00:11:39,080
And my file extension, too, is going to be lowercase.
我的文件扩展名也是小写的。

231
00:11:39,080 --> 00:11:41,840
Long story short, accidentally hitting the spacebar
长话短说，不小心按了空格键

232
00:11:41,840 --> 00:11:44,180
or using file names with spaces just tends
或者使用带有空格的文件名，这往往会

233
00:11:44,180 --> 00:11:47,130
to make life harder when you're in a command-line environment.
在命令行环境中使生活更加困难。

234
00:11:47,130 --> 00:11:49,530
So just beware silly, stupid things like that.
所以要小心这种愚蠢的事情。

235
00:11:49,530 --> 00:11:51,410
So all lowercase, no spaces for now.
所以现在都是小写，没有空格。

236
00:11:51,410 --> 00:11:54,380
So my cursor is literally blinking because the program
所以我的光标不停地闪烁，因为程序

237
00:11:54,380 --> 00:11:55,825
wants me to write some code.
希望我写一些代码。

238
00:11:55,825 --> 00:11:57,200
I'm going to do this from memory.
我要凭记忆来写。

239
00:11:57,200 --> 00:12:00,607
It'll take you presumably some time to acquire the same instincts.
你可能需要一些时间才能获得同样的直觉。

240
00:12:00,607 --> 00:12:02,940
But I'm going to go ahead and type this first line here,
但我将继续输入这第一行，

241
00:12:02,940 --> 00:12:06,390
pronounced "include standard io.h"--
读作“包含标准输入输出头文件”——

242
00:12:06,390 --> 00:12:07,590
more on that soon--
稍后会详细介绍——

243
00:12:07,590 --> 00:12:11,190
int main(void), with some parentheses thrown in.
int main(void)，包含一些括号。

244
00:12:11,190 --> 00:12:13,740
Notice what's about to happen here is a little interesting.
请注意，这里即将发生的事情有点意思。

245
00:12:13,740 --> 00:12:15,750
In the code I want to type, I want what we'll
在我想输入的代码中，我希望有我们所说的

246
00:12:15,750 --> 00:12:18,210
call curly braces, the sort of squiggles that you
花括号，你并不常在英语中使用的那种波浪线，但它就在

247
00:12:18,210 --> 00:12:20,460
don't use often in English, at least, but are there
你的键盘上某个地方。

248
00:12:20,460 --> 00:12:21,750
on your keyboard somewhere.
它就在你的键盘上某个地方。

249
00:12:21,750 --> 00:12:25,350
But notice what VS Code does, and a lot of programming environments,
但请注意 VS Code 的行为，还有许多编程环境的行为，

250
00:12:25,350 --> 00:12:27,480
is it finishes part of my thought.
它们会完成我的一部分想法。

251
00:12:27,480 --> 00:12:30,330
So I'm only going to type a left curly brace,
所以我只输入一个左花括号，

252
00:12:30,330 --> 00:12:32,950
but notice I actually get two of them.
但请注意，我实际上得到了两个。

253
00:12:32,950 --> 00:12:36,820
And if I hit Enter, notice that not only does it scooch one down a bit,
如果我按下 Enter 键，请注意，它不仅向下移动了一点，

254
00:12:36,820 --> 00:12:40,350
it also indents my cursor because, just like with pseudocode last week,
它还缩进了我的光标，因为，就像上周的伪代码一样，

255
00:12:40,350 --> 00:12:43,320
whenever you're doing something logically that should only
当你逻辑上做一些只有在上面一行执行后才能执行的操作时，类似地，

256
00:12:43,320 --> 00:12:45,930
happen if the thing above it happens, similarly
缩进将成为我们实际编写代码时的重要元素。

257
00:12:45,930 --> 00:12:48,900
is indentation going to be a thing when we actually write code.
所以 VS Code 和类似的程序只是试图为我们节省

258
00:12:48,900 --> 00:12:51,870
So VS Code and programs like it just try to save us
按键次数，这样我就不必浪费时间去按空格键

259
00:12:51,870 --> 00:12:54,450
keystrokes so I don't have to waste time hitting the spacebar
或 Tab 键，或者浪费我的时间。

260
00:12:54,450 --> 00:12:57,900
or hitting Tab or wasting my human time like that.
好的，说了这么多，我将继续

261
00:12:57,900 --> 00:13:00,180
All right, so with that said, I'm going to go ahead
输入最后一行，"printf"，

262
00:13:00,180 --> 00:13:02,430
and type the last of these lines, "printf,"
其中 F 代表“格式化”，后面跟着一个括号。

263
00:13:02,430 --> 00:13:05,860
where the F is going to mean "formatted," and then a parentheses.
请注意，它给了我两个。

264
00:13:05,860 --> 00:13:07,290
And notice it gave me two.
它免费给了我第二个。

265
00:13:07,290 --> 00:13:08,910
It gave me the second one for free.
有时它会弄混。

266
00:13:08,910 --> 00:13:10,270
Sometimes it will get confused.
当然，你可以覆盖它，删除它，然后重新开始。

267
00:13:10,270 --> 00:13:13,560
And you can certainly override this, delete it, and start over.
现在，与 Scratch 不同，在 C 语言中，事实证明

268
00:13:13,560 --> 00:13:16,680
And now, unlike Scratch, in C, It turns out
我需要在任何时候都使用双引号

269
00:13:16,680 --> 00:13:18,870
I'm going to need to use double quotes anytime
使用英语单词或短语，或任何人类语言。

270
00:13:18,870 --> 00:13:22,860
I'm using an English word or phrase or any human language for that matter.
“Hello”逗号“world”。

271
00:13:22,860 --> 00:13:25,050
"Hello" comma "world."
然后，在我的行末，就像英语使用句号一样，

272
00:13:25,050 --> 00:13:29,310
And then at the very end of my line, much like English uses periods,
我在 C 语言中使用分号。

273
00:13:29,310 --> 00:13:32,160
I'm going to use a semicolon in C.
说了这么多，但代码并不多。

274
00:13:32,160 --> 00:13:35,340
So that's a lot of talking, but it's not much coding.
它实际上是六行代码。

275
00:13:35,340 --> 00:13:37,290
It's technically six lines of code.
但说实话，从智力角度来看，唯一有趣的是第五行，

276
00:13:37,290 --> 00:13:40,600
But honestly, the only interesting one intellectually, as we'll soon see,
因为，正如我们很快就会看到的，它相当于那个块。

277
00:13:40,600 --> 00:13:41,670
is really line 5.
现在我要祈祷，希望

278
00:13:41,670 --> 00:13:44,580
Like, that is the equivalent of that, say, block.
Now here's where I'll cross my fingers, hoping

279
00:13:44,580 --> 00:13:46,500
everything will work.
一切都能正常运行。

280
00:13:46,500 --> 00:13:48,750
that I didn't make any typographical errors.
我确保没有打错字。

281
00:13:48,750 --> 00:13:50,700
It's going to automatically save for me.
它会自动帮我保存。

282
00:13:50,700 --> 00:13:53,790
And I'm going to go back to my terminal window where now I'm
我要回到我的终端窗口，我现在要

283
00:13:53,790 --> 00:13:56,670
going to do that second command, "make" space "hello."
执行第二个命令，“make” 空格 “hello”。

284
00:13:56,670 --> 00:14:00,180
Common mistake-- you do not say "make hello.c," because you
常见的错误是 - 你不能说“make hello.c”，因为你

285
00:14:00,180 --> 00:14:01,350
already made that file.
已经创建了那个文件。

286
00:14:01,350 --> 00:14:04,950
You say "make hello," which is the name of the program that in this case I do
你说“make hello”，这是程序的名字，在本例中，我想

287
00:14:04,950 --> 00:14:06,600
want to create.
创建它。

288
00:14:06,600 --> 00:14:07,830
And Make is smart.
Make 很智能。

289
00:14:07,830 --> 00:14:09,550
It's going to look in my folder.
它会查看我的文件夹。

290
00:14:09,550 --> 00:14:12,060
And if it sees a file called "hello.c," it's
如果它看到一个名为“hello.c”的文件，它会

291
00:14:12,060 --> 00:14:14,910
going to convert that source code to machine code
将源代码转换为机器代码

292
00:14:14,910 --> 00:14:18,510
and save the results in a simpler shorter-named file just called
并将结果保存在一个更简单、更短的文件中，名为

293
00:14:18,510 --> 00:14:20,650
"hello," like an icon on your desktop.
“hello”，就像你桌面上的一个图标。

294
00:14:20,650 --> 00:14:22,650
Now, hopefully nothing will happen.
现在，希望不会发生任何事情。

295
00:14:22,650 --> 00:14:25,560
And that is a good thing, quite paradoxically.
这其实是一件好事，虽然听起来很矛盾。

296
00:14:25,560 --> 00:14:28,350
If you do anything wrong when programming, odds are you're
如果你在编程时做错了什么，很有可能你会

297
00:14:28,350 --> 00:14:31,738
going to see one or many more lines of error sort of yelling
看到一两行或更多行的错误信息，像是在向你

298
00:14:31,738 --> 00:14:33,030
at you that you made a mistake.
大声喊叫你犯了一个错误。

299
00:14:33,030 --> 00:14:35,950
Seeing nothing happen is actually a good sign.
什么都没有发生实际上是一个好兆头。

300
00:14:35,950 --> 00:14:40,470
So the last command, to run my code, recall our three steps here.
所以最后一个命令，运行我的代码，回顾一下我们这里的三个步骤。

301
00:14:40,470 --> 00:14:46,260
We've written code to create the file, Make to compile the file from source
我们编写了代码来创建文件，Make 用于将文件从源代码

302
00:14:46,260 --> 00:14:47,140
code to machine code.
转换为机器代码。

303
00:14:47,140 --> 00:14:49,320
So lastly is "./hello."
所以最后是“./hello”。

304
00:14:49,320 --> 00:14:53,130
So this now is the equivalent of my double-clicking on a Mac or PC
所以现在这相当于我在 Mac 或 PC 上双击

305
00:14:53,130 --> 00:14:55,650
or single tapping on a phone.
或在手机上单击。

306
00:14:55,650 --> 00:14:57,360
Enter.
回车。

307
00:14:57,360 --> 00:14:58,893
[SIGHS] So close!
[叹气] 真是太近了！

308
00:14:58,893 --> 00:15:00,060
All right, it's pretty good.
好吧，还不错。

309
00:15:00,060 --> 00:15:02,970
I got the H-E-L-L-O comma space "world."
我得到了 H-E-L-L-O 逗号空格“world”。

310
00:15:02,970 --> 00:15:05,770
But there's something a little stupid about my output.
但是我的输出有一点愚蠢。

311
00:15:05,770 --> 00:15:09,565
What might rub some of you aesthetically the wrong way?
什么可能会让你们中的一些人从美学上感到反感？

312
00:15:09,565 --> 00:15:10,065
Yeah?
是的？

313
00:15:10,065 --> 00:15:11,460
STUDENT: The dollar sign.
学生：美元符号。

314
00:15:11,460 --> 00:15:14,430
DAVID MALAN: Yeah, so the dollar sign looks like I was like, "hello,
David Malan：是的，所以美元符号看起来像是“hello，

315
00:15:14,430 --> 00:15:16,390
world" dollar sign in my output.
world” 美元符号，在我的输出中。

316
00:15:16,390 --> 00:15:21,100
But no, that's just kind of a remnant of my prompt starting with a dollar sign.
但是，这只是我的提示以美元符号开头的一个残余。

317
00:15:21,100 --> 00:15:23,767
And this is a little nitpicky, but this just doesn't feel right,
这有点吹毛求疵，但这确实感觉不对，

318
00:15:23,767 --> 00:15:24,558
doesn't look right.
看起来也不对。

319
00:15:24,558 --> 00:15:25,600
It's not quite correct.
并不完全正确。

320
00:15:25,600 --> 00:15:27,030
So how can I go about fixing this?
那么我该如何解决这个问题呢？

321
00:15:27,030 --> 00:15:29,100
Well, here's where, at least initially, it's
好吧，至少一开始，

322
00:15:29,100 --> 00:15:33,660
going to take some introduction to just new syntax in C to fix this.
需要一些关于 C 语言新语法介绍才能解决这个问题。

323
00:15:33,660 --> 00:15:35,850
The simplest instinct might be to do this.
最简单的本能可能是这样做。

324
00:15:35,850 --> 00:15:37,590
Well, let me just hit Enter like that.
好吧，让我像那样按回车键。

325
00:15:37,590 --> 00:15:40,095
But this should soon, if not already, rub you
但这很快就会让你感到反感，如果不是已经的话，因为一般来说，我们

326
00:15:40,095 --> 00:15:41,970
the wrong way because in general, we're going
会发现，在 C 语言和 Python 语言中

327
00:15:41,970 --> 00:15:44,550
to see that programming in C and in Python
以及其他语言的编程往往是基于行的。

328
00:15:44,550 --> 00:15:46,920
and other languages tends to be line-based.
就像你应该在一行上开始和结束你的想法。

329
00:15:46,920 --> 00:15:49,763
Like, you should really start and finish your thought on one line.
所以如果你习惯于像这样按下回车键

330
00:15:49,763 --> 00:15:51,930
So if you're in the habit of hitting Enter like this
并在下一行结束你的想法，

331
00:15:51,930 --> 00:15:54,360
and finishing your thought on the next line,
通常编程语言不喜欢那样。

332
00:15:54,360 --> 00:15:57,250
generally programming languages don't like that.
所以这实际上不会按预期进行。

333
00:15:57,250 --> 00:16:00,030
So this is, in fact, not going to do what we expect.
为了向你展示，我将执行此操作。

334
00:16:00,030 --> 00:16:02,390
And just to show you as much, I'm going to do this.
让我回到我的终端窗口。

335
00:16:02,390 --> 00:16:04,430
Let me go back to my terminal window here.
我要在做出更改后重新运行“make hello”。

336
00:16:04,430 --> 00:16:07,670
I'm going to rerun "make hello" after making that change.
回车。

337
00:16:07,670 --> 00:16:08,380
Enter.
我们得到了第一个错误输出。

338
00:16:08,380 --> 00:16:11,830
And there we have it, like the first of our erroneous outputs.
它在向我大喊大叫。

339
00:16:11,830 --> 00:16:12,940
And it's yelling at me.
它缺少一个终止字符。

340
00:16:12,940 --> 00:16:15,075
It's missing a terminating character.
这里有一些红色和绿色，吸引着我的注意力。

341
00:16:15,075 --> 00:16:17,950
And there's some red in here, some green, drawing my attention to it.
有时这些错误消息会很直接。

342
00:16:17,950 --> 00:16:20,598
Sometimes these error messages will be straightforward.
有时你需要花点时间才能理解它们。

343
00:16:20,598 --> 00:16:23,390
Sometimes you're going to rack your brain a bit to figure them out.
但现在我已经剧透了。

344
00:16:23,390 --> 00:16:24,970
But for now I've kind of spoiled it.
显然，回车不是正确的解决方案。

345
00:16:24,970 --> 00:16:27,200
Obviously Enter is not the right solution.
让我清理一下我的终端窗口，隐藏那个错误。

346
00:16:27,200 --> 00:16:30,200
So let me clear my terminal window just to hide that error.
让我删除它。

347
00:16:30,200 --> 00:16:32,050
Let me delete this.
让我现在提议在这里添加这个咒语。

348
00:16:32,050 --> 00:16:36,850
And let me propose now that I add this incantation here.
事实证明，反斜杠 n 将是

349
00:16:36,850 --> 00:16:39,610
So backslash n, it turns out, is going to be
确保你的输出结尾处真正有新行的神奇方法。

350
00:16:39,610 --> 00:16:43,000
the sort of magical way of ensuring that you actually get
所以现在我将继续重新运行“make hello”，因为我改变了代码。

351
00:16:43,000 --> 00:16:45,830
a new line at the end of your output.
我需要现在重新转换、重新编译源代码到新的机器。

352
00:16:45,830 --> 00:16:49,930
So let me go ahead now and rerun "make hello," because I've changed my code.
“./hello”。

353
00:16:49,930 --> 00:16:55,390
I need to now reconvert, recompile the source code to new machine.
现在，出现了我本来想要写的规范的“hello, world”程序。

354
00:16:55,390 --> 00:16:56,290
"./hello."
所以现在，不要担心 include。

355
00:16:56,290 --> 00:17:00,580
And now, there is the canonical "hello, world" program
不要担心 standard io。

356
00:17:00,580 --> 00:17:03,330
that I hoped to write in the first place.
不要担心 int 或 main 或 void 或花括号。

357
00:17:03,330 --> 00:17:05,863
So for now, don't worry about the include.
主要关注这里的第 5 行。

358
00:17:05,863 --> 00:17:07,280
Don't worry about the standard io.
在今天和下周，

359
00:17:07,280 --> 00:17:10,369
Don't worry about int or main or void or the curly braces.
我们将开始拆解其他字符

360
00:17:10,369 --> 00:17:12,508
Focus primarily on line 5 here.
这些字符目前你应该直接接受。

361
00:17:12,508 --> 00:17:14,300
And over the course of today and next week,
不过，关于我们刚刚完成的任何步骤，你们有什么问题吗？

362
00:17:14,300 --> 00:17:16,520
we'll start to tease apart the other characters
是的？

363
00:17:16,520 --> 00:17:18,680
that, for now, you should take at face value.
学生：为什么反斜杠 n 在单引号里？

364
00:17:18,680 --> 00:17:22,200
Questions, though, on any of the steps we've just done?
David Malan：当然，为什么反斜杠 n 在引号里面呢？

365
00:17:22,200 --> 00:17:22,700
Yeah?
简而言之，它必须在那里，因为引号里面的内容是你想让 printf

366
00:17:22,700 --> 00:17:27,580
STUDENT: Why is the backslash n inside the apostrophes?
输出到屏幕上的内容。

367
00:17:27,580 --> 00:17:31,940
DAVID MALAN: Sure, why is the backslash n inside of the quotation marks,
所以，如果你想要 printf，这个函数，输出一个新行，

368
00:17:31,940 --> 00:17:32,570
if you will?
它必须包含在你要给它的引号文本中。

369
00:17:32,570 --> 00:17:35,350
So short answer is that's just where it needs
学生：[听不清]

370
00:17:35,350 --> 00:17:40,600
to be because inside of the quotes is the input that you want printf
David Malan：没错。

371
00:17:40,600 --> 00:17:42,320
to output to the screen.
反斜杠 n 是一个特殊的模式，它代表着“printf no”，意思是，好的，我应该

372
00:17:42,320 --> 00:17:46,030
So if you want printf, this function, to output a new line,
将光标移动到下一行。

373
00:17:46,030 --> 00:17:50,470
it must be included in the quoted text that you give it.
好问题。

374
00:17:50,470 --> 00:17:53,555
STUDENT: So the backslash n [INAUDIBLE].
关于这些步骤，还有其他问题吗？

375
00:17:53,555 --> 00:17:54,430
DAVID MALAN: Exactly.


376
00:17:54,430 --> 00:17:58,840
Backslash n is a special pattern that "printf no" means, OK, I should


377
00:17:58,840 --> 00:18:01,060
move the cursor to the next line.


378
00:18:01,060 --> 00:18:02,330
Good question.


379
00:18:02,330 --> 00:18:04,010
Other questions on any of these steps?


380
00:18:04,010 --> 00:18:04,510
Yeah?
嗯？

381
00:18:04,510 --> 00:18:05,562
STUDENT: [INAUDIBLE]
学生：[听不清]

382
00:18:05,562 --> 00:18:06,770
DAVID MALAN: A good question.
好问题。

383
00:18:06,770 --> 00:18:10,120
So what if you actually want to print backslash n?
那么，如果你真的想打印反斜杠 n 呢？

384
00:18:10,120 --> 00:18:12,140
Things get a little tricky there.
事情就有点棘手了。

385
00:18:12,140 --> 00:18:15,920
Let me go ahead and propose that we do this.
让我来提议我们这样做。

386
00:18:15,920 --> 00:18:18,490
So it turns out-- and this is often the case in programming--
结果证明，这在编程中经常发生，

387
00:18:18,490 --> 00:18:20,890
when you want a literal character to appear,
当你想要一个字面字符出现时，

388
00:18:20,890 --> 00:18:23,347
you actually put another backslash in front of it.
你实际上要在它前面放另一个反斜杠。

389
00:18:23,347 --> 00:18:25,430
But this is not going to be something we do often.
但这不是我们经常会做的事情。

390
00:18:25,430 --> 00:18:27,340
But there is in fact a solution to that.
但确实有一个解决方案。

391
00:18:27,340 --> 00:18:30,145
But let me propose that beyond that now we compare it
但让我提议，除此之外，现在我们把它

392
00:18:30,145 --> 00:18:31,520
against what we've actually done.
与我们实际做过的进行比较。

393
00:18:31,520 --> 00:18:35,260
So here is the first Scratch program we wrote with the green flag there.
所以，这是我们用绿色旗帜编写的第一个 Scratch 程序。

394
00:18:35,260 --> 00:18:37,690
Here, recall, is the mental model that I proposed
这里，回想一下，是我提出的思维模型

395
00:18:37,690 --> 00:18:41,950
we have for almost everything we do whereby functions are just
我们对几乎所有事情都持有这个思维模型，函数仅仅是

396
00:18:41,950 --> 00:18:45,820
an implementation, say, in code of algorithms, step-by-step instructions
一个实现，比方说，在代码中实现算法，一步一步的指令

397
00:18:45,820 --> 00:18:47,150
for solving problems.
用于解决问题。

398
00:18:47,150 --> 00:18:49,300
The inputs to functions, recall from last week,
函数的输入，从上周回顾一下，

399
00:18:49,300 --> 00:18:52,330
are called arguments, or in some contexts parameters.
被称为参数，或者在某些情况下被称为参数。

400
00:18:52,330 --> 00:18:55,130
And sometimes functions can have side effects.
有时函数会产生副作用。

401
00:18:55,130 --> 00:18:58,280
Like last time with Scratch, there was the speech bubble
就像上次用 Scratch 一样，有一个气泡

402
00:18:58,280 --> 00:19:00,440
that magically appeared next to the cat's mouth
神奇地出现在猫嘴旁边

403
00:19:00,440 --> 00:19:02,930
as a sort of side effect of using the Say block.
作为使用 Say 模块的一种副作用。

404
00:19:02,930 --> 00:19:07,310
So just like this then, we had the white oval as input.
所以就像这样，我们有一个白色的椭圆作为输入。

405
00:19:07,310 --> 00:19:09,590
The Say block was the function last week.
Say 模块是上周的函数。

406
00:19:09,590 --> 00:19:11,790
And then we had this here, side effect.
然后我们有了这个，副作用。

407
00:19:11,790 --> 00:19:14,550
Well, how do we compare these things left to right?
那么，我们如何从左到右比较这些东西呢？

408
00:19:14,550 --> 00:19:16,010
Well, here's the Say block at left.
好吧，左边是 Say 模块。

409
00:19:16,010 --> 00:19:17,990
Let's compare now to the C code at right.
现在让我们把 C 代码与右边进行比较。

410
00:19:17,990 --> 00:19:22,400
Notice a couple of things to adapt from Scratch to C. Print
注意从 Scratch 到 C 的一些适应之处。Print

411
00:19:22,400 --> 00:19:23,970
is almost the name of the function.
几乎是函数的名称。

412
00:19:23,970 --> 00:19:26,780
It is technically "printf," for reasons we'll eventually see.
技术上来说是 "printf"，原因我们最终会看到。

413
00:19:26,780 --> 00:19:32,210
Notice the parentheses in C are kind of evocative of the oval in Scratch.
注意 C 中的括号让人想起 Scratch 中的椭圆。

414
00:19:32,210 --> 00:19:36,140
And that's probably why MIT chose an oval, because a lot of languages
这可能是 MIT 选择椭圆的原因，因为许多语言

415
00:19:36,140 --> 00:19:37,850
use parentheses in this way.
用这种方式使用括号。

416
00:19:37,850 --> 00:19:42,050
You still write "hello, world" just as we did last week in Scratch.
你仍然像上周在 Scratch 中那样写 "hello, world"。

417
00:19:42,050 --> 00:19:45,800
But per our demo thus far, you do need the double quotes--
但是根据我们迄今为止的演示，你确实需要双引号——

418
00:19:45,800 --> 00:19:49,220
and double quotes, not single quotes-- double quotes on the left and right.
双引号，而不是单引号——左右两边都用双引号。

419
00:19:49,220 --> 00:19:52,580
And in order to get that new line, you need the backslash n.
为了得到那个换行符，你需要反斜杠 n。

420
00:19:52,580 --> 00:19:54,630
And one more thing is missing.
还有一件事是缺失的。

421
00:19:54,630 --> 00:19:55,130
Yeah?
嗯？

422
00:19:55,130 --> 00:19:55,460
STUDENT: Semicolon.
学生：分号。

423
00:19:55,460 --> 00:19:57,920
DAVID MALAN: The semicolon to finish your thought.
分号来结束你的想法。

424
00:19:57,920 --> 00:20:00,020
So all of these sort of stupid things now
所以现在所有这些愚蠢的事情

425
00:20:00,020 --> 00:20:03,395
that honestly you will forget initially if you've never programmed before,
老实说，如果你以前从未编程过，你一开始会忘记这些，

426
00:20:03,395 --> 00:20:05,270
but you'll soon-- within days, within weeks--
但你很快就会——在几天内，在几周内——

427
00:20:05,270 --> 00:20:08,330
develop the muscle memory where all of that stuff just jumps off,
形成肌肉记忆，所有这些东西都会跳出来，

428
00:20:08,330 --> 00:20:10,700
jumps off the page right at you.
直接从页面上跳到你面前。

429
00:20:10,700 --> 00:20:14,420
All right, so this backslash n is generally known,
好的，所以这个反斜杠 n 通常被称为，

430
00:20:14,420 --> 00:20:16,920
just so you know, as an escape sequence.
你知道，作为转义序列。

431
00:20:16,920 --> 00:20:20,420
And so backslash n allows us to specify a character that
所以反斜杠 n 允许我们指定一个字符，

432
00:20:20,420 --> 00:20:21,890
might otherwise be hard to type.
否则可能很难输入。

433
00:20:21,890 --> 00:20:26,150
But let's tease apart some of the other things atop that function already.
但让我们拆解一下该函数顶部的其他一些东西。

434
00:20:26,150 --> 00:20:28,880
So include stdio.h.
所以包含 stdio.h。

435
00:20:28,880 --> 00:20:33,290
It turns out that in C, a lot of the functionality that
事实证明，在 C 中，许多语言自带的功能

436
00:20:33,290 --> 00:20:36,900
comes with the language is tucked away in separate files.
被隐藏在单独的文件中。

437
00:20:36,900 --> 00:20:40,650
So if you want to use certain functions, you have to tell the compiler,
所以如果你想使用某些函数，你必须告诉编译器，

438
00:20:40,650 --> 00:20:43,430
hey, I want to do some standard input and output.
嘿，我想做一些标准输入和输出。

439
00:20:43,430 --> 00:20:45,680
Like, I want to print some things on the screen.
比如，我想在屏幕上打印一些东西。

440
00:20:45,680 --> 00:20:48,980
And that's because, for now, you can think of printf
而那是因为，现在，你可以把 printf 想象成

441
00:20:48,980 --> 00:20:52,340
as living in this file, stdio.h.
住在这个文件里，stdio.h。

442
00:20:52,340 --> 00:20:53,870
That's a bit of a white lie for now.
现在这有点像善意的谎言。

443
00:20:53,870 --> 00:20:57,890
But in stdio.h is essentially a declaration for printf
但在 stdio.h 中，本质上是对 printf 的声明

444
00:20:57,890 --> 00:21:01,820
that will teach the compiler how to print things to the screen.
它将教会编译器如何将东西打印到屏幕上。

445
00:21:01,820 --> 00:21:05,090
So "hash include" here simply tells the compiler
所以这里的 "hash include" 只是告诉编译器

446
00:21:05,090 --> 00:21:07,790
before it does anything else essentially go ahead and find
在它做其他任何事情之前，本质上是去找到

447
00:21:07,790 --> 00:21:10,700
on the local hard drive a file called stdio.h
在本地硬盘上名为 stdio.h 的文件

448
00:21:10,700 --> 00:21:14,330
and copy/paste it there so I know now about printf.
然后将它复制粘贴到那里，这样我就知道 printf 了。

449
00:21:14,330 --> 00:21:19,673
So this thing, this .h file, is what we'll technically call a header file.
所以这个东西，这个 .h 文件，我们从技术上来说把它称为头文件。

450
00:21:19,673 --> 00:21:21,590
And if you've ever heard this word, especially
如果你曾经听到过这个词，尤其是

451
00:21:21,590 --> 00:21:24,800
if you have programmed before, it represents essentially what
如果你以前编程过，它基本上代表着

452
00:21:24,800 --> 00:21:26,390
we'll start calling a library.
我们将开始称之为库。

453
00:21:26,390 --> 00:21:29,330
So a library in the world of programming is just code
所以，在编程世界中，库只是代码

454
00:21:29,330 --> 00:21:31,740
that someone else wrote that you can use.
由其他人编写，你可以使用。

455
00:21:31,740 --> 00:21:33,968
It's usually free and open source, which means
它通常是免费的开源软件，这意味着

456
00:21:33,968 --> 00:21:36,260
you can literally see the code that someone else wrote,
你可以直观地看到其他人编写的代码，

457
00:21:36,260 --> 00:21:37,670
or sometimes you pay for it.
或者有时你需要付费。

458
00:21:37,670 --> 00:21:40,370
Sometimes it's closed source, which maybe Microsoft wrote it.
有时它是闭源软件，比如微软可能编写了它。

459
00:21:40,370 --> 00:21:43,850
They won't show you the code, but they will let you use the zeros and ones.
他们不会向你展示代码，但他们会让你使用这些零和一。

460
00:21:43,850 --> 00:21:46,670
So libraries are super useful because honestly
所以库非常有用，因为老实说

461
00:21:46,670 --> 00:21:49,700
even I don't really know how printf works.
即使我也不知道 printf 是如何工作的。

462
00:21:49,700 --> 00:21:52,340
I've taken for granted for 25 years that if I use printf,
我已经 25 年来理所当然地认为，如果我使用 printf，

463
00:21:52,340 --> 00:21:53,780
stuff prints on the screen.
东西就会打印在屏幕上。

464
00:21:53,780 --> 00:21:56,330
But someone smarter than me had to actually write
但比我更聪明的人必须真正编写

465
00:21:56,330 --> 00:22:00,860
the code in C that figures out how to get the H, the E, the L-L-O, and so
用 C 编写的代码，它弄清楚了如何将 H、E、L-L-O 等等

466
00:22:00,860 --> 00:22:05,320
forth onto the Mac screen, the PC screen, the phone screen, or somewhere
放到 Mac 屏幕、PC 屏幕、手机屏幕或其他地方

467
00:22:05,320 --> 00:22:05,820
else.
其他地方。

468
00:22:05,820 --> 00:22:08,510
So libraries allow us to stand on each other's shoulders
所以库让我们能够站在彼此的肩膀上

469
00:22:08,510 --> 00:22:10,910
and so that someone else can do the hard work,
这样其他人就可以完成艰苦的工作，

470
00:22:10,910 --> 00:22:14,550
and we can now solve problems that are more interesting to us,
而我们现在可以解决对我们来说更有趣的问题，

471
00:22:14,550 --> 00:22:18,060
not the basic commodity stuff that everyone might want in their code.
而不是每个人都可能在他们的代码中需要的基本商品。

472
00:22:18,060 --> 00:22:20,480
So again, library is code that someone else wrote.
所以，库是由其他人编写的代码。

473
00:22:20,480 --> 00:22:23,540
A header file in C is just a file ending in ".h"
C 中的头文件只是一个以 ".h" 结尾的文件

474
00:22:23,540 --> 00:22:25,440
that gives you access to the same.
它让你能够访问相同的东西。

475
00:22:25,440 --> 00:22:28,040
And so for instance, if you to learn more about these,


476
00:22:28,040 --> 00:22:31,410
there are, what are called in the world of programming, manual pages.


477
00:22:31,410 --> 00:22:37,190
And these are textual files, like a documentation of sorts,


478
00:22:37,190 --> 00:22:39,860
via which you can just learn how a function works


479
00:22:39,860 --> 00:22:42,830
or how you can use its inputs or arguments.


480
00:22:42,830 --> 00:22:45,660
The reality is they're written for folks who aren't in CS50.


481
00:22:45,660 --> 00:22:48,410
They're written for folks who aren't just learning how to program.


482
00:22:48,410 --> 00:22:51,330
They're written for and by folks who have been programming for years.


483
00:22:51,330 --> 00:22:53,510
And so frankly, they're a little hard to understand.


484
00:22:53,510 --> 00:22:58,690
And so CS50 has its own version thereof at this URL, manual.cs50.io,


485
00:22:58,690 --> 00:23:03,260
where you'll see not only the official documentation for C, the language,


486
00:23:03,260 --> 00:23:07,360
but also staff-written simplifications in layperson's terms


487
00:23:07,360 --> 00:23:10,720
what all of the various popular functions are, what their inputs,


488
00:23:10,720 --> 00:23:12,130
and what their outputs are.


489
00:23:12,130 --> 00:23:17,990
So for instance, under stdio.h, you can actually go to that website.


490
00:23:17,990 --> 00:23:21,970
You can go to a URL like this, where stdio.h is in there.


491
00:23:21,970 --> 00:23:24,348
And you can actually see the documentation therefore.


492
00:23:24,348 --> 00:23:25,640
So let me go ahead and do this.


493
00:23:25,640 --> 00:23:27,640
I'm going to go ahead in my browser here,


494
00:23:27,640 --> 00:23:31,240
I'm going to go to manual.cs50.io.


495
00:23:31,240 --> 00:23:33,880
And let me go ahead here and select those functions


496
00:23:33,880 --> 00:23:36,220
that are frequently used in CS50.


497
00:23:36,220 --> 00:23:39,820
And under stdio.h, you'll see a bunch of functions,


498
00:23:39,820 --> 00:23:42,730
only one of which we've even discussed called printf.


499
00:23:42,730 --> 00:23:44,560
I'm going to click on printf there.


500
00:23:44,560 --> 00:23:46,573
And you'll see an interface that at first glance


501
00:23:46,573 --> 00:23:48,490
might be a little overwhelming, but it's going


502
00:23:48,490 --> 00:23:50,300
to start to look more and more familiar.


503
00:23:50,300 --> 00:23:54,620
So first of all, you'll see that if you want to use printf under Synopsis,


504
00:23:54,620 --> 00:23:56,690
you need to include this header file.


505
00:23:56,690 --> 00:23:59,960
Like, you literally copy and paste that line into your own code.


506
00:23:59,960 --> 00:24:03,440
You'll also see this, which for now is a bit arcane,


507
00:24:03,440 --> 00:24:07,890
but this is kind of a hint as to what the function is going to look like.


508
00:24:07,890 --> 00:24:09,043
But more on that soon.


509
00:24:09,043 --> 00:24:11,460
But more importantly, you can read a description about it.


510
00:24:11,460 --> 00:24:14,390
And because these descriptions, when you're in less comfortable mode,


511
00:24:14,390 --> 00:24:17,432
are written by me and the course's teaching fellows, teaching assistants,


512
00:24:17,432 --> 00:24:20,970
and course assistants, you'll find them to be much more in layperson's terms.


513
00:24:20,970 --> 00:24:23,340
And so long story short, rely on this site


514
00:24:23,340 --> 00:24:25,580
once you want to learn how to use some function


515
00:24:25,580 --> 00:24:27,960
and also what other functions exist.


516
00:24:27,960 --> 00:24:29,970
In fact, if I go back to the main page here,


517
00:24:29,970 --> 00:24:33,890
you'll see that there are all of these functions like are frequently


518
00:24:33,890 --> 00:24:35,000
used in CS50.


519
00:24:35,000 --> 00:24:37,190
And there's hundreds more that come with C.


520
00:24:37,190 --> 00:24:40,340
But learning a programming language is not about learning all of those


521
00:24:40,340 --> 00:24:45,020
but rather just getting a sense of where you find answers to questions when


522
00:24:45,020 --> 00:24:47,760
you do want to try something new.


523
00:24:47,760 --> 00:24:50,330
But what is important to know for CS50 today


524
00:24:50,330 --> 00:24:55,600
is that we have our own header file called cs50.h which has functions


525
00:24:55,600 --> 00:24:57,910
that we have written just to make life easier


526
00:24:57,910 --> 00:24:59,675
in the first few weeks of the class.


527
00:24:59,675 --> 00:25:02,050
These are training wheels that we'll eventually take off.


528
00:25:02,050 --> 00:25:04,270
But it turns out in C, especially if you've


529
00:25:04,270 --> 00:25:07,120
programmed before, it's actually really hard and annoying just


530
00:25:07,120 --> 00:25:11,900
to get input from users, to get them to type a word or a number or something


531
00:25:11,900 --> 00:25:12,400
else.


532
00:25:12,400 --> 00:25:15,850
Like, C does not make this easy, in part because it's one of the earliest


533
00:25:15,850 --> 00:25:17,800
languages that wasn't zeros and ones.


534
00:25:17,800 --> 00:25:20,050
So you have to do a lot of the heavy lifting yourself.


535
00:25:20,050 --> 00:25:23,200
But we'll put on these training wheels today and for a few weeks


536
00:25:23,200 --> 00:25:28,150
so that we can focus really on the intellectually interesting ideas of C


537
00:25:28,150 --> 00:25:30,970
and programming without getting bogged down in certain weeds


538
00:25:30,970 --> 00:25:33,160
that we will come back to before long.


539
00:25:33,160 --> 00:25:36,820
So for instance, CS50's own documentation is there at that URL.


540
00:25:36,820 --> 00:25:40,550
But within the library are these functions,


541
00:25:40,550 --> 00:25:44,440
a function called get_string to get a string of text.


542
00:25:44,440 --> 00:25:47,330
"String" is a synonym for just text in a programming language.


543
00:25:47,330 --> 00:25:50,170
So get_string will prompt the human for a string of text.


544
00:25:50,170 --> 00:25:52,660
Get_int is shorthand for "get integer," if you


545
00:25:52,660 --> 00:25:54,890
want to get a number from the user.


546
00:25:54,890 --> 00:25:58,550
Get_float is a little more arcane-- get a floating point number,


547
00:25:58,550 --> 00:26:00,780
like a real number with a decimal point in it.


548
00:26:00,780 --> 00:26:03,690
And dot, dot, dot, there are others, as well.


549
00:26:03,690 --> 00:26:08,180
So this is to say within CS50, we've got some user-friendly functions via which


550
00:26:08,180 --> 00:26:09,563
we can actually get some input.


551
00:26:09,563 --> 00:26:12,230
And let's go ahead and use one of these, for instance get_string


552
00:26:12,230 --> 00:26:15,950
because recall that last week our second program in Scratch


553
00:26:15,950 --> 00:26:18,920
was this one here, where we didn't just say "hello, world."


554
00:26:18,920 --> 00:26:21,110
We said "hello, David," or "hello, Carter,"


555
00:26:21,110 --> 00:26:24,590
"hello, Julia," whoever it was typing their name in.


556
00:26:24,590 --> 00:26:28,910
But to do that, we needed this Ask block in Scratch.


557
00:26:28,910 --> 00:26:30,470
And then we used the Say block.


558
00:26:30,470 --> 00:26:34,050
And then we used the Join block to make all of this work.


559
00:26:34,050 --> 00:26:36,352
So let's translate this program now into C


560
00:26:36,352 --> 00:26:39,560
because it's a little more interesting and representative of the kind of code


561
00:26:39,560 --> 00:26:40,670
we'll start to write.


562
00:26:40,670 --> 00:26:42,950
But we need a slightly different mental model.


563
00:26:42,950 --> 00:26:47,450
Still have a function here, which is the implementation in code of an algorithm.


564
00:26:47,450 --> 00:26:49,910
We still have some inputs called arguments.


565
00:26:49,910 --> 00:26:53,330
But previously, I said that the Say block and, in turn,


566
00:26:53,330 --> 00:26:56,870
printf have side effects, which is just something visually, typically,
printf 函数有副作用，这仅仅是在视觉上，通常情况下，

567
00:26:56,870 --> 00:26:58,340
that happens on the screen.
发生在屏幕上。

568
00:26:58,340 --> 00:27:02,900
Other functions actually have, what we called last week, return values.
而其他函数实际上有上周我们提到的返回值。

569
00:27:02,900 --> 00:27:08,540
And this is kind of analogous to a function maybe doing something for you,
这有点类似于一个函数可能为你做一些事情，

570
00:27:08,540 --> 00:27:11,990
writing down the answer on a slip of paper, and then handing you,
将答案写在纸条上，然后递给你，

571
00:27:11,990 --> 00:27:14,180
the programmer, the slip of paper to do whatever
程序员，那张纸条，让你用它去做任何事

572
00:27:14,180 --> 00:27:16,430
you want with it without just broadcasting it
你想要做的事情，而不是只是广播它

573
00:27:16,430 --> 00:27:19,190
to the world with, like, a speech bubble on the screen.
给世界，就像屏幕上的一个对话框。

574
00:27:19,190 --> 00:27:22,610
So a return value is germane for a program like this
所以，对于像这样的程序，返回值是相关的

575
00:27:22,610 --> 00:27:26,960
because recall when we used the Ask block and I typed in my name,
因为回想一下，当我们使用 Ask 块，我输入了我的名字，

576
00:27:26,960 --> 00:27:30,650
where did my name end up initially?
我的名字最初在哪里？

577
00:27:30,650 --> 00:27:32,217
It didn't go on the screen yet.
它还没有出现在屏幕上。

578
00:27:32,217 --> 00:27:33,050
Where did it end up?
它最终在哪里？

579
00:27:33,050 --> 00:27:33,967
STUDENT: In an answer.
学生：在答案里。

580
00:27:33,967 --> 00:27:35,900
DAVID MALAN: In an "answer" puzzle piece.
David Malan: 在一个叫做“答案”的拼图块里。

581
00:27:35,900 --> 00:27:39,320
And that special oval puzzle piece I claimed at the time
我当时说过的那个特殊的椭圆形拼图块

582
00:27:39,320 --> 00:27:43,250
represents a return value, so the metaphorical piece of paper
代表返回值，所以，这个比喻性的纸张

583
00:27:43,250 --> 00:27:46,410
that the answer is written down on so that I can then use it later.
答案被写在了上面，这样我就可以在以后使用它。

584
00:27:46,410 --> 00:27:48,740
So that's what we want to get to now in C,
所以，这就是我们现在在 C 中想要达到的目标，

585
00:27:48,740 --> 00:27:51,832
a return value that I can then do anything I want,
一个返回值，这样我就可以做任何我想做的事情，

586
00:27:51,832 --> 00:27:54,290
whether it's print it to the screen, change it in some way,
无论是把它打印到屏幕上，以某种方式改变它，

587
00:27:54,290 --> 00:27:56,430
save it in a database, or anything else.
把它保存在数据库中，或任何其他事情。

588
00:27:56,430 --> 00:27:58,670
So here, for instance, is what we did with Scratch,
所以，例如，这就是我们用 Scratch 做的事情，

589
00:27:58,670 --> 00:28:02,510
the input to the Say block-- or the Ask block was "what's your name," quote,
对 Say 块的输入——或者 Ask 块是 "what's your name"，引号，

590
00:28:02,510 --> 00:28:03,140
unquote.
引号。

591
00:28:03,140 --> 00:28:05,120
The function, of course, is the Ask function.
当然，这个函数是 Ask 函数。

592
00:28:05,120 --> 00:28:07,310
And the return value was "answer."
返回值是 "answer"。

593
00:28:07,310 --> 00:28:10,880
If we now consider how we might translate this to C,
如果我们现在考虑如何将它翻译成 C 语言，

594
00:28:10,880 --> 00:28:12,770
it's going to look a little weird at first.
它一开始看起来会有点奇怪。

595
00:28:12,770 --> 00:28:15,680
But it's going to follow a pattern today, next week, the week
但是，它将遵循今天，下周，下下周的模式

596
00:28:15,680 --> 00:28:18,090
after any time we do code like this.
我们每次写这种代码时都会遵循这种模式。

597
00:28:18,090 --> 00:28:23,480
So get_string, I claim, is going to be the most analogous function in C
所以，我认为，get_string 将是 C 语言中最类似于 Ask 块的函数

598
00:28:23,480 --> 00:28:24,650
to the Ask block.
Ask 块。

599
00:28:24,650 --> 00:28:28,400
And to be clear, this is a CS50-specific thing, training wheels of sorts.
需要明确的是，这是 CS50 特有的东西，算是辅助工具。

600
00:28:28,400 --> 00:28:31,520
But we'll show you in a few weeks what this function is doing and how you
但是，我们会在几周内向你展示这个函数在做什么，以及如何在你

601
00:28:31,520 --> 00:28:35,750
cannot use it moving forward once you're comfortable with the language itself.
习惯了语言本身之后，不能再使用它。

602
00:28:35,750 --> 00:28:37,820
Notice I've put parentheses, left and right,
注意，我已经放了括号，左括号和右括号，

603
00:28:37,820 --> 00:28:39,950
as sort of a placeholder for user input.
作为用户输入的占位符。

604
00:28:39,950 --> 00:28:43,118
And that user input is going to be "what's your name?"
用户输入将是 "what's your name?"

605
00:28:43,118 --> 00:28:45,410
But I can't just put "what's your name" in parentheses.
但是，我不能仅仅在括号里写 "what's your name"。

606
00:28:45,410 --> 00:28:47,327
What do I minimally need to add in there, too?
我还需要在里面添加什么？

607
00:28:47,327 --> 00:28:48,020
STUDENT: Quotes.
学生：引号。

608
00:28:48,020 --> 00:28:50,353
DAVID MALAN: Yeah, so the double quotes, left and right.
David Malan: 是的，所以要加上双引号，左边的和右边的。

609
00:28:50,353 --> 00:28:52,250
So let me go ahead and add those in.
所以，我加上了。

610
00:28:52,250 --> 00:28:55,040
I left a space here, not for a new line.
我在这里留了一个空格，不是为了换行。

611
00:28:55,040 --> 00:28:56,990
I could move the cursor to the next line.
我可以将光标移动到下一行。

612
00:28:56,990 --> 00:29:00,440
But I minimally at least want to move the cursor at least one space over
但是，我至少想要将光标向右移动至少一个空格

613
00:29:00,440 --> 00:29:03,140
just so it looks pretty, so that when I'm prompted for my name,
这样看起来更漂亮，这样当我被提示输入名字的时候，

614
00:29:03,140 --> 00:29:05,810
there's a space between the question and my answer.
在问题和我的答案之间有一个空格。

615
00:29:05,810 --> 00:29:07,280
But it could also be backslash n.
但也可以是反斜杠 n。

616
00:29:07,280 --> 00:29:09,830
That's just an aesthetic choice on my part.
这仅仅是我的审美选择。

617
00:29:09,830 --> 00:29:14,037
But what do I do with the answer that comes back from get_string?
但是，我该如何处理从 get_string 返回的答案？

618
00:29:14,037 --> 00:29:16,370
This is where the text is going to look different today.
这就是今天文本看起来不同的原因。

619
00:29:16,370 --> 00:29:21,770
In C, you start to use an equals sign from left to right respectively.
在 C 语言中，你开始使用等号，从左到右分别使用。

620
00:29:21,770 --> 00:29:26,540
And on the left, you put the name of the variable in which you
在左边，你放置你要存储返回值的变量名。

621
00:29:26,540 --> 00:29:29,730
want to store that return value.
你想存储那个返回值。

622
00:29:29,730 --> 00:29:32,030
So a return value is kind of a conceptual thing.
所以，返回值是一种概念性的东西。

623
00:29:32,030 --> 00:29:33,900
You can do with it what you want.
你可以随心所欲地使用它。

624
00:29:33,900 --> 00:29:36,590
And if I want to store it longer term in a variable,
如果我想把它长期存储在一个变量中，

625
00:29:36,590 --> 00:29:40,580
like x or y or z in math class, I can just give it a name here-- x
就像数学课上的 x 或 y 或 z 一样，我只需要在这里给它一个名字——x

626
00:29:40,580 --> 00:29:45,410
or y or z or, more reasonably, "answer," or any other English word.
或 y 或 z 或，更合理地，"answer"，或任何其他英文单词。

627
00:29:45,410 --> 00:29:49,850
No spaces, generally lowercase, same heuristics as before, but this means
没有空格，通常是小写字母，与之前相同的启发式方法，但这意味着

628
00:29:49,850 --> 00:29:53,010
now, ask the user, what's their name?
现在，问用户，他们的名字是什么？

629
00:29:53,010 --> 00:29:55,620
Whatever they type in, go ahead and store it from right
无论他们输入什么，请将它从右

630
00:29:55,620 --> 00:29:58,470
to left in this variable called "answer."
到左存储在这个名为 "answer" 的变量中。

631
00:29:58,470 --> 00:29:59,880
But C's not done with us yet.
但 C 还没完。

632
00:29:59,880 --> 00:30:02,130
If you've learned Python or certain other languages,
如果你学过 Python 或其他一些语言，

633
00:30:02,130 --> 00:30:04,470
you'd kind of be done writing code at this point.
你会在此时完成代码的编写。

634
00:30:04,470 --> 00:30:09,840
In C, though, you additionally have to tell the compiler what type of variable
但是，在 C 语言中，你还需要告诉编译器你想要使用哪种类型的变量

635
00:30:09,840 --> 00:30:11,080
you want to use.
你想使用。

636
00:30:11,080 --> 00:30:13,590
So if it's a string of text, you say "string."
所以，如果它是一串文本，你说 "string"。

637
00:30:13,590 --> 00:30:17,668
If it's an integer, a number, you say "int," as we might have seen before.
如果它是一个整数，一个数字，你说 "int"，就像我们之前可能看到的那样。

638
00:30:17,668 --> 00:30:18,960
So it's a little more pedantic.
所以它有点更学究气。

639
00:30:18,960 --> 00:30:22,320
It's more annoying, frankly, the more onus on you and me, the programmers.
坦率地说，它更烦人，更多地依赖于你和我的责任，作为程序员。

640
00:30:22,320 --> 00:30:24,120
But this just helps the compiler know how
但这仅仅是帮助编译器知道如何

641
00:30:24,120 --> 00:30:26,260
to store it in the computer's memory.
把它存储在计算机的内存中。

642
00:30:26,260 --> 00:30:29,838
And I'm so close to being done with this line of code, but what's missing?
我离完成这行代码只有一步之遥了，但是，还缺少什么？

643
00:30:29,838 --> 00:30:30,630
STUDENT: Semicolon.
学生：分号。

644
00:30:30,630 --> 00:30:31,713
DAVID MALAN: So semicolon.
David Malan: 所以是分号。

645
00:30:31,713 --> 00:30:34,980
And mark my words, if you've never programmed before, sometime this week,
记住我的话，如果你以前从未编程过，这周的某个时候，

646
00:30:34,980 --> 00:30:37,290
this semester, you will forget a semicolon.
这学期，你就会忘记分号。

647
00:30:37,290 --> 00:30:38,678
You will raise your hand.
你会举手。

648
00:30:38,678 --> 00:30:41,970
You'll get frustrated because you can't understand why your code's not working.
你会感到沮丧，因为你无法理解为什么你的代码无法工作。

649
00:30:41,970 --> 00:30:44,370
You will run into stupid issues like that.
你会遇到这种愚蠢的问题。

650
00:30:44,370 --> 00:30:46,385
But do take faith that they are stupid issues.
但请相信，它们确实是愚蠢的问题。

651
00:30:46,385 --> 00:30:49,260
It doesn't mean it's not clicking for you or you're not a programmer.
这并不意味着你没有理解，或者你不是程序员。

652
00:30:49,260 --> 00:30:53,020
It just takes time to see these things if it's a new language to you.
如果你对它是一种新的语言，那么需要时间才能看到这些东西。

653
00:30:53,020 --> 00:30:54,960
So there now is my semicolon.
所以，现在是我的分号。

654
00:30:54,960 --> 00:30:58,110
All right, let's go ahead then and do something
好的，我们继续做点什么

655
00:30:58,110 --> 00:31:02,100
with that return value using the second of the big puzzle pieces in Scratch.
用 Scratch 中的第二个大拼图块来处理返回值。

656
00:31:02,100 --> 00:31:06,720
So when I wanted to say, "hello, David," or whatever the human's name is,
所以，当我想说 "hello, David"，或者任何人的名字，

657
00:31:06,720 --> 00:31:09,850
I kind of stacked my puzzle pieces like this.
我将拼图块堆叠起来，像这样。

658
00:31:09,850 --> 00:31:13,350
This is actually similar to Python and maybe some other languages some of you
这实际上与 Python 类似，也许还有一些其他语言，你们中的一些人

659
00:31:13,350 --> 00:31:13,980
have learned.
我们已经学习了。

660
00:31:13,980 --> 00:31:15,990
But C is a little bit different.
但是C语言有点不同。

661
00:31:15,990 --> 00:31:21,750
And the closest analog to this Scratch solution is going to look like this.
而与Scratch解决方案最接近的模拟将看起来像这样。

662
00:31:21,750 --> 00:31:25,080
I still use printf because printf is the equivalent of Say.
我仍然使用printf，因为printf等同于Say。

663
00:31:25,080 --> 00:31:32,022
Inside of my parentheses, I'm going to go ahead and say, weirdly, "hello, %s."
在我的括号内，我将继续说，奇怪的是，“hello，％s”。

664
00:31:32,022 --> 00:31:35,580
So there's no real analog in C of Join.
所以C语言中没有Join的真正模拟。

665
00:31:35,580 --> 00:31:41,970
Instead, there's a way to specially format text using printf, hence the F
相反，有一种方法可以使用printf专门格式化文本，因此F

666
00:31:41,970 --> 00:31:42,900
in "printf."
在“printf”中。

667
00:31:42,900 --> 00:31:45,630
And what you do in printf is you type whatever English word
在printf中，您键入任何英文单词

668
00:31:45,630 --> 00:31:47,280
or human words that you want.
或您想要的单词。

669
00:31:47,280 --> 00:31:50,110
You then use %s a placeholder.
然后使用％s作为占位符。

670
00:31:50,110 --> 00:31:54,450
If you want a string of text to be added to your own text,
如果你想将一串文本添加到你自己的文本中，

671
00:31:54,450 --> 00:31:55,935
you literally write "%s."
你直接写“％s”。

672
00:31:55,935 --> 00:31:59,640
And let me anticipate a question from the crowd-- how do you print out %s?
让我预测一下观众的一个问题——你如何打印出％s？

673
00:31:59,640 --> 00:32:03,690
There's a solution to that, too, if you literally ever want to print out %s.
如果你真的想打印出％s，也有一个解决方案。

674
00:32:03,690 --> 00:32:07,390
But it's deliberately a weird choice of characters
但它故意选择了奇怪的字符

675
00:32:07,390 --> 00:32:10,140
so that the probability that we ever need to type this ourselves
这样我们自己需要输入它的概率

676
00:32:10,140 --> 00:32:12,870
is just low that no one really worries too much about it.
很低，没有人真的太担心它。

677
00:32:12,870 --> 00:32:14,550
All right, but that's not quite enough.
好吧，但这还不够。

678
00:32:14,550 --> 00:32:19,890
In addition to saying "hello", comma, space, placeholder %s--
除了说“hello”，逗号，空格，占位符％s之外——

679
00:32:19,890 --> 00:32:23,880
and just for vocabulary sake, that's a format code.
出于词汇的缘故，这是一个格式代码。

680
00:32:23,880 --> 00:32:26,250
Again, "format" being the F in printf.
再说一遍，“format”是printf中的F。

681
00:32:26,250 --> 00:32:29,010
I still need my double quotes around the whole thing.
我仍然需要在整个东西周围使用双引号。

682
00:32:29,010 --> 00:32:31,290
In this case, to match my previous program,
在这种情况下，为了匹配我之前的程序，

683
00:32:31,290 --> 00:32:33,270
I am going to go ahead and add the backslash n
我将继续添加反斜杠n

684
00:32:33,270 --> 00:32:35,910
to move the cursor to the next line.
将光标移到下一行。

685
00:32:35,910 --> 00:32:39,840
And now I've left a crazy amount of room here, but that's deliberate.
现在我在这里留下了很多空间，但这是故意的。

686
00:32:39,840 --> 00:32:42,240
Does anyone have an instinct for what I'm probably
有没有人直觉地知道我可能

687
00:32:42,240 --> 00:32:47,180
going to want to add after the quotes but still inside of the parentheses?
想要在引号之后但在括号内添加什么？

688
00:32:47,180 --> 00:32:48,310
STUDENT: The answer.
学生：答案。

689
00:32:48,310 --> 00:32:49,840
DAVID MALAN: So answer itself.
大卫·马兰：所以答案本身。

690
00:32:49,840 --> 00:32:54,010
I need to somehow tell printf with a second input,
我需要以某种方式告诉printf用第二个输入，

691
00:32:54,010 --> 00:32:58,870
otherwise known as an argument, what I want to substitute for that %s.
也称为参数，我想用什么来替换那个％s。

692
00:32:58,870 --> 00:33:02,650
And so I put a comma and then the name of the variable
所以我添加了一个逗号，然后是变量的名称

693
00:33:02,650 --> 00:33:06,028
that I want printf to figure out how to plug in here.
我想让printf弄清楚如何在这里插入。

694
00:33:06,028 --> 00:33:09,070
So honestly it's a little annoying, and this is kind of a dated approach.
所以说真的，这有点令人讨厌，这是一种过时的做法。

695
00:33:09,070 --> 00:33:11,620
Newer, more modern languages, like we'll see later
更新、更现代的语言，比如我们稍后会看到的

696
00:33:11,620 --> 00:33:13,630
in the course, Python and JavaScript, actually
在本课程中，Python和JavaScript，实际上

697
00:33:13,630 --> 00:33:15,950
have much more user-friendly ways of doing it.
有更人性化的方法来实现。

698
00:33:15,950 --> 00:33:19,390
But once you wrap your mind around the heuristics, the rules here,
但是一旦你掌握了启发式算法，这里的规则，

699
00:33:19,390 --> 00:33:23,470
it's just formatting a string by plugging in whatever you want
它只是通过插入你想要的任何东西来格式化字符串

700
00:33:23,470 --> 00:33:26,470
into this format string, so to speak.
到这个格式字符串中，可以这么说。

701
00:33:26,470 --> 00:33:28,810
And again, the comma here is important.
再说一遍，这里的逗号很重要。

702
00:33:28,810 --> 00:33:33,220
This signifies that it takes one input at left and a second input at right.
这表示它在左边接受一个输入，在右边接受第二个输入。

703
00:33:33,220 --> 00:33:34,420
But notice this comma.
但是注意这个逗号。

704
00:33:34,420 --> 00:33:35,950
There's technically two commas.
技术上讲有两个逗号。

705
00:33:35,950 --> 00:33:40,480
But I'm not claiming that this function takes three inputs.
但我不是说这个函数接受三个输入。

706
00:33:40,480 --> 00:33:41,680
Why?
为什么？

707
00:33:41,680 --> 00:33:43,975
This comma I'm pointing out doesn't mean the same.
我指出的这个逗号没有相同的含义。

708
00:33:43,975 --> 00:33:46,690
STUDENT: It's because that comma's part of the quotation marks
学生：因为那个逗号是引号的一部分

709
00:33:46,690 --> 00:33:48,070
and it's been part of the string.
并且它是字符串的一部分。

710
00:33:48,070 --> 00:33:48,700
DAVID MALAN: Exactly.
大卫·马兰：没错。

711
00:33:48,700 --> 00:33:51,867
This comma that I'm pointing to is part of the quotation marks and therefore
我指的这个逗号是引号的一部分，因此

712
00:33:51,867 --> 00:33:53,910
part of my string of English text.
是我英文文本的一部分。

713
00:33:53,910 --> 00:33:55,400
So this is just English grammar.
所以这只是英语语法。

714
00:33:55,400 --> 00:33:57,140
This is sort of C syntax.
这是C语言的语法。

715
00:33:57,140 --> 00:33:59,810
And again, these are the sort of annoying little details
再说一遍，这些都是令人讨厌的小细节

716
00:33:59,810 --> 00:34:03,795
that we're using the same symbol for different things, but context matters.
我们用相同的符号来表示不同的东西，但上下文很重要。

717
00:34:03,795 --> 00:34:06,170
So just stare at your code, look carefully left to right,
所以仔细看你的代码，从左到右仔细看，

718
00:34:06,170 --> 00:34:10,080
and generally the answer will pop out, no pun intended.
通常答案会跳出来，没有双关语。

719
00:34:10,080 --> 00:34:13,244
OK, questions now on this syntax before we actually write it and run it?
好的，现在在我们实际编写和运行它之前，关于这个语法的问题？

720
00:34:13,244 --> 00:34:13,744
Yeah?
是的？

721
00:34:13,744 --> 00:34:18,290
STUDENT: Why is the backslash n not after the answer?
学生：为什么反斜杠n不在答案之后？

722
00:34:18,290 --> 00:34:20,940
DAVID MALAN: Why is the backslash n not after the answer?
大卫·马兰：为什么反斜杠n不在答案之后？

723
00:34:20,940 --> 00:34:24,230
So the way functions work, including printf,
所以函数的工作方式，包括printf，

724
00:34:24,230 --> 00:34:28,310
is that you pass to them one argument inside of the parentheses.
就是你把一个参数传递给它们，放在括号里面。

725
00:34:28,310 --> 00:34:32,690
And then if you have a second argument, you put it after this comma here.
然后，如果你有一个第二个参数，你把它放在这个逗号之后。

726
00:34:32,690 --> 00:34:36,920
But the way printf works is that its first argument is always a string
但是printf的工作方式是它的第一个参数总是一个字符串

727
00:34:36,920 --> 00:34:39,330
that you want to be formatted for you.
你想要被格式化的。

728
00:34:39,330 --> 00:34:43,340
So anything you want printed on the screen has to go in those quotes.
所以你想在屏幕上打印的任何东西都必须放在这些引号中。

729
00:34:43,340 --> 00:34:45,560
And you can perhaps extrapolate from this.
你可以从这里推断出来。

730
00:34:45,560 --> 00:34:50,389
If I actually wanted to say multiple things in this sentence, so "hello,"
如果我实际上想在这句话中说很多东西，比如“hello”，

731
00:34:50,389 --> 00:34:55,670
maybe first name, last name, I could actually do "hello" comma, %s, space,
可能是名字，姓氏，我实际上可以写“hello”逗号，％s，空格，

732
00:34:55,670 --> 00:34:59,960
%s, if I had two variables, one called First Name, one called Last Name.
％s，如果我有两个变量，一个叫名字，一个叫姓氏。

733
00:34:59,960 --> 00:35:04,890
But then I would need another comma for a third input to the function.
但是，我需要另一个逗号作为函数的第三个输入。

734
00:35:04,890 --> 00:35:07,790
And so it's very general purpose in that sense.
因此，从这个意义上来说，它非常通用。

735
00:35:07,790 --> 00:35:08,720
Questions?
问题？

736
00:35:08,720 --> 00:35:09,702
Yeah?
是的？

737
00:35:09,702 --> 00:35:15,370
STUDENT: Can you abstract this further by [INAUDIBLE] the "hello" [INAUDIBLE]??
学生：你可以通过[听不清]“hello”[听不清]进一步抽象吗？

738
00:35:15,370 --> 00:35:19,870
DAVID MALAN: OK, so can you abstract away the format string itself, "hello,"
大卫·马兰：好的，所以你可以抽象掉格式字符串本身，“hello”，

739
00:35:19,870 --> 00:35:20,560
comma answer?
逗号答案？

740
00:35:20,560 --> 00:35:23,770
Short answer, yes, but not nearly as easily in C
简短的回答是，是的，但在C语言中并不像其他语言那样容易

741
00:35:23,770 --> 00:35:25,280
as you can in other languages.
就像你在其他语言中可以做到的那样。

742
00:35:25,280 --> 00:35:26,920
So that's why we're keeping it simple for now.
所以我们现在把它保持简单。

743
00:35:26,920 --> 00:35:29,200
But you're going to love something like Python or JavaScript,
但你会喜欢像Python或JavaScript这样的东西，

744
00:35:29,200 --> 00:35:31,090
where a lot of this complexity goes away.
在那里，很多复杂性都消失了。

745
00:35:31,090 --> 00:35:34,300
But you'll see also in Python and JavaScript and other languages,
但你也会在Python、JavaScript和其他语言中看到，

746
00:35:34,300 --> 00:35:37,610
they still are inspired by syntax like this.
它们仍然受到像这样的语法的启发。

747
00:35:37,610 --> 00:35:41,350
So just understanding it now will be useful for multiple languages
所以现在理解它将对多种语言有用

748
00:35:41,350 --> 00:35:42,670
down the line.
在未来。

749
00:35:42,670 --> 00:35:45,190
All right, so let's actually do something with this code
好吧，所以我们实际上用这段代码做点什么

750
00:35:45,190 --> 00:35:48,670
rather than just talk about what it might be doing for us.
而不是仅仅讨论它可能为我们做了什么。

751
00:35:48,670 --> 00:35:52,400
Let me go over to, for instance, VS Code again.
让我再次回到VS Code。

752
00:35:52,400 --> 00:35:56,920
And I'm going to go ahead now and remove this middle line of printf.
现在我将继续删除这行中间的printf。

753
00:35:56,920 --> 00:35:59,337
I'm still in my same file called "hello.c."
我仍然在我的同一个名为“hello.c”的文件中。

754
00:35:59,337 --> 00:36:02,170
I'm going to clear my terminal window just to eliminate distraction.
我将清除我的终端窗口，以消除干扰。

755
00:36:02,170 --> 00:36:04,097
And to do that, I can literally type "clear."
要做到这一点，我实际上可以键入“clear”。

756
00:36:04,097 --> 00:36:05,680
But this is just for aesthetic's sake.
但这仅仅是为了美观。

757
00:36:05,680 --> 00:36:07,240
That's not functionally that useful.
从功能上来说，这并不是那么有用。

758
00:36:07,240 --> 00:36:10,363
Or you can hit Control L to achieve the same on your keyboard.
或者，你可以在键盘上按住Ctrl+L来实现相同的效果。

759
00:36:10,363 --> 00:36:13,030
But I'm going to go back to line 5 here, where I previously just
但我要回到这里第5行，我之前只是

760
00:36:13,030 --> 00:36:14,990
said "hello, world."
说了“hello, world”。

761
00:36:14,990 --> 00:36:17,390
And I'm going to do this instead.
我打算这样做。

762
00:36:17,390 --> 00:36:20,330
I'm going to give myself a variable called string.
我要给自己一个叫做string的变量。

763
00:36:20,330 --> 00:36:22,760
Sorry, I'm going to give myself a variable called
对不起，我打算给自己一个叫做

764
00:36:22,760 --> 00:36:25,280
answer, the type of which is string.
answer 的变量，它的类型是string。

765
00:36:25,280 --> 00:36:28,220
I'm going to set it equal to whatever the return
我将把它设置为get_string函数的返回值，并询问一个英文问题“你叫什么名字？”

766
00:36:28,220 --> 00:36:33,290
value is of get_string, asking an English question, "what's your name?"
在问题的末尾，只留一个空格，以便将光标移到下一个位置，

767
00:36:33,290 --> 00:36:36,290
with just a single space just to move the cursor over,
然后加一个分号。

768
00:36:36,290 --> 00:36:38,430
followed by a semicolon.
接着，我将继续输入printf，双引号，

769
00:36:38,430 --> 00:36:41,300
Then I'm going to go ahead and say printf, quote,
双引号，“hello，占位符，反斜杠n，”

770
00:36:41,300 --> 00:36:48,680
unquote, "hello, placeholder, backslash n,"
逗号，然后这里又应该放什么呢？

771
00:36:48,680 --> 00:36:50,900
comma, and then what goes here again?
学生：Answer

772
00:36:50,900 --> 00:36:51,680
STUDENT: Answer.
大卫·马兰：答案应该放在这里。

773
00:36:51,680 --> 00:36:53,420
DAVID MALAN: This is where answer goes.
然后，我只需要在右侧加上一个分号。

774
00:36:53,420 --> 00:36:56,430
And then I just need a semicolon on the right of that.
但我认为现在我已经完成了。

775
00:36:56,430 --> 00:36:58,042
But I think now that I'm done.
但是，让我指出一些细节。

776
00:36:58,042 --> 00:36:59,750
But let me point out a couple of details.
它变得非常丰富多彩，非常漂亮。

777
00:36:59,750 --> 00:37:01,940
This got very colorful, very pretty quickly.
而且它不像我之前在屏幕上看到的黑白代码。

778
00:37:01,940 --> 00:37:05,610
And it's not like the black and white code I had on the screen a moment ago.
这是因为像VS Code这样的程序为我们做的事情是“美化”打印，

779
00:37:05,610 --> 00:37:10,160
This is because what programs like VS Code do for us is it "pretty" prints,
或者更确切地说，它为我们对代码进行语法高亮显示。

780
00:37:10,160 --> 00:37:13,980
or rather it syntax highlights our code for us.
语法高亮显示意味着只需在代码中添加一些颜色，

781
00:37:13,980 --> 00:37:17,060
So syntax highlighting means just add some colors to the code
这样不同的想法就会脱颖而出。

782
00:37:17,060 --> 00:37:19,080
so that different ideas pop out.
你会注意到，例如，这里的printf，这里的get_string

783
00:37:19,080 --> 00:37:22,760
So you'll notice, for instance, that printf here, get_string here
都是紫色的，因为它们代表函数，就像Say块一样。

784
00:37:22,760 --> 00:37:26,210
are in purple because they represent functions, just like the Say block.
这里，“你叫什么名字？”，引号，引号，在VS Code中

785
00:37:26,210 --> 00:37:28,460
Here, "what's your name?", quote, unquote, in VS Code
是浅蓝色而不是白色。

786
00:37:28,460 --> 00:37:29,990
is a light blue instead of white.
但如果我在其他地方使用文本字符串，它仍然会保持一致。

787
00:37:29,990 --> 00:37:33,230
But it's still going to be consistent if I use strings of text elsewhere,
同样。

788
00:37:33,230 --> 00:37:33,810
as well.
我并没有输入任何特殊的内容。

789
00:37:33,810 --> 00:37:35,453
So I didn't type anything special.
这不像Microsoft Word或Google Docs。

790
00:37:35,453 --> 00:37:37,370
This isn't like Microsoft Word or Google Docs,
我不会在那里高亮显示并更改事物的颜色。

791
00:37:37,370 --> 00:37:39,578
where I'm highlighting and changing colors of things.
这一切都是自动发生的。

792
00:37:39,578 --> 00:37:41,180
This is all happening automatically.
但它只是Unicode文本。

793
00:37:41,180 --> 00:37:44,060
But it's just unicode text.
它只是被自动解释，

794
00:37:44,060 --> 00:37:46,340
It's just being interpreted automatically
并应用这些颜色，以便事物在视觉上更加突出。

795
00:37:46,340 --> 00:37:51,080
and having these colors applied so that things pop out more usefully visually.
现在，我不小心犯了一个错误。

796
00:37:51,080 --> 00:37:52,985
Now, I've unfortunately made a mistake.
但我将故意诱发这个错误，因为你也会犯同样的错误。

797
00:37:52,985 --> 00:37:55,610
But I'm going to deliberately induce this one because you, too,
我将继续运行“make hello”。

798
00:37:55,610 --> 00:37:57,130
will probably make this mistake.
因为我已经更改了代码。

799
00:37:57,130 --> 00:37:58,880
I'm going to go ahead and run "make hello"
所以我必须从新源代码生成机器代码。

800
00:37:58,880 --> 00:38:00,380
again, because I've changed my code.
但不幸的是，当我按下Enter键时，我的天哪，

801
00:38:00,380 --> 00:38:03,740
So I have to regenerate the machine code from the new source code.
错误甚至无法显示在屏幕上。

802
00:38:03,740 --> 00:38:06,950
But unfortunately, when I hit Enter now, my God,
所以我把这个放大一点。

803
00:38:06,950 --> 00:38:08,790
the errors don't even fit on the screen.
我将点击这里的小插入符符号，

804
00:38:08,790 --> 00:38:09,990
So let me make this bigger.
只是为了让我的终端窗口短暂地变大一些。

805
00:38:09,990 --> 00:38:12,157
I'm going to click the little caret symbol here just
你会看到，错误行比我实际编写的代码行还要多。

806
00:38:12,157 --> 00:38:14,360
to make my terminal bigger for just a moment.
而且这些错误常常以一种相当晦涩难懂的方式写出来，又是针对那些编写代码已经10、20年的程序员。

807
00:38:14,360 --> 00:38:17,090
And you'll see that there's more lines of errors
但有一些细节映入眼帘。

808
00:38:17,090 --> 00:38:19,370
than there are of code that I actually wrote,
所以请注意，问题绝对出在hello.c。

809
00:38:19,370 --> 00:38:22,730
often which is written pretty arcanely, again, for programmers who've
太好了，是我的错误。这里的语法意味着第5行是问题所在。

810
00:38:22,730 --> 00:38:24,830
been writing code for 10, 20 years.
接下来的5表示第5个字符。

811
00:38:24,830 --> 00:38:27,210
But there are some details that pop out.
所以你可以通过定位第5行，

812
00:38:27,210 --> 00:38:30,620
So notice the problem is definitely with hello.c.
然后向右移动5个字符，来确定你的错误所在，它就在这个区域。

813
00:38:30,620 --> 00:38:36,180
So great, it is my fault. This syntax here means that line 5 is the problem.
具体来说，“该区域是使用未声明的标识符字符串”。

814
00:38:36,180 --> 00:38:38,810
And this next 5 means character 5.
你是想说标准输入吗？

815
00:38:38,810 --> 00:38:42,860
So you can literally triangulate your bug, your mistake by going to line 5
我不认为我想说的是这个。

816
00:38:42,860 --> 00:38:45,440
and then over five, and it's somewhere in that area.
就像，我确实想要string，然后这里还有一些其他的复杂情况。

817
00:38:45,440 --> 00:38:49,280
Specifically, "the area is use of undeclared identifier string.
但这里重要的是，并非这个错误的具体内容，而是它真的

818
00:38:49,280 --> 00:38:51,320
Did you mean standard in?"
无法识别“string”或“get_string”这两个词。

819
00:38:51,320 --> 00:38:52,460
I don't think I did.
那么，这可能是为什么呢？

820
00:38:52,460 --> 00:38:56,120
Like, I do want string, and then there's some other complexity here.
是的？

821
00:38:56,120 --> 00:39:00,860
But what's important here is not the specifics of this error but really
学生：你说为了[听不清]

822
00:39:00,860 --> 00:39:04,010
the implication that it doesn't recognize the word
大卫·马兰：没错。

823
00:39:04,010 --> 00:39:06,590
"string" or "get_string."
因为我们正在使用get_string，我声称

824
00:39:06,590 --> 00:39:08,355
Now, why might this be?
它是CS50中我们会用几周的东西，

825
00:39:08,355 --> 00:39:08,855
Yeah?
C语言本身并不支持它。

826
00:39:08,855 --> 00:39:14,195
STUDENT: You said that in order to [INAUDIBLE]
我必须告诉编译器get_string的存在，

827
00:39:14,195 --> 00:39:15,070
DAVID MALAN: Exactly.
就像我通过包含适当的头文件告诉编译器printf的存在一样。

828
00:39:15,070 --> 00:39:17,740
Because we are using get_string, which I claimed
在这种情况下，很简单，它被称为includeCS50.h。

829
00:39:17,740 --> 00:39:19,930
is a CS50 thing that we'll use for a few weeks,
现在，它告诉编译器，哦，其他人

830
00:39:19,930 --> 00:39:22,910
C does not know about it out of the box, so to speak.
已经写了这个函数，get_string，以及这个叫做string的变量类型。

831
00:39:22,910 --> 00:39:26,080
I have to teach the compiler that get_string exists,
所以现在如果我回到我的终端窗口，

832
00:39:26,080 --> 00:39:29,620
just like I taught the compiler that printf exists by including
并重新运行完全相同的命令“make hello”——也许祈祷一下——

833
00:39:29,620 --> 00:39:31,010
the appropriate header file.
现在事实上没有任何问题，因为编译器

834
00:39:31,010 --> 00:39:35,200
And in this case, quite simply, it's called includeCS50.h.
已经了解了它需要的所有功能。

835
00:39:35,200 --> 00:39:38,890
That now teaches the compiler, oh, someone else
现在如果我执行./hello，回车，它出现了，你叫什么名字？

836
00:39:38,890 --> 00:39:42,220
wrote this function already, get_string, and with it this type of variable
请注意，光标向前移动了一个空格，

837
00:39:42,220 --> 00:39:43,190
called "string."
因为我认为这样比将光标放在问号旁边更美观。

838
00:39:43,190 --> 00:39:45,430
So now if I go back to my terminal window
我输入D-A-V-I-D，然后回车。

839
00:39:45,430 --> 00:39:49,510
and rerun the exact same command, "make hello"-- maybe crossing my fingers--
然后，“hello，David”。

840
00:39:49,510 --> 00:39:52,060
now nothing in fact goes wrong because the compiler
到目前为止，关于这段代码你有什么问题吗？

841
00:39:52,060 --> 00:39:55,210
has been brought up to speed with all of the functionality it needs.
有问题吗？

842
00:39:55,210 --> 00:39:59,410
And now if I do ./hello, Enter, there it is, what's my name?
任何代码都可以。

843
00:39:59,410 --> 00:40:01,330
And notice the cursor is one space over just
没有？

844
00:40:01,330 --> 00:40:03,550
because I thought that looked prettier than having the cursor right


845
00:40:03,550 --> 00:40:05,110
next to the question mark.


846
00:40:05,110 --> 00:40:07,840
D-A-V-I-D as my input, and Enter.


847
00:40:07,840 --> 00:40:11,890
And "hello, David."


848
00:40:11,890 --> 00:40:16,780
Questions on any of this code thus far?


849
00:40:16,780 --> 00:40:18,630
Questions?


850
00:40:18,630 --> 00:40:20,800
Any of the code.


851
00:40:20,800 --> 00:40:21,370
No?


852
00:40:21,370 --> 00:40:25,630
All right, so let's introduce some other functionality into the mix.
好的，让我们在其中加入一些其他功能。

853
00:40:25,630 --> 00:40:28,570
It turns out that there are other types of data,
事实证明，世界上还有其他类型的数据，

854
00:40:28,570 --> 00:40:31,270
other types of variables in the world, not just strings
其他类型的变量，不仅仅是字符串，

855
00:40:31,270 --> 00:40:33,790
but indeed, per before, we have things called
但实际上，正如之前所说，我们有一些东西被称为

856
00:40:33,790 --> 00:40:38,260
integers, "int" for short, floating point values, "float" for short,
整数，简称为 "int"，浮点数，简称为 "float"，

857
00:40:38,260 --> 00:40:39,590
and a few others as well.
还有其他一些。

858
00:40:39,590 --> 00:40:41,530
So rather than only focus on string, let's
所以，与其只关注字符串，让我们

859
00:40:41,530 --> 00:40:43,330
get a little more interesting with numbers
用数字变得更有趣一些

860
00:40:43,330 --> 00:40:46,660
here and see what we can do with something like integers, again
这里，看看我们可以用整数做些什么，再一次

861
00:40:46,660 --> 00:40:51,130
"int" for short, by taking a look at not get_string, as before, but now
简称为 "int"，不再像之前那样看 get_string，而是现在

862
00:40:51,130 --> 00:40:52,630
how about get_int.
试试 get_int 如何。

863
00:40:52,630 --> 00:40:56,110
And for this, I'm going to give us a few other tools in our toolkit,
为此，我将在我们的工具箱中提供一些其他工具，

864
00:40:56,110 --> 00:40:59,986
those format codes to which I alluded earlier, like %s,
我之前提到的那些格式代码，比如 %s，

865
00:40:59,986 --> 00:41:01,640
fortunately are pretty straightforward.
幸运的是，它们非常简单直观。

866
00:41:01,640 --> 00:41:04,930
And here is a list of most of the popular format codes
这里列出了您在使用 printf 时可能需要用到的大多数常用格式代码

867
00:41:04,930 --> 00:41:07,510
that you might ever care about with printf.
您可能在使用 printf 时需要用到的大多数常用格式代码。

868
00:41:07,510 --> 00:41:10,180
In particular, we saw %s for string.
特别是，我们看到了用于字符串的 %s。

869
00:41:10,180 --> 00:41:13,060
And you can perhaps guess which one we're going to use for integers.
也许您能猜到我们会用哪一个来表示整数。

870
00:41:13,060 --> 00:41:13,932
STUDENT: %i.
学生：%i。

871
00:41:13,932 --> 00:41:16,640
DAVID MALAN: Yeah, so %i is what we're going to use for integers.
大卫·马兰：没错，所以我们将使用 %i 来表示整数。

872
00:41:16,640 --> 00:41:17,710
And this is the kind of thing that you can
而这类信息，您可以

873
00:41:17,710 --> 00:41:20,420
consult in the manual pages or a slide like this.
查阅手册页或类似这样的幻灯片。

874
00:41:20,420 --> 00:41:22,850
There's only a few of them that you might frequently use.
您可能经常使用到的只有几个。

875
00:41:22,850 --> 00:41:26,480
But let's go ahead and use integers in a more interesting context, not
但是，让我们在更有趣的环境中使用整数，而不仅仅是

876
00:41:26,480 --> 00:41:27,440
just using functions.
仅仅使用函数。

877
00:41:27,440 --> 00:41:29,510
But let's revisit this idea of conditionals.
但是，让我们重新审视一下条件语句的概念。

878
00:41:29,510 --> 00:41:32,750
And conditionals in Scratch were like these proverbial forks in the road.
在 Scratch 中，条件语句就像这些众所周知的岔路口。

879
00:41:32,750 --> 00:41:36,420
Like, do you want to do this thing or this thing or this other thing?
就像，您想做这件事还是那件事，或者做其他事情？

880
00:41:36,420 --> 00:41:38,750
It's a way of making decisions in a program, which
这是一种在程序中进行决策的方式，这

881
00:41:38,750 --> 00:41:42,170
is going to be super useful and pretty much omnipresent in any problems
将非常有用，并且在我们要解决的任何问题中几乎无处不在。

882
00:41:42,170 --> 00:41:43,320
that we try to solve.
我们尝试解决的任何问题中。

883
00:41:43,320 --> 00:41:45,290
So let me give you a few more building blocks
所以，让我向您展示更多 C 语言中的构建块

884
00:41:45,290 --> 00:41:48,140
in C by doing the side-by-side comparison again.
通过再次进行并排比较来展示。

885
00:41:48,140 --> 00:41:53,750
So here in Scratch is how we might say if two variables, x and y,
所以，在 Scratch 中，如果我们想说两个变量，x 和 y，

886
00:41:53,750 --> 00:41:57,110
one is less than the other, then go ahead and say, quote, unquote,
其中一个比另一个小，那么就可以说，引号，引号，

887
00:41:57,110 --> 00:41:58,250
"x is less than y."
"x 小于 y"。

888
00:41:58,250 --> 00:41:59,730
So kind of a stupid program.
所以，这是一个有点愚蠢的程序。

889
00:41:59,730 --> 00:42:02,300
But just to show you the basic syntax for Scratch,
但仅仅是为了向您展示 Scratch 的基本语法，

890
00:42:02,300 --> 00:42:07,160
this is how you would ask the question, if x is less than y, then say this.
这就是您提出问题的方式，如果 x 小于 y，那么就说这句话。

891
00:42:07,160 --> 00:42:08,570
So Say is the function.
所以 Say 是函数。

892
00:42:08,570 --> 00:42:09,920
"If" is the conditional.
"If" 是条件语句。

893
00:42:09,920 --> 00:42:14,307
And the green thing here we called, what?
而这里这个绿色的东西我们称之为，什么？

894
00:42:14,307 --> 00:42:15,140
What did we call it?
我们叫它什么？

895
00:42:15,140 --> 00:42:15,560
Yeah?
是的？

896
00:42:15,560 --> 00:42:16,040
STUDENT: A Boolean.
学生：布尔值。

897
00:42:16,040 --> 00:42:18,000
DAVID MALAN: A Boolean or a Boolean expression,
大卫·马兰：布尔值或布尔表达式，

898
00:42:18,000 --> 00:42:20,167
which is just a fancy way of saying a question whose
这只是一个花哨的说法，表示一个问题的答案是

899
00:42:20,167 --> 00:42:25,580
answer is true or false, yes or no, 1 or 0, however you want to think about it.
真或假，是或否，1 或 0，无论您想怎么思考。

900
00:42:25,580 --> 00:42:28,560
In C, the code is going to look like this.
在 C 语言中，代码将如下所示。

901
00:42:28,560 --> 00:42:32,480
So it'll take a little bit of habit, a little bit of muscle memory to develop.
所以，这需要一些习惯，需要发展一些肌肉记忆。

902
00:42:32,480 --> 00:42:35,880
But you're going to say "if," then in parentheses,
但您将说 "if"，然后在括号中，

903
00:42:35,880 --> 00:42:39,530
you're going to say "x less than y," assuming x and y are variables.
您将说 "x 小于 y"，假设 x 和 y 是变量。

904
00:42:39,530 --> 00:42:41,690
You're then going to use these curly braces.
然后，您将使用这些花括号。

905
00:42:41,690 --> 00:42:45,110
And then if you want to say, quote, unquote, "x is less than y"
然后，如果您想说，引号，引号，"x 小于 y"

906
00:42:45,110 --> 00:42:50,140
in C, what function should we use here presumably?
在 C 语言中，我们应该在这里使用什么函数？

907
00:42:50,140 --> 00:42:51,430
So printf.
所以 printf。

908
00:42:51,430 --> 00:42:54,803
So printf, quote, unquote, "x is less than y."
所以 printf，引号，引号，"x 小于 y"。

909
00:42:54,803 --> 00:42:57,220
So it's a bit of a mouthful, but again notice the pattern.
所以，这有点拗口，但请再次注意这种模式。

910
00:42:57,220 --> 00:42:58,750
Name of the function is printf.
函数名称是 printf。

911
00:42:58,750 --> 00:43:02,320
In the parentheses, left and right, is the argument to printf,
在括号中，左和右，是 printf 的参数，

912
00:43:02,320 --> 00:43:04,750
which is, quote, unquote, "x is less than y."
即，引号，引号，"x 小于 y"。

913
00:43:04,750 --> 00:43:07,730
And again, just for aesthetics, to move the cursor to the next line,
再次，为了美观，将光标移到下一行，

914
00:43:07,730 --> 00:43:10,522
which you don't have to worry about in Scratch because everything's
在 Scratch 中，您不必担心，因为所有内容都是

915
00:43:10,522 --> 00:43:14,000
in speech bubbles, we're adding a backslash n, as well.
在气泡中，我们也添加了一个反斜杠 n。

916
00:43:14,000 --> 00:43:16,390
So notice that these curly braces, as they're
所以，请注意，这些花括号，正如它们

917
00:43:16,390 --> 00:43:18,850
called, much like the orange puzzle piece here,
被称为的那样，就像这里这个橙色的拼图块一样，

918
00:43:18,850 --> 00:43:21,520
are kind of hugging the code like this.
就像这样拥抱代码。

919
00:43:21,520 --> 00:43:24,760
And I'll note that technically speaking in C,
我注意到，从技术上讲，在 C 语言中，

920
00:43:24,760 --> 00:43:28,990
If you only have one line of code inside of your conditional,
如果您在条件语句中只有一行代码，

921
00:43:28,990 --> 00:43:31,360
you can actually omit the curly braces altogether.
您可以完全省略花括号。

922
00:43:31,360 --> 00:43:34,190
And the code will still work if you have one single line of code.
如果您只有一行代码，代码仍然可以正常运行。

923
00:43:34,190 --> 00:43:34,690
Why?
为什么？

924
00:43:34,690 --> 00:43:36,190
Just saves people some keystrokes.
只是节省了一些人的按键次数。

925
00:43:36,190 --> 00:43:38,470
If you have two lines, three lines, or more in there,
如果您有两行、三行或更多行代码，

926
00:43:38,470 --> 00:43:39,670
you need the curly braces.
您需要使用花括号。

927
00:43:39,670 --> 00:43:41,920
But I'll always draw it with the curly braces in class
但我会在课堂上始终用花括号绘制它

928
00:43:41,920 --> 00:43:44,980
so it resembles Scratch as closely as possible.
以便尽可能地与 Scratch 类似。

929
00:43:44,980 --> 00:43:47,230
As an aside to some of you who have programmed before,
顺便说一下，对于之前已经编程过的一些人来说，

930
00:43:47,230 --> 00:43:49,340
you might be cringing now because like you really
您现在可能在皱眉，因为您真的

931
00:43:49,340 --> 00:43:52,610
like your curly brace to be over here instead of here, that,
希望您的花括号在这里而不是在这里，这，

932
00:43:52,610 --> 00:43:53,900
too, is a stylistic choice.
也是一种风格选择。

933
00:43:53,900 --> 00:43:55,790
And we'll talk, too, about this in the class.
我们也会在课堂上讨论这个问题。

934
00:43:55,790 --> 00:43:58,910
Aesthetically, stylistically there are certain decisions we can make.
从美观和风格的角度来说，我们可以做出一些决定。

935
00:43:58,910 --> 00:44:03,530
But generally in a class, in a company, you as a student or an employee
但通常在课堂上，在公司里，您作为学生或员工

936
00:44:03,530 --> 00:44:07,890
would simply standardize on one set of rules, so to speak.
只会简单地遵循一套规则，可以这么说。

937
00:44:07,890 --> 00:44:12,200
So we'll use these rules for formatting our code in class consistently.
因此，在课堂上，我们将始终如一地使用这些规则来格式化代码。

938
00:44:12,200 --> 00:44:16,792
All right, any questions on this snippet of C code?
好的，关于这部分 C 代码，有什么问题吗？

939
00:44:16,792 --> 00:44:18,250
All right, a couple of others then.
好的，还有其他几个。

940
00:44:18,250 --> 00:44:21,420
So here is how, in Scratch, we might have a two-way fork in the road.
所以，在 Scratch 中，我们可能会有一个双向的岔路口。

941
00:44:21,420 --> 00:44:26,340
If x is less than y, say x is less than y, else say x is not less than y.
如果 x 小于 y，就说 x 小于 y，否则就说 x 不小于 y。

942
00:44:26,340 --> 00:44:28,870
In C, It's going to look pretty much the same.
在 C 语言中，它看起来几乎是一样的。

943
00:44:28,870 --> 00:44:32,697
But notice I'm adding an "else" keyword here with another set of curly braces.
但请注意，我在这里添加了一个 "else" 关键字，以及另一组花括号。

944
00:44:32,697 --> 00:44:34,530
I'm going to have a couple of more printf's.
我将再添加几个 printf 语句。

945
00:44:34,530 --> 00:44:37,600
But in C, even though it's clearly keyboard based,
但在 C 语言中，即使它显然是基于键盘的，

946
00:44:37,600 --> 00:44:41,500
it's just text, no more puzzle pieces, it's kind of the same shape,
它只是文本，不再有拼图块，它的形状有点一样，

947
00:44:41,500 --> 00:44:44,440
so to speak, and it's definitely the same idea.
可以这么说，它绝对是一样的想法。

948
00:44:44,440 --> 00:44:46,150
So it's following a pattern.
所以它遵循着一定的模式。

949
00:44:46,150 --> 00:44:49,990
What about a three-way fork in the road, if x is less than y,
如果x小于y，会怎样？

950
00:44:49,990 --> 00:44:53,160
then say x is less than y, else if x is greater
那么就说x小于y，否则如果x大于

951
00:44:53,160 --> 00:45:01,012
than y, say x is greater than y, else if x equals y, then say x is equal to y.
y，就说x大于y，否则如果x等于y，就说x等于y。

952
00:45:01,012 --> 00:45:02,970
Well, you can probably see where this is going.
好吧，你可能已经猜到我们要做什么了。

953
00:45:02,970 --> 00:45:06,070
On the right-hand side, it looks almost the same.
在右边，它看起来几乎一样。

954
00:45:06,070 --> 00:45:09,360
In fact, if I add in the printf's, it's really almost the same,
事实上，如果我加上printf语句，它真的几乎一样，

955
00:45:09,360 --> 00:45:10,620
at least logically.
至少在逻辑上是相同的。

956
00:45:10,620 --> 00:45:16,320
But there is at least one curiosity, seemingly a typo
但是至少有一点奇怪，看起来像是一个打字错误

957
00:45:16,320 --> 00:45:17,765
but it's not this time.
但这次不是。

958
00:45:17,765 --> 00:45:18,265
Yeah?
是吗？

959
00:45:18,265 --> 00:45:19,390
STUDENT: The double equals.
学生：双等号。

960
00:45:19,390 --> 00:45:23,860
DAVID MALAN: Yeah, the double equal signs does not match Scratch,
戴维·马兰：是的，双等号与Scratch不匹配，

961
00:45:23,860 --> 00:45:28,150
but it's not in fact a bug or a mistake in C. Anyone
但事实上它不是C语言中的错误。有人

962
00:45:28,150 --> 00:45:33,610
have an intuition for why I did use two equal signs instead of one here?
对为什么我在这里使用两个等号而不是一个等号有直觉吗？

963
00:45:33,610 --> 00:45:34,571
Yeah?
是吗？

964
00:45:34,571 --> 00:45:37,460
STUDENT: Because otherwise it could be mistaken for a variable.
学生：因为否则它可能会被误认为是变量。

965
00:45:37,460 --> 00:45:38,335
DAVID MALAN: Exactly.
戴维·马兰：没错。

966
00:45:38,335 --> 00:45:41,180
Well, otherwise it would be mistaken for a variable, specifically
好吧，否则它会被误认为是变量，特别是

967
00:45:41,180 --> 00:45:42,990
assignment of a variable.
变量的赋值。

968
00:45:42,990 --> 00:45:47,270
So recall that in previous code, when we used the get_string function,
所以回忆一下之前代码中，当我们使用get_string函数时，

969
00:45:47,270 --> 00:45:52,465
we used an equals sign to assign, from right to left, the value of a variable.
我们使用了一个等号来赋值，从右到左，变量的值。

970
00:45:52,465 --> 00:45:53,840
And that's a reasonable decision.
这是一个合理的决定。

971
00:45:53,840 --> 00:45:56,007
"Equal" kind of means that the two should ultimately
“等于”某种程度上意味着两者最终

972
00:45:56,007 --> 00:45:59,660
be equal even though you think about it from going right to left.
应该是相等的，即使你是从右到左考虑的。

973
00:45:59,660 --> 00:46:03,180
Unfortunately, the authors of C kind of [? painted ?] themselves into a corner.
不幸的是，C语言的设计者把自己逼到一个角落里了。

974
00:46:03,180 --> 00:46:05,900
And presumably, decades ago when they realized, oh, shoot,
我想，几十年前当他们意识到，糟糕，

975
00:46:05,900 --> 00:46:07,910
we've already used a single equal sign, how
我们已经使用了一个等号，如何

976
00:46:07,910 --> 00:46:12,320
do we represent equality of two values, the answer they came up with was,
表示两个值相等，他们想出的答案是，

977
00:46:12,320 --> 00:46:14,450
all right, we'll just use two instead.
好吧，我们只用两个。

978
00:46:14,450 --> 00:46:16,058
And thus was born this decision.
就这样，这个决定诞生了。

979
00:46:16,058 --> 00:46:16,850
Is it the best one?
这是最好的吗？

980
00:46:16,850 --> 00:46:17,690
Who knows?
谁知道呢？

981
00:46:17,690 --> 00:46:20,450
Crazy enough, in other languages, like JavaScript,
有趣的是，在其他语言中，比如JavaScript，

982
00:46:20,450 --> 00:46:23,810
you have not just one, but two, but also three equal signs
你不仅有1个，还有2个，甚至还有3个等号

983
00:46:23,810 --> 00:46:25,770
in a row to solve yet another problem.
连续在一起，为了解决另一个问题。

984
00:46:25,770 --> 00:46:29,100
So reasonable people will disagree as to how good or bad these decisions are.
所以，理智的人会对这些决定是好是坏持不同意见。

985
00:46:29,100 --> 00:46:32,930
But in C, this is what you must do.
但在C语言中，你必须这样做。

986
00:46:32,930 --> 00:46:38,430
But there's a bad design decision here, too.
但是这里也存在一个糟糕的设计决策。

987
00:46:38,430 --> 00:46:40,560
It's still correct, the code, left and right.
代码仍然是正确的，左边和右边。

988
00:46:40,560 --> 00:46:45,210
But I bet I could critique the quality of the design of both the Scratch code
但我敢肯定我能批评Scratch代码和C代码的设计质量，因为什么原因？

989
00:46:45,210 --> 00:46:47,910
and the C code for reasons, what?
为什么？

990
00:46:47,910 --> 00:46:51,788
STUDENT: Do we have to do else if x equals [INAUDIBLE]??
学生：我们必须这样做吗？else if x等于[无法识别]？？

991
00:46:51,788 --> 00:46:53,580
DAVID MALAN: OK, no, really good intuition.
戴维·马兰：好的，不，直觉很好。

992
00:46:53,580 --> 00:46:57,030
Do we have to ask this third question, "else if x equals y?"
我们必须问第三个问题吗，“else if x等于y”？

993
00:46:57,030 --> 00:46:59,610
So short answer, no, logically, right?
简短的回答，不，从逻辑上讲，对吧？

994
00:46:59,610 --> 00:47:05,130
Just based on arithmetic, either x is less than y or x is greater than y
仅仅从算术的角度来说，要么x小于y，要么x大于y

995
00:47:05,130 --> 00:47:08,220
or, what's the only other possible answer?
或者，唯一可能的答案是什么？

996
00:47:08,220 --> 00:47:10,080
They must be equal, logically.
它们必须相等，从逻辑上讲。

997
00:47:10,080 --> 00:47:13,140
So technically, you're just kind of wasting the computer's time
所以从技术上讲，你只是在浪费计算机的时间

998
00:47:13,140 --> 00:47:15,270
by asking this question because it already knows,
因为你问了这个问题，但它已经知道了，

999
00:47:15,270 --> 00:47:16,353
at that point, the answer.
当时的答案。

1000
00:47:16,353 --> 00:47:18,780
And you're wasting your time as the programmer bothering
而你作为程序员，浪费时间去写

1001
00:47:18,780 --> 00:47:20,700
to type out more code or more puzzle pieces
更多代码或更多拼图块

1002
00:47:20,700 --> 00:47:24,010
than you need because logically one stems from the other.
比你需要的更多，因为在逻辑上，一个是从另一个得来的。

1003
00:47:24,010 --> 00:47:28,080
So I can tighten this up, get rid of the "else, if," just use an "else."
所以我可以简化它，去掉“else，if”，只用一个“else”。

1004
00:47:28,080 --> 00:47:31,110
And I can do the same thing over here in C, thereby avoiding
我可以在C语言中做同样的事情，从而避免

1005
00:47:31,110 --> 00:47:33,870
the double equal sign altogether, but not because it's wrong
双等号的出现，但不是因为它是错误的

1006
00:47:33,870 --> 00:47:38,340
but because you're wasting time, because now you're potentially asking only two
而是因为你在浪费时间，因为现在你可能只问了两个

1007
00:47:38,340 --> 00:47:43,050
questions, two Boolean expressions, instead of 50% more by asking
问题，两个布尔表达式，而不是通过问问题来增加50%

1008
00:47:43,050 --> 00:47:46,200
a total of three questions at most.
最多三个问题。

1009
00:47:46,200 --> 00:47:52,900
Other questions then on this kind of code, logically or otherwise?
关于这种代码，还有其他问题吗，无论是在逻辑上还是其他方面？

1010
00:47:52,900 --> 00:47:53,400
No?
没有？

1011
00:47:53,400 --> 00:47:58,450
All right, so if we have these puzzle pieces, so to speak, at our disposal,
好吧，如果我们有这些拼图块，可以这么说，我们可以使用它们，

1012
00:47:58,450 --> 00:48:00,753
how can we go about actually using these?
我们该如何实际使用它们呢？

1013
00:48:00,753 --> 00:48:03,420
Well, suppose that we actually want to do something with values.
假设我们实际上想用这些值做一些事情。

1014
00:48:03,420 --> 00:48:06,190
Let's introduce variables in C, as well.
让我们在C语言中也引入变量。

1015
00:48:06,190 --> 00:48:08,197
We saw an example using a string a moment ago.
我们刚才看到了一个使用字符串的例子。

1016
00:48:08,197 --> 00:48:10,030
But what about with something like integers?
但是对于像整数这样的东西呢？

1017
00:48:10,030 --> 00:48:11,947
Well, you might not have used this in Scratch.
好吧，你可能没有在Scratch中使用过它。

1018
00:48:11,947 --> 00:48:13,830
But here's the orange puzzle piece in Scratch
但在Scratch中，橙色拼图块是

1019
00:48:13,830 --> 00:48:17,100
via which you can create a variable called counter to count things.
你可以用它创建一个叫做计数器的变量来计数。

1020
00:48:17,100 --> 00:48:19,638
And you can set it equal to some value like 0.
你可以把它设置为一个值，比如0。

1021
00:48:19,638 --> 00:48:21,930
Now, you can perhaps guess where we're going with this.
现在，你可能已经猜到我们要去哪里了。

1022
00:48:21,930 --> 00:48:27,540
If I want in C a variable called counter and I want to set it equal to 0,
如果我在C语言中想要一个叫做计数器的变量，并且我想把它设置为0，

1023
00:48:27,540 --> 00:48:30,210
I use a single equal sign because logically you
我使用一个等号，因为从逻辑上讲，你

1024
00:48:30,210 --> 00:48:32,340
read it from right to left, or technically it's
从右到左读它，或者从技术上讲，它是

1025
00:48:32,340 --> 00:48:34,050
executed from right to left.
从右到左执行的。

1026
00:48:34,050 --> 00:48:37,128
But that's not enough in C. What's missing from the screen?
但这在C语言中还不够。屏幕上缺少了什么？

1027
00:48:37,128 --> 00:48:37,920
STUDENT: Data type.
学生：数据类型。

1028
00:48:37,920 --> 00:48:38,760
DAVID MALAN: I need a what?
戴维·马兰：我需要什么？

1029
00:48:38,760 --> 00:48:39,570
STUDENT: You need a data type.
学生：你需要一个数据类型。

1030
00:48:39,570 --> 00:48:40,860
DAVID MALAN: So we need a data type.
戴维·马兰：所以我们需要一个数据类型。

1031
00:48:40,860 --> 00:48:43,110
And if it's going to be an integer, indeed I'm going to use int.
如果它是一个整数，我确实要使用int。

1032
00:48:43,110 --> 00:48:44,943
And now the other mistake I keep making is--
现在我一直在犯的另一个错误是--

1033
00:48:44,943 --> 00:48:45,735
STUDENT: Semicolon.
学生：分号。

1034
00:48:45,735 --> 00:48:48,070
DAVID MALAN: So a semicolon at the end of the line.
戴维·马兰：所以在行尾添加一个分号。

1035
00:48:48,070 --> 00:48:50,153
So it's a little more verbose than some languages.
所以它比一些语言更冗长。

1036
00:48:50,153 --> 00:48:52,180
But if you read it left to right, this is
但是如果你从左到右读，这就是

1037
00:48:52,180 --> 00:48:56,600
how you tell C to give you a variable called counter of type int
你告诉C语言为你创建一个叫做计数器的int类型的变量的方式

1038
00:48:56,600 --> 00:49:00,010
and initialize it to a value of 0.
并初始化它为0。

1039
00:49:00,010 --> 00:49:00,850
That's all.
就是这样。

1040
00:49:00,850 --> 00:49:04,750
All right, how about, in Scratch, if you want to change that variable by 1,
好吧，在Scratch中，如果你想把那个变量改变1，

1041
00:49:04,750 --> 00:49:05,860
by adding 1 to it?
把它加1？

1042
00:49:05,860 --> 00:49:07,280
In Scratch, it's super simple.
在Scratch中，这非常简单。

1043
00:49:07,280 --> 00:49:09,430
You just change it by 1 or even negative 1
只需将其更改为 1 甚至 -1

1044
00:49:09,430 --> 00:49:11,830
if you want to go up or down respectively.
如果你想分别向上或向下移动。

1045
00:49:11,830 --> 00:49:14,590
In C, it turns out you have a few different ways to do this.
在 C 语言中，实际上你可以用几种不同的方法做到这一点。

1046
00:49:14,590 --> 00:49:18,140
And this looks like it's not mathematically possible,
这看起来在数学上是不可能的，

1047
00:49:18,140 --> 00:49:21,820
but that's because equals is assignment, recall.
但这是因为“等于”是赋值，还记得吗？

1048
00:49:21,820 --> 00:49:27,130
So this line of code is not saying that counter equals counter plus 1,
所以这一行代码并非在说计数器等于计数器加 1，

1049
00:49:27,130 --> 00:49:30,160
because that's just not possible using typical numbers.
因为对于一般的数字来说这是不可能的。

1050
00:49:30,160 --> 00:49:33,290
But this means take counter's value, add 1 to it,
但它的意思是取计数器的值，加上 1，

1051
00:49:33,290 --> 00:49:36,080
and assign it back to the counter variable.
然后将其重新赋值给计数器变量。

1052
00:49:36,080 --> 00:49:38,450
So it's like incrementing counter in this way.
所以这就像用这种方式递增计数器。

1053
00:49:38,450 --> 00:49:41,380
But this is such a common thing in C and in programming
但在 C 语言和编程中，

1054
00:49:41,380 --> 00:49:43,990
to increase or decrease the values of variables,
增加或减少变量的值是一件非常常见的事情，

1055
00:49:43,990 --> 00:49:46,090
there's a more succinct syntax.
因此存在一种更简洁的语法。

1056
00:49:46,090 --> 00:49:48,460
This is identical.
它们是一样的。

1057
00:49:48,460 --> 00:49:51,167
And it might take you a little practice to get used to it,
你可能需要一些练习才能习惯它，

1058
00:49:51,167 --> 00:49:52,750
but it just saves you some keystrokes.
但这可以节省一些按键操作。

1059
00:49:52,750 --> 00:49:56,050
But it similarly adds 1, or whatever number you use there.
但它同样地加 1，或者加你用在那里使用的任何数字。

1060
00:49:56,050 --> 00:49:58,720
And this is such a common operation in C especially
而这在 C 语言中尤其是一个非常常见的操作，

1061
00:49:58,720 --> 00:50:02,590
that there's an even tighter way of executing the same idea.
因此存在一种更紧凑的方法来执行相同的思想。

1062
00:50:02,590 --> 00:50:08,240
And you can literally just say counter++ and then semicolon in this case.
在这种情况下，你可以直接写计数器++，然后加上分号。

1063
00:50:08,240 --> 00:50:09,760
All three are exactly the same.
三种方法完全相同。

1064
00:50:09,760 --> 00:50:11,170
All three are perfectly correct.
三种方法都完全正确。

1065
00:50:11,170 --> 00:50:13,545
But you'll learn over time that typing less on the screen
但你会随着时间的推移而发现，在屏幕上输入越少，

1066
00:50:13,545 --> 00:50:15,860
is probably going to save you some time.
你就能节省更多的时间。

1067
00:50:15,860 --> 00:50:19,660
Meanwhile, if we wanted to do the opposite and do something like minus 1
同时，如果我们想要做相反的操作，比如减去 1，

1068
00:50:19,660 --> 00:50:24,610
in Scratch, we could similarly do minus minus in C. Or we could do--
在 Scratch 中，我们可以用类似的方法在 C 语言中写成减减。或者我们可以写成...

1069
00:50:24,610 --> 00:50:28,450
yeah, we could do minus minus in C here at right.
没错，我们可以在这里在 C 语言中写成减减。

1070
00:50:28,450 --> 00:50:31,480
All right, so just some additional building blocks, translating
好了，只是一些额外的构建模块，将

1071
00:50:31,480 --> 00:50:36,790
from scratch to C. Why don't we go ahead and try using this perhaps
从 Scratch 翻译到 C 语言。我们为什么不试着使用它呢？

1072
00:50:36,790 --> 00:50:38,260
in the following way?
以如下方式？

1073
00:50:38,260 --> 00:50:40,750
Let me go ahead and go back to VS Code.
让我回到 VS Code 中。

1074
00:50:40,750 --> 00:50:45,910
And let me propose that we do something like this.
让我提议我们做一些类似的事情。

1075
00:50:45,910 --> 00:50:48,550
In VS Code, I'm going to go ahead and clear my terminal window.
在 VS Code 中，我将清除我的终端窗口。

1076
00:50:48,550 --> 00:50:50,650
I'm going to close "hello.c" by just clicking
我将通过点击来关闭“hello.c”

1077
00:50:50,650 --> 00:50:54,220
the X. I'm going to go ahead and create a new file called "compare.c"
X。我将创建一个名为“compare.c”的新文件

1078
00:50:54,220 --> 00:50:56,410
because the purpose in life of this program
因为这个程序存在的意义

1079
00:50:56,410 --> 00:50:58,942
is going to be to compare integers on the screen.
就是要在屏幕上比较整数。

1080
00:50:58,942 --> 00:51:00,400
This time I'm not going to mess up.
这一次我不会搞砸了。

1081
00:51:00,400 --> 00:51:04,480
I'm going to preemptively include CS50.h.
我将预先包含 CS50.h。

1082
00:51:04,480 --> 00:51:07,630
I'm going to preemptively include stdio.h.
我将预先包含 stdio.h。

1083
00:51:07,630 --> 00:51:13,690
And here, too, is a very common mistake in learning C. It is not "studio.h."
在学习 C 语言时，这也是一个很常见的错误。它不是“studio.h”。

1084
00:51:13,690 --> 00:51:16,690
So when you email us asking why "studio.h" is not working,
所以当你发邮件给我们询问为什么“studio.h”不起作用时，

1085
00:51:16,690 --> 00:51:18,190
that's because that is not the word.
那是因为这个词是错误的。

1086
00:51:18,190 --> 00:51:22,420
It is "standard io.h," meaning standard input and output,
它是“standard io.h”，意思是标准输入和输出，

1087
00:51:22,420 --> 00:51:24,370
stuff involving the screen and the keyboard.
涉及屏幕和键盘的东西。

1088
00:51:24,370 --> 00:51:27,370
Then I'm going to go ahead and, just as before, int main(void),
然后我将继续，和以前一样，int main(void)，

1089
00:51:27,370 --> 00:51:29,830
but we'll come back to that eventually as to what it means.
但我们最终会回到它，来了解它的含义。

1090
00:51:29,830 --> 00:51:35,050
And now inside of "main," which is just where the main part of my program goes,
现在在“main”中，也就是我的程序的主体部分所在的地方，

1091
00:51:35,050 --> 00:51:39,310
again you can think of this as being analogous to "when green flag clicked."
你可以将其看作与“当绿旗被点击时”类似。

1092
00:51:39,310 --> 00:51:40,870
This just kicks everything off.
这仅仅是启动了一切。

1093
00:51:40,870 --> 00:51:42,680
I'm going to go ahead and do two things.
我将要做两件事。

1094
00:51:42,680 --> 00:51:45,100
I'm going to go ahead and get an integer called x,
我将获取一个名为 x 的整数，

1095
00:51:45,100 --> 00:51:47,080
and I'm going to prompt the user for that int
并提示用户输入该整数

1096
00:51:47,080 --> 00:51:50,770
and just say something like, "what's x?", space.
并提示用户输入类似“x 是多少？”这样的信息，后面带空格。

1097
00:51:50,770 --> 00:51:55,540
Then I'm going to do int y equals get_int, quote, unquote, "what's y?",
然后我将进行 int y 等于 get_int，双引号，“y 是多少？”

1098
00:51:55,540 --> 00:51:56,410
space.
后面带空格。

1099
00:51:56,410 --> 00:52:00,830
And then let's just do something simple like, if x is less than y,
然后让我们做一些简单的事情，比如，如果 x 小于 y，

1100
00:52:00,830 --> 00:52:03,520
then go ahead and print out, quote, unquote,
那么就打印出，双引号，

1101
00:52:03,520 --> 00:52:08,740
"x is less than y backslash n," semicolon.
“x 小于 y 换行符”，分号。

1102
00:52:08,740 --> 00:52:10,610
So it's not a very deep program.
所以它不是一个非常复杂的程序。

1103
00:52:10,610 --> 00:52:13,610
It's just going to do what most any human brain could do pretty quickly.
它只是会做任何一个人类大脑都能很快完成的事情。

1104
00:52:13,610 --> 00:52:17,080
But it's at least demonstrating how we might use now
但它至少展示了我们现在如何使用

1105
00:52:17,080 --> 00:52:19,480
something like a conditional in code.
类似条件语句这样的东西。

1106
00:52:19,480 --> 00:52:21,490
So let me go ahead and re--
所以让我继续重新...

1107
00:52:21,490 --> 00:52:25,750
let me compile this code for the first time, make compare, enter.
让我第一次编译这段代码，make compare，回车。

1108
00:52:25,750 --> 00:52:31,150
Nothing bad happens, which is good. "./compare" is how I run the program.
没有发生任何错误，这是好事。"./compare" 是我运行程序的方式。

1109
00:52:31,150 --> 00:52:33,820
And just to tease this apart, dot, as we'll soon see,
为了让它更清晰，点号，正如我们很快就会看到的，

1110
00:52:33,820 --> 00:52:36,770
essentially means that the file is in your current folder.
本质上意味着该文件位于你的当前文件夹中。

1111
00:52:36,770 --> 00:52:38,620
So dot means in your current folder.
所以点号意味着在你的当前文件夹中。

1112
00:52:38,620 --> 00:52:41,440
And we'll eventually see that dot dot means your parent
而我们最终会看到点点意味着你的父级

1113
00:52:41,440 --> 00:52:43,780
folder, like the one that contains wherever
文件夹，比如包含我所在位置的文件夹

1114
00:52:43,780 --> 00:52:45,820
I am on my computer's hard drive.
我的电脑硬盘上的文件夹。

1115
00:52:45,820 --> 00:52:47,050
All right. ./compare.
好的。 ./compare。

1116
00:52:47,050 --> 00:52:48,264
What's x?
x 是多少？

1117
00:52:48,264 --> 00:52:49,210
1.
1。

1118
00:52:49,210 --> 00:52:50,470
2 for y.
y 是 2。

1119
00:52:50,470 --> 00:52:54,217
And hopefully it should say that x is less than y.
我希望它会说 x 小于 y。

1120
00:52:54,217 --> 00:52:55,300
So pretty straightforward.
所以很简单。

1121
00:52:55,300 --> 00:52:56,290
Proof by example.
举例证明。

1122
00:52:56,290 --> 00:52:58,480
And hopefully this would work in other cases, too.
我希望它在其他情况下也能工作。

1123
00:52:58,480 --> 00:53:04,960
But if I flip that around and I rerun it, ./compare, and I do 2 and 1,
但如果我反过来，重新运行它，./compare，然后我输入 2 和 1，

1124
00:53:04,960 --> 00:53:06,432
nothing's going to happen.
什么也不会发生。

1125
00:53:06,432 --> 00:53:08,140
But you would expect that because there's
但你会发现，因为只有一个

1126
00:53:08,140 --> 00:53:11,860
only one Boolean expression deciding whether or not
布尔表达式来决定是否

1127
00:53:11,860 --> 00:53:13,880
I should actually type this out.
我应该实际输入它。

1128
00:53:13,880 --> 00:53:15,160
So what's going on?
所以发生了什么？

1129
00:53:15,160 --> 00:53:17,140
Well, if this helps you, you might find it
好吧，如果这对你有所帮助，你可能会发现它

1130
00:53:17,140 --> 00:53:20,830
useful to think about the logic of any program, be it in Scratch or C,
有助于思考任何程序的逻辑，无论是 Scratch 还是 C 语言，

1131
00:53:20,830 --> 00:53:22,600
as kind of a flowchart of sorts.
将其视为一种流程图。

1132
00:53:22,600 --> 00:53:24,910
And we'll put up a few of these over time just in case
而我们将会随着时间的推移，提供一些这样的流程图，以防万一

1133
00:53:24,910 --> 00:53:26,690
you're a particularly visual thinker.
你是个非常视觉化的思考者。

1134
00:53:26,690 --> 00:53:28,780
And this represents what it is I just did.
而这代表了我刚刚做的事情。

1135
00:53:28,780 --> 00:53:32,470
So here in this picture is where the program starts conceptually.
所以在这幅图中，就是程序概念上的起点。

1136
00:53:32,470 --> 00:53:35,860
And any time you see a diamond, think of that as a Boolean expression,
而当你在流程图中看到菱形时，就将其视为一个布尔表达式，

1137
00:53:35,860 --> 00:53:37,330
a question that's being asked.
一个正在被问的问题。

1138
00:53:37,330 --> 00:53:39,940
And the question being asked is, is x less than y?
而正在被问的问题是，x 是否小于 y？

1139
00:53:39,940 --> 00:53:44,600
That has two possible answers, true or false, yes or no respectively.
它有两个可能的答案，真或假，分别对应是或否。

1140
00:53:44,600 --> 00:53:48,400
So let me propose, per the arrow, that if the answer is true, then print out,
因此，我建议，根据箭头，如果答案为真，则打印出来，

1141
00:53:48,400 --> 00:53:52,480
per this rectangle, "x is less than y," just quote, unquote, and then stop.
根据这个矩形，“x 小于 y”，直接引号，引号，然后停止。

1142
00:53:52,480 --> 00:53:53,680
That's it for the program.
这就是整个程序了。

1143
00:53:53,680 --> 00:53:56,800
But logically, if x is not less than y, that
但从逻辑上讲，如果 x 不小于 y，那么

1144
00:53:56,800 --> 00:54:00,310
is that question's answer is false, we'll just skip right to the end
也就是该问题的答案为假，我们将直接跳到最后

1145
00:54:00,310 --> 00:54:01,210
and stop.
并停止。

1146
00:54:01,210 --> 00:54:03,493
So this is a control-flow diagram.
所以，这是一个控制流程图。

1147
00:54:03,493 --> 00:54:05,410
It's just a pictorial way that you could write
这只是一个你可以用图片的方式在

1148
00:54:05,410 --> 00:54:09,490
on a piece of paper that just represents what it is the program is doing.
纸上写下来，它只是表示程序正在做的事情。

1149
00:54:09,490 --> 00:54:12,520
And this gets a little more interesting if now we
如果现在我们做一些其他事情，这会变得更有趣。

1150
00:54:12,520 --> 00:54:14,260
do something else with the code.
对代码做一些其他的操作。

1151
00:54:14,260 --> 00:54:20,620
For instance, instead of just concluding that it's less than 1 or the other,
例如，与其只是得出结论它小于 1 还是小于另一个，

1152
00:54:20,620 --> 00:54:22,330
let's go back to the code here.
让我们回到这里的代码。

1153
00:54:22,330 --> 00:54:24,028
Let me clear my terminal window.
让我清除我的终端窗口。

1154
00:54:24,028 --> 00:54:25,070
And let me add an "else."
让我添加一个“else”。

1155
00:54:25,070 --> 00:54:29,950
So else, go ahead and print out "x"--
所以，else，继续打印出“x”--

1156
00:54:29,950 --> 00:54:34,240
I don't think I want to say this-- "greater than y."
我不认为我想说这个-- “大于 y”。

1157
00:54:34,240 --> 00:54:35,480
It's not quite right.
不太对。

1158
00:54:35,480 --> 00:54:38,208
What would be reasonable to say here?
这里应该说些什么比较合理？

1159
00:54:38,208 --> 00:54:39,500
STUDENT: "x is not less than y.
学生：“x 不小于 y。

1160
00:54:39,500 --> 00:54:43,850
DAVID MALAN: Yeah, subtle, but "x is not less than y" because it could be equal.
大卫·马兰：是的，很微妙，但“x 不小于 y”，因为它可能相等。

1161
00:54:43,850 --> 00:54:48,990
We don't know if we're only checking two scenarios here.
我们不知道我们这里是否只检查了两种情况。

1162
00:54:48,990 --> 00:54:53,030
So if I recompile this, make compare, ./compare.
所以，如果我重新编译这个，make compare，./compare。

1163
00:54:53,030 --> 00:54:55,970
Now if I do 1, comma 2, I still get the same answer.
现在，如果我输入 1，逗号 2，我仍然得到相同的答案。

1164
00:54:55,970 --> 00:55:01,532
If I rerun ./compare 2, comma 1, I now get the opposite answer.
如果我重新运行 ./compare 2，逗号 1，我现在得到相反的答案。

1165
00:55:01,532 --> 00:55:02,990
It's not as good as might be ideal.
这并不像理想的那样好。

1166
00:55:02,990 --> 00:55:05,750
It'd be nice to know if it's equal to or greater than.
如果能知道它等于还是大于就好了。

1167
00:55:05,750 --> 00:55:08,330
But at least that's all of the code that we have here.
但至少这就是我们在这里所有的代码。

1168
00:55:08,330 --> 00:55:10,430
And just to now paint a picture, if I go back
现在，为了画一幅图，如果我回到

1169
00:55:10,430 --> 00:55:13,340
to my control-flow diagram, my flow chart here,
我的控制流程图，我的流程图，

1170
00:55:13,340 --> 00:55:15,800
this is what it looked like before logically.
从逻辑上来说，它以前是这个样子。

1171
00:55:15,800 --> 00:55:21,600
Now that I've added in a second branch, so to speak,
现在，我已经添加了第二个分支，可以这么说，

1172
00:55:21,600 --> 00:55:26,420
now, if the answer is false, I first print out x is not less than y,
现在，如果答案为假，我首先打印出 x 不小于 y，

1173
00:55:26,420 --> 00:55:28,370
and then I stop the program.
然后我停止程序。

1174
00:55:28,370 --> 00:55:31,297
So same idea, but the decision tree, if you will,
所以，同样的想法，但决策树，如果你愿意的话，

1175
00:55:31,297 --> 00:55:34,130
if you've taken a 10 or the like, is getting a little bit bigger now
如果你已经学过 10 门课或者类似的，现在它会变得稍微大一些

1176
00:55:34,130 --> 00:55:34,672
conceptually.
在概念上。

1177
00:55:34,672 --> 00:55:36,755
All right, what if we do something more than this?
好吧，如果我们做一些比这更多的事情呢？

1178
00:55:36,755 --> 00:55:38,700
Let's actually have that third condition.
让我们实际拥有那个第三个条件。

1179
00:55:38,700 --> 00:55:40,973
Let me go back into my code here.
让我回到这里的代码。

1180
00:55:40,973 --> 00:55:43,890
I'm going to hide the terminal window just to make room for more code.
我要隐藏终端窗口，以便为更多代码腾出空间。

1181
00:55:43,890 --> 00:55:47,730
And I'm going to say, "else if x is greater
我将说，“else if x 大于

1182
00:55:47,730 --> 00:55:51,720
than y," then go ahead and say not "x is not less than y,"
y”，那么继续说，不是“x 不小于 y”，

1183
00:55:51,720 --> 00:55:55,710
but rather "x is greater than y."
而是“x 大于 y”。

1184
00:55:55,710 --> 00:55:59,950
And then down here, I'll do an "else if x equals equals y,"
然后，在这里，我将做一个“else if x 等于等于 y”，

1185
00:55:59,950 --> 00:56:06,540
then I can go ahead and say printf, "x is equal to y backslash n,"
然后，我可以继续说 printf，“x 等于 y 反斜杠 n”，

1186
00:56:06,540 --> 00:56:07,990
close quote.
关闭引号。

1187
00:56:07,990 --> 00:56:11,160
All right, so now if I run it-- let me open my terminal window again.
好了，现在如果我运行它--让我再次打开我的终端窗口。

1188
00:56:11,160 --> 00:56:13,380
Let me rerun make compare.
让我重新运行 make compare。

1189
00:56:13,380 --> 00:56:15,570
Let me rerun ./compare.
让我重新运行 ./compare。

1190
00:56:15,570 --> 00:56:17,400
1 and 2 are the same.
1 和 2 是相同的。

1191
00:56:17,400 --> 00:56:18,600
Let me rerun it.
让我重新运行它。

1192
00:56:18,600 --> 00:56:20,730
2 and 1 are the same.
2 和 1 是相同的。

1193
00:56:20,730 --> 00:56:22,470
Let me rerun it a third time.
让我第三次重新运行它。

1194
00:56:22,470 --> 00:56:26,130
1 and 1 are now in fact equal.
1 和 1 现在实际上是相等的。

1195
00:56:26,130 --> 00:56:28,080
So this works correctly.
所以，这工作正常。

1196
00:56:28,080 --> 00:56:31,920
But why did I make a point of using these "else if"s?
但为什么我要特别强调使用这些“else if”呢？

1197
00:56:31,920 --> 00:56:36,660
Put another way, couldn't I just make my life a little simpler
换句话说，我不能让我的生活更简单一些吗？

1198
00:56:36,660 --> 00:56:39,180
and just say, if this, then that?
只说，如果这样，那么那样？

1199
00:56:39,180 --> 00:56:40,200
If this, then that.
如果这样，那么那样。

1200
00:56:40,200 --> 00:56:41,640
If this, then that.
如果这样，那么那样。

1201
00:56:41,640 --> 00:56:43,290
Just ask all three questions.
只问三个问题。

1202
00:56:43,290 --> 00:56:44,340
Keep the code simple.
保持代码简单。

1203
00:56:44,340 --> 00:56:47,010
Don't bother with these else's.
不要理会这些 else。

1204
00:56:47,010 --> 00:56:48,715
Would this work for me?
这对我有用吗？

1205
00:56:48,715 --> 00:56:49,215
Yeah?
是吗？

1206
00:56:49,215 --> 00:56:52,312
STUDENT: It just seems like [INAUDIBLE] the program
学生：这看起来就像 [听不清] 程序

1207
00:56:52,312 --> 00:56:53,520
doesn't have to run the rest.
不必运行剩下的部分。

1208
00:56:53,520 --> 00:56:56,980
DAVID MALAN: Yeah, so it saves a little bit of time because in this case,
大卫·马兰：是的，所以它节省了一点时间，因为在这种情况下，

1209
00:56:56,980 --> 00:57:00,840
just like in English, this is like asking three separate questions.
就像在英语中，这就像问三个独立的问题。

1210
00:57:00,840 --> 00:57:05,190
And it's not harnessing any information from previous questions
并且它没有利用来自之前问题的任何信息

1211
00:57:05,190 --> 00:57:08,950
in order to decide whether you should bother asking that other question.
来决定你是否应该费心问另一个问题。

1212
00:57:08,950 --> 00:57:11,610
In other words, if x is less than y-- and you already
换句话说，如果 x 小于 y-- 而且你已经

1213
00:57:11,610 --> 00:57:14,460
figured that out because it's 1 and 2 respectively-- you're
弄清楚了，因为它分别是 1 和 2-- 你将

1214
00:57:14,460 --> 00:57:15,420
going to print this.
打印这个。

1215
00:57:15,420 --> 00:57:17,967
Why would you waste time asking this question when
为什么你会浪费时间问这个问题，当

1216
00:57:17,967 --> 00:57:19,050
it's not going to be true?
它不会是真值？

1217
00:57:19,050 --> 00:57:21,133
Why would you waste time asking this question when
为什么你会浪费时间问这个问题，当

1218
00:57:21,133 --> 00:57:22,240
it's not going to be true?
它不会是真值？

1219
00:57:22,240 --> 00:57:24,115
And so the point I wanted to make here, which
所以，我在这里想说的重点是，

1220
00:57:24,115 --> 00:57:27,300
is that if we visualize that particular design,
就是，如果我们可视化那个特定的设计，

1221
00:57:27,300 --> 00:57:30,000
what the flow chart looks like is actually this.
流程图实际上是这样。

1222
00:57:30,000 --> 00:57:31,320
And let me zoom in at the top.
让我放大顶部。

1223
00:57:31,320 --> 00:57:34,500
If you ask the question "is x less than y," well,
如果你问问题“x 是否小于 y”，那么

1224
00:57:34,500 --> 00:57:37,502
you're going to go ahead and say, x less than y.
你将继续说，x 小于 y。

1225
00:57:37,502 --> 00:57:39,210
Then if you go down to the next question,
然后，如果你继续往下问下一个问题，

1226
00:57:39,210 --> 00:57:41,490
you're still going to ask is x greater than y.
你仍然会问 x 是否大于 y。

1227
00:57:41,490 --> 00:57:45,060
And then below that, you're still going to ask is x equal equal to y?
然后，在下面，你仍然会问 x 是否等于等于 y？

1228
00:57:45,060 --> 00:57:50,730
So no matter what x and y are, you're asking one, two, three questions all
所以，无论 x 和 y 是什么，你总是要问一个、两个、三个问题

1229
00:57:50,730 --> 00:57:51,580
of the time.
所有时间。

1230
00:57:51,580 --> 00:57:54,840
But if we actually go in and do what we did the first time,
但如果我们实际上进入并做我们第一次做的事情，

1231
00:57:54,840 --> 00:57:59,700
where if I go back to my code and I undo this edit and add back the "else if"s--
在那里，如果我回到我的代码，撤销这个编辑并添加回“else if”--

1232
00:57:59,700 --> 00:58:01,990
and now let me go back to the flow chart,
现在，让我回到流程图，

1233
00:58:01,990 --> 00:58:05,440
which I claim is bad because it's one, two, three questions, one
我认为它不好，因为它是一个、两个、三个问题，一个

1234
00:58:05,440 --> 00:58:09,630
or two of which might not be necessary-- now if I visualize what I just did,
或者两个可能是不必要的--现在，如果我可视化我刚刚做的，

1235
00:58:09,630 --> 00:58:12,480
the flow chart gets a little more complicated looking,
流程图看起来会更复杂一些，

1236
00:58:12,480 --> 00:58:15,430
but it's going to be better designed, more efficient.
但它将被更好地设计，更高效。

1237
00:58:15,430 --> 00:58:15,930
Why?
为什么？

1238
00:58:15,930 --> 00:58:19,320
Well, because if I start at the top here, I ask one question,
嗯，因为如果我从这里开始，我会问一个问题，

1239
00:58:19,320 --> 00:58:20,460
is x less than y.
x 是否小于 y。

1240
00:58:20,460 --> 00:58:22,050
If the answer is true, OK.
如果答案是正确的，好的。

1241
00:58:22,050 --> 00:58:23,220
I say x less than y.
我会说 x 小于 y。

1242
00:58:23,220 --> 00:58:25,680
And then, boom, I sort of cheat and go all the way
然后，砰，我有点作弊，直接

1243
00:58:25,680 --> 00:58:29,400
to the end of the program and stop, having asked only one question.
到达程序的末尾并停止，只问了一个问题。

1244
00:58:29,400 --> 00:58:33,600
If, though, x is not less than y, OK, fine, I'll ask you a second question.
但是，如果 x 不小于 y，好的，我会问你第二个问题。

1245
00:58:33,600 --> 00:58:37,680
But if the answer is true, boom, I print out x is greater than y,
但如果答案是正确的，砰，我会打印出 x 大于 y，

1246
00:58:37,680 --> 00:58:38,730
and then I stop.
然后我停止。

1247
00:58:38,730 --> 00:58:42,000
And only in a perverse case where x actually
并且只有在一个奇怪的情况下，即 x 实际上

1248
00:58:42,000 --> 00:58:46,410
equals y, which I'm going to claim is very unlikely or infrequent,
等于 y，我将声称这种情况非常不可能或不常见，

1249
00:58:46,410 --> 00:58:51,420
only then am I going to ask one, two, three questions to figure out whether
只有在这种情况下，我才会问一个、两个、三个问题来弄清楚是否

1250
00:58:51,420 --> 00:58:53,950
or not to print something at all.
打印任何东西。

1251
00:58:53,950 --> 00:58:56,557
So this is what we mean by distinguishing between correctness
所以这就是我们所说的代码正确性之间的区别

1252
00:58:56,557 --> 00:58:58,140
of code-- because it's still correct--
因为代码仍然是正确的——

1253
00:58:58,140 --> 00:59:01,050
but this version is better designed because hopefully you're
但这个版本设计得更好，因为希望你会

1254
00:59:01,050 --> 00:59:04,980
going to go down this branch or this branch rather than the longest one
沿着这条分支或那条分支，而不是最长的分支

1255
00:59:04,980 --> 00:59:06,390
frequently.
频繁地。

1256
00:59:06,390 --> 00:59:13,660
Any questions now about this code or this visualization thereof?
现在有关这段代码或其可视化，还有问题吗？

1257
00:59:13,660 --> 00:59:14,230
Yeah?
是吗？

1258
00:59:14,230 --> 00:59:17,597
STUDENT: I don't know if [INAUDIBLE]
学生：我不知道是否 [听不清]

1259
00:59:19,332 --> 00:59:20,540
DAVID MALAN: A perfect segue.
戴维·马兰：这是一个完美的过渡。

1260
00:59:20,540 --> 00:59:23,153
Why did I bother, though, even asking this question?
不过，我为什么要费心问这个问题呢？

1261
00:59:23,153 --> 00:59:25,070
Don't need to because when I hit this button--
不需要，因为当我按下这个按钮——

1262
00:59:25,070 --> 00:59:27,440
hopefully I have the right slide in place--
希望我的幻灯片正确就位——

1263
00:59:27,440 --> 00:59:30,287
this would be even better than that design.
这个设计会比那个设计更好。

1264
00:59:30,287 --> 00:59:31,620
So thank you for teeing that up.
所以感谢你提出这个问题。

1265
00:59:31,620 --> 00:59:32,662
This is the same picture.
这幅图是一样的。

1266
00:59:32,662 --> 00:59:35,630
It sort of got bigger because there's fewer nodes,
它变得更大了一点，因为节点更少了，

1267
00:59:35,630 --> 00:59:37,100
fewer shapes in the picture.
图片中的形状也更少了。

1268
00:59:37,100 --> 00:59:40,400
Notice that if x less than y, boom, we say as much, and we stop.
注意，如果 x 小于 y，砰，我们这样说，然后停止。

1269
00:59:40,400 --> 00:59:43,910
If x is not less than y but it's greater than y, boom, we stop.
如果 x 不小于 y，但它大于 y，砰，我们停止。

1270
00:59:43,910 --> 00:59:46,820
Or if it's not greater than, we immediately
或者如果它不大于，我们立即

1271
00:59:46,820 --> 00:59:49,580
conclude x indeed is equal to y.
得出结论，x 确实等于 y。

1272
00:59:49,580 --> 00:59:50,900
And again, we stop.
然后我们再次停止。

1273
00:59:50,900 --> 00:59:54,680
So this picture is about as efficient and as
所以这幅图在效率和

1274
00:59:54,680 --> 00:59:57,200
well designed as we can make our logic.
设计方面，已经达到我们逻辑所能达到的最佳水平。

1275
00:59:57,200 --> 00:59:59,640
That's about as good as we can solve this problem.
这是我们所能解决这个问题的最佳方法。

1276
00:59:59,640 --> 01:00:02,690
So if I go back to my code now to make my C code
所以，如果我现在回到我的代码，来修改我的 C 代码，

1277
01:00:02,690 --> 01:00:06,830
match that, the only thing I need to do is stop wasting the computer's time.
使其与之匹配，我只需要做的事情是，停止浪费计算机的时间。

1278
01:00:06,830 --> 01:00:08,540
Don't ask that third question.
不要问第三个问题。

1279
01:00:08,540 --> 01:00:12,290
Just logically, mathematically conclude that of course it's
从逻辑上和数学上得出结论，当然它会

1280
01:00:12,290 --> 01:00:16,455
going to be equal at that point in the story.
在那一点上相等。

1281
01:00:16,455 --> 01:00:18,080
All right, any other questions on this?
好了，关于这个还有其他问题吗？

1282
01:00:18,080 --> 01:00:21,340
STUDENT: [INAUDIBLE]
学生： [听不清]

1283
01:00:21,340 --> 01:00:23,906
DAVID MALAN: Sorry, a little louder?
戴维·马兰：抱歉，能大点声吗？

1284
01:00:23,906 --> 01:00:26,702
STUDENT: [INAUDIBLE]
学生： [听不清]

1285
01:00:28,353 --> 01:00:29,770
DAVID MALAN: Really good question.
戴维·马兰：非常好的问题。

1286
01:00:29,770 --> 01:00:31,728
What if I put in something that's not a number?
如果我输入了不是数字的东西，会怎么样？

1287
01:00:31,728 --> 01:00:35,910
So here, too, is where the CS50 library and the implementation of get_int
所以这里也是 CS50 库和 get_int 实现发挥作用的地方

1288
01:00:35,910 --> 01:00:36,990
will be your friend.
将会是你的好帮手。

1289
01:00:36,990 --> 01:00:41,400
So for instance, if I run ./compare and I want to compare cats and dogs,
例如，如果我运行 ./compare，我想比较猫和狗，

1290
01:00:41,400 --> 01:00:43,905
I could type in "cats," Enter.
我可以输入 "cats"，回车。

1291
01:00:43,905 --> 01:00:45,780
It's just going to prompt me again and again.
它会不断地提示我。

1292
01:00:45,780 --> 01:00:47,738
It's not going to let me type in "dogs" either.
它也不会让我输入 "dogs"。

1293
01:00:47,738 --> 01:00:49,740
It's going to force me to give it an integer.
它会强制我给它一个整数。

1294
01:00:49,740 --> 01:00:51,880
C does not do that by default.
C 不会默认这样做。

1295
01:00:51,880 --> 01:00:55,110
And in fact, as we'll soon see over the course of CS50,
事实上，正如我们很快将在 CS50 课程中看到的那样，

1296
01:00:55,110 --> 01:00:57,660
C is actually a very dangerous language at the end of the day
C 实际上是一种非常危险的语言，因为

1297
01:00:57,660 --> 01:01:00,660
because it just trusts that the human is doing what it wants.
它只是相信人类会按照它的意愿做事。

1298
01:01:00,660 --> 01:01:04,890
And as such, a lot of today's software that is hacked in some ways,
因此，今天很多以某种方式被黑客攻击的软件，

1299
01:01:04,890 --> 01:01:07,800
if it's using C or another language called C++,
如果它使用了 C 或另一种名为 C++ 的语言，

1300
01:01:07,800 --> 01:01:11,190
are actually very vulnerable to certain types of hacking,
实际上非常容易受到某些类型的黑客攻击，

1301
01:01:11,190 --> 01:01:14,880
whereas other languages that we'll get to in the class are less so for reasons
而我们将在课堂上学习的其他语言，由于诸如

1302
01:01:14,880 --> 01:01:17,170
like this.
这样的原因，不太容易受到攻击。

1303
01:01:17,170 --> 01:01:21,440
All right, so besides this, let's consider just one other data type.
好了，除了这个之外，让我们考虑一下另一种数据类型。

1304
01:01:21,440 --> 01:01:21,940
how about.
比如

1305
01:01:21,940 --> 01:01:26,710
So besides strings, besides chars, there's some others on this list here.
除了字符串之外，除了字符之外，这里列表中还有其他的数据类型。

1306
01:01:26,710 --> 01:01:29,110
Sorry, besides strings, besides integers,
抱歉，除了字符串之外，除了整数之外，

1307
01:01:29,110 --> 01:01:33,410
there's this other data type here in C known as a char for a single character.
在 C 中还有另一种数据类型，称为 char，用于表示单个字符。

1308
01:01:33,410 --> 01:01:35,050
So here, let me just tease this apart.
所以，让我来解释一下。

1309
01:01:35,050 --> 01:01:37,690
A string is indeed a string of text.
字符串确实是一串文本。

1310
01:01:37,690 --> 01:01:40,540
It is zero or more characters together.
它是由零个或多个字符组成的。

1311
01:01:40,540 --> 01:01:45,130
A char is always precisely one character.
char 始终是一个字符。

1312
01:01:45,130 --> 01:01:48,520
Not all languages bother distinguishing between a single character
并非所有语言都区分单个字符

1313
01:01:48,520 --> 01:01:49,660
and a string of characters.
和一串字符。

1314
01:01:49,660 --> 01:01:53,140
But in C, a string is typically multiple characters,
但在 C 中，字符串通常包含多个字符，

1315
01:01:53,140 --> 01:01:54,640
but technically can be zero.
但从技术上讲也可以是零个。

1316
01:01:54,640 --> 01:01:56,350
Coincidentally, it could be one.
巧合的是，它也可以是一个。

1317
01:01:56,350 --> 01:01:58,210
But it's capable of being more.
但它也可以是更多。

1318
01:01:58,210 --> 01:02:02,290
But a char is literally, as the word implies, a single character.
但 char 正如字面意思，就是单个字符。

1319
01:02:02,290 --> 01:02:05,050
All right, given that, notice that in the CS50 library,
好了，鉴于此，请注意在 CS50 库中，

1320
01:02:05,050 --> 01:02:08,388
besides get_string, besides get_int, we also have get_char,
除了 get_string，除了 get_int，我们还有 get_char，

1321
01:02:08,388 --> 01:02:10,930
so another handy function for just getting a single character
因此，这是另一个方便的函数，用于从用户那里获取单个字符

1322
01:02:10,930 --> 01:02:11,770
from the user.
。

1323
01:02:11,770 --> 01:02:14,603
Now, why would it be useful to get a single character from the user?
现在，为什么要从用户那里获取单个字符呢？

1324
01:02:14,603 --> 01:02:16,312
Well, what if you're just doing something
嗯，如果你只是在做一些

1325
01:02:16,312 --> 01:02:19,310
that you and I do pretty frequently when you install new software
你和我经常做的事情，比如安装新软件

1326
01:02:19,310 --> 01:02:20,750
or fill out some form?
或者填写一些表格？

1327
01:02:20,750 --> 01:02:23,370
You agree to some form of terms and conditions.
你会同意某种形式的条款和条件。

1328
01:02:23,370 --> 01:02:25,650
So in fact, let me go back over to VS Code here.
所以，事实上，让我回到这里的 VS Code。

1329
01:02:25,650 --> 01:02:29,540
And let me propose that I create a new program called agree.c,
让我提议创建一个名为 agree.c 的新程序，

1330
01:02:29,540 --> 01:02:32,420
so something akin to asking for the user's agreement.
所以，类似于征求用户的同意。

1331
01:02:32,420 --> 01:02:35,698
So in VS Code, I'm going to type "code agree.c."
所以，在 VS Code 中，我将输入 "code agree.c"。

1332
01:02:35,698 --> 01:02:37,490
And I'm going to do some quick boilerplate.
我将快速完成一些基本内容。

1333
01:02:37,490 --> 01:02:43,280
So include CS50.h, include stdio.h, int main(void).
所以，包含 CS50.h，包含 stdio.h，int main(void)。

1334
01:02:43,280 --> 01:02:46,820
And then inside of main, which is like the "green flag clicked,"
然后在 main 内部，这就像 "绿色旗帜被点击"，

1335
01:02:46,820 --> 01:02:47,960
I'm going to do this.
我要这么做。

1336
01:02:47,960 --> 01:02:51,290
Go ahead and get a character from the user,
获取用户输入的一个字符，

1337
01:02:51,290 --> 01:02:54,500
and ask them something simple like, "Do you agree?,"
并问他们一个简单的问题，例如："你同意吗？"

1338
01:02:54,500 --> 01:02:56,490
expecting a yes/no response.
预期得到一个“是”或“否”的答案。

1339
01:02:56,490 --> 01:03:00,778
But at the beginning of this line, I need to put the return value somewhere.
但在这行的开头，我需要将返回值存储到某个地方。

1340
01:03:00,778 --> 01:03:02,570
So I'm going to put it in a variable called
所以我将把它放到一个名为

1341
01:03:02,570 --> 01:03:06,200
C. And in programming, if you're just getting a single value,
C 的变量中。在编程中，如果你只是获取一个单一值，

1342
01:03:06,200 --> 01:03:11,645
it's OK sometimes to use X and Y or C when you're using--
有时使用 X 和 Y 或 C 也是可以的，当你使用--

1343
01:03:11,645 --> 01:03:15,470
in larger programs, you'll benefit from using actual words like "answer,"
在大型程序中，使用诸如“answer”之类的实际单词会更有益，

1344
01:03:15,470 --> 01:03:16,820
like we did from the get go.
就像我们从一开始就做的那样。

1345
01:03:16,820 --> 01:03:18,870
But C has to be a specific type.
但 C 必须是一种特定类型。

1346
01:03:18,870 --> 01:03:21,020
So I'm going to literally say "char," and then
所以我会直接写“char”，然后

1347
01:03:21,020 --> 01:03:23,180
I'm going to finish my thought with a semicolon.
用分号结束我的语句。

1348
01:03:23,180 --> 01:03:26,030
And here's now how I could check if the user agrees or not.
现在我可以检查用户是否同意。

1349
01:03:26,030 --> 01:03:27,480
I could do something like this.
我可以这样写。

1350
01:03:27,480 --> 01:03:31,580
If the value of C equals equals, quote, unquote,
如果 C 的值等于等于，双引号，双引号，

1351
01:03:31,580 --> 01:03:38,240
lowercase 'y,' then go ahead and print out "Agreed backslash n."
小写的 'y'，那么就打印 "Agreed backslash n"。

1352
01:03:38,240 --> 01:03:44,420
Else if the variable C has a value equal to lowercase 'n', let's go ahead
否则，如果变量 C 的值为小写的 'n'，我们继续

1353
01:03:44,420 --> 01:03:48,440
and print out, say, "Not agreed," as though I'm agreeing or not to some
打印 "Not agreed"，就好像我同意或不同意某些

1354
01:03:48,440 --> 01:03:49,670
terms and conditions.
条款和条件。

1355
01:03:49,670 --> 01:03:51,590
But notice these are not typos.
但注意，这些不是错误输入。

1356
01:03:51,590 --> 01:03:56,400
What did I do ever so subtly different from last time I used text?
我做了什么微妙的改变，和上次我使用文本时不同？

1357
01:03:56,400 --> 01:03:56,900
Yeah?
是吗？

1358
01:03:56,900 --> 01:03:58,983
STUDENT: Single quotes instead of double quotes.
学生：使用单引号而不是双引号。

1359
01:03:58,983 --> 01:04:01,150
DAVID MALAN: Single quotes instead of double quotes.
大卫·马兰：使用单引号而不是双引号。

1360
01:04:01,150 --> 01:04:02,150
So here's the heuristic.
所以这里有一个经验法则。

1361
01:04:02,150 --> 01:04:04,860
When using strings, which are generally multiple characters,
当你使用字符串，通常包含多个字符，

1362
01:04:04,860 --> 01:04:06,240
have to use double quotes.
必须使用双引号。

1363
01:04:06,240 --> 01:04:09,900
When using a single character, you should use single quotes
当你使用单个字符，应该使用单引号

1364
01:04:09,900 --> 01:04:11,320
around the single character.
将单个字符括起来。

1365
01:04:11,320 --> 01:04:13,770
So let me go ahead now and, make agree.
现在让我运行一下，让程序同意。

1366
01:04:13,770 --> 01:04:16,890
Nothing went wrong, which is good. ./agree, Enter,
没有任何错误，这很好。 ./agree，回车，

1367
01:04:16,890 --> 01:04:19,080
and let me go ahead and type in y for yes.
让我输入 y 代表 yes。

1368
01:04:19,080 --> 01:04:20,350
It seems to work.
它似乎工作正常。

1369
01:04:20,350 --> 01:04:24,480
Let me run it again. ./agree. n for no, and it seems to work.
我再运行一次。 ./agree。n 代表 no，它似乎工作正常。

1370
01:04:24,480 --> 01:04:27,600
And just if I type in something random like question mark, I don't know,
如果我输入一个随机的字符，比如问号，我不知道，

1371
01:04:27,600 --> 01:04:28,590
it doesn't crash.
它不会崩溃。

1372
01:04:28,590 --> 01:04:32,830
It just ignores me because I only had two Boolean expressions there.
它只是忽略了我，因为我只有两个布尔表达式。

1373
01:04:32,830 --> 01:04:35,610
But notice that it's actually a little buggy arguably.
但请注意，它实际上可能有点bug。

1374
01:04:35,610 --> 01:04:38,550
Let me run it again. ./agree, Enter.
我再运行一次。 ./agree，回车。

1375
01:04:38,550 --> 01:04:41,760
How about capital Y because, like, my Caps Lock is down.
大写的 Y 怎么样？因为我的 Caps Lock 键坏了。

1376
01:04:41,760 --> 01:04:43,050
OK, it just ignores me.
好的，它只是忽略了我。

1377
01:04:43,050 --> 01:04:46,020
Let me do it again. ./agree, capital N because my-- oops--
我再试一次。 ./agree，大写的 N，因为我的-- Oops--

1378
01:04:46,020 --> 01:04:48,540
because my Caps Lock is down.
因为我的 Caps Lock 键坏了。

1379
01:04:48,540 --> 01:04:49,590
OK, it just ignores me.
好的，它只是忽略了我。

1380
01:04:49,590 --> 01:04:52,590
But this should make sense because I'm literally checking for lowercase.
但这应该是有道理的，因为我实际上只检查了小写字母。

1381
01:04:52,590 --> 01:04:55,990
So how could I fix this?
那么我该如何解决这个问题？

1382
01:04:55,990 --> 01:05:00,347
How could I fix this without just changing lowercase to uppercase,
我该如何解决这个问题，而不只是将小写字母改为大写字母，

1383
01:05:00,347 --> 01:05:02,680
because that would then break it in the other direction?
因为那样就会在另一个方向上产生错误？

1384
01:05:02,680 --> 01:05:03,220
Yeah?
是吗？

1385
01:05:03,220 --> 01:05:06,510
STUDENT: [INAUDIBLE]
学生： [听不清]

1386
01:05:09,698 --> 01:05:12,490
DAVID MALAN: Yeah, let's just add another branch here, so to speak.
大卫·马兰：好的，我们在这里添加另一个分支。

1387
01:05:12,490 --> 01:05:18,090
So if variable C equals equals capital Y, then I can go ahead here
所以，如果变量 C 等于等于大写的 Y，那么我就可以在这里

1388
01:05:18,090 --> 01:05:20,280
and say printf agreed.
写上 printf agreed。

1389
01:05:20,280 --> 01:05:23,160
And then let me close my terminal to make more room.
然后，我关闭我的终端，腾出更多空间。

1390
01:05:23,160 --> 01:05:27,690
Otherwise, down here, else if C equals equals capital N,
否则，在这里，else if C 等于等于大写的 N，

1391
01:05:27,690 --> 01:05:31,050
let's go ahead and again say printf not agreed.
我们继续写上 printf not agreed。

1392
01:05:31,050 --> 01:05:33,600
And I claim that this would actually now work.
我认为这样应该可以正常工作了。

1393
01:05:33,600 --> 01:05:36,180
It's a four-way fork in the road, but I'm at least
这是一个四叉路口，但我至少

1394
01:05:36,180 --> 01:05:40,500
checking for lowercase, uppercase, lowercase, uppercase for y and n
检查了 y 和 n 的小写字母、大写字母、小写字母、大写字母

1395
01:05:40,500 --> 01:05:41,580
respectively.
分别。

1396
01:05:41,580 --> 01:05:44,910
I claim that this is correct, but this too,
我认为这样是正确的，但这样也

1397
01:05:44,910 --> 01:05:47,490
even if you've never programmed before, should start today
即使你之前从未编程过，也应该从今天开始

1398
01:05:47,490 --> 01:05:49,290
to rub you the wrong way.
让你感到不舒服。

1399
01:05:49,290 --> 01:05:51,420
Like, we can do better.
就像，我们可以做得更好。

1400
01:05:51,420 --> 01:05:53,790
This isn't the best design.
这不是最好的设计。

1401
01:05:53,790 --> 01:05:54,570
Why might that be?
为什么这么说？

1402
01:05:54,570 --> 01:05:55,490
Yeah?
是吗？

1403
01:05:55,490 --> 01:06:00,735
STUDENT: Could you change the character c to be uppercase, like before you even
学生： 你可以将字符 c 更改为大写字母，就像你在输入之前

1404
01:06:00,735 --> 01:06:01,235
[INAUDIBLE]?
[听不清]

1405
01:06:01,235 --> 01:06:02,420
DAVID MALAN: Ah, clever.
大卫·马兰：哦，很聪明。

1406
01:06:02,420 --> 01:06:07,790
So could we change the variable c to just be forced to uppercase
所以我们可以将变量 c 强制转换为大写字母

1407
01:06:07,790 --> 01:06:09,320
or maybe forced to lowercase?
或者强制转换为小写字母？

1408
01:06:09,320 --> 01:06:12,650
No matter what the human types, we just do that ourselves so that way
无论人类输入什么，我们自己做就可以了，这样

1409
01:06:12,650 --> 01:06:15,380
we can just simplify this again to two possible scenarios.
我们可以将它简化为两种可能的情况。

1410
01:06:15,380 --> 01:06:17,930
I love that, but we haven't seen any functions yet
我喜欢这个想法，但我们还没有看到任何函数

1411
01:06:17,930 --> 01:06:20,570
in C that would let me change things to uppercase or lowercase.
在 C 中可以将字符转换为大写或小写字母。

1412
01:06:20,570 --> 01:06:22,795
So we'll get there, but a good instinct and correct.
我们会学到的，但这是一个很好的直觉，也是正确的。

1413
01:06:22,795 --> 01:06:23,420
Other thoughts?
还有其他的想法吗？

1414
01:06:23,420 --> 01:06:24,620
STUDENT: Use "or."
学生：使用“或”。

1415
01:06:24,620 --> 01:06:28,550
DAVID MALAN: So we could use "or" in some sense, like a logical "or."
大卫·马兰：所以我们可以使用某种意义上的“或”，就像逻辑上的“或”。

1416
01:06:28,550 --> 01:06:32,760
What I don't like about this, to be clear, is that it's repeating itself.
我要说清楚，我不喜欢这一点，因为它重复了自己。

1417
01:06:32,760 --> 01:06:35,510
And there's this principle in programming, and in life in general,
在编程中，以及生活中，有一个原则，

1418
01:06:35,510 --> 01:06:37,940
like, don't repeat yourself unnecessarily.
就是不要无谓地重复。

1419
01:06:37,940 --> 01:06:41,930
And by that I mean I literally have the same line 10 as 14.
我的意思是，第 10 行和第 14 行完全相同。

1420
01:06:41,930 --> 01:06:44,760
I have the same line 18 as 22.
第 18 行和第 22 行也完全相同。

1421
01:06:44,760 --> 01:06:48,920
And if anything, one, I literally wasted twice as much time as I needed to.
而且，我浪费了两倍于必要的时间。

1422
01:06:48,920 --> 01:06:51,200
Put another way, per our discussion of Scratch,
换句话说，根据我们之前对 Scratch 的讨论，

1423
01:06:51,200 --> 01:06:53,510
what if I go in and just change something like,
如果我进入程序并更改某些内容，例如，

1424
01:06:53,510 --> 01:06:55,610
I want to be more excited, like "Agreed!"?
我想更兴奋一些，例如 "Agreed!"？

1425
01:06:55,610 --> 01:06:57,818
Well, I might forget to change it in the other place.
那么，我可能会忘记在另一个地方进行修改。

1426
01:06:57,818 --> 01:07:00,527
And let's just claim for today's purposes that that looks stupid,
而且，今天就假设那看起来很愚蠢，

1427
01:07:00,527 --> 01:07:02,580
it's a bug, because I want them to be consistent.
这是一个错误，因为我希望它们保持一致。

1428
01:07:02,580 --> 01:07:06,090
So don't invite situations where you might change something
所以，不要让代码出现你可能在一个地方修改，

1429
01:07:06,090 --> 01:07:07,650
in one place but not another.
而在另一个地方却没有修改的情况。

1430
01:07:07,650 --> 01:07:10,030
Just only write it in one place total.
只在一个地方写就行了。

1431
01:07:10,030 --> 01:07:12,280
So I like this idea of "or"-ing things together.
我喜欢将它们用“或”连接起来的想法。

1432
01:07:12,280 --> 01:07:14,580
So let me go ahead and delete what I just did.
所以我删除掉我刚写的代码。

1433
01:07:14,580 --> 01:07:18,240
And just to be clear, too, while this is on the screen, when you highlight code
为了更清楚起见，当你在屏幕上高亮代码时，

1434
01:07:18,240 --> 01:07:21,630
in VS Code based on how we've configured it, these dots just show you
在 VS Code 中，根据我们的配置，这些点只是显示

1435
01:07:21,630 --> 01:07:25,230
how much I've indented because in C, stylistically, the convention
我缩进了多少，因为在 C 语言中，从风格上来说，约定俗成的是

1436
01:07:25,230 --> 01:07:29,710
is generally to indent four spaces and maybe four more spaces.
通常缩进四个空格，可能还要再缩进四个空格。

1437
01:07:29,710 --> 01:07:32,100
So those dots just help you count without having
所以，这些点可以帮助你计数，而无需

1438
01:07:32,100 --> 01:07:34,560
to manually eyeball things yourself.
手动去估算。

1439
01:07:34,560 --> 01:07:36,180
But let me delete those lines.
但让我删除这些行。

1440
01:07:36,180 --> 01:07:38,250
Let me delete these lines.
让我删除这些行。

1441
01:07:38,250 --> 01:07:40,090
And this is going to look a little weird,
这看起来会有点奇怪，

1442
01:07:40,090 --> 01:07:43,590
but the way you can "or" two thoughts together, so to
但是，你可以将两个想法“或”在一起，也就是说，

1443
01:07:43,590 --> 01:07:46,950
speak, like "or" them together, is you don't say "or,"
将它们“或”在一起，你不会说“或”，

1444
01:07:46,950 --> 01:07:50,610
but you use two vertical bars, which syntactically
而是使用两个竖线，在语法上，

1445
01:07:50,610 --> 01:07:53,070
means the English word "or."
就代表英语单词“或”。

1446
01:07:53,070 --> 01:07:55,650
And you can just ask the other question, if C equals,
你也可以问另一个问题，如果 C 等于

1447
01:07:55,650 --> 01:07:57,330
quote, unquote, capital 'Y.'
引号引号，大写的‘Y’。

1448
01:07:57,330 --> 01:08:02,340
And then down here, I can say or C equals equals capital 'N.'
然后在下面，我可以说或者 C 等于等于大写的‘N’。

1449
01:08:02,340 --> 01:08:05,170
So it adds a little more code to each of those lines,
所以它给每一行都增加了一点代码，

1450
01:08:05,170 --> 01:08:09,450
but it doesn't add redundancy, because I've not duplicated my printf.
但它并没有增加冗余，因为我没有重复我的 printf。

1451
01:08:09,450 --> 01:08:12,570
I've not added more curly braces unnecessarily.
我没有无端地添加更多花括号。

1452
01:08:12,570 --> 01:08:17,040
Now as an aside, there's the opposite of "or", logically is the word "and."
顺便说一句，与“或”相反，在逻辑上就是“与”。

1453
01:08:17,040 --> 01:08:19,740
Just so you've seen it, I could do this.
为了让你看到它，我可以这样做。

1454
01:08:19,740 --> 01:08:24,430
"&&" in C is how you express that the thing on the left must be true
在 C 语言中，"&&" 表示左边的表达式必须为真

1455
01:08:24,430 --> 01:08:26,319
and the thing on the right must be true.
而右边的表达式也必须为真。

1456
01:08:26,319 --> 01:08:30,045
But why would this make no sense in this context of line 8?
但是，为什么在第 8 行的上下文中，这毫无意义呢？

1457
01:08:30,045 --> 01:08:31,920
STUDENT: It can't be uppercase and lowercase.
学生：它不可能既是大写又是小写。

1458
01:08:31,920 --> 01:08:33,753
DAVID MALAN: Yeah, at least to my knowledge,
大卫·马兰：是的，至少据我所知，

1459
01:08:33,753 --> 01:08:36,300
a character can't be both lowercase and uppercase.
一个字符不可能既是小写又是大写。

1460
01:08:36,300 --> 01:08:37,720
That just makes no logical sense.
这在逻辑上说不通。

1461
01:08:37,720 --> 01:08:41,250
So indeed "or" is what we want in this case.
所以，在这种情况下，我们确实需要“或”。

1462
01:08:41,250 --> 01:08:43,286
Other questions?
还有其他问题吗？

1463
01:08:43,286 --> 01:08:49,245
STUDENT: In CS50.h, is there a way to directly compare strings [INAUDIBLE]??
学生：在 CS50.h 中，有没有办法直接比较字符串 [听不清]？

1464
01:08:49,245 --> 01:08:50,370
DAVID MALAN: Good question.
大卫·马兰：好问题。

1465
01:08:50,370 --> 01:08:53,310
Via CS50.h, is there a way to compare strings.
通过 CS50.h，有没有办法比较字符串。

1466
01:08:53,310 --> 01:08:54,270
Short answer, no.
简短的回答，没有。

1467
01:08:54,270 --> 01:08:56,100
But C is going to give us that capability.
但是，C 语言会给我们提供这种能力。

1468
01:08:56,100 --> 01:08:59,439
And in fact, next week, among the things we'll do is actually compare strings.
事实上，下周，我们将会做的事情之一就是比较字符串。

1469
01:08:59,439 --> 01:09:01,439
And if you've programmed before, you'll see in C
如果你之前做过编程，你会在 C 语言中看到

1470
01:09:01,439 --> 01:09:04,533
that it actually doesn't work the way that you might expect.
它实际上并没有按照你预期的方式工作。

1471
01:09:04,533 --> 01:09:06,450
But that's a problem, too, that we will solve.
但这也是一个问题，我们会解决的。

1472
01:09:06,450 --> 01:09:08,040
But that transcends CS50.
但这超出了 CS50 的范畴。

1473
01:09:08,040 --> 01:09:15,370
That's a question for C. Other questions on this kind of logic?
这是关于 C 语言的问题。关于这种逻辑还有其他问题吗？

1474
01:09:15,370 --> 01:09:18,790
Just to make this real then, anytime you click one of those EULAs
为了使这一点变得真实，每当你点击那些 EULA

1475
01:09:18,790 --> 01:09:22,000
or terms and conditions on a form in a piece of software,
或软件中表格上的条款和条件时，

1476
01:09:22,000 --> 01:09:24,850
odds are there is code as simple as this underneath the hood.
很可能，在幕后会有像这样的简单代码。

1477
01:09:24,850 --> 01:09:25,760
Maybe it's graphical.
也许它是图形化的。

1478
01:09:25,760 --> 01:09:27,760
Maybe it's checking for you clicking this button
也许它在检查你是否点击了这个按钮

1479
01:09:27,760 --> 01:09:29,052
or maybe hitting the Enter key.
或者是否按下了回车键。

1480
01:09:29,052 --> 01:09:31,479
But underneath the hood is presumably some kind
但在幕后，很可能有一些

1481
01:09:31,479 --> 01:09:35,740
of conditional checking for those kinds of outputs.
条件检查来处理这些输出。

1482
01:09:35,740 --> 01:09:37,600
All right, how about another building block
好了，再来看看上一次的另一个构建块，

1483
01:09:37,600 --> 01:09:39,558
from last time, which we'll now translate to C,
现在我们将把它翻译成 C 语言，

1484
01:09:39,558 --> 01:09:41,720
namely loops, things that happen again and again?
也就是循环，反复发生的事情？

1485
01:09:41,720 --> 01:09:43,640
And these, too, are everywhere in code.
这些东西在代码中随处可见。

1486
01:09:43,640 --> 01:09:47,710
So in Scratch, here's how we might meow three times, super simple.
所以在 Scratch 中，我们可以用以下方法发出三声喵叫，非常简单。

1487
01:09:47,710 --> 01:09:49,430
In C, it's going to look a little weird.
在 C 语言中，它看起来会有点奇怪。

1488
01:09:49,430 --> 01:09:52,810
But you will get used to this over time if you've never programmed before.
但如果你以前从未做过编程，你会随着时间的推移逐渐习惯的。

1489
01:09:52,810 --> 01:09:55,540
It looks like a mouthful, OK.
它看起来很繁琐，好吧。

1490
01:09:55,540 --> 01:09:57,940
But let's tease it apart line by line.
但让我们逐行分析一下。

1491
01:09:57,940 --> 01:10:01,360
And you'll see that you won't have that reaction frequently because it's all
你会发现，你不会经常有这种反应，因为所有这些

1492
01:10:01,360 --> 01:10:03,500
going to start to look very similar to itself.
都会开始看起来非常相似。

1493
01:10:03,500 --> 01:10:04,900
But what are we doing here?
但我们在做什么呢？

1494
01:10:04,900 --> 01:10:09,400
In C, you don't have the luxury of these cute and fun puzzle pieces
在 C 语言中，你没有这些可爱有趣拼图块的便利，

1495
01:10:09,400 --> 01:10:12,430
that just do the work for you, repeat three times.
它们为你完成工作，重复三次。

1496
01:10:12,430 --> 01:10:16,250
In fact, in C and programming in general, sometimes
事实上，在 C 语言和一般的编程中，有时

1497
01:10:16,250 --> 01:10:18,870
the work is on us to actually figure out, OK,
我们要自己想办法解决，好吧，

1498
01:10:18,870 --> 01:10:21,830
how can I use functions, variables, conditionals, and loops
我怎样才能使用函数、变量、条件语句和循环

1499
01:10:21,830 --> 01:10:25,580
and implement some idea like repetition, like looping?
来实现重复这样的概念，比如循环？

1500
01:10:25,580 --> 01:10:27,680
And in C, here's how this might work.
而在 C 语言中，它可能是这样工作的。

1501
01:10:27,680 --> 01:10:31,850
How can I go about doing something like printing "meow" three times?
我如何才能做到像打印“喵”三次这样的事情呢？

1502
01:10:31,850 --> 01:10:33,620
Well, I know about variables now.
好吧，我现在知道变量了。

1503
01:10:33,620 --> 01:10:35,270
We're about to see loops.
我们马上就要看到循环了。

1504
01:10:35,270 --> 01:10:39,110
And I've seen how I can update variables by plussing or minusing
我已经看到了如何通过加减来更新变量

1505
01:10:39,110 --> 01:10:40,280
some value to them.
某个值。

1506
01:10:40,280 --> 01:10:41,850
Let's combine those ideas.
让我们把这些想法结合起来。

1507
01:10:41,850 --> 01:10:46,375
So first, I'm doing what with this highlighted line in English?
那么首先，用英语来说，我用这行高亮的代码在做什么呢？

1508
01:10:46,375 --> 01:10:49,250
If a friend cared to ask you, like, 'what is this line of code doing'
如果一个朋友想知道，比如，‘这行代码在做什么’

1509
01:10:49,250 --> 01:10:51,012
later today, what would you say?
今天晚些时候，你会怎么说？

1510
01:10:51,012 --> 01:10:54,250
STUDENT: It's creating a variable called "counter" and setting it equal to 3.
学生：它创建了一个名为“counter”的变量，并将其设置为 3。

1511
01:10:54,250 --> 01:10:56,750
DAVID MALAN: Good, it's creating a variable called "counter"
大卫·马兰：很好，它创建了一个名为“counter”的变量

1512
01:10:56,750 --> 01:10:58,400
and setting it equal to 3.
并将其设置为 3。

1513
01:10:58,400 --> 01:11:01,040
I'll use slightly new jargon.
我将使用一些新的术语。

1514
01:11:01,040 --> 01:11:04,157
I'm defining a variable, would be the term of our "called counter"
我正在定义一个变量，我们把它叫做“counter”

1515
01:11:04,157 --> 01:11:05,240
and setting it equal to 3.
并将其设置为 3。

1516
01:11:05,240 --> 01:11:07,152
So I'll use my hand to represent the counter.
所以我将用我的手来代表计数器。

1517
01:11:07,152 --> 01:11:08,360
And that's all a variable is.
而这就是变量的全部。

1518
01:11:08,360 --> 01:11:11,870
It's like storage in some case that I'm representing information, using
它就像一个存储器，我用它来表示信息，使用

1519
01:11:11,870 --> 01:11:14,480
my hand in this case or the computer's memory here.
我的手在这个例子中，或者计算机的内存在这里。

1520
01:11:14,480 --> 01:11:17,575
Now what happens when using a loop in C?
现在，在 C 语言中使用循环会发生什么？

1521
01:11:17,575 --> 01:11:20,700
There's different types of loops, one of which is called a for loop-- oop--
有很多不同类型的循环，其中之一叫做 for 循环——oop——

1522
01:11:20,700 --> 01:11:22,790
one of which is called a while loop-- spoiler.
其中之一叫做 while 循环——剧透一下。

1523
01:11:22,790 --> 01:11:24,770
A while loop works like this.
while 循环是这样的。

1524
01:11:24,770 --> 01:11:28,910
Inside of parentheses is a Boolean expression just like inside
在括号里面是一个布尔表达式，就像在

1525
01:11:28,910 --> 01:11:30,770
of a conditional that asks a question.
条件语句中询问问题一样。

1526
01:11:30,770 --> 01:11:33,330
But this time the question is going to determine,
但这一次，问题将决定，

1527
01:11:33,330 --> 01:11:37,080
do you keep going through the loop again and again and again?
你是否一遍又一遍地循环下去？

1528
01:11:37,080 --> 01:11:38,810
So it's not a one-time thing potentially.
所以这可能不是一次性的事情。

1529
01:11:38,810 --> 01:11:41,210
It is checked again and again and again to decide
它一遍又一遍地检查，以决定

1530
01:11:41,210 --> 01:11:44,810
when it is time to stop looping, to stop cycling.
何时停止循环，停止循环。

1531
01:11:44,810 --> 01:11:46,970
All right, so it's asking this question first.
好的，所以它首先问这个问题。

1532
01:11:46,970 --> 01:11:49,713
Is counter greater than 0?
计数器是否大于 0？

1533
01:11:49,713 --> 01:11:52,880
OK, obviously the answer is true because I'm still holding up three fingers.
好吧，答案显然是正确的，因为我仍然举着三根手指。

1534
01:11:52,880 --> 01:11:54,140
So what happens?
那么会发生什么？

1535
01:11:54,140 --> 01:11:58,070
C goes inside of the curly braces per the indentation
C 按照缩进进入花括号内

1536
01:11:58,070 --> 01:12:02,340
and executes printf of "meow," which prints out a "meow" on the screen.
并执行 "meow" 的 printf，它在屏幕上打印出 "meow"。

1537
01:12:02,340 --> 01:12:04,640
The next line of code executes, which, recall,
下一行代码被执行，回想一下，

1538
01:12:04,640 --> 01:12:07,250
is the same as just subtracting 1 from counter.
它和从计数器中减去 1 是相同的。

1539
01:12:07,250 --> 01:12:10,790
So I think I take down one finger, so I'm left with two.
所以我想我放下了一根手指，现在剩下两根了。

1540
01:12:10,790 --> 01:12:12,035
And what happens next?
接下来会发生什么？

1541
01:12:12,035 --> 01:12:13,910
Well, this you just kind of have to memorize.
好吧，这个你就必须记住。

1542
01:12:13,910 --> 01:12:16,580
Once you get to the end of the inside of a loop,
当你到达循环内部的末尾时，

1543
01:12:16,580 --> 01:12:19,460
you go back to the beginning of a loop here
你回到这里循环的开头

1544
01:12:19,460 --> 01:12:22,770
and ask the same question, the same Boolean expression.
并问相同的问题，相同的布尔表达式。

1545
01:12:22,770 --> 01:12:24,680
So is 2 greater than 0?
所以 2 大于 0 吗？

1546
01:12:24,680 --> 01:12:25,700
OK, obviously so.
好吧，显然是。

1547
01:12:25,700 --> 01:12:27,890
So you go into it, you print a "meow."
所以你进入它，你打印一个 "meow"。

1548
01:12:27,890 --> 01:12:31,400
You go into it and decrement counter further by one.
你进入它并将计数器再减 1。

1549
01:12:31,400 --> 01:12:33,470
So now my hand is holding up one.
所以现在我的手举起一根手指。

1550
01:12:33,470 --> 01:12:35,900
Now we wrap back around to the Boolean expression.
现在我们回到布尔表达式。

1551
01:12:35,900 --> 01:12:37,790
Is 1 greater than 0?
1 大于 0 吗？

1552
01:12:37,790 --> 01:12:38,480
Obviously.
显然是。

1553
01:12:38,480 --> 01:12:40,340
We print out a third "meow."
我们打印出第三个 "meow"。

1554
01:12:40,340 --> 01:12:43,850
We then decrement counter again, and my hand goes to zero.
然后我们再次减小计数器，我的手变为零。

1555
01:12:43,850 --> 01:12:45,680
We go back around once more.
我们再绕一圈。

1556
01:12:45,680 --> 01:12:47,600
Is 0 greater than 0?
0 大于 0 吗？

1557
01:12:47,600 --> 01:12:48,350
No.
不。

1558
01:12:48,350 --> 01:12:49,970
And now the program just terminates.
现在程序就结束了。

1559
01:12:49,970 --> 01:12:51,980
Or if there were more code here, it would just
或者如果这里有更多代码，它就会

1560
01:12:51,980 --> 01:12:56,240
jump outside of the curly braces and keep going lower on the screen.
跳出花括号，继续向下移动到屏幕上。

1561
01:12:56,240 --> 01:12:57,810
So that's all that's happening.
这就是发生的所有事情。

1562
01:12:57,810 --> 01:13:00,740
And so this is what MIT has the luxury of doing with pictures.
所以，这就是麻省理工学院可以用图片做到的。

1563
01:13:00,740 --> 01:13:03,440
But at MIT, someone probably essentially wrote
但在麻省理工学院，有人可能基本上写了

1564
01:13:03,440 --> 01:13:09,030
code that looks like this to give us the illusion, the abstraction of this.
看起来像这样的代码来给我们这种错觉，这种抽象。

1565
01:13:09,030 --> 01:13:12,710
So what we're learning today is how they invented these puzzle pieces
所以我们今天学习的是他们如何利用这些低级管道，如果你愿意的话，就像这样，

1566
01:13:12,710 --> 01:13:17,370
by just using lower-level plumbing, if you will, like this here.
发明了这些拼图块。

1567
01:13:17,370 --> 01:13:17,870
Yeah?
对吧？

1568
01:13:17,870 --> 01:13:21,900
STUDENT: What would happen if you created the variable "counter"
学生：如果你在花括号内创建变量 "counter" 会怎么样？

1569
01:13:21,900 --> 01:13:23,330
inside of the curly braces?
在花括号内？

1570
01:13:23,330 --> 01:13:24,830
DAVID MALAN: A really good question.
大卫·马兰：这是一个很好的问题。

1571
01:13:24,830 --> 01:13:28,430
What would happen if you created the variable inside of the curly braces?
如果你在花括号内创建变量会怎么样？

1572
01:13:28,430 --> 01:13:30,650
Short answer, it just wouldn't work in C,
简短的答案，它在 C 中不起作用，

1573
01:13:30,650 --> 01:13:33,560
because if I were to try with my slide here,
因为如果我要用我的幻灯片来试一下，

1574
01:13:33,560 --> 01:13:39,650
for instance, to move this line of code here down inside of this, for instance,
例如，将这行代码移到这里，例如，

1575
01:13:39,650 --> 01:13:44,700
now the very top line is trying to use counter before it even exists.
现在最上面的那行代码试图在它存在之前使用计数器。

1576
01:13:44,700 --> 01:13:46,160
So C is very literal it.
所以 C 非常严格。

1577
01:13:46,160 --> 01:13:48,000
Reads top to bottom, left to right.
从上到下，从左到右读取。

1578
01:13:48,000 --> 01:13:50,870
And if it hasn't seen you define or create a variable yet,
如果它还没有看到你定义或创建变量，

1579
01:13:50,870 --> 01:13:55,550
you're going to get some scary error message on the screen instead.
你将在屏幕上看到一些可怕的错误信息。

1580
01:13:55,550 --> 01:13:59,010
All right, other questions on this here code?
好的，关于这段代码还有其他问题吗？

1581
01:13:59,010 --> 01:13:59,510
No?
没有？

1582
01:13:59,510 --> 01:14:03,110
All right, so if we want to then maybe tighten this up a bit,
好的，如果我们想要紧凑一些，

1583
01:14:03,110 --> 01:14:05,130
let me propose that we could do this instead.
我建议我们可以这样做。

1584
01:14:05,130 --> 01:14:07,850
So besides this version of the code, let me just
除了这段代码之外，让我只

1585
01:14:07,850 --> 01:14:10,070
do something more canonical, more conventional.
做一些更规范、更传统的事情。

1586
01:14:10,070 --> 01:14:13,280
So you're totally fine with using a variable like counter .
所以你完全可以接受使用像 counter 这样的变量。

1587
01:14:13,280 --> 01:14:15,500
It's what Scratch uses by default. It's very verbose.
这是 Scratch 默认使用的，它非常冗长。

1588
01:14:15,500 --> 01:14:16,520
It does what it says.
它做它说的事。

1589
01:14:16,520 --> 01:14:18,410
Frankly, once you get comfy with programming,
坦白地说，一旦你对编程感到舒适，

1590
01:14:18,410 --> 01:14:20,480
like most typical programmers, whenever they
就像大多数典型的程序员一样，每当他们

1591
01:14:20,480 --> 01:14:24,210
have a single integer in a program whose sole purpose in life is to count,
在一个程序中有一个唯一的整数，它的唯一目的是计数，

1592
01:14:24,210 --> 01:14:27,810
they'll just use "i" for integer just like I used "c" for character.
他们会像我使用 "c" 来表示字符一样，使用 "i" 来表示整数。

1593
01:14:27,810 --> 01:14:29,820
When you have larger programs, you don't want
当你拥有更大的程序时，你不会想要

1594
01:14:29,820 --> 01:14:35,070
to start using A and B and C and D and E and F and so forth for your variables
使用 A、B、C、D、E、F 等等作为你的变量，

1595
01:14:35,070 --> 01:14:36,880
because nothing's going to make any sense.
因为什么都说不通。

1596
01:14:36,880 --> 01:14:40,980
But when you're doing something super simple like counting with an integer,
但当你做一些非常简单的事情，比如用整数计数时，

1597
01:14:40,980 --> 01:14:44,670
using a short-named variable is totally stylistically reasonable.
使用短命名的变量在风格上是完全合理的。

1598
01:14:44,670 --> 01:14:48,195
But I can tighten this up further, not just renaming counter to i.
但我可以进一步压缩它，不仅仅是将计数器重命名为 i。

1599
01:14:48,195 --> 01:14:50,580
What else can I do, if you recall?
你还记得我还能做什么吗？

1600
01:14:50,580 --> 01:14:51,300
Over here?
在这里？

1601
01:14:51,300 --> 01:14:52,800
STUDENT: [INAUDIBLE]
学生： [听不清]

1602
01:14:52,800 --> 01:14:53,550
DAVID MALAN: Sure.
大卫·马兰：当然。

1603
01:14:53,550 --> 01:14:55,150
STUDENT: A for loop?
学生：一个 for 循环？

1604
01:14:55,150 --> 01:14:56,400
DAVID MALAN: Oh, OK, for loop.
大卫·马兰：哦，好的，for 循环。

1605
01:14:56,400 --> 01:14:57,442
Yes, that was my spoiler.
是的，那是我剧透的。

1606
01:14:57,442 --> 01:15:00,300
But while in a while loop, I can tighten this up slightly more.
但在 while 循环中，我可以进一步压缩它。

1607
01:15:00,300 --> 01:15:01,460
Over here?
在这里？

1608
01:15:01,460 --> 01:15:03,660
STUDENT: Instead of i equals i minus 1.
学生：而不是 i 等于 i 减 1。

1609
01:15:03,660 --> 01:15:06,420
DAVID MALAN: Yeah, instead of i equals i minus 1,
大卫·马兰：是的，而不是 i 等于 i 减 1，

1610
01:15:06,420 --> 01:15:08,310
I can actually tighten this up this way.
我实际上可以这样压缩它。

1611
01:15:08,310 --> 01:15:10,143
And we didn't see the minus before, but it's
我们之前没有看到减号，但它是

1612
01:15:10,143 --> 01:15:15,120
the same idea-- i minus equals 1, or even more succinctly, i minus minus.
同一个想法——i 减等于 1，或者更简洁地说，i 减减。

1613
01:15:15,120 --> 01:15:18,210
So when you get comfortable with programming, any of these approaches
所以当你对编程感到舒适时，这些方法中的任何一种

1614
01:15:18,210 --> 01:15:19,230
are correct.
都是正确的。

1615
01:15:19,230 --> 01:15:21,875
This would be more conventional at this point.
现在，这将更常规。

1616
01:15:21,875 --> 01:15:24,000
So if you want to write code like most other people
所以如果你想像大多数其他人一样写代码，

1617
01:15:24,000 --> 01:15:28,410
write code, adopt ultimately these kinds of conventions.
写代码，最终采用这些约定。

1618
01:15:28,410 --> 01:15:31,170
All right, so that just does the exact same thing, though.
好的，虽然这只是做了完全相同的事情。

1619
01:15:31,170 --> 01:15:33,780
But let's now put this into practice.
但现在让我们把它付诸实践。

1620
01:15:33,780 --> 01:15:36,460
Let me go back to VS Code here.
让我回到这里的 VS Code。

1621
01:15:36,460 --> 01:15:40,590
Let me go ahead and clear my terminal and close agree.c from before.
让我清除我的终端，并关闭之前的 agree.c。

1622
01:15:40,590 --> 01:15:43,200
And let me go ahead and create a file called "meow."
让我创建一个名为 "meow" 的文件。

1623
01:15:43,200 --> 01:15:45,540
So code meow.c.
所以代码 meow.c。

1624
01:15:45,540 --> 01:15:47,530
And let me do this the sort of wrong way.
让我用错误的方式来做这件事。

1625
01:15:47,530 --> 01:15:49,320
Let me include stdio.h.
让我包含 stdio.h。

1626
01:15:49,320 --> 01:15:52,860
at the top, int main(void) thereafter.
在顶部，int main(void) 之后。

1627
01:15:52,860 --> 01:15:56,282
Inside of there, let me do printf "meow."
在里面，让我执行 printf "meow"。

1628
01:15:56,282 --> 01:15:57,240
And then you know what?
然后你知道吗？

1629
01:15:57,240 --> 01:15:58,020
I don't want to keep typing that.
我不想一直打字。

1630
01:15:58,020 --> 01:16:00,460
Let me just go ahead and copy/paste two more times.
让我直接复制粘贴两次。

1631
01:16:00,460 --> 01:16:04,140
So I claim this is correct, make meow.
所以，我认为这是正确的，运行 meow。

1632
01:16:04,140 --> 01:16:05,520
./meow, done.
./meow，完成。

1633
01:16:05,520 --> 01:16:07,980
I've got code that prints "meow" three times.
我写了三遍打印“meow”的代码。

1634
01:16:07,980 --> 01:16:11,790
But this, again, should already rub you the wrong way.
但是，这，再次强调，应该让你感到不舒服。

1635
01:16:11,790 --> 01:16:13,290
Why?
为什么？

1636
01:16:13,290 --> 01:16:14,040
Yeah?
是吗？

1637
01:16:14,040 --> 01:16:15,267
STUDENT: There's duplication.
学生：代码重复了。

1638
01:16:15,267 --> 01:16:16,350
DAVID MALAN: Because what?
大卫·马兰：因为什么？

1639
01:16:16,350 --> 01:16:17,030
STUDENT: There's duplication.
学生：代码重复了。

1640
01:16:17,030 --> 01:16:18,690
DAVID MALAN: Because I have duplication.
大卫·马兰：因为我的代码重复了。

1641
01:16:18,690 --> 01:16:20,250
I mean, I literally copied and pasted it.
我的意思是，我直接复制粘贴了。

1642
01:16:20,250 --> 01:16:21,510
And that's kind of a good rule of thumb.
这是一个经验法则。

1643
01:16:21,510 --> 01:16:24,690
If you, in the future, start finding yourself copying and pasting code
如果你在未来开始发现自己复制粘贴代码

1644
01:16:24,690 --> 01:16:27,570
within the same program, you're probably doing something wrong.
在同一个程序中，你可能做错了什么。

1645
01:16:27,570 --> 01:16:30,100
There's a better way to design it even if it's correct.
即使它是正确的，也有一种更好的设计方法。

1646
01:16:30,100 --> 01:16:32,513
So this is clearly a candidate for a loop.
所以这显然是一个循环的候选者。

1647
01:16:32,513 --> 01:16:34,180
So let me go ahead and actually do that.
所以，让我继续执行。

1648
01:16:34,180 --> 01:16:37,380
Let me just go ahead and remove all of this duplication.
让我直接删除所有重复代码。

1649
01:16:37,380 --> 01:16:42,630
Let me give myself a variable called i, set it equal to 3.
让我给自己一个名为 i 的变量，并将其设置为 3。

1650
01:16:42,630 --> 01:16:44,580
Let me go ahead and give myself a while loop
让我给自己一个 while 循环

1651
01:16:44,580 --> 01:16:47,550
and check that i is greater than 0.
并检查 i 是否大于 0。

1652
01:16:47,550 --> 01:16:50,640
Inside of this loop, let me print out just "meow" once.
在这个循环中，让我打印一次“meow”。

1653
01:16:50,640 --> 01:16:54,060
But I'll reuse that code again and again because here I'm
但是，我会反复使用这段代码，因为在这里我

1654
01:16:54,060 --> 01:16:56,100
going to do i minus minus.
将执行 i 减减。

1655
01:16:56,100 --> 01:16:59,820
So that's the exact same code, the tight version of it that we saw a moment ago.
所以，这是完全相同的代码，是我们刚才看到的紧凑版本。

1656
01:16:59,820 --> 01:17:04,900
Let me go ahead and "make meow" again, ./meow, and it still works.
让我继续运行“make meow”，./meow，它仍然有效。

1657
01:17:04,900 --> 01:17:06,270
Why is this version better?
为什么这个版本更好？

1658
01:17:06,270 --> 01:17:10,320
Because if you want the cat to meow five times, you change it in one place.
因为如果你想让猫叫五声，你只需要在一个地方进行修改。

1659
01:17:10,320 --> 01:17:15,630
If you want to make the cat a dog, you change the meow to a woof in one place,
如果你想把猫变成狗，你只需要在一个地方将 meow 改为 woof，

1660
01:17:15,630 --> 01:17:18,210
albeit changing the file name eventually, but changing it
虽然最终要更改文件名，但修改

1661
01:17:18,210 --> 01:17:22,950
in one place, not worrying about changing it again and again and again.
只需要在一个地方，而不用担心反复修改。

1662
01:17:22,950 --> 01:17:25,810
But there are other ways to do this.
但是还有其他方法可以做到。

1663
01:17:25,810 --> 01:17:30,300
For instance, let me propose that.
例如，我建议这样做。

1664
01:17:30,300 --> 01:17:34,540
And actually, let's see, let me propose that instead of just doing it this way,
实际上，让我们看看，我建议不要用这种方式，

1665
01:17:34,540 --> 01:17:36,870
just to be clear--
为了清楚起见，

1666
01:17:36,870 --> 01:17:39,660
yeah, let's go ahead and propose that instead of doing this,
是的，让我们继续建议不要这样做，

1667
01:17:39,660 --> 01:17:41,670
we can actually count in different directions.
我们可以用不同的方向计数。

1668
01:17:41,670 --> 01:17:44,820
I'm kind of forcing this idea of starting at 3, going down to 0.
我有点强迫大家接受从 3 开始，然后降到 0 的想法。

1669
01:17:44,820 --> 01:17:47,610
But when normal humans in this room, if you ever count something,
但是，当房间里正常的人类，如果你曾经数过东西，

1670
01:17:47,610 --> 01:17:49,530
you probably do 1, 2, 3, and done.
你可能就会 1，2，3，然后就完了。

1671
01:17:49,530 --> 01:17:51,640
Like, that's how we would count in the real world.
就像，这是我们在现实世界中计数的方式。

1672
01:17:51,640 --> 01:17:54,480
Well, we can do that, too, here code-wise.
好吧，我们也可以在代码中做到这一点。

1673
01:17:54,480 --> 01:17:56,670
We could initialize i to 1.
我们可以将 i 初始化为 1。

1674
01:17:56,670 --> 01:18:00,870
We could check that i is less than or equal to 3.
我们可以检查 i 是否小于或等于 3。

1675
01:18:00,870 --> 01:18:03,000
And we've not seen this syntax before, but there's
我们以前没有见过这种语法，但这里有

1676
01:18:03,000 --> 01:18:06,060
no easy way on a typical keyboard to type a less than or equal sign
在普通键盘上没有简单的方法来输入小于或等于符号

1677
01:18:06,060 --> 01:18:07,020
like in a math book.
就像数学书那样。

1678
01:18:07,020 --> 01:18:11,100
So we use two characters, a less-than sign and then an equal sign
所以我们使用两个字符，一个小于符号，然后是一个等于符号

1679
01:18:11,100 --> 01:18:11,940
back to back.
紧挨着。

1680
01:18:11,940 --> 01:18:13,620
And that means less than or equal to.
这意味着小于或等于。

1681
01:18:13,620 --> 01:18:18,030
And this is the same idea so long as I plus plus i inside of it
只要我在里面加上 i 的值

1682
01:18:18,030 --> 01:18:22,080
because that'll start at 1, then 2, but it won't stop then.
因为这将从 1 开始，然后是 2，但不会在那时停止。

1683
01:18:22,080 --> 01:18:25,440
It will go up to until i is equal to 3.
它将一直持续到 i 等于 3。

1684
01:18:25,440 --> 01:18:29,500
Once i becomes 4, then that Boolean expression isn't going to be true.
一旦 i 变成 4，那么这个布尔表达式将不再为真。

1685
01:18:29,500 --> 01:18:32,430
So it stops after three "meow"s total.
所以，它总共在三次“meow”之后停止。

1686
01:18:32,430 --> 01:18:34,710
But there's another way, too, and this is probably
但是，还有另一种方法，这可能是

1687
01:18:34,710 --> 01:18:37,560
the most conventional and the way you should do it
最传统的方法，也是你应该采用的方法

1688
01:18:37,560 --> 01:18:39,360
even though it's just as correct.
虽然它也是正确的。

1689
01:18:39,360 --> 01:18:43,030
In CS, if you've seen already last week, we almost always start counting from 0.
在 CS 中，如果你上周已经了解过，我们几乎总是从 0 开始计数。

1690
01:18:43,030 --> 01:18:43,530
Why?
为什么？

1691
01:18:43,530 --> 01:18:46,380
Just because, so we're not wasting a pattern of bits.
仅仅是因为，这样我们就不会浪费一串比特。

1692
01:18:46,380 --> 01:18:49,480
So generally when you start writing code that counts,
所以，通常当你开始编写计数的代码时，

1693
01:18:49,480 --> 01:18:52,770
you should, quote, unquote, "almost always" start at 0,
你应该，引号，引号，"几乎总是"从 0 开始，

1694
01:18:52,770 --> 01:18:56,070
count up to but not through the total you
计数到，但不要超过你

1695
01:18:56,070 --> 01:18:59,200
care about so you don't get one extra by accident.
关心的总数，这样你不会意外多出一个。

1696
01:18:59,200 --> 01:19:01,710
And so this would be the most conventional way
所以，这将是我们刚才描述的最传统的方法

1697
01:19:01,710 --> 01:19:04,090
of doing what we just described.
来完成我们刚才描述的事情。

1698
01:19:04,090 --> 01:19:05,130
But they're all correct.
但它们都是正确的。

1699
01:19:05,130 --> 01:19:07,620
You can make an argument that all of them are equally good.
你可以争辩说它们都同样好。

1700
01:19:07,620 --> 01:19:10,740
This is what most people, quote, unquote, "would do."
这是大多数人，引号，引号，"会做的事情"。

1701
01:19:10,740 --> 01:19:15,255
OK, other questions on this here syntax or logic?
好的，关于这种语法或逻辑，还有其他问题吗？

1702
01:19:18,440 --> 01:19:19,220
No?
没有？

1703
01:19:19,220 --> 01:19:21,530
All right, how about--
好的，怎么样 -

1704
01:19:21,530 --> 01:19:23,120
we got some cookies on the horizon.
我们快有饼干了。

1705
01:19:23,120 --> 01:19:26,240
But before we get there, let's meow a few more times, if we may.
但在我们到达那里之前，让我们再叫几声“meow”，如果可以的话。

1706
01:19:26,240 --> 01:19:31,373
So how about doing a little bit differently versus the while loop.
那么，与 while 循环相比，我们如何进行一些不同的操作呢？

1707
01:19:31,373 --> 01:19:32,790
And I think we heard it over here.
我认为我们在这里听到了。

1708
01:19:32,790 --> 01:19:35,850
Turns out there's another type of loop altogether.
事实证明，还存在另一种类型的循环。

1709
01:19:35,850 --> 01:19:37,850
So this one here.
所以，这个循环。

1710
01:19:37,850 --> 01:19:40,940
And this one, if you can believe it, is probably even more conventional
而且这个循环，如果你相信的话，可能比另一种方法更传统

1711
01:19:40,940 --> 01:19:41,940
than the other way.
更传统。

1712
01:19:41,940 --> 01:19:43,940
And this is going to be thematic in programming.
这在编程中将是主题性的。

1713
01:19:43,940 --> 01:19:46,463
There's rarely one way, one right way to do things.
很少有一种方法，一种正确的方法来做事情。

1714
01:19:46,463 --> 01:19:49,130
You're going to have bunches of different tools in your toolkit.
你的工具箱里会有很多不同的工具。

1715
01:19:49,130 --> 01:19:52,213
And your code might look different from someone else's because each of you
你的代码可能与别人的代码看起来不同，因为你们每个人

1716
01:19:52,213 --> 01:19:54,470
tends to reach for a different tool in that toolkit.
倾向于从工具箱中选择不同的工具。

1717
01:19:54,470 --> 01:19:55,650
And here's another tool--
这是另一个工具 -

1718
01:19:55,650 --> 01:19:57,350
and as you proposed earlier--
正如你之前所建议的那样 -

1719
01:19:57,350 --> 01:19:58,370
a for loop.
一个 for 循环。

1720
01:19:58,370 --> 01:20:02,960
A for loop is just another way of achieving the exact same idea
一个 for 循环只是实现完全相同想法的另一种方式

1721
01:20:02,960 --> 01:20:04,800
using slightly different syntax.
使用略微不同的语法。

1722
01:20:04,800 --> 01:20:08,360
And it's appealing, frankly in general, because it's a little more succinct.
坦率地说，它一般来说比较吸引人，因为它更简洁。

1723
01:20:08,360 --> 01:20:11,540
It just saves some keystrokes even though you have to memorize
它可以节省一些按键，即使你必须记住

1724
01:20:11,540 --> 01:20:12,980
the order in which it works.
它工作的顺序。

1725
01:20:12,980 --> 01:20:18,628
This code is identical to this code here functionally.
从功能上来说，这段代码和这里这段代码是一样的。

1726
01:20:18,628 --> 01:20:20,670
But aesthetically, of course, it looks different.
但从美学上来说，它看起来当然不同。

1727
01:20:20,670 --> 01:20:21,630
How does it work?
它是如何工作的？

1728
01:20:21,630 --> 01:20:24,330
In a for loop, notice that in the parentheses
在for循环中，请注意在括号中

1729
01:20:24,330 --> 01:20:26,790
is not a single simple Boolean expression.
不是一个简单的布尔表达式。

1730
01:20:26,790 --> 01:20:28,480
There are three things.
有三个东西。

1731
01:20:28,480 --> 01:20:33,060
One, before a semicolon, is a place to initialize a variable
第一个，在分号之前，是初始化变量的地方

1732
01:20:33,060 --> 01:20:34,710
to do your counting typically.
通常用于计数。

1733
01:20:34,710 --> 01:20:36,617
Second is the Boolean expression.
第二个是布尔表达式。

1734
01:20:36,617 --> 01:20:37,450
So it's still there.
所以它还在那里。

1735
01:20:37,450 --> 01:20:40,242
It's just surrounded on the left and the right by two other things.
它只是被另外两个东西包围着。

1736
01:20:40,242 --> 01:20:41,610
Lastly is the update.
最后一个是更新。

1737
01:20:41,610 --> 01:20:45,917
What do you want to do at the end of every loop through this block of code?
在循环通过这段代码的末尾，你想做什么？

1738
01:20:45,917 --> 01:20:48,250
So you can probably imagine where we're going with this.
所以你可能已经猜到我们要做什么了。

1739
01:20:48,250 --> 01:20:49,300
How does this work?
它是如何工作的？

1740
01:20:49,300 --> 01:20:51,570
The first thing that happens is that a variable
首先发生的是一个变量

1741
01:20:51,570 --> 01:20:54,360
called i is defined and initialized to the value of 0.
叫做i被定义并初始化为0。

1742
01:20:54,360 --> 01:20:56,400
That happens once and only once.
这只会发生一次。

1743
01:20:56,400 --> 01:20:58,020
Then we check the condition.
然后我们检查条件。

1744
01:20:58,020 --> 01:21:00,570
Is 0 less than 3?
0小于3吗？

1745
01:21:00,570 --> 01:21:01,470
Obviously yes.
很明显是的。

1746
01:21:01,470 --> 01:21:03,690
So now we don't do the plus plus yet.
所以现在我们还没有做加加操作。

1747
01:21:03,690 --> 01:21:04,810
We go into the loop.
我们进入循环。

1748
01:21:04,810 --> 01:21:07,352
And this is where the for loop's a little confusing at first.
刚开始的时候，for循环有点让人困惑。

1749
01:21:07,352 --> 01:21:08,460
We print out "meow."
我们打印出“喵”。

1750
01:21:08,460 --> 01:21:09,540
Then what happens?
然后发生了什么？

1751
01:21:09,540 --> 01:21:10,480
There's no more lines.
没有更多的行。

1752
01:21:10,480 --> 01:21:14,740
So we go back to the for loop, and we increment i at that point.
所以我们回到for循环，然后在那个时候增加i的值。

1753
01:21:14,740 --> 01:21:16,200
So now i is 1.
所以现在i是1。

1754
01:21:16,200 --> 01:21:19,290
Then we check the condition. i is less than 3?
然后我们检查条件。i小于3吗？

1755
01:21:19,290 --> 01:21:20,640
Yes, because 1 is less than 3.
是的，因为1小于3。

1756
01:21:20,640 --> 01:21:23,040
We go back into the loop and print "meow."
我们回到循环中，并打印出“喵”。

1757
01:21:23,040 --> 01:21:26,250
Now we go back to the plus plus, so i is now 2.
现在我们回到加加操作，所以i现在是2。

1758
01:21:26,250 --> 01:21:27,390
We check the condition.
我们检查条件。

1759
01:21:27,390 --> 01:21:28,890
2 is less than 3 obviously.
2显然小于3。

1760
01:21:28,890 --> 01:21:31,200
So we go back into the loop and print "meow."
所以我们回到循环中，并打印出“喵”。

1761
01:21:31,200 --> 01:21:34,590
Then we do the increment. i is now 3.
然后我们进行增量操作。i现在是3。

1762
01:21:34,590 --> 01:21:37,380
Is 3 less than 3?
3小于3吗？

1763
01:21:37,380 --> 01:21:41,070
No, so we exit the loop, and we're done, or we keep
不是，所以我们退出循环，然后就完成了，或者我们继续

1764
01:21:41,070 --> 01:21:42,960
going down here if there's more code.
如果还有更多的代码，则继续向下执行。

1765
01:21:42,960 --> 01:21:45,240
But how many times did I say "meow?"
但我说了多少次“喵”？

1766
01:21:45,240 --> 01:21:52,280
1, 2, 3 total, when my hand was 0, 1, and 2.
一共说了1、2、3次，当我的手是0、1、2的时候。

1767
01:21:52,280 --> 01:21:54,410
Questions on this alternative syntax?
关于这种替代语法，有什么问题吗？

1768
01:21:54,410 --> 01:21:56,540
It takes some getting used to, but most people
它需要一些时间来适应，但大多数人

1769
01:21:56,540 --> 01:21:58,910
would write loops using a for loop, I would say.
会使用for循环来写循环，我会说。

1770
01:21:58,910 --> 01:22:02,150
STUDENT: Could you now in the curly braces, use just one line of code?
学生：你现在可以在花括号中只使用一行代码吗？

1771
01:22:02,150 --> 01:22:02,870
DAVID MALAN: Yes.
大卫·马兰：是的。

1772
01:22:02,870 --> 01:22:05,540
If you really want to be cool and save syntax,
如果你真的想酷一点，节省语法，

1773
01:22:05,540 --> 01:22:11,390
yes, it is correct and common to eliminate the curly braces if you only
是的，如果你只有一行代码，那么省略花括号是正确且常见的。

1774
01:22:11,390 --> 01:22:13,400
have one line of code therein.
只有一行代码。

1775
01:22:13,400 --> 01:22:16,150
We in class will always put the curly braces there
我们在课堂上会一直放上花括号

1776
01:22:16,150 --> 01:22:19,400
because this is the kind of thing where, if you get forgetful, you go in later
因为这是那种，如果你健忘，你以后再去

1777
01:22:19,400 --> 01:22:20,360
and add a second line.
添加第二行。

1778
01:22:20,360 --> 01:22:22,360
Like, darn it, like you forgot the curly braces,
就像，该死，你忘了花括号，

1779
01:22:22,360 --> 01:22:24,150
things will not work as expected.
事情将不会按预期进行。

1780
01:22:24,150 --> 01:22:27,950
So in general, use the curly braces, but you do not have to strictly.
所以一般来说，使用花括号，但你没有必要严格要求。

1781
01:22:27,950 --> 01:22:30,000
Other questions on 6?
关于第6题还有其他问题吗？

1782
01:22:30,000 --> 01:22:30,500
Yes?
有吗？

1783
01:22:30,500 --> 01:22:33,665
STUDENT: [INAUDIBLE]
学生： [听不清]

1784
01:22:33,665 --> 01:22:35,290
DAVID MALAN: Can be used without, what?
大卫·马兰：可以不用什么？

1785
01:22:35,290 --> 01:22:37,168
STUDENT: [INAUDIBLE]
学生： [听不清]

1786
01:22:37,168 --> 01:22:39,460
DAVID MALAN: Oh, could you do it without the condition?
大卫·马兰：哦，你能不用条件吗？

1787
01:22:39,460 --> 01:22:43,570
Yes, there are very fancy things you can do that we won't focus on today.
是的，你可以做很多非常花哨的事情，我们今天不会关注它们。

1788
01:22:43,570 --> 01:22:48,160
But yes, if you want to get rid of the condition, you could get rid of this
但是是的，如果你想摆脱条件，你可以摆脱这个

1789
01:22:48,160 --> 01:22:48,820
here.
这里。

1790
01:22:48,820 --> 01:22:51,370
And that would actually make the loop go forever,
这实际上会使循环永远运行，

1791
01:22:51,370 --> 01:22:53,290
which may be a good thing if it's like a clock
如果它像一个钟表，这可能是一件好事

1792
01:22:53,290 --> 01:22:57,010
that you want to tick forever, but often not a good thing in code.
你想要它永远走动，但在代码中这通常不是一件好事。

1793
01:22:57,010 --> 01:22:58,600
Good question, though.
不过，这是一个好问题。

1794
01:22:58,600 --> 01:23:03,023
All right, so beyond that, let's just go ahead and put this into context.
好的，除此之外，让我们继续把它放到上下文中。

1795
01:23:03,023 --> 01:23:04,940
Just in case it helps you to think about this,
以防万一这能帮助你思考这个问题，

1796
01:23:04,940 --> 01:23:07,360
this is just another flow chart, if you're
这是一个流程图，如果你是一个

1797
01:23:07,360 --> 01:23:09,520
more of a visual thinker, that represents
视觉型思考者，它代表着

1798
01:23:09,520 --> 01:23:11,590
what it is this loop is now doing.
这个循环现在正在做什么。

1799
01:23:11,590 --> 01:23:14,630
Previously, all of our arrows went from top to bottom and stopped.
之前，我们所有的箭头都从上到下，然后停止。

1800
01:23:14,630 --> 01:23:16,960
But now there's an arrow going back, up, and around
但现在有一个箭头向后、向上和环绕

1801
01:23:16,960 --> 01:23:18,740
because of this loop, this cycle.
因为这个循环，这个循环。

1802
01:23:18,740 --> 01:23:21,550
So when we start this program, we set i equal to 0.
所以当我们启动这个程序时，我们将i设置为0。

1803
01:23:21,550 --> 01:23:23,920
We then check, is i less than 3?
然后我们检查，i小于3吗？

1804
01:23:23,920 --> 01:23:25,990
Obviously it is, so we print "meow."
很明显是的，所以我们打印出“喵”。

1805
01:23:25,990 --> 01:23:29,860
We increment i, and then we go back to that same condition.
我们增加i的值，然后返回到相同的条件。

1806
01:23:29,860 --> 01:23:31,930
We check the condition.
我们检查条件。

1807
01:23:31,930 --> 01:23:33,040
We print "meow."
我们打印出“喵”。

1808
01:23:33,040 --> 01:23:36,190
i plus plus, go back, go back.
i加加，返回，返回。

1809
01:23:36,190 --> 01:23:40,440
Now, if i equals 3, 3 is not less than 3, so the answer is false.
现在，如果i等于3，3不小于3，所以答案是假的。

1810
01:23:40,440 --> 01:23:41,248
And we stop.
然后我们停止。

1811
01:23:41,248 --> 01:23:43,040
So again, it's just another way of thinking
所以，这又是一种思考方式

1812
01:23:43,040 --> 01:23:46,460
about how the code in Scratch, how the code in C
关于Scratch中的代码，C中的代码

1813
01:23:46,460 --> 01:23:50,660
might alternatively work in each of these contexts.
如何在这些上下文中交替工作。

1814
01:23:50,660 --> 01:23:53,750
But there's this one other puzzle piece in Scratch,
但在Scratch中还有一个拼图块，

1815
01:23:53,750 --> 01:23:55,700
recall, that's not the repeat block, which
回想一下，那不是“重复”块，而是

1816
01:23:55,700 --> 01:23:59,210
is for finite numbers of repetitions, but forever.
用于有限次数的重复，而是永远。

1817
01:23:59,210 --> 01:24:02,240
And in C, there is a way to do this, but it's a little weird looking.
在C语言中，有一种方法可以做到这一点，但看起来有点奇怪。

1818
01:24:02,240 --> 01:24:03,860
There's no forever keyword.
没有“永远”关键字。

1819
01:24:03,860 --> 01:24:08,300
But you can use the while loop or, as you inferred,
但你可以使用while循环，或者，正如你推断的那样，

1820
01:24:08,300 --> 01:24:12,000
you can actually use the for loop without a condition in the middle.
你实际上可以使用for循环，中间没有条件。

1821
01:24:12,000 --> 01:24:14,720
So here, I can actually say this.
所以在这里，我实际上可以这么说。

1822
01:24:14,720 --> 01:24:17,690
If I want to do something forever, I want
如果我想永远做某事，我想

1823
01:24:17,690 --> 01:24:20,600
to make sure that the answer to my question, the Boolean expression,
确保我问题的答案，布尔表达式，

1824
01:24:20,600 --> 01:24:23,570
is always true, always true, always true,
永远为真，永远为真，永远为真

1825
01:24:23,570 --> 01:24:27,680
the easiest way to achieve that goal is just literally write "true" there
实现这个目标最简单的方法就是直接写"true"

1826
01:24:27,680 --> 01:24:29,670
because true is true no matter what.
因为无论如何，真就是真。

1827
01:24:29,670 --> 01:24:31,970
And it's a trick for making the loop forever
这是一个让循环永无止境的技巧

1828
01:24:31,970 --> 01:24:33,740
go around and around, as you might if you
一遍遍地循环，就像你可能想

1829
01:24:33,740 --> 01:24:36,740
want the cat to live forever and meow incessantly
让猫永远活着，不断地喵喵叫

1830
01:24:36,740 --> 01:24:39,690
or if it is a clock that you want to tick forever or the like.
或者如果你想要一个永远滴答作响的钟表等等。

1831
01:24:39,690 --> 01:24:44,720
So here, for instance, is how we might have a cat meow endlessly,
例如，这里是如何让一只猫无限地喵喵叫的

1832
01:24:44,720 --> 01:24:47,420
using this so-called for loop instead.
使用这个所谓的for循环。

1833
01:24:47,420 --> 01:24:50,330
But recall that in Scratch, we also had this ability
但请记住，在Scratch中，我们也有这种能力

1834
01:24:50,330 --> 01:24:52,700
to create some of our own puzzle pieces.
创建我们自己的积木。

1835
01:24:52,700 --> 01:24:55,700
And this, too, is something that we're going to be able to do here in C.
在C语言中，我们也能做到这一点。

1836
01:24:55,700 --> 01:24:59,570
And let me propose that we do exactly that
我建议我们这样做

1837
01:24:59,570 --> 01:25:03,090
by introducing the C analog of this.
通过引入C语言的等效代码。

1838
01:25:03,090 --> 01:25:08,023
So here, for instance, is, in Scratch, our definition
例如，在Scratch中，这是我们对

1839
01:25:08,023 --> 01:25:10,190
of a function called meow whose sole purpose in life
名为"meow"的函数的定义，它的唯一目的

1840
01:25:10,190 --> 01:25:12,740
was to just play the sound "meow" until it's done.
只是播放“喵”的声音，直到播放完毕。

1841
01:25:12,740 --> 01:25:15,000
This is going to look a little weird at first.
乍一看，这会有点奇怪。

1842
01:25:15,000 --> 01:25:17,540
But you'll notice some similarities with main.
但你会注意到它与main有一些相似之处。

1843
01:25:17,540 --> 01:25:21,230
So recall this thing I keep typing with main, int main(void), int main(void).
请记住，我一直在用main键入的东西，int main(void)，int main(void)。

1844
01:25:21,230 --> 01:25:25,080
That's just the "when green flag clicked" equivalent for today.
这只是今天“当绿色旗帜被点击时”的等效代码。

1845
01:25:25,080 --> 01:25:28,940
But if you want to create your own puzzle piece or your own function in C,
但如果你想在C语言中创建你自己的积木或函数

1846
01:25:28,940 --> 01:25:31,190
you, for now, literally do this.
你现在要做的就是。

1847
01:25:31,190 --> 01:25:34,760
You say, void, the name of the function you want to create, and then
你要说，void，你想创建的函数的名称，然后

1848
01:25:34,760 --> 01:25:35,870
void in parentheses.
括号里的void。

1849
01:25:35,870 --> 01:25:39,920
And technically what this means is that this function has no return value.
从技术上讲，这意味着这个函数没有返回值。

1850
01:25:39,920 --> 01:25:42,800
It doesn't hand you anything back like get_string or get_int.
它不会像get_string或get_int那样返回任何东西。

1851
01:25:42,800 --> 01:25:45,500
And the "void" in parentheses means it takes no inputs.
括号里的“void”意味着它不接受任何输入。

1852
01:25:45,500 --> 01:25:46,437
It only meows.
它只会喵喵叫。

1853
01:25:46,437 --> 01:25:48,020
You don't have to tell it how to meow.
你不必告诉它如何喵喵叫。

1854
01:25:48,020 --> 01:25:49,220
It's just going to meow.
它只会喵喵叫。

1855
01:25:49,220 --> 01:25:51,740
So no arguments, so to speak.
所以，可以说，没有参数。

1856
01:25:51,740 --> 01:25:53,990
This literally just prints out "meow."
它只是打印出“喵”。

1857
01:25:53,990 --> 01:25:56,990
But what this does for me is it abstracts away the idea of meowing.
但对我来说，这抽象了喵喵叫的概念。

1858
01:25:56,990 --> 01:25:59,360
I don't need to know how to use printf or that you're
我不需要知道如何使用printf，或者说你正在

1859
01:25:59,360 --> 01:26:01,370
using printf to make the cat meow.
使用printf让猫喵喵叫。

1860
01:26:01,370 --> 01:26:05,300
I now have a function in life called meow because in Scratch, recall,
我现在有一个名为“meow”的函数，因为在Scratch中，请记住，

1861
01:26:05,300 --> 01:26:06,470
I used it like this.
我这样使用它。

1862
01:26:06,470 --> 01:26:10,640
When the green flag is clicked, I could repeat three times this new custom
当绿色旗帜被点击时，我可以重复三次这个新的自定义

1863
01:26:10,640 --> 01:26:11,450
puzzle piece.
积木。

1864
01:26:11,450 --> 01:26:13,940
But in C, I could now do this.
但在C语言中，我现在可以这样做。

1865
01:26:13,940 --> 01:26:18,920
In my main program, I can use a for loop just like we saw a moment ago,
在我的主程序中，我可以使用一个for循环，就像我们刚才看到的那样

1866
01:26:18,920 --> 01:26:20,480
copy/pasted from earlier.
复制粘贴自之前。

1867
01:26:20,480 --> 01:26:25,310
But now I can call my own C function called meow.
但现在我可以调用我自己的C语言函数，名为“meow”。

1868
01:26:25,310 --> 01:26:28,040
And let me go ahead now and do this.
现在让我继续做这件事。

1869
01:26:28,040 --> 01:26:33,560
If I go over to my C code here, back in VS Code, let me go ahead
如果我在VS Code中转到我的C语言代码，让我继续

1870
01:26:33,560 --> 01:26:35,480
and delete everything inside main.
删除main里面的所有内容。

1871
01:26:35,480 --> 01:26:42,260
Let me go ahead and do for int i equals 0, i is less than 3, i++.
让我继续做for int i等于0，i小于3，i++。

1872
01:26:42,260 --> 01:26:45,980
Inside of my curly braces, let me go ahead and say "meow."
在我的花括号内，让我继续说“喵”。

1873
01:26:45,980 --> 01:26:49,460
But I now need this meow function to exist because if I
但我现在需要这个“meow”函数存在，因为如果我

1874
01:26:49,460 --> 01:26:52,280
do "make meow" again, notice error.
再次执行“make meow”，注意错误。

1875
01:26:52,280 --> 01:26:56,660
"Implicit declaration of function meow is invalid in C99"--
“在C99中，对函数“meow”的隐式声明是无效的”——

1876
01:26:56,660 --> 01:26:59,970
the 1999 version of C. What does that mean?
C语言的1999版本。这意味着什么？

1877
01:26:59,970 --> 01:27:02,510
Well, it doesn't know what the meow function is.
好吧，它不知道“meow”函数是什么。

1878
01:27:02,510 --> 01:27:04,820
And the meow function is not in CS50.h.
而“meow”函数不在CS50.h中。

1879
01:27:04,820 --> 01:27:06,710
It's not in stdio.h.
它不在stdio.h中。

1880
01:27:06,710 --> 01:27:08,070
I have to create it.
我必须创建它。

1881
01:27:08,070 --> 01:27:12,020
So let me type out or really copy/paste what I had on the screen a moment ago--
所以让我键入，或者更确切地说，复制粘贴我刚才屏幕上的内容——

1882
01:27:12,020 --> 01:27:13,370
"void meow meow"--
"void meow meow"——

1883
01:27:13,370 --> 01:27:20,210
[CHUCKLES] "void meow(void)" printf, quote, unquote, "meow," close quote,
[CHUCKLES]"void meow(void)" printf，引号，反引号，“喵”，闭合引号，

1884
01:27:20,210 --> 01:27:21,440
semicolon.
分号。

1885
01:27:21,440 --> 01:27:24,350
But here, too, let me scooch this down a bit
但在这里，让我把它稍微往下移一点

1886
01:27:24,350 --> 01:27:26,010
so you can see all the code at once.
这样你就可以一次性看到所有代码。

1887
01:27:26,010 --> 01:27:27,620
Let me now do make meow.
现在让我执行make meow。

1888
01:27:27,620 --> 01:27:30,860
And unfortunately, I still have an error.
不幸的是，我仍然有错误。

1889
01:27:30,860 --> 01:27:36,680
If I scroll up, still on line 7 of meow.c,
如果我向上滚动，仍然在meow.c的第7行

1890
01:27:36,680 --> 01:27:42,300
my compiler thinks that meow is invalid, that it does not exist.
我的编译器认为“meow”是无效的，它不存在。

1891
01:27:42,300 --> 01:27:44,150
This too is a common mistake.
这也是一个常见的错误。

1892
01:27:44,150 --> 01:27:50,240
And as simple as this code might be in spirit, where did I screw up?
虽然这段代码从精神上来说很简单，但我究竟错在哪里？

1893
01:27:50,240 --> 01:27:51,655
Yeah, in the middle.
是的，在中间。

1894
01:27:51,655 --> 01:27:54,530
STUDENT: You need to define the function like above where you use it.
学生：你需要像在使用它的地方那样定义这个函数。

1895
01:27:54,530 --> 01:27:57,238
DAVID MALAN: Yeah, I need to define the function before I use it.
大卫·马兰：是的，我需要在使用函数之前定义它。

1896
01:27:57,238 --> 01:27:59,120
So again, C is going to take you literally.
所以，C语言会严格按照你的意思来执行。

1897
01:27:59,120 --> 01:28:03,230
If you try to call meow on line 7, you better not define it on line 11.
如果你尝试在第7行调用“meow”，你最好不要在第11行定义它。

1898
01:28:03,230 --> 01:28:05,120
You better define it higher up.
你最好在上面定义它。

1899
01:28:05,120 --> 01:28:09,290
So the simplest fix is going to be just to do this.
所以，最简单的解决方法就是这样做。

1900
01:28:09,290 --> 01:28:10,610
Let me clear my terminal.
让我清除我的终端。

1901
01:28:10,610 --> 01:28:13,970
Let me highlight and just delete the meow function.
让我选中并删除“meow”函数。

1902
01:28:13,970 --> 01:28:15,770
And let me just paste it up here.
然后让我把它粘贴到上面。

1903
01:28:15,770 --> 01:28:18,000
And this will actually solve the problem.
这实际上会解决问题。

1904
01:28:18,000 --> 01:28:19,950
Make meow now works.
现在make meow可以工作了。

1905
01:28:19,950 --> 01:28:22,550
And if I do ./meow, that, too, works.
如果我执行./meow，它也工作。

1906
01:28:22,550 --> 01:28:26,090
But this isn't really the best solution because if your solution is constantly,
但这并不是最好的解决方案，因为如果你的解决方案总是

1907
01:28:26,090 --> 01:28:28,798
oh, well, just put it up there, put it up there, put it up there,
哦，好吧，把它放到那里，把它放到那里，把它放到那里

1908
01:28:28,798 --> 01:28:30,530
I bet we could contrive a situation where
我敢打赌，我们可以设计出一种情况

1909
01:28:30,530 --> 01:28:32,450
one function needs to be above the other,
一个函数需要在另一个函数之上，

1910
01:28:32,450 --> 01:28:33,620
but it needs to be above the other.
但它必须在另一个函数之上。

1911
01:28:33,620 --> 01:28:35,495
And that's just not going to work in general.
而这在一般情况下是行不通的。

1912
01:28:35,495 --> 01:28:40,110
And more importantly, it just pushes main lower and lower and lower
更重要的是，它只是将main向下推，向下推，向下推

1913
01:28:40,110 --> 01:28:40,712
in your file.
在你的文件中。

1914
01:28:40,712 --> 01:28:42,420
But the whole point of your main function
但你的main函数的重点是

1915
01:28:42,420 --> 01:28:43,890
is like, that's the entry point.
就像，它是入口点。

1916
01:28:43,890 --> 01:28:46,540
That is what happens when the green flag is clicked.
这就是绿色旗帜被点击时发生的事情。

1917
01:28:46,540 --> 01:28:50,340
And so just in terms of user conventions, it's just useful for main
因此，就用户惯例而言，将main放在文件的顶部是有用的，因为这样你就可以快速找到它。

1918
01:28:50,340 --> 01:28:53,400
to always be at the top of a file because then you can find it fast.
如果main在文件的顶部，你的朋友、你的助教可以快速找到它。

1919
01:28:53,400 --> 01:28:56,910
Your friends can, your TFs can find it quickly if it's at the top.
如果main在顶部，你的朋友、你的助教可以快速找到它。

1920
01:28:56,910 --> 01:29:01,290
So the other solution here would be to leave meow at the bottom
所以这里另一个解决方案是将meow放在底部

1921
01:29:01,290 --> 01:29:02,880
and leave main at the top.
并将main留在顶部。

1922
01:29:02,880 --> 01:29:07,080
But this is the only time, if I may, that copy/paste is OK.
但恕我直言，这可能是唯一一次可以复制粘贴的地方。

1923
01:29:07,080 --> 01:29:11,560
What I've highlighted here in line 11 is what's called the function's prototype.
我在第11行中突出显示的部分被称为函数原型。

1924
01:29:11,560 --> 01:29:16,860
It is enough information to give you the return type, the name of the function,
它提供了足够的信息来告诉你函数的返回类型和函数名称，

1925
01:29:16,860 --> 01:29:18,630
and the return value--
以及返回值——

1926
01:29:18,630 --> 01:29:20,820
and any arguments.
以及任何参数。

1927
01:29:20,820 --> 01:29:25,590
And so if you just copy/paste that one line and end it with a semicolon
所以如果你只复制粘贴那一行并在末尾加上分号

1928
01:29:25,590 --> 01:29:29,850
up there, that's enough of a hint to the compiler
放在上面，这已经足以提示编译器了

1929
01:29:29,850 --> 01:29:32,370
that, OK, it doesn't exist yet, but it will.
好的，它现在还不存在，但它会存在。

1930
01:29:32,370 --> 01:29:34,650
And it will look like that.
而且它会像那样。

1931
01:29:34,650 --> 01:29:37,110
That's the only time it's OK to copy/paste
这可能是唯一一次可以复制粘贴的地方

1932
01:29:37,110 --> 01:29:39,630
the very first line of a function you've written
你编写的函数的第一行

1933
01:29:39,630 --> 01:29:42,000
to the top of the file with a semicolon so
到文件顶部并加上分号，这样

1934
01:29:42,000 --> 01:29:45,270
that you can make the compiler happy.
你就可以让编译器开心了。

1935
01:29:45,270 --> 01:29:51,390
So if I do make meow now, still no errors. ./meow, and it now works.
所以现在如果我创建meow，仍然没有错误。 ./meow，现在它可以正常工作了。

1936
01:29:51,390 --> 01:29:55,800
But let me add one final feature, coming back to Scratch here.
但是让我添加一个最后的特性，回到Scratch这里。

1937
01:29:55,800 --> 01:29:57,480
And then it's time for a snack.
然后该吃点心了。

1938
01:29:57,480 --> 01:30:01,920
So here, recall, was sort of the last fancy thing we did in Scratch, where
所以在这里，回忆一下，这是我们在Scratch中做的最后一个花哨的东西，在那里

1939
01:30:01,920 --> 01:30:04,380
we created not only our own custom puzzle piece,
我们不仅创建了自己的自定义拼图块，

1940
01:30:04,380 --> 01:30:08,370
but it took an input so that we didn't need to keep using the loop ourself.
而且它接受一个输入，这样我们就不用一直自己使用循环了。

1941
01:30:08,370 --> 01:30:11,250
We could just let the meow function be told how many times
我们可以让meow函数告诉我们多少次

1942
01:30:11,250 --> 01:30:12,570
do you want the cat to meow.
你想让猫叫。

1943
01:30:12,570 --> 01:30:16,980
So in C, we don't have to make that many changes except this.
所以在C语言中，我们不需要进行太多更改，除了这个。

1944
01:30:16,980 --> 01:30:21,670
We change the prototype to take an argument inside of parentheses.
我们将原型修改为在括号内接受一个参数。

1945
01:30:21,670 --> 01:30:23,190
And this is the syntax for that.
这是这样做的语法。

1946
01:30:23,190 --> 01:30:26,850
If you want your own function in C to take one or more arguments,
如果你想让C语言中的函数接受一个或多个参数，

1947
01:30:26,850 --> 01:30:30,330
you give the arguments a name, n, or whatever you want to call it.
你需要给参数一个名字，n，或者你想要叫它什么都行。

1948
01:30:30,330 --> 01:30:33,060
But you have to tell C what the type of that input is.
但是你必须告诉C语言输入的类型是什么。

1949
01:30:33,060 --> 01:30:34,650
So it's an int n.
所以它是一个int类型的n。

1950
01:30:34,650 --> 01:30:36,240
So it knows it's a number.
所以它知道这是一个数字。

1951
01:30:36,240 --> 01:30:38,290
And then you can just use n in your program.
然后你就可以在程序中使用n了。

1952
01:30:38,290 --> 01:30:41,460
So instead of hard coding, typing manually the number 3,
所以与其硬编码，手动输入数字3，

1953
01:30:41,460 --> 01:30:43,090
I'm just using n here.
我在这里使用n。

1954
01:30:43,090 --> 01:30:46,590
So this is equivalent to what I did with Scratch, by just dragging and dropping
所以这相当于我在Scratch中所做的，通过拖放

1955
01:30:46,590 --> 01:30:48,720
the n variable there.
那里的n变量。

1956
01:30:48,720 --> 01:30:51,240
And then "meow" will get printed that many times.
然后“喵”会被打印那么多次。

1957
01:30:51,240 --> 01:30:54,780
If I want to then use this-- notice, this is the last version of the cat
如果我想使用它——注意，这是我们上周做的猫的最后一个版本

1958
01:30:54,780 --> 01:30:58,330
that we did last week-- you just say "meow" this many times.
——你只需要说“喵”那么多次。

1959
01:30:58,330 --> 01:31:03,060
So in C, this is where now the code gets very succinct
所以在C语言中，现在代码变得非常简洁

1960
01:31:03,060 --> 01:31:06,653
because all the main part of the program does is meow three times.
因为程序的主要部分就是让猫叫三次。

1961
01:31:06,653 --> 01:31:08,070
So this, again, is an abstraction.
所以这再次是一个抽象。

1962
01:31:08,070 --> 01:31:11,730
I don't need to know, care, or remember how meow is implemented.
我不用知道，关心或记住meow是如何实现的。

1963
01:31:11,730 --> 01:31:16,230
I just need to know what its return value, its name, and any arguments
我只需要知道它的返回值，它的名字，以及任何参数

1964
01:31:16,230 --> 01:31:17,560
thereto are.
而已。

1965
01:31:17,560 --> 01:31:21,600
So if I make this change, I think we can get the cat
所以如果我进行这个改变，我认为我们可以让猫

1966
01:31:21,600 --> 01:31:23,490
to meow any number of times.
叫任何次数。

1967
01:31:23,490 --> 01:31:25,920
Let me go back over to my C code here.
让我回到C代码这里。

1968
01:31:25,920 --> 01:31:31,710
Let me go back into the file and change "void" here to be int n,
让我回到文件中，将这里的“void”改为int n，

1969
01:31:31,710 --> 01:31:33,390
where n just means number.
其中n只表示数字。

1970
01:31:33,390 --> 01:31:36,960
I could use i, but n tends to be a quantity instead of a counter.
我可以使用i，但n通常是一个数量而不是一个计数器。

1971
01:31:36,960 --> 01:31:40,320
I then, inside of this function, am going to do a for loop--
然后，在这个函数内部，我将执行一个for循环——

1972
01:31:40,320 --> 01:31:43,620
for int i get 0; i less than n--
for int i等于0；i小于n——

1973
01:31:43,620 --> 01:31:46,110
instead of 3-- i++.
而不是3——i++。

1974
01:31:46,110 --> 01:31:49,050
And then inside of here, I'll paste that "meow" again.
然后在这里面，我会再粘贴那个“meow”。

1975
01:31:49,050 --> 01:31:52,950
I need to change my prototype to be identical, so another copy/paste,
我需要将原型改成一样的，所以再复制粘贴一次，

1976
01:31:52,950 --> 01:31:54,240
or just manually edit it.
或者直接手动编辑它。

1977
01:31:54,240 --> 01:31:56,940
But now notice what's cool about main, is
但现在注意main的妙处在于

1978
01:31:56,940 --> 01:32:00,090
that now I can meow maybe three times.
现在我可以让猫叫三次。

1979
01:32:00,090 --> 01:32:04,260
Make meow, Enter, ./meow.
创建meow，回车，./meow。

1980
01:32:04,260 --> 01:32:09,870
OK, or if I really want to be cool, I can change this to 30,000 times.
好的，或者如果我真的想酷炫一点，我可以把它改成30000次。

1981
01:32:09,870 --> 01:32:11,940
Go back here, make meow.
回到这里，创建meow。

1982
01:32:11,940 --> 01:32:16,500
Increase the size of my terminal window for a dramatic pre-break flourish.
为了戏剧性的断点，扩大我的终端窗口。

1983
01:32:16,500 --> 01:32:18,390
And there are 30-- that was a fast cat.
有30个——那是一只很快的猫。

1984
01:32:18,390 --> 01:32:19,950
There are 30,000 meows.
有30000个喵。

1985
01:32:19,950 --> 01:32:22,990
I think now let's go ahead and take-- that's a lot-- a 10-minute break.
我认为现在让我们去——太多了——休息10分钟。

1986
01:32:22,990 --> 01:32:23,940
We'll see you in 10.
10分钟后见。

1987
01:32:23,940 --> 01:32:26,400
Cookies are now served outside.
现在外面供应饼干。

1988
01:32:26,400 --> 01:32:29,490
All right, so we are back.
好的，我们回来了。

1989
01:32:29,490 --> 01:32:31,920
And I realize this has been a lot so far, right?
我意识到到目前为止已经学了很多，对吧？

1990
01:32:31,920 --> 01:32:33,630
So there's a lot of new syntax.
所以有很多新的语法。

1991
01:32:33,630 --> 01:32:36,100
There's a lot of translation of Scratch over to C.
有很多将Scratch翻译成C语言的内容。

1992
01:32:36,100 --> 01:32:39,790
But among the goals of having spent last week in Scratch
但是，在上周花了时间学习Scratch之后，我们的目标之一

1993
01:32:39,790 --> 01:32:44,830
and having spent problems at 0 in Scratch is that none of today's ideas
以及在Scratch中花了时间解决问题，就是今天讨论的这些想法

1994
01:32:44,830 --> 01:32:46,430
are really all that new.
其实都不是全新的。

1995
01:32:46,430 --> 01:32:49,780
It's just a lot of syntax that will get more comfortable and more
只是一些语法，随着时间的推移，你会越来越熟悉，越来越

1996
01:32:49,780 --> 01:32:52,480
in your muscle memory as time passes.
进入你的肌肉记忆中。

1997
01:32:52,480 --> 01:32:56,170
Up until now, though, we've focused largely on these side effects,
然而，到目前为止，我们主要关注的是这些副作用，

1998
01:32:56,170 --> 01:32:58,100
like things happening on the screen.
比如屏幕上发生的事情。

1999
01:32:58,100 --> 01:33:01,450
And that was akin to the speech bubble appearing in the world of Scratch.
这就像Scratch世界中出现的气泡。

2000
01:33:01,450 --> 01:33:05,170
But let's focus for just a bit-- before we then explore things
但让我们稍微关注一下——在我们探索一些东西之前

2001
01:33:05,170 --> 01:33:07,930
we can't do very well in code-- on return
我们无法在代码中很好地做到——关于返回

2002
01:33:07,930 --> 01:33:10,870
values instead in C. We've seen them already.
值，而不是在C语言中。我们已经见过它们了。

2003
01:33:10,870 --> 01:33:12,880
Like, get_string returns a value.
比如，get_string返回一个值。

2004
01:33:12,880 --> 01:33:16,400
Get_int returns a value, a string and an int respectively.
Get_int分别返回一个值，一个字符串和一个整数。

2005
01:33:16,400 --> 01:33:19,000
But what if we want to make our own functions that don't just
但是，如果我们想创建自己的函数，而这些函数不仅仅是

2006
01:33:19,000 --> 01:33:21,910
meow and visually have this side effect of meowing on the screen
叫“喵”并在视觉上产生在屏幕上叫“喵”的副作用

2007
01:33:21,910 --> 01:33:24,310
but actually hand us back some value?
而是真正地将一些值返回给我们呢？

2008
01:33:24,310 --> 01:33:26,950
Well, I bet we can do this in C, as well.
好吧，我敢打赌我们也可以在C语言中做到。

2009
01:33:26,950 --> 01:33:30,488
Well, let me propose that to go that route--
好吧，我建议我们沿着这条路走下去——

2010
01:33:30,488 --> 01:33:31,780
let me go back to VS Code here.
让我回到VS Code这里。

2011
01:33:31,780 --> 01:33:33,940
And let's make our very simple calculator
让我们创建一个非常简单的计算器

2012
01:33:33,940 --> 01:33:35,668
that just adds some numbers together.
它只把一些数字加在一起。

2013
01:33:35,668 --> 01:33:37,460
But the same calculator, we'll soon see, is
但是很快我们会发现，同一个计算器

2014
01:33:37,460 --> 01:33:40,790
going to get us into trouble if you don't understand what the computer is
如果我们不理解计算机是什么，就会陷入困境。

2015
01:33:40,790 --> 01:33:42,770
doing underneath the hood.
代码的内部运作。

2016
01:33:42,770 --> 01:33:47,690
Let me go ahead and run code of, say, calculator.c.
让我运行一下代码，比如 calculator.c。

2017
01:33:47,690 --> 01:33:49,910
And in here, let me go ahead and give myself
在这里，让我添加一些代码，

2018
01:33:49,910 --> 01:33:56,660
access to the CS50 library with CS50.h, the stdio.h library with stdio.h,
访问 CS50 库，使用 CS50.h 头文件，访问 stdio.h 库，使用 stdio.h 头文件，

2019
01:33:56,660 --> 01:34:01,370
int main(void), which, again, we'll just take for granted today that we have
int main(void)，再次强调，今天我们将假定我们拥有

2020
01:34:01,370 --> 01:34:03,290
to include atop any of these programs.
这些程序顶部的包含语句。

2021
01:34:03,290 --> 01:34:06,420
And let's just add two numbers together-- super simple calculator.
让我们把两个数字加起来，一个超级简单的计算器。

2022
01:34:06,420 --> 01:34:08,420
So it gives me a variable called x.
因此，我定义了一个名为 x 的变量。

2023
01:34:08,420 --> 01:34:10,640
Assign it the return value of get_int.
将 get_int 函数的返回值赋值给它。

2024
01:34:10,640 --> 01:34:13,520
And I'll ask the user to give us x.
然后我会让用户输入 x 的值。

2025
01:34:13,520 --> 01:34:15,530
Give me another variable called y.
再给我一个名为 y 的变量。

2026
01:34:15,530 --> 01:34:18,470
Assign it the return value of get_int again.
同样，将 get_int 函数的返回值赋值给它。

2027
01:34:18,470 --> 01:34:20,900
But this time, ask the user for y.
这次，让用户输入 y 的值。

2028
01:34:20,900 --> 01:34:26,600
And then, lastly, let's just go ahead and print out the value of x plus y.
最后，让我们打印出 x 加 y 的值。

2029
01:34:26,600 --> 01:34:29,540
But I don't think I can get away with something
但是我认为我不能直接使用

2030
01:34:29,540 --> 01:34:33,230
like this, x plus y semicolon, because if I
这样的代码，x 加 y 加分号，因为如果我

2031
01:34:33,230 --> 01:34:36,080
do this, based on what we've seen before,
这么做，基于我们之前所学，

2032
01:34:36,080 --> 01:34:37,790
what's actually going to get printed out?
实际打印出来的是什么？

2033
01:34:37,790 --> 01:34:38,390
STUDENT: x plus y.
学生：x 加 y。

2034
01:34:38,390 --> 01:34:40,250
DAVID MALAN: Right, literally like x plus y.
大卫·马兰：没错，就是 x 加 y。

2035
01:34:40,250 --> 01:34:43,700
So I think this is where I need the F in "printf" for formatting.
所以我认为这里需要用到 printf 中的 F，用于格式化。

2036
01:34:43,700 --> 01:34:48,470
What I think I really want to do is print out the value of some placeholder
我认为我真正想要做的是打印出一个占位符的值，

2037
01:34:48,470 --> 01:34:51,140
because, what do I want to substitute for percent i
因为，我想用什么来替换百分号 i

2038
01:34:51,140 --> 01:34:55,280
maybe as a second argument to printf intuitively?
可能作为 printf 的第二个参数？

2039
01:34:55,280 --> 01:34:56,990
Maybe just x plus y.
也许就是 x 加 y。

2040
01:34:56,990 --> 01:34:59,630
So indeed, I can get away with this because it turns out in C,
因此，我可以用这种方式，因为在 C 语言中，

2041
01:34:59,630 --> 01:35:03,290
there's a bunch of arithmetic operators, all of the ones that you might expect,
有很多算术运算符，包括你可能想到的所有运算符，

2042
01:35:03,290 --> 01:35:07,010
including addition, subtraction, multiplication, division,
包括加法、减法、乘法、除法，

2043
01:35:07,010 --> 01:35:09,570
and even this one, the so-called modulo operator,
甚至还有这个，所谓的模运算符，

2044
01:35:09,570 --> 01:35:12,470
which generally gives us the ability to calculate a remainder when
它通常可以用来计算除法运算的余数，

2045
01:35:12,470 --> 01:35:13,977
you divide one number by another.
你用一个数字除以另一个数字时。

2046
01:35:13,977 --> 01:35:15,560
But I'll keep it simple with addition.
但我将只使用简单的加法。

2047
01:35:15,560 --> 01:35:20,480
And indeed, with printf, if I want to print out the value of x plus y,
事实上，使用 printf，如果我想打印出 x 加 y 的值，

2048
01:35:20,480 --> 01:35:21,480
I can do that.
我可以做到。

2049
01:35:21,480 --> 01:35:25,940
But I have to tell printf what kind of value to expect, an integer,
但我必须告诉 printf 它应该期待什么样的值，一个整数，

2050
01:35:25,940 --> 01:35:29,010
thus the percent i instead of %s for string.
因此使用百分号 i 而不是百分号 s 用于字符串。

2051
01:35:29,010 --> 01:35:30,630
And I think this should do the job.
我认为这应该可以实现。

2052
01:35:30,630 --> 01:35:32,090
So let me go back to my terminal.
现在让我回到终端。

2053
01:35:32,090 --> 01:35:34,370
Make calculator, Enter.
输入 make calculator 并回车。

2054
01:35:34,370 --> 01:35:37,430
All is well so far. ./calculator, and let's keep it simple--
目前一切正常，输入 ./calculator，让我们保持简单，

2055
01:35:37,430 --> 01:35:39,230
1 for x, 2 for y.
x 输入 1，y 输入 2。

2056
01:35:39,230 --> 01:35:42,140
And indeed, I get 3 as the output.
结果确实是 3。

2057
01:35:42,140 --> 01:35:43,170
It's not very dynamic.
它不太灵活。

2058
01:35:43,170 --> 01:35:46,170
It can't do a subtraction or multiplication or much more.
它不能进行减法、乘法或更复杂的运算。

2059
01:35:46,170 --> 01:35:49,370
But it does at least do those kinds of calculations.
但至少它可以进行这些计算。

2060
01:35:49,370 --> 01:35:54,085
But let me propose now that we maybe make a reusable addition
但现在我建议我们创建一个可重复使用的加法

2061
01:35:54,085 --> 01:35:56,960
function, right, because addition is something I'm going to do a lot.
函数，对吧，因为加法是我要经常使用的运算。

2062
01:35:56,960 --> 01:35:59,750
And maybe it should be abstracted away with a function
也许应该使用一个函数来抽象它

2063
01:35:59,750 --> 01:36:02,310
just like meowing was abstracted away a moment ago.
就像刚才我们抽象了喵叫声一样。

2064
01:36:02,310 --> 01:36:05,060
So let me go ahead and instead of doing this,
所以让我们尝试一下，而不是像这样写，

2065
01:36:05,060 --> 01:36:08,360
let me go ahead and give myself a function called add,
让我们定义一个名为 add 的函数，

2066
01:36:08,360 --> 01:36:11,870
but instead of last time where I had a meow function,
但这次不像之前我们定义的 meow 函数，

2067
01:36:11,870 --> 01:36:14,420
I'm obviously going to call this "add" instead.
我显然要把它命名为 “add”。

2068
01:36:14,420 --> 01:36:19,040
And instead of last time, taking in no arguments,
而且和之前不同，它不需要接受任何参数，

2069
01:36:19,040 --> 01:36:21,600
I think I want add to work a little differently.
我认为 add 函数应该以不同的方式工作。

2070
01:36:21,600 --> 01:36:24,920
I don't want add necessarily to take an argument yet,
我暂时不想让 add 函数接收参数，

2071
01:36:24,920 --> 01:36:27,320
but I do want add to return some type of value.
但我想让 add 函数返回某种类型的值。

2072
01:36:27,320 --> 01:36:31,347
And just intuitively, what type of value should an addition function return?
直观地来说，加法函数应该返回什么类型的值？

2073
01:36:31,347 --> 01:36:32,180
STUDENT: An integer.
学生：整数。

2074
01:36:32,180 --> 01:36:33,680
DAVID MALAN: An integer, so an int.
大卫·马兰：整数，所以是 int。

2075
01:36:33,680 --> 01:36:37,250
So I'm going to change void, which means the absence of a return value--
所以我要将 void 改为 int，void 表示没有返回值，

2076
01:36:37,250 --> 01:36:39,860
nothing's coming back-- to literally "int."
什么都没有返回。

2077
01:36:39,860 --> 01:36:43,250
But I'm not going to change the thing inside parentheses yet.
但我暂时不会改变括号里的内容。

2078
01:36:43,250 --> 01:36:47,090
I'm going to go ahead and copy my prototype up here.
我将复制这个函数原型到上面。

2079
01:36:47,090 --> 01:36:51,590
And I'm going to make this change, return x plus y.
然后，我将做这样的修改，返回 x 加 y 的值。

2080
01:36:51,590 --> 01:36:57,438
And then here, instead of printing out x plus y, let's go ahead and do this.
然后这里，我们不再打印 x 加 y 的值，而是这样写。

2081
01:36:57,438 --> 01:36:59,480
Let me give myself a third variable just for now.
现在让我先定义一个第三个变量。

2082
01:36:59,480 --> 01:37:02,540
z equals the return value of this brand-new
z 等于这个新定义的

2083
01:37:02,540 --> 01:37:05,660
add function that's going to add x plus y for me.
add 函数的返回值，它将为我计算 x 加 y 的值。

2084
01:37:05,660 --> 01:37:07,520
And then let me print out the value of z.
然后我打印 z 的值。

2085
01:37:07,520 --> 01:37:10,860
Instead of x plus y, I'm outsourcing now to this add function
现在，我不再使用 x 加 y，而是将计算工作外包给了 add 函数，

2086
01:37:10,860 --> 01:37:14,690
so it will do the addition of x plus y.
它将计算 x 加 y 的值。

2087
01:37:14,690 --> 01:37:19,160
So similar in spirit to meowing, but the return values, I claim,
所以，它和喵叫声函数很像，但是返回值，我猜，

2088
01:37:19,160 --> 01:37:20,400
are about to create an issue.
将要引发一个问题。

2089
01:37:20,400 --> 01:37:22,640
So let me make calculator again.
所以，让我重新编译 calculator。

2090
01:37:22,640 --> 01:37:24,270
And there's definitely some errors.
显然出现了一些错误。

2091
01:37:24,270 --> 01:37:28,580
So here we have, "use of undeclared identifier x."
这里有错误提示，"未声明的标识符 x"。

2092
01:37:28,580 --> 01:37:30,390
And that's on line 17.
错误发生在第 17 行。

2093
01:37:30,390 --> 01:37:32,300
So that's pretty far down in the file.
所以是在文件比较后面的地方。

2094
01:37:32,300 --> 01:37:37,350
So specifically, my compiler does not like my use of x on line 17.
具体来说，我的编译器不接受我在第 17 行使用 x。

2095
01:37:37,350 --> 01:37:42,510
But wait a minute, x is clearly defined on line 8.
等等，x 明明在第 8 行被定义了。

2096
01:37:42,510 --> 01:37:46,555
What intuitively might explain this issue
直观地来说，是什么导致了这个问题

2097
01:37:46,555 --> 01:37:48,180
even if you've never programmed before?
即使你之前没有编程经验？

2098
01:37:48,180 --> 01:37:48,750
Yeah?
是吗？

2099
01:37:48,750 --> 01:37:52,245
STUDENT: Well, because x and y are defined in the main function, not
学生：嗯，因为 x 和 y 是在 main 函数中定义的，而不是

2100
01:37:52,245 --> 01:37:53,277
the add function.
在 add 函数中。

2101
01:37:53,277 --> 01:37:56,110
DAVID MALAN: Yeah, because x and y are defined in the main function,
大卫·马兰：没错，因为 x 和 y 是在 main 函数中定义的，

2102
01:37:56,110 --> 01:37:57,412
not in the add function.
而不是在 add 函数中。

2103
01:37:57,412 --> 01:37:59,620
So the term of art here that we're about to introduce
所以，我们即将引入一个专业术语

2104
01:37:59,620 --> 01:38:00,820
is something called "scope."
叫做 "作用域"。

2105
01:38:00,820 --> 01:38:05,920
So "scope" just refers to the context in which variables exist--
作用域指的是变量存在的上下文，

2106
01:38:05,920 --> 01:38:08,030
the context in which variables exist.
变量存在的上下文。

2107
01:38:08,030 --> 01:38:09,580
So by that, I mean this.
也就是说，

2108
01:38:09,580 --> 01:38:11,200
On line 8, I've declared x.
在第 8 行，我声明了 x。

2109
01:38:11,200 --> 01:38:12,595
On line y, I've declared--
在 y 行，我声明了，

2110
01:38:12,595 --> 01:38:14,830
[CHUCKLES] on line 9, I've declared y.
哈哈，在第 9 行，我声明了 y。

2111
01:38:14,830 --> 01:38:18,100
But the catch is-- and here's where the curly braces are helpful--
但是，关键在于，也是大括号发挥作用的地方，

2112
01:38:18,100 --> 01:38:25,000
those variables only exist in the context of the outer curly braces
这些变量只存在于最外层的括号中

2113
01:38:25,000 --> 01:38:26,950
that are nearest to them, like this.
最靠近它们的那一对，就像这样。

2114
01:38:26,950 --> 01:38:31,690
So I can use x and y on lines 10, 11, 12, and even up to 13,
所以，我可以在第 10 行、11 行、12 行，甚至一直到第 13 行使用 x 和 y。

2115
01:38:31,690 --> 01:38:33,170
but not thereafter.
但不能再往后用了。

2116
01:38:33,170 --> 01:38:35,920
So I certainly can't use x down here on line 7.
所以我当然不能在第 7 行使用 x。

2117
01:38:35,920 --> 01:38:39,400
But this is a problem, because if add's purpose in life is to add x and y
但这是一个问题，因为如果 add 的作用是将 x 和 y 相加

2118
01:38:39,400 --> 01:38:43,540
but add can't access x plus y, well, we have an issue of scope.
但 add 无法访问 x 加 y，那么，我们就遇到了一个范围问题。

2119
01:38:43,540 --> 01:38:46,840
Like, x and y are not in scope for this add function.
比如，x 和 y 在这个 add 函数的范围内不可用。

2120
01:38:46,840 --> 01:38:50,650
But that's OK because remember that every function we've seen thus far
但这没关系，因为请记住，到目前为止，我们看到的每个函数

2121
01:38:50,650 --> 01:38:53,790
can have maybe a return value or a side effect,
可能有一个返回值或副作用。

2122
01:38:53,790 --> 01:38:59,220
but it can also take 0 or one or two or more inputs, known as arguments.
但它也可以接受 0 个、1 个、2 个或多个输入，称为参数。

2123
01:38:59,220 --> 01:39:00,740
So what if I instead do this?
那我试试这个怎么样？

2124
01:39:00,740 --> 01:39:02,460
Let me clear my terminal window.
让我清理一下终端窗口。

2125
01:39:02,460 --> 01:39:05,630
And let me update add to not take nothing
让我更新 add，让它不接受任何

2126
01:39:05,630 --> 01:39:07,550
as input but maybe two integers.
作为输入，而可能接受两个整数。

2127
01:39:07,550 --> 01:39:10,130
And I'll call them arbitrarily a and b.
我将它们随意命名为 a 和 b。

2128
01:39:10,130 --> 01:39:12,920
But I have to tell the compiler what type of arguments
但我必须告诉编译器参数的类型

2129
01:39:12,920 --> 01:39:16,040
they are-- two integers, one after the other.
是两个整数，一个接一个。

2130
01:39:16,040 --> 01:39:18,720
And now what I can do is this.
现在我可以这样做。

2131
01:39:18,720 --> 01:39:21,380
Let me change this up here, too-- int a, int b--
让我在这里也改变一下，int a，int b。

2132
01:39:21,380 --> 01:39:23,840
just so that the prototype is exactly the same.
这样原型就完全一样了。

2133
01:39:23,840 --> 01:39:27,800
And the only purpose of this prototype is just to avoid the previous error,
而这个原型的唯一作用就是避免之前的错误。

2134
01:39:27,800 --> 01:39:30,440
where the compiler didn't realize add was going to exist
因为编译器之前没有意识到 add 会存在

2135
01:39:30,440 --> 01:39:32,790
because it came later in the file.
因为它出现在文件中的后面。

2136
01:39:32,790 --> 01:39:37,580
So here on line 11 now, if I want to add two values, x and y,
所以现在在第 11 行，如果我想把两个值 x 和 y 相加，

2137
01:39:37,580 --> 01:39:39,650
this is now the syntax.
这就是语法。

2138
01:39:39,650 --> 01:39:42,530
We saw syntax in Scratch for passing in inputs
我们在 Scratch 中看到了传递输入的语法

2139
01:39:42,530 --> 01:39:44,360
to tell it how many times to meow.
告诉它要叫多少次。

2140
01:39:44,360 --> 01:39:50,160
So this is just telling add what two numbers to add together.
所以这只是告诉 add 要将哪两个数字加在一起。

2141
01:39:50,160 --> 01:39:54,787
So now I have to change this to a plus b, for reasons we'll soon see.
所以现在我必须将它改为 a 加 b，原因我们很快就会看到。

2142
01:39:54,787 --> 01:39:56,120
And let me see if this is right.
让我看看是不是这样。

2143
01:39:56,120 --> 01:39:57,060
Make calculator.
生成计算器。

2144
01:39:57,060 --> 01:39:59,000
So far so good. ./calculator.
目前为止看起来不错。./calculator。

2145
01:39:59,000 --> 01:40:02,120
Let's do 1 and 2 for x and y respectively.
我们分别将 x 和 y 设置为 1 和 2。

2146
01:40:02,120 --> 01:40:05,630
And hopefully we should, again, see 3.
希望我们仍然能看到 3。

2147
01:40:05,630 --> 01:40:07,020
Now, what's going on?
现在，发生了什么？

2148
01:40:07,020 --> 01:40:11,990
So here, again, if I zoom in on my add function, this "int" here on the left,
所以这里，如果我放大 add 函数，左侧的这个 "int"

2149
01:40:11,990 --> 01:40:15,476
on line 15, means what about add?
在第 15 行，关于 add 是什么意思？

2150
01:40:15,476 --> 01:40:16,700
STUDENT: [INAUDIBLE]
学生：[听不清]

2151
01:40:16,700 --> 01:40:18,980
DAVID MALAN: This means that it has a return value, that it's an int.
大卫·马兰：这意味着它有一个返回值，它是一个整数。

2152
01:40:18,980 --> 01:40:21,563
So it's going to hand me back, metaphorically, a slip of paper
所以，它将象征性地交还给我一张纸条

2153
01:40:21,563 --> 01:40:24,080
with an answer on it that is of type integer.
上面写着答案，答案类型是整数。

2154
01:40:24,080 --> 01:40:25,400
It's not a word, like my name.
它不是一个词，比如我的名字。

2155
01:40:25,400 --> 01:40:26,750
It's a number instead.
而是一个数字。

2156
01:40:26,750 --> 01:40:33,290
These mentions of int here and here are inside the parentheses, which means
这里和这里提到的 int 都在括号内，这意味着

2157
01:40:33,290 --> 01:40:36,390
this function, add, takes two inputs.
这个函数，add，接受两个输入。

2158
01:40:36,390 --> 01:40:37,460
The first is an int.
第一个是整数。

2159
01:40:37,460 --> 01:40:38,540
The second is an int.
第二个也是整数。

2160
01:40:38,540 --> 01:40:42,930
And just so we have something to call them, I call them a and b respectively.
为了方便称呼，我分别称它们为 a 和 b。

2161
01:40:42,930 --> 01:40:49,010
So what happens essentially when I call the add function now on line 11,
所以当我在第 11 行调用 add 函数时，实际上发生了什么，

2162
01:40:49,010 --> 01:40:51,050
I'm kind of passing in x.
我实际上是在传递 x。

2163
01:40:51,050 --> 01:40:52,610
I'm passing in y.
我实际上是在传递 y。

2164
01:40:52,610 --> 01:40:56,210
But the add function is going to think of them as a and b respectively.
但 add 函数会分别将它们理解为 a 和 b。

2165
01:40:56,210 --> 01:40:57,770
It could call them anything I want.
我可以随意命名它们。

2166
01:40:57,770 --> 01:41:00,710
I could change this to the word "first" and "second."
我可以将它们改为 "first" 和 "second"。

2167
01:41:00,710 --> 01:41:03,500
And then I could literally change this to "first + second."
然后我可以直接将这里改为 "first + second"。

2168
01:41:03,500 --> 01:41:07,220
Those are perfectly acceptable as argument or variable names.
这些作为参数或变量名都是完全可以接受的。

2169
01:41:07,220 --> 01:41:08,210
But who really cares?
但这有什么关系呢？

2170
01:41:08,210 --> 01:41:12,500
Like, a and b for such a simple function is perfectly reasonable, too.
比如，对于这样一个简单的函数来说，a 和 b 也完全合理。

2171
01:41:12,500 --> 01:41:14,540
Technically, if your mind is going there,
从技术上来说，如果你想这样，

2172
01:41:14,540 --> 01:41:18,365
I could even call them the exact same thing.
我甚至可以给它们起一样的名字。

2173
01:41:18,365 --> 01:41:21,240
But let me propose for today, certainly don't do that because it just
但让我建议一下，今天就不要这样做，因为这样做会

2174
01:41:21,240 --> 01:41:24,210
confuses things if you've got x's and y's here, x's and y's here,
让人困惑，因为这里有 x 和 y，这里也有 x 和 y，

2175
01:41:24,210 --> 01:41:25,470
but they're clearly different.
但它们显然是不同的。

2176
01:41:25,470 --> 01:41:26,310
Just don't do that.
就不要这样做。

2177
01:41:26,310 --> 01:41:29,640
Try to come up with different variables just to keep yourself sane.
尽量想出不同的变量名称，这样才能保持清醒。

2178
01:41:29,640 --> 01:41:33,930
But here, I have a function that takes now two integers, a and b respectively.
但是这里，我有一个函数，它现在接受两个整数，分别为 a 和 b。

2179
01:41:33,930 --> 01:41:37,920
It just returns the sum of them so that I can now store the return
它只是返回它们的和，这样我就可以将返回值

2180
01:41:37,920 --> 01:41:40,680
value of add in a variable called z.
存储在一个名为 z 的变量中。

2181
01:41:40,680 --> 01:41:45,180
And then, quite simply, print it out.
然后，简单地将它打印出来。

2182
01:41:45,180 --> 01:41:47,520
But there's one other thing I can do here.
但我还可以做另外一件事。

2183
01:41:47,520 --> 01:41:51,690
Now, if we think about design, even if you've never programmed before,
现在，如果我们考虑设计，即使你以前从未编程过，

2184
01:41:51,690 --> 01:41:55,350
do I really need the variable z?
我真的需要变量 z 吗？

2185
01:41:55,350 --> 01:41:58,890
Because I'm defining it on line 11, and then I'm quickly using it on line 12,
因为我在第 11 行定义了它，然后我在第 12 行很快地使用了它，

2186
01:41:58,890 --> 01:41:59,672
and that's it?
就这样？

2187
01:41:59,672 --> 01:42:01,380
Like, sometimes you don't need variables.
比如，有时候你不需要变量。

2188
01:42:01,380 --> 01:42:03,213
And they might make your code more readable.
它们可能会让你的代码更易读。

2189
01:42:03,213 --> 01:42:06,840
But strictly speaking-- and this is just kind of like substitution in math--
但严格来说，这就像数学中的代入。

2190
01:42:06,840 --> 01:42:10,980
if z is the same thing as "add (x, y)," well, let me go ahead
如果 z 等于 "add (x, y)"，那么，让我继续

2191
01:42:10,980 --> 01:42:12,870
and just delete line 11 altogether.
直接删除第 11 行。

2192
01:42:12,870 --> 01:42:14,520
Let me get rid of mention of z.
让我删除 z。

2193
01:42:14,520 --> 01:42:16,800
You can actually get away with doing this.
你实际上可以这样做。

2194
01:42:16,800 --> 01:42:20,340
And much like the Join block in Scratch, where I kind of overlaid it
就像 Scratch 中的 Join 块一样，我把它叠加在

2195
01:42:20,340 --> 01:42:24,390
on the Say block, kind of stacking them, you can stack functions in C,
Say 块上，将它们叠起来，你可以在 C 中将函数叠起来。

2196
01:42:24,390 --> 01:42:26,640
or nest them really, kind of mathematically.
或者将它们嵌套起来，就像数学中那样。

2197
01:42:26,640 --> 01:42:28,530
Honestly, it makes it a little harder to read
说实话，这会让它稍微难以阅读一些

2198
01:42:28,530 --> 01:42:31,320
because your mind has to dive in conceptually deeper and deeper
因为你的思维必须在概念上不断深入

2199
01:42:31,320 --> 01:42:33,010
into this second argument.
到这个第二个参数。

2200
01:42:33,010 --> 01:42:35,310
But it's perfectly acceptable, too.
但这同样完全可以接受。

2201
01:42:35,310 --> 01:42:38,100
And just to connect the dots to maybe something from high school,
为了将这些点与高中的一些东西联系起来，

2202
01:42:38,100 --> 01:42:40,890
this is kind of analogous to a function in math class
这类似于数学课上的函数

2203
01:42:40,890 --> 01:42:43,260
being like f of x, where f is some function name,
就像 f(x)，其中 f 是一个函数名，

2204
01:42:43,260 --> 01:42:45,700
x is some arbitrary input to that function.
x 是该函数的任意输入。

2205
01:42:45,700 --> 01:42:49,120
And when you start to put functions inside of functions
当你开始将函数嵌套在函数中

2206
01:42:49,120 --> 01:42:51,570
so that the output of one becomes the input to the next,
使得一个函数的输出成为另一个函数的输入，

2207
01:42:51,570 --> 01:42:54,313
it's like using this syntax, f of g of x and so forth.
就像使用这种语法，f(g(x)) 等等。

2208
01:42:54,313 --> 01:42:56,230
If you've never seen that before, don't worry.
如果你以前从未见过，别担心。

2209
01:42:56,230 --> 01:42:59,730
But if you have, it's a way to connect some of these dots.
但如果你有，它是一种连接这些点的方法。

2210
01:42:59,730 --> 01:43:02,880
Any questions, though, on just this idea of now
不过，关于现在这个概念还有任何问题吗？

2211
01:43:02,880 --> 01:43:05,580
having a function that doesn't just have a side effect
有一个函数，它不仅仅有一个副作用

2212
01:43:05,580 --> 01:43:10,500
but instead has a return value?
而是有一个返回值？

2213
01:43:10,500 --> 01:43:11,790
Yeah, in back?
是的，后面那位同学？

2214
01:43:11,790 --> 01:43:14,031
STUDENT: In our declaration of main, why did we
学生：在我们的 main 函数声明中，为什么我们

2215
01:43:14,031 --> 01:43:16,622
show it as returning an integer instead of void?
把它显示为返回一个整数而不是 void？

2216
01:43:16,622 --> 01:43:19,080
DAVID MALAN: In our definition of main, why did I do, what?
大卫·马兰：在我们的 main 函数定义中，我做了什么？

2217
01:43:19,080 --> 01:43:21,445
STUDENT: Why do we show it as returning an integer
学生：为什么我们把它显示为返回一个整数

2218
01:43:21,445 --> 01:43:22,870
instead of returning as void?
而不是返回 void？

2219
01:43:22,870 --> 01:43:24,820
DAVID MALAN: Oh, a really good question that I was trying
大卫·马兰：哦，这是一个很好的问题，我今天正试图

2220
01:43:24,820 --> 01:43:26,195
to sweep under the rug for today.
把它掩盖起来。

2221
01:43:26,195 --> 01:43:28,240
But in every one of our programs thus far,
但在我们迄今为止的所有程序中，

2222
01:43:28,240 --> 01:43:31,330
I have indeed said "int main(void)."
我确实说过了“int main(void)”。

2223
01:43:31,330 --> 01:43:34,940
Technically speaking, whenever you write a program and it finishes running,
从技术上讲，每当你编写一个程序并运行完毕时，

2224
01:43:34,940 --> 01:43:37,750
it actually returns a value somewhat secretly.
它实际上会秘密地返回一个值。

2225
01:43:37,750 --> 01:43:41,200
It returns the number 0 by convention, which means all is well.
根据惯例，它返回数字 0，这意味着一切正常。

2226
01:43:41,200 --> 01:43:44,420
And it can return any other integer if something goes wrong.
如果出现问题，它可以返回任何其他整数。

2227
01:43:44,420 --> 01:43:46,960
In fact, on your Mac, PC, or even phone, if you've ever
事实上，在你的 Mac、PC 甚至手机上，如果你曾经

2228
01:43:46,960 --> 01:43:50,030
gotten like a weird message on the screen, like something went wrong
收到过屏幕上奇怪的消息，比如出现了错误

2229
01:43:50,030 --> 01:43:53,710
and it's like a weird numeric code, like error negative 129, or something
并且它像一个奇怪的数字代码，比如错误 -129，或者类似的东西

2230
01:43:53,710 --> 01:43:57,340
arbitrary like that, that tends to mean that some program running
像这样随意，这往往意味着你的 Mac、PC 或者手机上正在运行的某个程序

2231
01:43:57,340 --> 01:44:01,660
on your Mac, PC, or phone had something go wrong with the main function.
出现了 main 函数错误。

2232
01:44:01,660 --> 01:44:03,608
And that is the number that was returned.
那就是返回的数字。

2233
01:44:03,608 --> 01:44:05,650
But that's more than we want to talk about today.
但我们今天不想谈论太多。

2234
01:44:05,650 --> 01:44:07,060
But we'll come back to this.
但我们以后会再谈到这个。

2235
01:44:07,060 --> 01:44:08,890
But main always returns a number.
但 main 函数总是返回一个数字。

2236
01:44:08,890 --> 01:44:10,930
By default, it is 0.
默认情况下，它是 0。

2237
01:44:10,930 --> 01:44:12,640
More on that soon.
很快就会详细讲解。

2238
01:44:12,640 --> 01:44:15,790
All right, so with that said, let's actually tease
好了，现在让我们深入了解一下

2239
01:44:15,790 --> 01:44:18,100
apart what it is we've been using underneath the hood
我们一直在使用的一些幕后内容

2240
01:44:18,100 --> 01:44:21,743
here a little bit by returning to VS Code's interface itself.
通过回到 VS Code 的界面本身。

2241
01:44:21,743 --> 01:44:23,660
It turns out that all this time, even though I
事实证明，一直以来，尽管我

2242
01:44:23,660 --> 01:44:27,050
keep alluding to macOS and Windows, which like 99% of us
一直在暗示 macOS 和 Windows，就像我们 99% 的人

2243
01:44:27,050 --> 01:44:29,540
are probably running on our laptops or desktops,
可能都运行在我们的笔记本电脑或台式机上，

2244
01:44:29,540 --> 01:44:32,390
there's actually other very popular operating systems in the world,
实际上，世界上还有其他非常流行的操作系统，

2245
01:44:32,390 --> 01:44:33,620
among which is Linux.
其中之一就是 Linux。

2246
01:44:33,620 --> 01:44:36,960
So Linux is a very popular operating system,
所以 Linux 是一个非常流行的操作系统，

2247
01:44:36,960 --> 01:44:39,380
the thing that turns on-- the thing that boots up
是打开东西的东西——在你第一次开机时启动的东西。

2248
01:44:39,380 --> 01:44:40,880
when you first turn on a computer.
当你第一次开机时。

2249
01:44:40,880 --> 01:44:44,690
And it's very commonly used for servers nowadays.
现在，它非常普遍地用于服务器。

2250
01:44:44,690 --> 01:44:48,860
All of CS50's own servers run some version of Linux.
CS50 的所有服务器都运行着某个版本的 Linux。

2251
01:44:48,860 --> 01:44:51,080
Those students more comfortable sometimes
那些有时更习惯用 Linux 的学生

2252
01:44:51,080 --> 01:44:54,410
run Linux on their own Macs or PCs even.
甚至会在自己的 Mac 或 PC 上运行 Linux。

2253
01:44:54,410 --> 01:44:56,720
So Linux is a very popular operating system.
所以 Linux 是一个非常流行的操作系统。

2254
01:44:56,720 --> 01:45:00,110
And it's particularly characterized by its textual interface,
它的特点是文本界面，

2255
01:45:00,110 --> 01:45:03,770
its command-line interface, even though it also comes with graphical ones,
它的命令行界面，即使它也带有一个图形界面，

2256
01:45:03,770 --> 01:45:04,410
as well.
也是。

2257
01:45:04,410 --> 01:45:07,490
So again, this term we started today with, a graphical user interface
所以再次强调，我们今天开始讨论的术语，图形用户界面

2258
01:45:07,490 --> 01:45:09,230
is a thing with menus and buttons.
是指带有菜单和按钮的东西。

2259
01:45:09,230 --> 01:45:11,850
It's literally what you and I use every day on our devices,
它就是我们每天在设备上使用的，

2260
01:45:11,850 --> 01:45:13,220
otherwise known as a GUI.
也被称为 GUI。

2261
01:45:13,220 --> 01:45:15,440
But today onward, you'll get more comfortable
但从今天开始，你会对

2262
01:45:15,440 --> 01:45:18,380
with and more practice with this terminal window
这个终端窗口越来越熟悉，并且练习得越来越多

2263
01:45:18,380 --> 01:45:22,430
down here, which represents a command-line interface, or CLI.
这里，它代表的是命令行界面，即 CLI。

2264
01:45:22,430 --> 01:45:26,270
And just so you have a mental model of what's going on in the cloud here,
为了让你对这里云端发生的事情有一个心理模型，

2265
01:45:26,270 --> 01:45:31,460
when you access cs50.dev, you are accessing this version of VS Code
当你访问 cs50.dev 时，你正在访问这个版本的 VS Code

2266
01:45:31,460 --> 01:45:34,290
in the cloud, a piece of software just running in a browser.
在云端，这是一个在浏览器中运行的软件。

2267
01:45:34,290 --> 01:45:36,680
But that piece of software is automatically
但该软件会自动地

2268
01:45:36,680 --> 01:45:41,600
connected to your very own personal server in the cloud, so to speak.
连接到你自己的云服务器，可以这么说。

2269
01:45:41,600 --> 01:45:43,860
Technically speaking, it's a "docker container."
从技术上讲，它是一个“docker 容器”。

2270
01:45:43,860 --> 01:45:47,930
But it means that you have essentially your own mini server in the cloud
但这意味着你本质上拥有自己的云端迷你服务器

2271
01:45:47,930 --> 01:45:50,640
that only you have access to.
只有你才能访问它。

2272
01:45:50,640 --> 01:45:55,460
And that server or container is running an operating system called Linux.
该服务器或容器运行的操作系统叫做 Linux。

2273
01:45:55,460 --> 01:45:58,370
And in fact, every time I've been running a command down here,
事实上，每次我在下面运行命令时，

2274
01:45:58,370 --> 01:46:02,750
whether it's code or make or ./hello or anything else,
无论是 code 还是 make 还是 ./hello 或者其他任何东西，

2275
01:46:02,750 --> 01:46:06,740
I've been running commands from here in Sanders Theatre on a server somewhere
我都在桑德斯剧院的某台服务器上运行命令

2276
01:46:06,740 --> 01:46:10,280
in the cloud, my own Linux container or server.
在云端，我的 Linux 容器或服务器。

2277
01:46:10,280 --> 01:46:12,050
And you'll have the same yourself.
你也会拥有自己的。

2278
01:46:12,050 --> 01:46:14,270
This is the thing that we have pre-configured
这是我们预先配置好的

2279
01:46:14,270 --> 01:46:18,320
for you by installing the compiler in so many other pieces of software
为你们安装了编译器，以及其他许多软件

2280
01:46:18,320 --> 01:46:20,180
you'll soon see in the class.
你们很快就会在课程中看到。

2281
01:46:20,180 --> 01:46:24,920
But underneath the hood, then, of Linux is a soon-to-be familiar environment
但是，在 Linux 的幕后，有一个很快就会熟悉的环境

2282
01:46:24,920 --> 01:46:27,530
that allows you to run different types of commands.
它允许你运行不同类型的命令。

2283
01:46:27,530 --> 01:46:29,542
And those commands include things like this.
这些命令包括这些东西。

2284
01:46:29,542 --> 01:46:32,250
And this is something you'll develop muscle memory for over time.
随着时间的推移，你将会对它形成肌肉记忆。

2285
01:46:32,250 --> 01:46:36,710
But I wanted to give you a sense of some of the most popular textual commands
但我希望你们对一些最流行的文本命令有所了解

2286
01:46:36,710 --> 01:46:38,690
because we're essentially about to take away
因为我们基本上要拿走

2287
01:46:38,690 --> 01:46:42,740
muscle memory you have from a GUI world and have you type out words that
你们在 GUI 世界中形成的肌肉记忆，让你们打出代表着

2288
01:46:42,740 --> 01:46:46,280
represent double-clicking on things, dragging on other things,
双击某些东西、拖动其他东西的单词，

2289
01:46:46,280 --> 01:46:48,680
and other such commands that you and I take for granted.
以及其他我们习以为常的命令。

2290
01:46:48,680 --> 01:46:51,830
It'll be a little painful at first in the first days or weeks,
最初的几天或几周内会有点痛苦，

2291
01:46:51,830 --> 01:46:56,150
but it will make you far more productive long term so that even after CS50,
但从长远来看，这会让你效率更高，即使在 CS50 之后，

2292
01:46:56,150 --> 01:46:59,390
if you start using your programming skills in some other domain, class,
如果你开始在其他领域、课程中使用你的编程技能，

2293
01:46:59,390 --> 01:47:02,660
or real-world job, you'll just be a lot faster at the keyboard
或者现实工作中，你就会在键盘上快很多

2294
01:47:02,660 --> 01:47:04,980
and able to do more work more quickly.
而且能够更快地完成更多工作。

2295
01:47:04,980 --> 01:47:08,660
So with that said, let me go back to VS Code over here.
所以，现在让我们回到这里的 VS Code。

2296
01:47:08,660 --> 01:47:11,360
I'm going to go ahead and open up my File Explorer over here.
我要打开这里的文件资源管理器。

2297
01:47:11,360 --> 01:47:14,180
And you'll see at left all of the files that I've
你会在左边看到所有我已经有的文件

2298
01:47:14,180 --> 01:47:17,210
created thus far in class and all of the programs
目前在课堂上创建的所有程序

2299
01:47:17,210 --> 01:47:19,250
that I've compiled thus far in class.
以及我在课堂上编译的所有程序。

2300
01:47:19,250 --> 01:47:21,620
I also have this source 1 directory, which
我还有这个 source 1 目录，它

2301
01:47:21,620 --> 01:47:25,070
you can download from the course's website, which has all of today's code
可以从课程网站下载，其中包含今天的所有代码

2302
01:47:25,070 --> 01:47:27,740
pre-written in advance, so you don't have to type everything
事先编写好了，所以你不必输入所有内容

2303
01:47:27,740 --> 01:47:28,910
that I literally type.
我逐字输入的内容。

2304
01:47:28,910 --> 01:47:31,560
But all of these files are things that I've created.
但所有这些文件都是我创建的。

2305
01:47:31,560 --> 01:47:34,070
And you'll see that in white are the C files.
你会看到用白色显示的是 C 文件。

2306
01:47:34,070 --> 01:47:38,180
And grayed out are actually the binary files, the machine code
用灰色显示的是二进制文件，也就是机器码

2307
01:47:38,180 --> 01:47:40,160
that I created that I was running.
我创建并运行的机器码。

2308
01:47:40,160 --> 01:47:45,080
So you can click on any of these files in VS Code to open them.
因此，你可以在 VS Code 中点击任何这些文件来打开它们。

2309
01:47:45,080 --> 01:47:47,330
For instance, here is hello.c.
例如，这里就是 hello.c。

2310
01:47:47,330 --> 01:47:49,860
And voila, it opens in the text editor.
瞧，它在文本编辑器中打开了。

2311
01:47:49,860 --> 01:47:52,520
But if I try to open "hello," that's not going to work,
但如果我尝试打开“hello”，那就不行，

2312
01:47:52,520 --> 01:47:53,870
because that's zeros and ones.
因为那都是 0 和 1。

2313
01:47:53,870 --> 01:47:57,098
And frankly, the computer could show me all those zeros and ones,
坦白说，计算机可以向我展示所有这些 0 和 1，

2314
01:47:57,098 --> 01:47:58,640
but it's just not going to be useful.
但它并没有什么用。

2315
01:47:58,640 --> 01:48:01,800
And honestly, it's too easy to make one mistake and break the whole thing.
老实说，犯一个错误就很容易破坏整个程序。

2316
01:48:01,800 --> 01:48:05,690
So instead, VS Code says that it can't display the text, because it's binary
所以，VS Code 会提示它无法显示文本，因为它是二进制的

2317
01:48:05,690 --> 01:48:07,860
or maybe unsupported more generally.
或者更一般地说，它不受支持。

2318
01:48:07,860 --> 01:48:12,470
So know that you want to only click on the .c files when writing C code.
所以，记住，在编写 C 代码时，你只需要点击 .c 文件。

2319
01:48:12,470 --> 01:48:14,240
But let me go ahead and do something else.
但让我继续做点别的事情。

2320
01:48:14,240 --> 01:48:18,650
Suppose that I decide that, wait a minute, we're nearing the end of class.
假设我决定，等等，我们快下课了。

2321
01:48:18,650 --> 01:48:23,180
And we're not done yet, but what if I want to change hello.c to goodbye.c
我们还没结束，但如果我想把 hello.c 改成 goodbye.c

2322
01:48:23,180 --> 01:48:26,990
or if I want to change meow.c to woof.c and turn it into a dog?
或者如果我想把 meow.c 改成 woof.c 并把它变成一只狗？

2323
01:48:26,990 --> 01:48:28,310
Well, let's actually do that.
好吧，我们实际操作一下。

2324
01:48:28,310 --> 01:48:32,450
I could go over here and right click or Control click on the file,
我可以到这边，右键点击或 Control 点击文件，

2325
01:48:32,450 --> 01:48:33,650
just like on a Mac or PC.
就像在 Mac 或 PC 上一样。

2326
01:48:33,650 --> 01:48:35,520
I can find the Rename option.
我可以找到重命名选项。

2327
01:48:35,520 --> 01:48:37,460
And I can do it all via the GUI.
我也可以通过图形界面来完成所有操作。

2328
01:48:37,460 --> 01:48:41,120
But you should get more comfortable using commands like these here.
但你应该更习惯使用像这里这样的命令。

2329
01:48:41,120 --> 01:48:45,410
And among the commands on this list are "mv" for move, a.k.a.
在列表中的命令中，有“mv”，代表移动，也即

2330
01:48:45,410 --> 01:48:46,430
rename.
重命名。

2331
01:48:46,430 --> 01:48:52,430
So for instance, if I want to change meow.c to be woof.c instead,
例如，如果我想把 meow.c 改成 woof.c，

2332
01:48:52,430 --> 01:48:56,960
I literally type "mv" space, the original file name, space,
我会直接输入“mv”，空格，原始文件名，空格，

2333
01:48:56,960 --> 01:48:58,140
and the new file name.
以及新文件名。

2334
01:48:58,140 --> 01:49:00,050
So this is very similar to what I've already
所以这与我之前

2335
01:49:00,050 --> 01:49:03,260
been doing with the code program or the make program.
使用 code 程序或 make 程序的操作非常相似。

2336
01:49:03,260 --> 01:49:06,200
I not only type the name of the command but also the thing
我不仅输入命令的名称，还输入

2337
01:49:06,200 --> 01:49:08,690
that I want to code or the thing that I want to make.
我想编码的东西或我想制作的东西。

2338
01:49:08,690 --> 01:49:12,140
In this case, I type the thing that I want to move from old to new.
在这种情况下，我输入我想从旧位置移动到新位置的东西。

2339
01:49:12,140 --> 01:49:15,230
Now, if I hit Enter in a moment, watch on the left-hand side,
现在，如果我过一会儿按下回车，注意左侧，

2340
01:49:15,230 --> 01:49:18,200
meow.c in the GUI should automatically change
GUI 中的 meow.c 应该自动改变

2341
01:49:18,200 --> 01:49:23,800
even though I'm doing this all via the command-line keyboard interface.
即使我是在通过命令行键盘界面进行操作。

2342
01:49:23,800 --> 01:49:25,282
And now it becomes woof.c.
现在它变成了 woof.c。

2343
01:49:25,282 --> 01:49:26,740
I mean, it's not all that exciting.
我的意思是，它并不是那么令人兴奋。

2344
01:49:26,740 --> 01:49:29,380
But this is just to say that they are one and the same.
但这只是说它们是一回事。

2345
01:49:29,380 --> 01:49:33,260
One is a GUI, one is a CLI, but it's the same exact thing.
一个是 GUI，一个是 CLI，但它们本质上是一样的。

2346
01:49:33,260 --> 01:49:35,530
Moreover, let me go ahead and close now the GUI
此外，让我继续关闭左侧的 GUI

2347
01:49:35,530 --> 01:49:37,510
at left, the so-called explorer.
即所谓的资源管理器。

2348
01:49:37,510 --> 01:49:41,327
And in my terminal window alone, now I'm kind of out of my element,
现在，只有我的终端窗口，我有点不知所措，

2349
01:49:41,327 --> 01:49:43,660
like wait a minute, what was the file I created earlier?
比如，等等，我之前创建的文件是什么？

2350
01:49:43,660 --> 01:49:45,550
Well, there's other commands as well.
好吧，还有其他命令。

2351
01:49:45,550 --> 01:49:50,500
On this list is, coincidentally, "ls," which lists
巧合的是，列表中有“ls”，它列出了

2352
01:49:50,500 --> 01:49:52,940
the file in your current folder.
当前文件夹中的文件。

2353
01:49:52,940 --> 01:49:56,770
And as you might have gleaned here, "mv" for move, "ls" for list,
你可能已经注意到，“mv”代表移动，“ls”代表列出，

2354
01:49:56,770 --> 01:49:59,560
CS people like to be succinct, terse, and type
CS 人员喜欢简洁、简短，并且输入

2355
01:49:59,560 --> 01:50:01,150
the minimal number of keystrokes.
最少的按键。

2356
01:50:01,150 --> 01:50:04,180
That's why these are all abbreviated commands instead of full words.
这就是为什么这些都是缩写命令，而不是完整的单词。

2357
01:50:04,180 --> 01:50:07,480
But if I go back to my terminal window and type "ls," voila,
但如果我回到我的终端窗口并输入“ls”，瞧，

2358
01:50:07,480 --> 01:50:13,540
there is exactly the same contents of my server but displayed textually.
我的服务器的内容完全相同，但以文本形式显示。

2359
01:50:13,540 --> 01:50:14,920
And there's some heuristics here.
这里有一些启发式方法。

2360
01:50:14,920 --> 01:50:18,040
In green with an asterisk is all of the programs
用绿色和星号显示的是所有

2361
01:50:18,040 --> 01:50:21,110
that I made with make that are executable.
用 make 创建的可执行程序。

2362
01:50:21,110 --> 01:50:24,150
So the asterisks just means this is executable with dot-slash.
所以星号表示它可以用点斜杠执行。

2363
01:50:24,150 --> 01:50:27,860
Meanwhile, the source 1 directory, which only I have because I downloaded it
同时，source 1 目录，它只有我有，因为是我事先下载的

2364
01:50:27,860 --> 01:50:31,520
in advance, has a slash to indicate that it's a folder instead of a file.
它用斜杠表示它是一个文件夹，而不是文件。

2365
01:50:31,520 --> 01:50:36,570
But all of these white files ending in .c we created together here today.
但所有这些以 .c 结尾的白色文件都是我们今天在这里一起创建的。

2366
01:50:36,570 --> 01:50:42,020
Now, what if I really am embarrassed by my very first program, hello.c?
现在，如果我真的很害羞，不想保留我的第一个程序 hello.c 呢？

2367
01:50:42,020 --> 01:50:48,020
Well, I can very destructively go and use the rm command for remove.
好吧，我可以使用 rm 命令来删除它，它非常具有破坏性。

2368
01:50:48,020 --> 01:50:52,370
And rm hello.c is going to prompt me, a little cryptically,
而 rm hello.c 会提示我，有点神秘，

2369
01:50:52,370 --> 01:50:54,740
"remove regular file 'hello.c'?"
“删除普通文件‘hello.c’吗？”

2370
01:50:54,740 --> 01:51:01,580
And amazingly, this rm program has code just like we wrote earlier for agree.c,
令人惊奇的是，这个 rm 程序的代码和我们之前为 agree.c 编写的代码一样，

2371
01:51:01,580 --> 01:51:03,560
where I can type 'y' to delete it.
我可以在其中输入 'y' 来删除它。

2372
01:51:03,560 --> 01:51:05,060
I can type 'n' not to delete it.
我可以输入 'n' 来不删除它。

2373
01:51:05,060 --> 01:51:06,180
But let's delete it.
但我们还是删除它吧。

2374
01:51:06,180 --> 01:51:08,210
Let's go ahead and hit y, enter.
我们按下 y，回车。

2375
01:51:08,210 --> 01:51:09,840
Nothing seems to happen.
似乎什么也没发生。

2376
01:51:09,840 --> 01:51:11,370
But in general, that's a good thing.
但总的来说，这是一件好事。

2377
01:51:11,370 --> 01:51:14,170
But if I type "ls" again, notice what is now missing?
但如果我再次输入“ls”，你会发现现在缺少了什么？

2378
01:51:14,170 --> 01:51:15,920
And in fact, the list is a little shorter.
事实上，列表短了一点。

2379
01:51:15,920 --> 01:51:18,110
So it's one line instead of two.
所以只有一行，而不是两行。

2380
01:51:18,110 --> 01:51:20,370
"hello.c" is now gone.
“hello.c”现在不见了。

2381
01:51:20,370 --> 01:51:24,300
Now, if you do that, there are not easy ways to get the file back.
现在，如果你这样做了，就没有简单的方法来恢复文件。

2382
01:51:24,300 --> 01:51:26,750
So don't do that unless you really want to.
所以，除非你真的想这样做，否则不要这样做。

2383
01:51:26,750 --> 01:51:29,910
But there are backups maintained of these files, as well.
但这些文件的备份也得到了维护。

2384
01:51:29,910 --> 01:51:31,160
Well, what else is there, too?
还有别的什么吗？

2385
01:51:31,160 --> 01:51:32,510
Well, there's all of these other commands.
还有所有这些其他的命令。

2386
01:51:32,510 --> 01:51:34,052
And you'll experience them over time.
你会随着时间的推移而体验到它们。

2387
01:51:34,052 --> 01:51:35,540
Like, "cp" is copy.
比如，“cp”代表复制。

2388
01:51:35,540 --> 01:51:40,190
"mkdir" is make directory. "rmdir" is remove directory.
“mkdir”代表创建目录。“rmdir”代表删除目录。

2389
01:51:40,190 --> 01:51:43,070
And for instance, let me just show you one folder.
例如，让我展示给你一个文件夹。

2390
01:51:43,070 --> 01:51:45,770
If I type "ls," there's that source 1 folder
如果我输入“ls”，就会显示那个 source 1 文件夹

2391
01:51:45,770 --> 01:51:47,510
that I claimed I downloaded in advance.
我之前声称已经提前下载了。

2392
01:51:47,510 --> 01:51:50,120
If you want to see what's there, you can type "cd"
如果你想看看那里有什么，你可以输入 "cd"

2393
01:51:50,120 --> 01:51:53,810
for change directory, source 1, enter.
用于更改目录，源代码 1，回车。

2394
01:51:53,810 --> 01:51:56,970
And voila, notice that your prompt has now changed.
瞧，注意你的提示现在已经改变了。

2395
01:51:56,970 --> 01:51:58,310
And let me clear the screen.
让我清理一下屏幕。

2396
01:51:58,310 --> 01:52:03,320
Just as a visual reminder of where you are, you can see before the dollar sign
仅仅作为你所在位置的视觉提醒，你可以在美元符号之前看到

2397
01:52:03,320 --> 01:52:05,370
now the name of the folder that you're inside of.
你现在所在的文件夹的名称。

2398
01:52:05,370 --> 01:52:08,090
So in Mac or Windows, you'd see obviously a graphical folder.
所以在 Mac 或 Windows 上，你会很明显地看到一个图形化的文件夹。

2399
01:52:08,090 --> 01:52:11,360
Here, you just see a little textual reminder of where you now are.
在这里，你只是看到一个小小的文本提醒你你现在在哪里。

2400
01:52:11,360 --> 01:52:14,840
And if I type "ls," you'll see that I wrote a crazy number of files
如果我输入 "ls"，你会看到我在课前写了很多文件

2401
01:52:14,840 --> 01:52:15,770
before class.
。

2402
01:52:15,770 --> 01:52:18,380
And each of these represents different versions of the files
而这些文件中的每一个都代表着不同版本的

2403
01:52:18,380 --> 01:52:20,540
that we've been coding here in real time that I usually
我们一直在实时编码的文件，我通常

2404
01:52:20,540 --> 01:52:22,748
have printouts of just to go through things in series
会有打印版，只是为了按顺序浏览这些内容

2405
01:52:22,748 --> 01:52:25,135
so you have copies online, as well.
所以你也可以在网上获得副本。

2406
01:52:25,135 --> 01:52:28,010
So in short, all of these commands, if you've never used them before,
简而言之，所有这些命令，如果你以前从未使用过，

2407
01:52:28,010 --> 01:52:29,780
they will soon become like muscle memory.
它们很快就会成为你的肌肉记忆。

2408
01:52:29,780 --> 01:52:31,760
And they do the most basic of operations.
它们执行最基本的操作。

2409
01:52:31,760 --> 01:52:33,927
But there will be other commands that we'll see over
但我们会看到其他命令

2410
01:52:33,927 --> 01:52:36,470
time that do even much more than that.
随着时间的推移，这些命令的功能会比这些更加强大。

2411
01:52:36,470 --> 01:52:39,050
But let's go ahead now and solve some actual problems.
但现在让我们继续解决一些实际问题。

2412
01:52:39,050 --> 01:52:41,990
And it's no coincidence that we keep showing or alluding
我们不断展示或影射

2413
01:52:41,990 --> 01:52:44,300
to Super Mario Brothers in some form, an older game
超级马里奥兄弟并不偶然，这是一种比较古老的游戏

2414
01:52:44,300 --> 01:52:47,660
from the Nintendo Entertainment System, that allows you ultimately
来自任天堂娱乐系统，它最终允许你

2415
01:52:47,660 --> 01:52:50,720
to have this two-dimensional world, where Mario moves up and down
拥有这个二维世界，马里奥在其中上下移动

2416
01:52:50,720 --> 01:52:52,730
and side scrolls from left to right.
并从左到右水平滚动。

2417
01:52:52,730 --> 01:52:55,940
But you'll see we can distill even some aspects of "Mario"
但你会发现，我们甚至可以将 “马里奥” 的某些方面

2418
01:52:55,940 --> 01:53:00,260
into some fairly representative programming problems.
提炼成一些相当具有代表性的编程问题。

2419
01:53:00,260 --> 01:53:02,835
And in fact, let me propose that we consider this screen
实际上，我建议我们考虑一下这个屏幕

2420
01:53:02,835 --> 01:53:04,460
from the original Super Mario Brothers.
来自最初的超级马里奥兄弟。

2421
01:53:04,460 --> 01:53:09,810
So there's these four blocks in the sky, each with a question mark.
所以，天空中有四个方块，每个方块上都有一个问号。

2422
01:53:09,810 --> 01:53:12,800
And if you click on one of these-- or if Mario jumps up
如果你点击其中一个——或者马里奥跳到

2423
01:53:12,800 --> 01:53:15,800
underneath each of these question marks, he
这些问号的下面，他

2424
01:53:15,800 --> 01:53:18,140
gets like a coin or something else that pops out.
会得到一枚硬币或其他弹出的小东西。

2425
01:53:18,140 --> 01:53:22,550
Let's distill this, though, into its essence and consider in C, how can
让我们把它提炼到本质，并在 C 语言中考虑，我们如何

2426
01:53:22,550 --> 01:53:26,310
we make, not a blue sky yet, not a green grassy hill, and so forth,
制作，目前还没有蓝色的天空，也没有绿色的草地等等，

2427
01:53:26,310 --> 01:53:28,910
but how can we just make four question marks in a row,
但我们如何仅仅制作四个连续的问号，

2428
01:53:28,910 --> 01:53:32,790
because I dare say that we do have the building blocks via which to do this.
因为我敢说，我们确实拥有制作这些的必要组件。

2429
01:53:32,790 --> 01:53:38,180
Well, the simplest way might be to go over here and run code of mario.c.
好吧，最简单的方法可能是移到这里，运行 mario.c 的代码。

2430
01:53:38,180 --> 01:53:42,560
And then in mario.c, let's include some stdio.h so we have printf.
然后在 mario.c 中，让我们包含一些 stdio.h，这样我们就可以使用 printf。

2431
01:53:42,560 --> 01:53:45,200
Let's do int main(void), as we keep doing.
让我们像往常一样使用 int main(void)。

2432
01:53:45,200 --> 01:53:47,960
And inside of main, let's keep it super simple--
在 main 函数内部，让我们保持超级简单——

2433
01:53:47,960 --> 01:53:51,360
1, 2, 3, 4, backslash n.
1、2、3、4、反斜杠 n。

2434
01:53:51,360 --> 01:53:52,880
Doesn't get much simpler than that.
没有比这更简单了。

2435
01:53:52,880 --> 01:53:54,838
This is not going to be the prettiest of games.
这不会是最漂亮的游戏。

2436
01:53:54,838 --> 01:54:00,947
But if I make Mario now, ./mario, I get my four question marks in the sky.
但如果我现在制作马里奥，./mario，我就能得到天空中四个问号。

2437
01:54:00,947 --> 01:54:02,780
All right, so it's not all that interesting.
好吧，所以它并没有那么有趣。

2438
01:54:02,780 --> 01:54:07,287
But this is clearly a candidate for what type of programming feature.
但很明显，这适合哪种编程功能？

2439
01:54:07,287 --> 01:54:08,565
STUDENT: Scratch.
学生：Scratch。

2440
01:54:08,565 --> 01:54:11,690
DAVID MALAN: Not to Scratch, though Scratch would make it more interesting.
大卫·马兰：虽然 Scratch 会让它更有趣，但不是 Scratch。

2441
01:54:11,690 --> 01:54:12,005
yeah?
是吧？

2442
01:54:12,005 --> 01:54:12,320
STUDENT: A loop.
学生：循环。

2443
01:54:12,320 --> 01:54:14,028
DAVID MALAN: So some kind of loop, right?
大卫·马兰：所以是某种循环，对吧？

2444
01:54:14,028 --> 01:54:15,980
So print the thing out iteratively instead.
所以用迭代的方式打印出来。

2445
01:54:15,980 --> 01:54:16,730
So let me do that.
让我来做这件事。

2446
01:54:16,730 --> 01:54:19,620
Instead of just printing this out all at once,
而不是一次性地打印出来，

2447
01:54:19,620 --> 01:54:25,106
let me go ahead and remove this and do for int i gets zero; i less than 4;
让我继续删除这个，并使用 for int i gets zero; i less than 4;

2448
01:54:25,106 --> 01:54:26,280
i++.
i++。

2449
01:54:26,280 --> 01:54:29,390
And then in here, let me go ahead and print out just one question mark
然后在这里，让我继续打印出一个问号

2450
01:54:29,390 --> 01:54:30,420
instead.
。

2451
01:54:30,420 --> 01:54:31,800
And now let's run this.
现在让我们运行它。

2452
01:54:31,800 --> 01:54:35,210
So "make mario" to recompile it, ./mario.
所以用 "make mario" 来重新编译它，./mario。

2453
01:54:35,210 --> 01:54:37,910
And does anyone not want me to hit Enter yet?
还有谁不想让我按下回车键吗？

2454
01:54:37,910 --> 01:54:38,855
Why?
为什么？

2455
01:54:38,855 --> 01:54:40,730
STUDENT: Because it's gonna print a new line.
学生：因为它要打印一个新行。

2456
01:54:40,730 --> 01:54:43,860
DAVID MALAN: Yeah, it's going to print out a new line every time.
大卫·马兰：是的，它每次都会打印一个新行。

2457
01:54:43,860 --> 01:54:48,205
So notice it's four question marks, but there each on its own line.
所以注意它有四个问号，但它们都在自己的行上。

2458
01:54:48,205 --> 01:54:49,580
All right, well, let me fix this.
好吧，让我来修正一下。

2459
01:54:49,580 --> 01:54:51,590
It's obviously because of the backslash n.
很明显，这是因为反斜杠 n。

2460
01:54:51,590 --> 01:54:52,940
So let me remove that.
所以让我删除它。

2461
01:54:52,940 --> 01:54:55,850
Let me rerun make mario, ./mario.
让我重新运行 make mario，./mario。

2462
01:54:55,850 --> 01:54:59,960
And it's better in one way but worse in another.
这样一来，它在某些方面更好，但在另一些方面更差。

2463
01:54:59,960 --> 01:55:01,910
So wait, but now the dollar sign is doing
所以等等，但现在美元符号正在

2464
01:55:01,910 --> 01:55:03,785
that thing where it's on the same line, which
在同一行上做这样的事情，这

2465
01:55:03,785 --> 01:55:05,550
just looks stupid if nothing else.
至少看起来很愚蠢。

2466
01:55:05,550 --> 01:55:07,830
So how can I fix that?
那么我该怎么解决这个问题呢？

2467
01:55:07,830 --> 01:55:08,400
Yeah?
是吧？

2468
01:55:08,400 --> 01:55:11,070
STUDENT: [INAUDIBLE]
学生：[听不清]

2469
01:55:11,070 --> 01:55:14,070
DAVID MALAN: Yeah, so logically, we don't have that many building blocks
大卫·马兰：是的，所以从逻辑上讲，我们今天没有那么多的组件

2470
01:55:14,070 --> 01:55:14,570
today.
。

2471
01:55:14,570 --> 01:55:17,200
It's a lot of new syntax, but it's not that many new ideas.
虽然有很多新的语法，但没有那么多新的想法。

2472
01:55:17,200 --> 01:55:21,330
Let's just use printf to print out literally one and only
让我们只使用 printf 来打印一个

2473
01:55:21,330 --> 01:55:24,690
one of these backslash n's, but outside of the loop so
反斜杠 n，但放在循环之外，这样

2474
01:55:24,690 --> 01:55:27,750
it happens after all four of those have been printed.
它会在打印完所有四个问号之后发生。

2475
01:55:27,750 --> 01:55:30,510
All right, let me do make mario again, ./mario.
好吧，让我再次使用 make mario，./mario。

2476
01:55:30,510 --> 01:55:32,680
And OK, now we're back in business.
好的，现在我们又恢复正常了。

2477
01:55:32,680 --> 01:55:35,760
So sort of silly syntactical details, but if you
所以，这只是一些愚蠢的语法细节，但是如果你

2478
01:55:35,760 --> 01:55:39,750
reduce the problem to its essence, it should hopefully, logically,
将问题简化到本质，它应该有希望，从逻辑上讲，

2479
01:55:39,750 --> 01:55:41,225
become clear over time.
随着时间的推移变得清晰。

2480
01:55:41,225 --> 01:55:44,100
All right, well, how about not just something like that but vertical?
好吧，那么，除了这样，还有其他方法可以实现垂直排列吗？

2481
01:55:44,100 --> 01:55:45,720
Well, we've done something vertical already.
好吧，我们已经做过一些垂直排列的事情。

2482
01:55:45,720 --> 01:55:47,720
And so I can imagine we could change the program
所以我可以想象我们可以改变这个程序

2483
01:55:47,720 --> 01:55:51,540
to very simply print out three bricks instead of four question marks.
简单地打印三个砖块，而不是四个问号。

2484
01:55:51,540 --> 01:55:53,890
But what if we consider a two-dimensional world?
但是如果我们考虑一个二维世界呢？

2485
01:55:53,890 --> 01:55:55,890
And later on in this game if you go underground,
在这个游戏的后期，如果你进入地下，

2486
01:55:55,890 --> 01:55:57,720
everything looks like this with lots of bricks.
所有东西都像这样，有很多砖块。

2487
01:55:57,720 --> 01:55:59,678
And let me propose, for the sake of discussion,
为了讨论起见，我建议

2488
01:55:59,678 --> 01:56:03,947
that this big wall here is like a 3-by-3 grid of bricks.
这个大墙就像一个 3x3 的砖块网格。

2489
01:56:03,947 --> 01:56:05,280
So it's not just a single brick.
所以它不仅仅是一块砖。

2490
01:56:05,280 --> 01:56:07,530
It's like three by three, or nine total.
它就像三乘三，一共九块。

2491
01:56:07,530 --> 01:56:09,450
Now things get interesting.
现在事情变得有趣了。

2492
01:56:09,450 --> 01:56:11,820
And let me go back to mario.c.
让我回到 mario.c。

2493
01:56:11,820 --> 01:56:15,150
I could take the easy road out and just say, all right, well,
我可以走捷径，直接说，好吧，

2494
01:56:15,150 --> 01:56:21,270
let's printf, how about 1, 2, 3, backslash n, close quote.
让我们打印，如何用 1、2、3，反斜杠 n，关闭引号。

2495
01:56:21,270 --> 01:56:23,490
And then, OK, let me just copy/paste.
然后，好的，让我直接复制粘贴。

2496
01:56:23,490 --> 01:56:26,520
And I'm using hashes instead of the actual bricks.
我用井号来代替真正的砖块。

2497
01:56:26,520 --> 01:56:28,860
But aesthetically, it's pretty close.
但从美学上讲，它很接近。

2498
01:56:28,860 --> 01:56:33,073
Let me now go ahead and "make mario" again, ./mario.
现在让我继续执行 "make mario"，./mario。

2499
01:56:33,073 --> 01:56:34,740
And it doesn't quite look like a square.
它看起来不像一个正方形。

2500
01:56:34,740 --> 01:56:37,823
But that's just because the hashes are a little taller than they are wide.
但这仅仅是因为井号比它们宽要高一点。

2501
01:56:37,823 --> 01:56:40,140
But it is correct, but not well designed.
但它是正确的，但设计不好。

2502
01:56:40,140 --> 01:56:44,430
So here, too, what would be better designed than just hardcoding, typing
所以在这里，比直接硬编码、输入要好的是

2503
01:56:44,430 --> 01:56:48,280
literally all of these hashes?
所有这些井号？

2504
01:56:48,280 --> 01:56:49,876
Yeah?
是吗？

2505
01:56:49,876 --> 01:56:51,540
STUDENT: We could use maybe two loops.
学生：我们可以使用两个循环。

2506
01:56:51,540 --> 01:56:53,040
DAVID MALAN: Interesting, two loops.
大卫·马兰：有趣，两个循环。

2507
01:56:53,040 --> 01:56:56,080
And why two loops instead of one?
为什么用两个循环而不是一个？

2508
01:56:56,080 --> 01:56:57,580
STUDENT: Oh, wait, nevermind.
学生：哦，等等，不用了。

2509
01:56:57,580 --> 01:57:00,545
Well, I was going to say you could do it one for vertical and one
好吧，我要说你可以用一个循环做垂直，另一个循环做

2510
01:57:00,545 --> 01:57:01,170
for horizontal.
水平方向。

2511
01:57:01,170 --> 01:57:02,280
DAVID MALAN: OK, it's the right instinct.
大卫·马兰：好的，这是正确的直觉。

2512
01:57:02,280 --> 01:57:04,170
So one for vertical, one for horizontal.
所以一个循环做垂直，一个循环做水平。

2513
01:57:04,170 --> 01:57:06,060
And even though these predate most of us,
尽管这些东西早于我们大多数人，

2514
01:57:06,060 --> 01:57:08,220
old-school typewriters you might know or might
老式打字机，你可能知道或可能

2515
01:57:08,220 --> 01:57:12,180
recall that if you feed a piece of paper into it, you can print like line,
回想起，如果你把一张纸放进去，你可以像一行一样打印，

2516
01:57:12,180 --> 01:57:16,180
then it scrolls, line, then it scrolls, line, then it scrolls.
然后它滚动，一行，然后它滚动，一行，然后它滚动。

2517
01:57:16,180 --> 01:57:18,390
This is kind of how the terminal window works, too.
这有点像终端窗口的工作方式。

2518
01:57:18,390 --> 01:57:20,970
You can print rows and columns, but you have
你可以打印行和列，但是你必须

2519
01:57:20,970 --> 01:57:24,540
to print one row at a time, one row at a time, one row at a time.
一次打印一行，一次一行，一次一行。

2520
01:57:24,540 --> 01:57:28,810
It's not easy, but it is possible to go backwards and go up and down.
这并不容易，但可以向后移动，上下移动。

2521
01:57:28,810 --> 01:57:31,960
But just going row by row by row is more typical.
但一行一行地打印更常见。

2522
01:57:31,960 --> 01:57:33,010
So how can I do this?
那么我该如何做呢？

2523
01:57:33,010 --> 01:57:36,370
Well, I could use at least one and maybe even indeed two loops.
好吧，我可以用至少一个，甚至可能两个循环。

2524
01:57:36,370 --> 01:57:39,270
And this is where we're just now composing different ideas
这就是我们现在将不同的想法结合起来的地方

2525
01:57:39,270 --> 01:57:40,990
from today and even last week.
来自今天甚至上周。

2526
01:57:40,990 --> 01:57:45,900
So let me go ahead and say, for int i gets 0; i less than 3--
所以让我继续说，对于 int i 等于 0；i 小于 3--

2527
01:57:45,900 --> 01:57:47,370
for a 3-by-3 grid--
对于一个 3x3 网格--

2528
01:57:47,370 --> 01:57:48,810
i++.
i++。

2529
01:57:48,810 --> 01:57:51,180
And now let me cheat slightly.
现在让我稍微作弊一下。

2530
01:57:51,180 --> 01:57:55,790
Let me print out just three of these here, and that's it.
让我只打印出这三个，仅此而已。

2531
01:57:55,790 --> 01:57:56,790
So I'm kind of cheating.
所以我有点作弊。

2532
01:57:56,790 --> 01:58:01,360
I'm printing out rows dynamically, but I'm still printing three columns all
我正在动态打印行，但仍然在一次打印中打印三列。

2533
01:58:01,360 --> 01:58:02,170
in one breath.
一口气。

2534
01:58:02,170 --> 01:58:03,430
But let's see what happens.
但让我们看看会发生什么。

2535
01:58:03,430 --> 01:58:07,840
Make mario, ./mario, and it does work.
执行 mario，./mario，它确实有效。

2536
01:58:07,840 --> 01:58:12,610
But what if you said, no, I want 4 by 4 or 5 by 5 or 6 by 6?
但是如果你说，不，我想要 4x4 或 5x5 或 6x6 呢？

2537
01:58:12,610 --> 01:58:17,590
Now I have to change the 3 to a 6, and I have to add another three hashes here.
现在我必须把 3 变成 6，并且必须在这里再添加三个井号。

2538
01:58:17,590 --> 01:58:20,180
Things get messy if we don't do this mathematically.
如果我们不按数学方法来做，事情就会变得很混乱。

2539
01:58:20,180 --> 01:58:22,120
So let me now do this instead.
所以现在让我这样做。

2540
01:58:22,120 --> 01:58:26,440
Why don't I go ahead and print out every row at a time.
为什么我不一次打印一行。

2541
01:58:26,440 --> 01:58:30,340
But for each row, let me use another loop to decide, like, rat-a-tat-tat,
但对于每一行，让我用另一个循环来决定，比如，嗒嗒嗒，

2542
01:58:30,340 --> 01:58:33,010
from left to right, how many do I want to print.
从左到右，我想打印多少个。

2543
01:58:33,010 --> 01:58:35,890
So to do this, I could do another for loop.
为了做到这一点，我可以再用一个 for 循环。

2544
01:58:35,890 --> 01:58:39,050
I could call this variable something different. j is pretty common.
我可以给这个变量取一个不同的名字。j 很常见。

2545
01:58:39,050 --> 01:58:40,480
We start at i, we go to j.
我们从 i 开始，到 j 结束。

2546
01:58:40,480 --> 01:58:43,720
If you go past k, maybe l, you're probably doing something wrong.
如果你超过了 k，可能到 l，你可能做错了。

2547
01:58:43,720 --> 01:58:46,990
You don't want nested, nested, nested loops, but two is OK.
你不想要嵌套、嵌套、嵌套的循环，但两个是可以的。

2548
01:58:46,990 --> 01:58:52,480
j equals 0; j is less than 3; j++.
j 等于 0；j 小于 3；j++。

2549
01:58:52,480 --> 01:58:57,178
And then here, I can print out a single one of these and no new line.
然后在这里，我可以打印出一个，并且没有新行。

2550
01:58:57,178 --> 01:58:58,970
I don't want to screw up like I did before.
我不想像以前那样搞砸了。

2551
01:58:58,970 --> 01:59:00,340
So I'll just do one.
所以我只做一次。

2552
01:59:00,340 --> 01:59:03,970
Let me go ahead and do make mario now, ./mario.
现在让我继续执行 make mario，./mario。

2553
01:59:03,970 --> 01:59:06,482
But when I hit Enter, this is not correct yet.
但我按下回车键后，这还不正确。

2554
01:59:06,482 --> 01:59:07,690
What's it going to look like?
它会是什么样子？

2555
01:59:07,690 --> 01:59:09,130
STUDENT: A single line?
学生：一行？

2556
01:59:09,130 --> 01:59:12,040
DAVID MALAN: A single line of nine hashes, I think,
大卫·马兰：我认为是一行九个井号，

2557
01:59:12,040 --> 01:59:14,980
because I never used a single backslash n.
因为我从来没有用过一个反斜杠 n。

2558
01:59:14,980 --> 01:59:16,220
So that looks wrong.
所以看起来不对。

2559
01:59:16,220 --> 01:59:23,620
So between what line number should I insert a printf of backslash n?
那么我应该在哪些行号之间插入一个反斜杠 n 的 printf？

2560
01:59:23,620 --> 01:59:25,660
Let me look a little farther back if I can.
让我看看更远的地方。

2561
01:59:25,660 --> 01:59:26,920
How about over here?
怎么样？

2562
01:59:26,920 --> 01:59:27,520
Yeah?
是吗？

2563
01:59:27,520 --> 01:59:28,720
STUDENT: 10 and 11.
学生：10 和 11。

2564
01:59:28,720 --> 01:59:30,280
DAVID MALAN: Between 10 and 11.
大卫·马兰：在 10 和 11 之间。

2565
01:59:30,280 --> 01:59:31,580
So I'm going to go in here.
所以我将在这里

2566
01:59:31,580 --> 01:59:34,930
I'm going to add printf, quote, unquote, "backslash n" semicolon.
添加 printf，引号，引号，"反斜杠 n" 分号。

2567
01:59:34,930 --> 01:59:37,380
Let me go back and recompile mario--
让我返回并重新编译 mario--

2568
01:59:37,380 --> 01:59:38,290
./mario.
./mario。

2569
01:59:38,290 --> 01:59:41,320
And crossing fingers-- voila, perfect.
并且祈祷一切顺利--好了，完美。

2570
01:59:41,320 --> 01:59:43,210
I printed out now a 3-by-3.
我现在打印了一个 3x3。

2571
01:59:43,210 --> 01:59:44,440
Now, it's correct.
现在，它是正确的。

2572
01:59:44,440 --> 01:59:48,130
It's not, if we want to be really nitpicky, maybe still not
如果我们要吹毛求疵，可能仍然不是

2573
01:59:48,130 --> 01:59:49,240
the best design.
最好的设计。

2574
01:59:49,240 --> 01:59:51,310
Where am I perhaps repeating myself?
我可能在哪里重复了？

2575
01:59:53,840 --> 01:59:54,627
Yeah?
是吗？

2576
01:59:54,627 --> 01:59:55,770
STUDENT: [INAUDIBLE]
学生：[听不清]

2577
01:59:55,770 --> 01:59:57,770
DAVID MALAN: Yeah, I mean, it's not a huge deal.
大卫·马兰：是的，我的意思是，这不是什么大问题。

2578
01:59:57,770 --> 02:00:00,247
But now I have two, people would call these magic numbers.
但我现在有两个，人们会称它们为神奇数字。

2579
02:00:00,247 --> 02:00:02,330
"Magic" in the sense of, where did that come from?
“神奇”是指，这些数字从哪里来的？

2580
02:00:02,330 --> 02:00:05,100
You just randomly put it in the middle of your code.
你只是把它随机地放在代码中间。

2581
02:00:05,100 --> 02:00:06,878
And you also put the same thing here.
你也在这里放了同样的东西。

2582
02:00:06,878 --> 02:00:10,170
Now I have to make sure I don't screw up and make one change but not the other.
现在我必须确保我没有搞错，只修改了一个地方，而没有修改另一个地方。

2583
02:00:10,170 --> 02:00:11,837
So it turns out we can factor these out.
事实证明，我们可以把这些提取出来。

2584
02:00:11,837 --> 02:00:15,050
I can actually do something like this, int n equals 3.
我实际上可以做这样的事情，int n 等于 3。

2585
02:00:15,050 --> 02:00:17,690
And then I can just change this to n and this
然后我只需要把这个改成 n，把这个

2586
02:00:17,690 --> 02:00:19,730
to n, which is marginally better because now
改成 n，这样稍微好一点，因为现在

2587
02:00:19,730 --> 02:00:22,160
I only have to change n in one place if I want
如果我想，我只需要在一个地方修改 n。

2588
02:00:22,160 --> 02:00:24,113
to make this thing bigger or smaller.
使这个东西变大或变小。

2589
02:00:24,113 --> 02:00:25,530
It's still going to work the same.
它仍然会以相同的方式工作。

2590
02:00:25,530 --> 02:00:27,830
So make mario, ./mario.
所以，编译mario，./mario。

2591
02:00:27,830 --> 02:00:28,880
There's our 3-by-3.
这是我们的3x3。

2592
02:00:28,880 --> 02:00:35,120
But if I want to make a 5-by-5, let me change the n to 5, rerun make mario,
但如果我想做5x5的，让我把n改成5，重新运行make mario，

2593
02:00:35,120 --> 02:00:35,900
./mario.
./mario。

2594
02:00:35,900 --> 02:00:38,480
And now it's a bigger grid, 5-by-5.
现在它是一个更大的网格，5x5。

2595
02:00:38,480 --> 02:00:40,162
But this is a little fragile.
但这有点脆弱。

2596
02:00:40,162 --> 02:00:42,620
And it turns out there's another trick we should introduce.
事实证明，我们应该引入另一个技巧。

2597
02:00:42,620 --> 02:00:45,590
It turns out that C supports what are called constants,
事实证明，C语言支持所谓的常量，

2598
02:00:45,590 --> 02:00:48,920
whereby if you have a variable that you want to exist because it's useful
也就是说，如果你有一个变量，你想让它存在因为它很有用

2599
02:00:48,920 --> 02:00:50,857
but you don't want to accidentally change it,
但你不想意外地改变它，

2600
02:00:50,857 --> 02:00:53,690
or if you're working with a partner in class or a colleague at work,
或者如果你在课堂上与搭档合作或在工作中与同事合作，

2601
02:00:53,690 --> 02:00:57,140
you don't want your partner or colleague to accidentally change
你不想你的搭档或同事意外地改变

2602
02:00:57,140 --> 02:01:01,250
that value with their own code, you can go into your code and tell C,
那个值使用他们自己的代码，你可以在代码中告诉C，

2603
02:01:01,250 --> 02:01:05,790
this is actually a constant integer, a const, so to speak.
这实际上是一个常量整数，一个const，可以这样说。

2604
02:01:05,790 --> 02:01:07,790
And this will just prevent you or someone else
这将阻止你或其他人

2605
02:01:07,790 --> 02:01:11,430
from doing something stupid by accidentally changing it elsewhere.
通过在其他地方意外地改变它来做一些愚蠢的事情。

2606
02:01:11,430 --> 02:01:14,510
The code is still going to work the same, ./mario,
代码仍然会以相同的方式工作，./mario，

2607
02:01:14,510 --> 02:01:18,690
but you won't be accidentally able to change it very easily to something
但你将无法轻易地意外地将其更改为其他内容

2608
02:01:18,690 --> 02:01:19,190
else.
其他。

2609
02:01:19,190 --> 02:01:22,160
And honestly, what we've now done, too, is set ourselves
老实说，我们现在也已经设置了自己

2610
02:01:22,160 --> 02:01:23,420
up to make this more dynamic.
为使之更具动态性。

2611
02:01:23,420 --> 02:01:27,920
Let me go up here, and let me add the CS50 library so that we have access
让我到上面来，让我添加CS50库，以便我们有权访问

2612
02:01:27,920 --> 02:01:30,050
to get_int because now we could do something
get_int，因为现在我们可以做一些

2613
02:01:30,050 --> 02:01:36,920
fancy like ask the get_int function for the size of this brick wall.
花哨的事情，比如向get_int函数询问这堵砖墙的大小。

2614
02:01:36,920 --> 02:01:39,150
And then we can use n dynamically.
然后我们可以动态地使用n。

2615
02:01:39,150 --> 02:01:42,300
So for instance, let me increase the size of my terminal, make mario,
例如，让我增加终端的大小，编译mario，

2616
02:01:42,300 --> 02:01:45,140
./mario, size 3.
./mario，大小为3。

2617
02:01:45,140 --> 02:01:47,150
Gives me a 3-by-3.
给我一个3x3的。

2618
02:01:47,150 --> 02:01:50,000
./mario size 5 gives me a 5-by-5.
./mario，大小为5，给我一个5x5的。

2619
02:01:50,000 --> 02:01:54,600
./mario, how about 50, gives me a crazy big one, but it's all dynamic.
./mario，50怎么样，给我一个超大的，但它是动态的。

2620
02:01:54,600 --> 02:01:56,760
And now I don't have to even change the code.
现在我甚至不需要更改代码。

2621
02:01:56,760 --> 02:01:58,980
It just now works.
它现在就起作用了。

2622
02:01:58,980 --> 02:02:01,500
As an aside, if you're wondering how I type so darn fast,
顺便说一句，如果你想知道我为什么打字这么快，

2623
02:02:01,500 --> 02:02:03,900
sometimes it's just because I'm hitting the up arrow.
有时只是因为我按了上箭头。

2624
02:02:03,900 --> 02:02:06,600
It turns out that Linux will remember, if you
事实证明，如果你配置Linux，它会记住

2625
02:02:06,600 --> 02:02:08,860
configure it this way, all of your previous commands.
以这种方式，你之前的所有命令。

2626
02:02:08,860 --> 02:02:12,480
So if you hit up, up, up, I can go through the past couple of hours
所以如果你向上，向上，向上，我可以浏览过去几个小时

2627
02:02:12,480 --> 02:02:14,820
of commands that I've typed, which is useful sometimes--
我键入的命令，有时这很有用--

2628
02:02:14,820 --> 02:02:16,950
not for hours of commands but the past few--
不是几个小时的命令，而是过去几个--

2629
02:02:16,950 --> 02:02:18,810
just to save yourself some keystrokes.
只是为了节省一些按键。

2630
02:02:18,810 --> 02:02:22,110
And another trick in a terminal window is to do this.
另一个在终端窗口中的技巧是这样做。

2631
02:02:22,110 --> 02:02:28,050
If I do ./ma and I get bored and I don't want to type out "rio,"
如果我输入./ma，我感到厌烦，不想打出“rio”，

2632
02:02:28,050 --> 02:02:31,800
I can also just hit Tab, and it will autocomplete based on the characters
我也可以直接按Tab键，它会根据匹配的字符自动补全

2633
02:02:31,800 --> 02:02:32,470
that do match.
匹配的字符。

2634
02:02:32,470 --> 02:02:36,990
So those kinds of tricks, too, will save you time over time.
所以这些技巧也会随着时间的推移为你节省时间。

2635
02:02:36,990 --> 02:02:38,070
But let's do this.
但让我们这样做。

2636
02:02:38,070 --> 02:02:41,880
It's kind of broken, arguably, if I do this.
可以说，如果我这样做，它有点坏了。

2637
02:02:41,880 --> 02:02:44,400
How about "cat?"
“cat”怎么样？

2638
02:02:44,400 --> 02:02:45,900
All right, well, that works.
好吧，这有效。

2639
02:02:45,900 --> 02:02:48,480
That prevents me from doing something stupid
这阻止我做一些愚蠢的事情

2640
02:02:48,480 --> 02:02:51,120
because get_int only accepts integers.
因为get_int只接受整数。

2641
02:02:51,120 --> 02:02:54,000
But it will accept 0, which does nothing.
但它会接受0，这什么也不做。

2642
02:02:54,000 --> 02:02:56,370
It will accept negative 1, which does nothing.
它会接受负1，这什么也不做。

2643
02:02:56,370 --> 02:02:57,600
And that's not bad.
这还不错。

2644
02:02:57,600 --> 02:02:59,040
It's not doing something weird.
它没有做奇怪的事情。

2645
02:02:59,040 --> 02:03:01,890
But it would be nice to catch that and force the user
但最好能捕捉到这一点，并强制用户

2646
02:03:01,890 --> 02:03:04,410
to give us a positive integer instead so we at least
给我们一个正整数，这样我们至少

2647
02:03:04,410 --> 02:03:05,732
see something on the screen.
在屏幕上看到一些东西。

2648
02:03:05,732 --> 02:03:08,190
So let me go back into my code, and let me propose that now
所以让我回到我的代码，现在我建议

2649
02:03:08,190 --> 02:03:12,018
that we have the CS50 library, why don't we do something like this?
我们有了CS50库，为什么我们不这样做呢？

2650
02:03:12,018 --> 02:03:13,060
I'm going to change this.
我要改变这个。

2651
02:03:13,060 --> 02:03:14,640
I'm going to get rid of the constant just in case
我要去掉这个常量，以防万一

2652
02:03:14,640 --> 02:03:16,080
the user needs to type it again.
用户需要重新输入它。

2653
02:03:16,080 --> 02:03:17,250
And what if I do this?
如果我这样做呢？

2654
02:03:17,250 --> 02:03:20,070
While n is less than 1--
当n小于1时--

2655
02:03:20,070 --> 02:03:23,610
so if it's 0, negative 1, negative 2, or whatever, let's go ahead
所以，如果它为0，负1，负2，或者其他任何值，让我们继续

2656
02:03:23,610 --> 02:03:28,860
and again ask the user for an int, and ask them for the size again.
再次询问用户一个整数，并再次询问他们大小。

2657
02:03:28,860 --> 02:03:33,780
And therefore, only once n is not less than 1 will
因此，只有当n不小于1时，

2658
02:03:33,780 --> 02:03:36,670
this loop break out and will proceed with the rest of the code.
这个循环才会退出，并继续执行代码的其余部分。

2659
02:03:36,670 --> 02:03:37,770
So now let me try this.
所以现在让我试试这个。

2660
02:03:37,770 --> 02:03:42,120
Make mario, ./mario 0--
编译mario，./mario 0 --

2661
02:03:42,120 --> 02:03:42,960
didn't like that.
不喜欢那个。

2662
02:03:42,960 --> 02:03:44,370
Negative 1-- didn't like that.
负1 -- 不喜欢那个。

2663
02:03:44,370 --> 02:03:45,810
Negative 2-- didn't like that.
负2 -- 不喜欢那个。

2664
02:03:45,810 --> 02:03:48,640
3-- it did like that.
3 -- 它喜欢那个。

2665
02:03:48,640 --> 02:03:52,950
So using a loop now, I can ensure that the human is providing me
所以现在使用循环，我可以确保人类正在为我提供

2666
02:03:52,950 --> 02:03:55,810
with input that I actually want.
我真正想要的输入。

2667
02:03:55,810 --> 02:03:57,180
So this is correct.
所以这是正确的。

2668
02:03:57,180 --> 02:04:01,140
But I dare say 6 through 10 could be done better.
但我想说6到10可以做得更好。

2669
02:04:01,140 --> 02:04:06,580
Why is this poorly designed instinctively?
为什么这在本能上设计得不好？

2670
02:04:06,580 --> 02:04:07,080
Yeah?
是吗？

2671
02:04:07,080 --> 02:04:07,930
STUDENT: There's repetition.
学生：有重复。

2672
02:04:07,930 --> 02:04:10,600
DAVID MALAN: What's the repetition, to be clear, what lines?
大卫·马兰：重复的是什么，说清楚点，是哪几行？

2673
02:04:10,600 --> 02:04:12,145
STUDENT: Lines 6 and 9.
学生：第6行和第9行。

2674
02:04:12,145 --> 02:04:13,240
DAVID MALAN: 6 and 9.
大卫·马兰：第6行和第9行。

2675
02:04:13,240 --> 02:04:16,400
OK, so they're literally the same, and that's generally not a good thing.
好的，所以它们实际上是一样的，这通常不是一件好事。

2676
02:04:16,400 --> 02:04:19,390
And maybe I could change this one to remind the user like, hey,
也许我可以改变这一行，提醒用户，嘿，

2677
02:04:19,390 --> 02:04:20,688
that's not a positive number.
这不是一个正数。

2678
02:04:20,688 --> 02:04:22,480
So you might want to customize the message.
所以你可能想自定义消息。

2679
02:04:22,480 --> 02:04:26,390
But just having copy/paste here for the most part is not a good thing.
但仅仅在这里进行复制粘贴，在大多数情况下不是一件好事。

2680
02:04:26,390 --> 02:04:29,770
So it turns out-- and there's just one feature of C we wanted to introduce you
所以事实证明 -- 而且C语言只有一个特性我们想让你了解

2681
02:04:29,770 --> 02:04:33,400
to today-- it turns out there's one other way that would actually help us
今天 -- 事实证明，还有另一种方法实际上可以帮助我们

2682
02:04:33,400 --> 02:04:37,450
eliminate this redundancy of using get_int twice and particularly asking
消除使用get_int两次的冗余，特别是询问

2683
02:04:37,450 --> 02:04:39,670
literally the same question-- size--
同一个问题 -- 大小 --

2684
02:04:39,670 --> 02:04:40,990
twice in duplicate.
两次重复。

2685
02:04:40,990 --> 02:04:42,937
So I'm actually going to go into my code here,
所以我要进入我的代码，

2686
02:04:42,937 --> 02:04:45,520
and I'm going to delete the loop as we've written it thus far.
我要删除我们迄今为止编写的循环。

2687
02:04:45,520 --> 02:04:47,750
And instead of using a while loop, I'm going
而不是使用 while 循环，我将

2688
02:04:47,750 --> 02:04:49,750
to introduce instead something that we typically
介绍我们通常所说的

2689
02:04:49,750 --> 02:04:52,960
call a do while loop, which is a little bit different.
do while 循环，它有一点不同。

2690
02:04:52,960 --> 02:04:55,360
Indeed, we begin with the keyword "do," and then
实际上，我们从关键字“do”开始，然后

2691
02:04:55,360 --> 02:04:57,850
inside of the curly braces, what I'm going to do here
在大括号内，我要在这里做的事情是

2692
02:04:57,850 --> 02:05:02,690
is that thing I might want to do once and more times thereafter.
我可能想做一次，然后多次重复的事情。

2693
02:05:02,690 --> 02:05:08,690
So for instance, I'm going to say n equals get_int quote, unquote, "size."
例如，我要说 n 等于 get_int，引号，引号，“size”。

2694
02:05:08,690 --> 02:05:12,110
And then at the bottom of this block of code, then
然后在这段代码的底部，

2695
02:05:12,110 --> 02:05:15,380
I'm going to use the keyword "while," as well as parentheses as always
我要使用关键字“while”，以及像往常一样使用括号

2696
02:05:15,380 --> 02:05:16,740
for a Boolean expression.
用于布尔表达式。

2697
02:05:16,740 --> 02:05:17,280
And here.
在这里。

2698
02:05:17,280 --> 02:05:21,500
I'm going to ask the question, do this while n is less than 1.
我要问这个问题，当 n 小于 1 时执行此操作。

2699
02:05:21,500 --> 02:05:25,250
But there's one fix I still need to do here because notice on the current line
但是这里还有一处需要修正，因为注意当前行

2700
02:05:25,250 --> 02:05:28,280
8, I actually haven't given n a type.
8，实际上我还没有给 n 指定类型。

2701
02:05:28,280 --> 02:05:29,990
I haven't declared n yet.
我还没有声明 n。

2702
02:05:29,990 --> 02:05:37,100
But it would not be correct to declare n here, inside of that do block.
但是在这里，在那个 do 代码块内声明 n 是不正确的。

2703
02:05:37,100 --> 02:05:39,060
But why might that be?
但这为什么呢？

2704
02:05:39,060 --> 02:05:44,780
Why would it not be a good thing to declare n inside of these curly braces?
为什么在这些大括号内声明 n 不是一件好事？

2705
02:05:44,780 --> 02:05:47,240
Yeah, so recall that this is an issue of scope.
是的，所以请记住，这是一个范围问题。

2706
02:05:47,240 --> 02:05:49,820
Recall that the scope of a variable is generally
请记住，变量的范围通常

2707
02:05:49,820 --> 02:05:53,690
confined to the most recently opened curly braces in which that variable is
局限于最最近打开的大括号，该变量在其中

2708
02:05:53,690 --> 02:05:54,230
declared.
被声明。

2709
02:05:54,230 --> 02:05:56,690
And so if I declare this variable on line 8,
因此，如果我在第 8 行声明此变量，

2710
02:05:56,690 --> 02:05:58,845
I'm not going to be able to use it on line 10.
我将无法在第 10 行使用它。

2711
02:05:58,845 --> 02:06:01,470
But there is a fix, even though it might look a little strange.
但是有一个解决方案，尽管它可能看起来有点奇怪。

2712
02:06:01,470 --> 02:06:04,020
I'm going to go above my do block here.
我将移至此处 do 代码块的上方。

2713
02:06:04,020 --> 02:06:06,290
And before I go into this loop, I'm actually
在进入此循环之前，我实际上

2714
02:06:06,290 --> 02:06:10,183
going to declare n to be an integer, but semicolon, end of thought.
要声明 n 为整数，但分号，结束思考。

2715
02:06:10,183 --> 02:06:12,350
I'm not going to bother giving it a value, because I
我不会费心给它一个值，因为我知道

2716
02:06:12,350 --> 02:06:17,000
know logically I'm going to end up giving it a value anyway now on line 9.
在逻辑上，我最终会给它一个值，现在在第 9 行。

2717
02:06:17,000 --> 02:06:19,400
And so what's different about this version of the code
所以，这个版本的代码与之前的版本有什么不同呢？

2718
02:06:19,400 --> 02:06:24,200
is that the do while loop ensures that we prompt the user for input at least
就是 do while 循环确保我们至少提示用户输入一次。

2719
02:06:24,200 --> 02:06:24,740
once.
一次。

2720
02:06:24,740 --> 02:06:30,140
And then while that input is not what we expect, for instance less than 1, then
然后，只要该输入不是我们预期的，例如小于 1，那么

2721
02:06:30,140 --> 02:06:32,583
it's going to execute again, again, again.
它将再次执行，再次执行，再次执行。

2722
02:06:32,583 --> 02:06:34,250
And indeed, the semantics are just that.
实际上，语义就是如此。

2723
02:06:34,250 --> 02:06:38,460
Do the following while this Boolean expression is true.
在该布尔表达式为真时，执行以下操作。

2724
02:06:38,460 --> 02:06:44,180
So if I go ahead now and rerun make mario, compiles OK-- ./mario.
因此，如果我现在继续重新运行 make mario，编译正常 - ./mario。

2725
02:06:44,180 --> 02:06:48,140
And now I'll go ahead and input something that's not correct, like 0.
现在，我将输入一些不正确的内容，比如 0。

2726
02:06:48,140 --> 02:06:49,340
But I'm prompted again.
但我被再次提示。

2727
02:06:49,340 --> 02:06:52,250
I'll input something like negative 1, and I'm prompted again.
我将输入类似负 1 的内容，然后我被再次提示。

2728
02:06:52,250 --> 02:06:54,920
But if I go ahead and input, for instance, 10,
但是如果我继续输入，例如 10，

2729
02:06:54,920 --> 02:07:02,060
now, because that's a positive integer, I indeed get a 10-by-10 grid of bricks.
现在，因为这是一个正整数，我确实得到了一个 10x10 的砖块网格。

2730
02:07:02,060 --> 02:07:05,110
And there's one other thing we should introduce here, too, in C, too.
在 C 中，我们还应该介绍另一件事。

2731
02:07:05,110 --> 02:07:06,022
C supports comments.
C 支持注释。

2732
02:07:06,022 --> 02:07:07,730
And a couple of you have asked about this
你们中的一些人已经问过这个问题了

2733
02:07:07,730 --> 02:07:09,740
if you come from other programming languages.
如果你来自其他编程语言。

2734
02:07:09,740 --> 02:07:13,070
Suppose I want to remember what it is I just did with this program.
假设我想记住我刚刚用这个程序做了什么。

2735
02:07:13,070 --> 02:07:20,120
Let me go in between lines 5 and 6 here and do "// prompt user for positive
让我在第 5 行和第 6 行之间做 "// 提示用户输入正

2736
02:07:20,120 --> 02:07:20,713
integer."
整数。"

2737
02:07:20,713 --> 02:07:22,130
This is what's known as a comment.
这就是所谓的注释。

2738
02:07:22,130 --> 02:07:25,378
And it's grayed out only in the sense that the compiler is not
它只是灰色的，因为编译器不会

2739
02:07:25,378 --> 02:07:26,420
going to care about this.
关心它。

2740
02:07:26,420 --> 02:07:28,295
The computer is not going to care about this.
计算机不会关心它。

2741
02:07:28,295 --> 02:07:31,430
This is a note to self, like a sticky note in the context of Scratch.
这是一个给自己看的笔记，就像 Scratch 中的便签一样。

2742
02:07:31,430 --> 02:07:35,000
And it starts with "//," which essentially tells the compiler ignore
它以“//”开头，本质上告诉编译器忽略

2743
02:07:35,000 --> 02:07:37,490
this, this is for the human, not for the computer.
它，这是给人类看的，不是给计算机看的。

2744
02:07:37,490 --> 02:07:41,270
But this comment, so to speak, is a way of just reminding yourself, reminding
但可以说，这个注释是一种提醒自己、提醒

2745
02:07:41,270 --> 02:07:43,520
your colleague, reminding your TF what it
你的同事，提醒你的助教几行代码应该做什么。

2746
02:07:43,520 --> 02:07:46,460
is a few lines of code are meant to do.
就是几行代码应该做什么。

2747
02:07:46,460 --> 02:07:53,930
And now this comment might be print, and how about n-by-n grid of bricks?
现在这个注释可能是打印，n x n 的砖块网格呢？

2748
02:07:53,930 --> 02:07:57,890
And what's nice about comments is that theoretically you can get away with,
注释的好处是理论上你可以逃脱，

2749
02:07:57,890 --> 02:08:00,440
or someone else can get away with, just reading this comment
或者其他人可以逃脱，只阅读这个注释

2750
02:08:00,440 --> 02:08:02,787
and then not even have to look at the rest of the code.
然后甚至不必查看其余的代码。

2751
02:08:02,787 --> 02:08:05,870
They can look at this comment and not have to look at the rest of the code
他们可以查看这个注释，而不必查看其余的代码

2752
02:08:05,870 --> 02:08:09,195
because you've described for them what it's meant to do.
因为你已经为他们描述了它应该做什么。

2753
02:08:09,195 --> 02:08:09,695
Yeah?
是吗？

2754
02:08:09,695 --> 02:08:13,020
STUDENT: I just had a question about the hashtag [INAUDIBLE]
学生：我有一个关于井号的问题[听不清]

2755
02:08:13,020 --> 02:08:14,790
DAVID MALAN: Sure.
大卫·马兰：当然。

2756
02:08:14,790 --> 02:08:16,440
STUDENT: That's for [INAUDIBLE]
学生：那是为了[听不清]

2757
02:08:16,440 --> 02:08:19,080
DAVID MALAN: Correct, the hash sign in Python is a comment,
大卫·马兰：正确，Python 中的井号是注释，

2758
02:08:19,080 --> 02:08:24,360
is not the same thing in C. In C, hash include means to include the library's
在 C 中则不同。在 C 中，井号包含表示以这种方式包含库的

2759
02:08:24,360 --> 02:08:26,320
header files in that way.
头文件。

2760
02:08:26,320 --> 02:08:28,290
Other questions on these here tricks?
还有其他关于这些技巧的问题吗？

2761
02:08:31,060 --> 02:08:31,600
No?
没有？

2762
02:08:31,600 --> 02:08:37,810
All right, so as promised, what is maybe C not actually good at?
好的，正如承诺的那样，C 可能不太擅长什么？

2763
02:08:37,810 --> 02:08:40,840
Well, let me propose that we consider what's
嗯，让我提议我们考虑一下

2764
02:08:40,840 --> 02:08:42,280
actually inside of your computer.
你计算机内部到底是什么。

2765
02:08:42,280 --> 02:08:45,340
At the end of the day, whether it's a Mac, PC, iPhone, Android, phone,
归根结底，无论是 Mac、PC、iPhone、Android 手机，

2766
02:08:45,340 --> 02:08:48,257
or some other computer device, there's something that looks like this.
还是其他一些计算机设备，都有一个看起来像这样的东西。

2767
02:08:48,257 --> 02:08:51,423
And this is memory, otherwise known as RAM, or random access memory,
这就是内存，也称为 RAM，即随机存取存储器，

2768
02:08:51,423 --> 02:08:53,090
for reasons we'll get to in a few weeks.
原因我们将在几周后讲到。

2769
02:08:53,090 --> 02:08:54,770
But this is where data is stored.
但这里就是存储数据的地方。

2770
02:08:54,770 --> 02:08:56,570
This is where "hello, world" is stored.
这就是存储“hello, world”的地方。

2771
02:08:56,570 --> 02:08:59,200
This is where 1 and 2 and all of those numbers are stored.
这就是存储 1 和 2 以及所有这些数字的地方。

2772
02:08:59,200 --> 02:09:03,590
Any data in your program is stored ultimately in the computer's memory.
程序中的任何数据最终都存储在计算机的内存中。

2773
02:09:03,590 --> 02:09:06,460
And the most important takeaway for today is that all of us
而今天最重要的收获是，我们所有人

2774
02:09:06,460 --> 02:09:10,090
only have a finite amount of memory in our devices.
在我们的设备中都只有有限的内存。

2775
02:09:10,090 --> 02:09:12,970
You might have a high-end device which has a lot of memory,
你可能拥有一台高端设备，它拥有很多内存，

2776
02:09:12,970 --> 02:09:15,970
but it's still finite, which means you can only
但它仍然是有限的，这意味着你只能

2777
02:09:15,970 --> 02:09:17,650
count so high with that device.
用那个设备数到那么高。

2778
02:09:17,650 --> 02:09:20,150
You can only store so many files with that device.
你只能用那个设备存储那么多的文件。

2779
02:09:20,150 --> 02:09:24,730
There are fundamental physical limitations even though mathematically,
即使从数学角度来说，也存在着一些基本的物理限制，

2780
02:09:24,730 --> 02:09:27,617
theoretically, we should be able to count toward infinity.
理论上我们应该可以一直数到无穷大。

2781
02:09:27,617 --> 02:09:29,200
So what are the implications for this?
那么这对我们来说意味着什么呢？

2782
02:09:29,200 --> 02:09:30,530
Well, consider this.
让我们考虑一下这个。

2783
02:09:30,530 --> 02:09:34,677
In the world of numbers, as per week 0, if you're only using three digits--
在数字的世界里，就像上周我们讲的那样，如果你只用三个数字——

2784
02:09:34,677 --> 02:09:37,760
and I've grayed out the fourth one just to make the point-- if you're only
为了说明问题，我把第四个数字涂成了灰色——如果你只

2785
02:09:37,760 --> 02:09:43,750
using three digits, we can count from 0 to 1 in decimal, to 2, to3, to 4,
使用三个数字，我们就可以用十进制从 0 数到 1，到 2，到 3，到 4，

2786
02:09:43,750 --> 02:09:47,030
to 5, to 6, to 7.
到 5，到 6，到 7。

2787
02:09:47,030 --> 02:09:50,180
And as soon as you count to 8, you technically, per last week,
而当你数到 8 的时候，从技术角度来说，根据上周的内容，

2788
02:09:50,180 --> 02:09:51,600
need a fourth bit.
你需要一个第四位。

2789
02:09:51,600 --> 02:09:55,970
But if you don't have it, the number 7 might seem
但是如果你没有第四位，数字 7 之后看起来

2790
02:09:55,970 --> 02:09:58,770
to be followed by what number instead?
应该是多少呢？

2791
02:09:58,770 --> 02:09:59,450
STUDENT: 0.
学生：0。

2792
02:09:59,450 --> 02:10:00,380
DAVID MALAN: 0.
大卫·马兰：0。

2793
02:10:00,380 --> 02:10:03,260
The number overflows, so to speak, right?
这个数字就溢出了，可以这么说，对吧？

2794
02:10:03,260 --> 02:10:04,155
You carry the 1.
你进位 1。

2795
02:10:04,155 --> 02:10:07,280
But if there's no place to put the 1, because there's no fourth light bulb,
但是如果没有地方可以放这个 1，因为没有第四个灯泡，

2796
02:10:07,280 --> 02:10:09,740
if there's no fourth transistor, if there's no fourth bit,
没有第四个晶体管，没有第四位，

2797
02:10:09,740 --> 02:10:14,180
the lower bits, the zeros, are going to be mistaken for the number you
低位的 0 将会被误认为是你

2798
02:10:14,180 --> 02:10:15,080
and I know is 0.
和我都知道的 0。

2799
02:10:15,080 --> 02:10:18,410
So integer overflow is a thing in computers
所以，在计算机中，整数溢出是真实存在的

2800
02:10:18,410 --> 02:10:21,560
whereby if you don't have enough memory, if you count high enough,
如果你内存不足，如果你数到足够高的数字，

2801
02:10:21,560 --> 02:10:23,690
the number will wrap around back to 0.
这个数字就会回绕到 0。

2802
02:10:23,690 --> 02:10:26,210
Or sometimes it will wrap around to a negative number,
或者有时候它会回绕到一个负数，

2803
02:10:26,210 --> 02:10:30,350
depending on whether the code supports negative and positive numbers and 0
这取决于代码是否支持负数、正数和 0

2804
02:10:30,350 --> 02:10:30,950
alike.
这些值。

2805
02:10:30,950 --> 02:10:33,080
So that has some very real world implications
所以，这在现实世界中有一些非常重要的影响

2806
02:10:33,080 --> 02:10:36,590
in integer overflow that's sort of a fundamental limitation of how
整数溢出，这实际上是对数字存储方式的一种基本限制。

2807
02:10:36,590 --> 02:10:37,850
numbers are typically stored.
数字通常是如何存储的。

2808
02:10:37,850 --> 02:10:39,980
Now, thankfully, we typically don't store things
现在，值得庆幸的是，我们通常不会根据

2809
02:10:39,980 --> 02:10:42,590
based on number of digits but number of bits.
数字位数来存储数据，而是使用位数。

2810
02:10:42,590 --> 02:10:44,270
And a bit is just a 0 or 1.
而一个位就是一个 0 或 1。

2811
02:10:44,270 --> 02:10:46,820
And recall from last week that a common unit of measure
还记得上周我们讲过，一个常见的单位

2812
02:10:46,820 --> 02:10:51,080
is minimally eight bits, or a byte, but even more commonly is 32.
至少是八位，也就是一个字节，但更常见的是 32 位。

2813
02:10:51,080 --> 02:10:54,263
So for instance, here are 32 bits, all zeros.
例如，这里有 32 位，都是 0。

2814
02:10:54,263 --> 02:10:56,180
And if you do out the math, this is the number
如果你算一下，这个数字

2815
02:10:56,180 --> 02:10:58,760
you and I know in decimal is of course 0.
你和我都知道用十进制表示就是 0。

2816
02:10:58,760 --> 02:11:03,410
But if I change all 32 zeros to ones, this is a really big number now.
但如果我把这 32 个 0 全部变成 1，现在就是一个非常大的数字了。

2817
02:11:03,410 --> 02:11:05,810
If we're only using positive numbers, not negatives,
如果我们只使用正数，不使用负数，

2818
02:11:05,810 --> 02:11:10,680
what number roughly is this, 32 ones?
这个数字大约是多少呢，32 个 1？

2819
02:11:10,680 --> 02:11:15,520
It's roughly 4 billion in total-- roughly 4 billion in total.
大约是 40 亿——大约是 40 亿。

2820
02:11:15,520 --> 02:11:16,020
Why?
为什么？

2821
02:11:16,020 --> 02:11:19,770
Well, if you've got 32 bits, each can be two possible values, 0 or 1, that's
因为你有 32 位，每一位都有两种可能的值，0 或 1，那就是

2822
02:11:19,770 --> 02:11:22,260
2 to the 32nd power, which is roughly--
2 的 32 次方，大约是——

2823
02:11:22,260 --> 02:11:26,490
I'll stipulate-- roughly 4 billion total.
我承认——大约是 40 亿。

2824
02:11:26,490 --> 02:11:29,883
The problem is, what if you want to count to 4,000,000,001?
问题是，如果你想要数到 4,000,000,001 呢？

2825
02:11:29,883 --> 02:11:31,050
That's a bit of a white lie.
那有点说谎了。

2826
02:11:31,050 --> 02:11:32,290
It's not precisely that.
不是完全准确的。

2827
02:11:32,290 --> 02:11:34,457
But what if you want to count just higher than that?
但如果你想要数到比这更大的数字呢？

2828
02:11:34,457 --> 02:11:36,780
You'd need a 33rd bit because all of the others
你需要一个第 33 位，因为其他的所有位

2829
02:11:36,780 --> 02:11:40,860
are going to go to 0 at that point, and you might count from 1 to 2
此时都会变成 0，你可能会从 1 数到 2

2830
02:11:40,860 --> 02:11:45,690
to 3 to 4 billion back to 0, or worse if you're dealing with negative numbers,
到 3 到 40 亿再回到 0，或者更糟的是，如果你在处理负数，

2831
02:11:45,690 --> 02:11:46,300
too.
也是如此。

2832
02:11:46,300 --> 02:11:51,540
So the fact that there are finitely many bits used in computers is a problem.
所以，计算机中使用的是有限位数，这本身就是一个问题。

2833
02:11:51,540 --> 02:11:55,050
And negative numbers do add a complexity because this is specifically
而负数确实增加了复杂性，因为这是特指的

2834
02:11:55,050 --> 02:11:56,460
the 4 billion in question--
我们所谈论的 40 亿——

2835
02:11:56,460 --> 02:12:00,300
4,294,968,295.
4,294,968,295。

2836
02:12:00,300 --> 02:12:03,480
That is as high as you can count with 32 bits
这是你可以用 32 位数到的最大数字

2837
02:12:03,480 --> 02:12:05,033
if you don't bother with negatives.
如果你不考虑负数。

2838
02:12:05,033 --> 02:12:07,200
But if you want negative numbers, you've got to half
但如果你想要负数，你就必须把

2839
02:12:07,200 --> 02:12:10,350
that because you've got to save half of them for negative, half of them
这些位数分成两半，一半用于负数，一半用于

2840
02:12:10,350 --> 02:12:11,770
for positive, give or take.
正数，大致如此。

2841
02:12:11,770 --> 02:12:14,640
And so if you're supporting negative numbers, as you probably
所以，如果你需要支持负数，就像你可能

2842
02:12:14,640 --> 02:12:17,850
should for a calculator, for Microsoft Excel, Google Spreadsheets,
应该为计算器、Microsoft Excel、Google Sheets 做的那样，

2843
02:12:17,850 --> 02:12:21,060
you can only count as high up as 2 billion roughly,
你只能数到大约 20 亿，

2844
02:12:21,060 --> 02:12:24,640
or negative 2 billion roughly instead.
或者负 20 亿。

2845
02:12:24,640 --> 02:12:29,340
So it turns out that when you are using data types in C,
所以，当你使用 C 语言中的数据类型时，

2846
02:12:29,340 --> 02:12:32,760
you have some control over how many bits are actually used.
你可以控制实际使用的位数。

2847
02:12:32,760 --> 02:12:34,980
And this list is longer than we've covered today,
这个列表比我们今天讲的要长，

2848
02:12:34,980 --> 02:12:37,800
but we did talk about integers for a while.
但我们确实讨论了一段时间整数。

2849
02:12:37,800 --> 02:12:40,680
Those are, by convention nowadays, 32 bits.
现在，按照惯例，它们是 32 位。

2850
02:12:40,680 --> 02:12:44,760
If that's not enough, you can upgrade your variables to longs, which
如果不够，你可以将你的变量升级为 long 类型，这

2851
02:12:44,760 --> 02:12:49,290
tend to be 64 bits instead, which isn't just twice as big as an integer,
通常是 64 位，这不仅仅是整数的两倍，

2852
02:12:49,290 --> 02:12:52,500
it's actually 64 bits, which is exponentially more.
而是 64 位，这要大得多。

2853
02:12:52,500 --> 02:12:54,510
It's an unpronounceable number, at least for me.
至少对我来说，这是一个难以说出口的数字。

2854
02:12:54,510 --> 02:12:58,240
That's a crazy big number, but it's available to you.
这是一个非常大的数字，但你可以使用它。

2855
02:12:58,240 --> 02:13:02,700
Moreover, we can see this if we actually are a little reckless with how
此外，如果我们对代码的使用方式稍微不负责任一点，就能看到这一点。

2856
02:13:02,700 --> 02:13:03,428
we're using code.
我们使用代码的方式。

2857
02:13:03,428 --> 02:13:05,220
And just so you know too, though, there are
不过，你也要知道，还有

2858
02:13:05,220 --> 02:13:07,140
functions even in CS50's library that let
CS50 库中的函数，可以让你

2859
02:13:07,140 --> 02:13:10,930
you use these larger values, get long of course, will get you a long.
使用这些更大的值，当然，get long 函数可以获取一个 long 类型的值。

2860
02:13:10,930 --> 02:13:16,240
And this one's a little non-obvious, but "%li" is the format code for printf,
这个有点不太明显，但 "%li" 是 printf 函数的格式代码，

2861
02:13:16,240 --> 02:13:20,720
just so you know, for printing a long integer and not just an integer.
让你知道，用于打印长整型而不是仅仅打印整型。

2862
02:13:20,720 --> 02:13:22,330
So it's two characters instead of one.
所以，它有两个字符而不是一个字符。

2863
02:13:22,330 --> 02:13:26,860
Suppose, though, we actually want to use code involving some large numbers.
假设，我们确实想要使用一些包含较大数字的代码。

2864
02:13:26,860 --> 02:13:29,208
It turns out that certain bad things can happen.
结果表明，某些不好的事情可能会发生。

2865
02:13:29,208 --> 02:13:30,500
So let me go ahead and do this.
所以，我来做一下。

2866
02:13:30,500 --> 02:13:32,200
I'm going to go back over to VS Code here,
我将回到这里的 VS Code，

2867
02:13:32,200 --> 02:13:35,408
and I'm going to modify my calculator to do something that, at glance, should
并修改我的计算器，让它做一些看起来很合理的事情。

2868
02:13:35,408 --> 02:13:36,880
be perfectly reasonable.
看起来非常合理。

2869
02:13:36,880 --> 02:13:40,030
Let me go ahead and open up calculator.c, as before.
让我打开 calculator.c 文件，和之前一样。

2870
02:13:40,030 --> 02:13:42,220
And where we left off, we had this add function.
我们上次说到这里，我们有这个 add 函数。

2871
02:13:42,220 --> 02:13:42,970
And you know what?
你知道吗？

2872
02:13:42,970 --> 02:13:45,502
I'm going to simplify it back to its very original version.
我要把它简化回最初的版本。

2873
02:13:45,502 --> 02:13:47,710
I'm going to go ahead and get rid of the add function
我要删除 add 函数

2874
02:13:47,710 --> 02:13:50,845
and just distill it to its essence, which is not to add any more.
并且将其提炼到本质，即不要再添加任何东西。

2875
02:13:50,845 --> 02:13:51,970
But let's just do division.
但让我们只做除法。

2876
02:13:51,970 --> 02:13:55,120
I want to print out this time maybe x divided by y.
这一次我想打印出 x 除以 y 的结果。

2877
02:13:55,120 --> 02:13:59,770
So here we go. x divided by y is a nice simple program in my calculator.
所以我们开始吧。 x 除以 y 在我的计算器中是一个简单的程序。

2878
02:13:59,770 --> 02:14:03,250
Let me do make calculator again, ./calculator.
让我再次制作计算器，./calculator。

2879
02:14:03,250 --> 02:14:07,170
And let's divide something like 1 divided by 3, which should--
让我们除以类似 1 除以 3 的东西，结果应该——

2880
02:14:07,170 --> 02:14:08,860
hm, OK, weird.
嗯，好吧，奇怪。

2881
02:14:08,860 --> 02:14:13,360
It gave me 0 instead of probably 0.3333333,
它给了我 0 而不是 0.3333333，

2882
02:14:13,360 --> 02:14:16,540
as you might have expected for 1/3.
正如你对 1/3 所期望的那样。

2883
02:14:16,540 --> 02:14:19,990
So what might the takeaway there be?
所以那里有什么启示呢？

2884
02:14:19,990 --> 02:14:22,090
Why am I seeing zero perhaps?
为什么我看到了 0 呢？

2885
02:14:22,090 --> 02:14:22,600
Yeah?
是吗？

2886
02:14:22,600 --> 02:14:27,060
STUDENT: If 0's the integer [INAUDIBLE],, then if you want decimals [INAUDIBLE]..
学生：如果 0 是整数，那么如果你想要小数...

2887
02:14:27,060 --> 02:14:29,178
DAVID MALAN: Yeah, so 0 is an integer.
大卫·马兰：是的，所以 0 是一个整数。

2888
02:14:29,178 --> 02:14:31,470
And indeed, that's what I'm telling the thing to print.
而且确实，这就是我告诉它要打印的。

2889
02:14:31,470 --> 02:14:34,980
And in fact, if we go over to my little cheat sheet here of format codes,
事实上，如果我们看一下我这里关于格式代码的小速查表，

2890
02:14:34,980 --> 02:14:36,525
I'm currently using %i.
我目前使用的是 %i。

2891
02:14:36,525 --> 02:14:41,460
I should actually, when I do division of numbers that might have floating point
实际上，当我进行可能包含浮点数的数字的除法时，

2892
02:14:41,460 --> 02:14:43,560
values, a decimal point that floats left to right,
值，一个从左到右浮动的的小数点，

2893
02:14:43,560 --> 02:14:47,698
otherwise known as a real number, I want to use %f for float instead.
也称为实数，我想用 %f 代替浮点数。

2894
02:14:47,698 --> 02:14:49,740
So I'm actually going to go back to my code here.
所以我实际上要回到我的代码这里。

2895
02:14:49,740 --> 02:14:52,920
And let's try this-- %f instead of %i.
让我们试试这个——%f 而不是 %i。

2896
02:14:52,920 --> 02:14:55,560
And let me go ahead and "make calculator."
让我继续执行“make calculator”。

2897
02:14:55,560 --> 02:14:56,370
Huh, all right.
嗯，好吧。

2898
02:14:56,370 --> 02:14:57,930
Well, this didn't work then.
好吧，这个不起作用。

2899
02:14:57,930 --> 02:15:01,830
"Format specifies type 'double,' but the argument has type 'int.'
“格式指定类型为“double”，但参数类型为“int”。

2900
02:15:01,830 --> 02:15:05,260
All right, so that, too, is not quite working.
好吧，这个也不起作用。

2901
02:15:05,260 --> 02:15:09,150
So I think I actually need to make a change here further.
所以我想我实际上需要在这里进一步更改。

2902
02:15:09,150 --> 02:15:10,870
Let me actually go ahead and do this.
让我继续做这个。

2903
02:15:10,870 --> 02:15:13,230
It turns out that besides integers, there
事实证明，除了整数之外，还有

2904
02:15:13,230 --> 02:15:15,750
are these things called floats, and also doubles.
叫做浮点数，还有双精度数。

2905
02:15:15,750 --> 02:15:19,082
A float uses 32 bits, and a double uses 64 bits.
一个浮点数使用 32 位，一个双精度数使用 64 位。

2906
02:15:19,082 --> 02:15:20,790
And that doesn't necessarily mean you can
这并不一定意味着你可以

2907
02:15:20,790 --> 02:15:22,860
count higher as much as it means you can have
计数更高，而是说你可以拥有

2908
02:15:22,860 --> 02:15:24,820
more numbers after the decimal point.
小数点后更多的数字。

2909
02:15:24,820 --> 02:15:27,610
So if you want a more precise value, you throw memory at it
所以如果你想要一个更精确的值，你用内存来解决

2910
02:15:27,610 --> 02:15:30,363
by using a double and 64 bits instead of a float.
使用一个双精度数和 64 位而不是一个浮点数。

2911
02:15:30,363 --> 02:15:32,780
But we'll keep it simple, and let me go ahead and do this.
但我们会保持简单，让我继续做这个。

2912
02:15:32,780 --> 02:15:37,250
Let me just do the math using the type of variable that I should be here.
让我使用这里应该使用的变量类型来进行计算。

2913
02:15:37,250 --> 02:15:43,240
Let me do not int, but float z equals x divided by y.
让我使用 float z 而不是 int，它等于 x 除以 y。

2914
02:15:43,240 --> 02:15:45,730
And now let me go ahead and print out the value of z.
现在让我继续打印出 z 的值。

2915
02:15:45,730 --> 02:15:47,605
Strictly speaking, I don't need the variable.
严格来说，我不需要这个变量。

2916
02:15:47,605 --> 02:15:50,830
But I'm trying to be pedantic and actually use a float explicitly
但我试图过于拘泥，并明确使用一个浮点数

2917
02:15:50,830 --> 02:15:52,900
this time so we see a real number.
这次，这样我们就能看到一个实数。

2918
02:15:52,900 --> 02:15:57,760
All right, let me go ahead and do make calculator, ./calculator.
好吧，让我继续执行 make calculator，./calculator。

2919
02:15:57,760 --> 02:16:00,610
1 divided by 3 equals--
1 除以 3 等于——

2920
02:16:00,610 --> 02:16:04,420
damn, now it's just showing me more zeros, which clearly isn't the case.
该死，现在它只显示我更多 0，这显然不是事实。

2921
02:16:04,420 --> 02:16:08,750
Well, this is because of an issue that we'll generally call truncation.
好吧，这是因为一个问题，我们通常称之为截断。

2922
02:16:08,750 --> 02:16:12,320
So truncation is just a term of art that means if you take an integer
所以截断只是一个术语，意思是如果你取一个整数

2923
02:16:12,320 --> 02:16:15,760
and you divide it by an integer, even if you get a fractional value,
并且你用一个整数除它，即使你得到一个分数值，

2924
02:16:15,760 --> 02:16:18,880
the fraction just gets thrown away because you're only
这个分数就被丢弃了，因为你只是

2925
02:16:18,880 --> 02:16:21,062
doing integer-based math.
在进行基于整数的数学运算。

2926
02:16:21,062 --> 02:16:23,020
So if there's anything after the decimal point,
所以如果小数点后有东西，

2927
02:16:23,020 --> 02:16:25,280
it just gets truncated, literally discarded.
它就被截断了，实际上被丢弃了。

2928
02:16:25,280 --> 02:16:27,460
So what should 1 divided by 3 be?
那么 1 除以 3 应该是什么呢？

2929
02:16:27,460 --> 02:16:31,810
Obviously, 0.33333333-- ad nauseum.
显然是 0.33333333——无限循环。

2930
02:16:31,810 --> 02:16:34,670
Fortunately, you throw away everything after the decimal point,
幸运的是，你丢弃了小数点后的所有东西，

2931
02:16:34,670 --> 02:16:37,000
which leaves you still with just 0.
这使得你仍然只有 0。

2932
02:16:37,000 --> 02:16:40,510
And even though I'm seeing more zeros, that's because we threw away all
即使我看到更多 0，那也是因为我们丢弃了所有

2933
02:16:40,510 --> 02:16:41,049
of the 3's.
3。

2934
02:16:41,049 --> 02:16:44,200
That is just what happens when you use integers and do
当你使用整数并进行

2935
02:16:44,200 --> 02:16:46,090
any kind of division like that.
任何类似的除法运算时，就会发生这种情况。

2936
02:16:46,090 --> 02:16:47,959
But there is a solution.
但有一个解决方法。

2937
02:16:47,959 --> 02:16:53,320
We can actually convert, or cast, integers to floating point values.
我们实际上可以转换或强制转换整数为浮点数。

2938
02:16:53,320 --> 02:16:56,230
So we can tell C, I know this is an integer now.
所以我们可以告诉 C，我知道现在这是一个整数。

2939
02:16:56,230 --> 02:16:59,290
But go ahead and treat it as though it has a decimal point, even
但继续把它当作有小数点，即使

2940
02:16:59,290 --> 02:17:01,690
if it's .0 At the end of the number.
它是数字末尾的 .0。

2941
02:17:01,690 --> 02:17:06,100
So I can go into this, and I can use parentheses and literally write
所以我可以在这个里面，我可以使用括号并直接写

2942
02:17:06,100 --> 02:17:07,750
"float" in parentheses.
括号中的“float”。

2943
02:17:07,750 --> 02:17:12,700
And over here for y, I can literally use parentheses and convert y to a float.
在 y 这里，我可以直接使用括号并将 y 转换为浮点数。

2944
02:17:12,700 --> 02:17:15,129
The term of art here is type casting.
这里的术语是类型转换。

2945
02:17:15,129 --> 02:17:19,330
You're converting one type to another effectively, or technically treating
你实际上将一种类型转换为另一种类型，或者在技术上将

2946
02:17:19,330 --> 02:17:23,080
one type as though it's another even if it doesn't necessarily
一种类型当作另一种类型，即使它不一定

2947
02:17:23,080 --> 02:17:24,430
have a mathematical impact.
产生数学影响。

2948
02:17:24,430 --> 02:17:28,959
But what it means now is that z will be defined
但现在这意味着 z 将被定义

2949
02:17:28,959 --> 02:17:31,219
by dividing one float by another.
为一个浮点数除以另一个浮点数。

2950
02:17:31,219 --> 02:17:33,700
So truncation will not now happen.
所以截断现在不会发生了。

2951
02:17:33,700 --> 02:17:36,580
So let me do make calculator, ./calculator.
所以让我执行 make calculator，./calculator。

2952
02:17:36,580 --> 02:17:39,100
And now 1 divided by 3, there it is.
现在 1 除以 3，结果出来了。

2953
02:17:39,100 --> 02:17:41,480
Now the math is actually correct.
现在数学计算是正确的。

2954
02:17:41,480 --> 02:17:45,770
But my God, we had to jump through hoops just to get this to work.
但我的天，我们不得不费尽周折才能让它工作。

2955
02:17:45,770 --> 02:17:48,610
So to be clear, the two issues we-- well, the issue we encountered
所以明确地说，我们遇到的两个问题——好吧，我们遇到的问题

2956
02:17:48,610 --> 02:17:49,480
was truncation.
是截断。

2957
02:17:49,480 --> 02:17:52,389
If you divide an int by an int, you will get an int no matter
如果你用一个 int 除以一个 int，无论它在数学上应该是什么，你都会得到一个 int。

2958
02:17:52,389 --> 02:17:54,070
what it should be mathematically.
是什么。

2959
02:17:54,070 --> 02:17:59,020
But if you instead type cast the values, the variables to a floating point
但如果你改为将值，变量强制转换为浮点数

2960
02:17:59,020 --> 02:18:03,610
value, or a double for that matter, then a float divided by a float will give
值，或者是一个双精度数，那么一个浮点数除以一个浮点数将得到

2961
02:18:03,610 --> 02:18:06,520
you a float and preserve all of those 3's.
一个浮点数，并保留所有 3。

2962
02:18:06,520 --> 02:18:10,870
But here's another catch, or at least a limitation potentially with computers.
但这里还有一个问题，或者至少是计算机可能存在的限制。

2963
02:18:10,870 --> 02:18:14,379
What if I go ahead here and do--
如果我在这里继续执行——

2964
02:18:14,379 --> 02:18:15,559
let me do this.
让我做这个。

2965
02:18:15,559 --> 02:18:18,820
Let me show you one trick here, even though the syntax is a bit weird.
让我在这里展示你一个技巧，即使语法有点奇怪。

2966
02:18:18,820 --> 02:18:25,750
Instead of printing out %f alone, let me print out % dot,
而不是单独打印 %f，让我打印 % 点，

2967
02:18:25,750 --> 02:18:30,080
maybe 5f So this is weird syntax.
也许是 5f。所以这是奇怪的语法。

2968
02:18:30,080 --> 02:18:32,350
And it's only specific to printf.
它只特定于 printf。

2969
02:18:32,350 --> 02:18:36,770
"%.5f" means 'show me five decimal places specifically.'
"%.5f"的意思是“准确地显示我五位小数”。

2970
02:18:36,770 --> 02:18:40,480
So if I do make calculator, ./calculator, 1, 3, voila,
所以如果我做计算器，./计算器，1，3，瞧，

2971
02:18:40,480 --> 02:18:43,010
I get five decimal places.
我得到了五位小数。

2972
02:18:43,010 --> 02:18:44,469
If I want six, let's do this.
如果我想要六位，让我们这样做。

2973
02:18:44,469 --> 02:18:45,969
I'll change the code to 6.
我将代码改为6。

2974
02:18:45,969 --> 02:18:52,337
Make calculator, ./calculator, 1, 3, and now I get six 3's instead.
制作计算器，./计算器，1，3，现在我得到了六个3，而不是五個。

2975
02:18:52,337 --> 02:18:54,879
All right, well, wouldn't it be nice to be even more precise?
好吧，如果能更精确一点，岂不是很好吗？

2976
02:18:54,879 --> 02:18:59,209
Let's give me 20 significant digits after the decimal point.
让我们在小数点后给出20位有效数字。

2977
02:18:59,209 --> 02:19:04,420
So make calculator, ./calculator, 1 divided by 3, and-- woo.
所以制作计算器，./计算器，1 除以 3，然后 - 哇。

2978
02:19:04,420 --> 02:19:09,481
So your middle school teacher seems to have lied to you at this point.
所以你的初中老师似乎在这个时候对你撒了谎。

2979
02:19:09,481 --> 02:19:14,620
1 divided by 3 is apparently not 0.33333 with a line over it,
1 除以 3 显然不是 0.33333 并在其上加一条线，

2980
02:19:14,620 --> 02:19:17,350
or just infinite number of 3's.
或者仅仅是无限个 3。

2981
02:19:17,350 --> 02:19:19,690
OK, that's not quite the right conclusion, though.
好吧，虽然这不是完全正确的结论。

2982
02:19:19,690 --> 02:19:20,230
Oops.
哎呀。

2983
02:19:20,230 --> 02:19:24,820
Why might I be seeing these weird numbers instead
为什么我可能会看到这些奇怪的数字，而不是

2984
02:19:24,820 --> 02:19:28,200
of just lots of 3's, intuitively?
仅仅是许多 3，直观地说？

2985
02:19:31,340 --> 02:19:32,999
Why this rounding error?
为什么会有这种舍入误差？

2986
02:19:32,999 --> 02:19:33,499
Yeah?
是吗？

2987
02:19:33,499 --> 02:19:36,307
STUDENT: The computer just has a [? limited ?] [? memory. ?] So
学生：计算机只有 [？有限的？] [？内存。？] 所以

2988
02:19:36,307 --> 02:19:37,665
there's [INAUDIBLE]
那里有 [听不清]

2989
02:19:37,665 --> 02:19:38,540
DAVID MALAN: Exactly.
大卫·马兰：没错。

2990
02:19:38,540 --> 02:19:41,270
The computer only has limited memory, finite memory.
计算机只有有限的内存，有限的内存。

2991
02:19:41,270 --> 02:19:44,840
So it just can't represent every possible number in the universe
所以它只是无法表示宇宙中所有可能的数字

2992
02:19:44,840 --> 02:19:48,240
because we know from grade school there are infinitely many of those numbers.
因为我们从小学就知道有无限多个这样的数字。

2993
02:19:48,240 --> 02:19:52,520
So what you're essentially seeing is the closest it can actually get.
所以你实际上看到的只是它能达到的最接近的数字。

2994
02:19:52,520 --> 02:19:56,120
It's rounding to the nearest floating point value, if you will.
如果可以的话，它将舍入到最接近的浮点值。

2995
02:19:56,120 --> 02:19:58,850
And it also relates to how the numbers themselves are represented
这也与数字本身在内存中的表示方式有关

2996
02:19:58,850 --> 02:20:00,145
in memory underneath the hood.
在幕后内存中。

2997
02:20:00,145 --> 02:20:01,520
I can do a little better, though.
不过，我可以做得更好一些。

2998
02:20:01,520 --> 02:20:02,330
Let me zoom out.
让我缩小范围。

2999
02:20:02,330 --> 02:20:06,530
And let me upgrade, so to speak, from 32 bits to 64 bits and use
我可以说是从 32 位升级到 64 位，并使用

3000
02:20:06,530 --> 02:20:07,400
doubles instead.
双精度浮点数。

3001
02:20:07,400 --> 02:20:09,410
I can still use %f.
我仍然可以使用 %f。

3002
02:20:09,410 --> 02:20:11,030
You don't use %d for double.
你不应该对双精度浮点数使用 %d。

3003
02:20:11,030 --> 02:20:14,750
Let me do make calculator again, ./calculator, 1, 3.
让我再次制作计算器，./计算器，1，3。

3004
02:20:14,750 --> 02:20:17,490
I get more 3's but still some rounding.
我得到更多 3，但仍然有一些舍入。

3005
02:20:17,490 --> 02:20:21,842
It's more precise, but it's not 100% accurate,
它更精确，但它并不完全准确，

3006
02:20:21,842 --> 02:20:24,050
because that's just not going to be possible in terms
因为就计算机内存而言，这是不可能的。

3007
02:20:24,050 --> 02:20:25,320
of the computer's memory.
计算机的内存。

3008
02:20:25,320 --> 02:20:29,450
So this is a whole other issue known as floating point imprecision, which
所以，这是另一个问题，被称为浮点精度问题，它

3009
02:20:29,450 --> 02:20:31,910
is another type of limitation.
是另一种限制。

3010
02:20:31,910 --> 02:20:34,640
We saw integer overflow, if integers can only
我们看到了整数溢出，如果整数只能

3011
02:20:34,640 --> 02:20:37,860
count so high before you run out of bits and things wrap around.
计数到一定程度，然后你就用完了位，然后就会发生溢出。

3012
02:20:37,860 --> 02:20:40,350
Floating point imprecision means that you can't possibly
浮点精度问题意味着你不可能

3013
02:20:40,350 --> 02:20:43,470
represent the infinite number of real numbers that exist in the universe
表示宇宙中存在的无限多个实数

3014
02:20:43,470 --> 02:20:46,830
if you only have a finite amount of memory.
如果你只有有限的内存。

3015
02:20:46,830 --> 02:20:49,710
You would need an infinite number of bits, it would seem.
看起来你需要无限多个位。

3016
02:20:49,710 --> 02:20:51,902
So these are two issues that actually fundamentally
所以，这些问题实际上从根本上

3017
02:20:51,902 --> 02:20:53,610
can influence the correctness not only of
会影响代码的正确性，不仅是

3018
02:20:53,610 --> 02:20:55,260
your code but code in the real world.
你的代码，也包括现实世界中的代码。

3019
02:20:55,260 --> 02:20:56,820
And case in point, back in my day--
举个例子，在我那个时代 -

3020
02:20:56,820 --> 02:20:59,310
I graduated in 1999-- and a lot of the world
我毕业于 1999 年 - 当时世界上的许多人

3021
02:20:59,310 --> 02:21:01,350
thought the world was going to end around then
都认为世界将在那时终结

3022
02:21:01,350 --> 02:21:06,180
because around the time the years rolled over from 1999 to 2000,
因为在年份从 1999 年跨越到 2000 年的时候，

3023
02:21:06,180 --> 02:21:08,850
there was a lot of old software still running in the world.
世界上还有很多旧软件在运行。

3024
02:21:08,850 --> 02:21:12,450
And in fact, that old software, reasonably so,
事实上，那些旧软件，也是合情合理的，

3025
02:21:12,450 --> 02:21:14,740
only used two digits to represent years.
只用两位数字来表示年份。

3026
02:21:14,740 --> 02:21:15,240
Why?
为什么？

3027
02:21:15,240 --> 02:21:17,200
Memory was very expensive early on.
早期内存非常昂贵。

3028
02:21:17,200 --> 02:21:20,910
And if you could use half as much memory to store a year, that was a win.
如果你能用一半的内存来存储一年，那就是胜利。

3029
02:21:20,910 --> 02:21:21,870
That saved you money.
这为你节省了钱。

3030
02:21:21,870 --> 02:21:23,310
That saved you memory.
这为你节省了内存。

3031
02:21:23,310 --> 02:21:25,350
The problem though, of course, is that a lot
但是问题是，当然，很多

3032
02:21:25,350 --> 02:21:29,970
of old software from the '70s and prior was still running in 1999.
来自 70 年代及之前的旧软件在 1999 年仍然在运行。

3033
02:21:29,970 --> 02:21:32,970
And unless companies or individuals updated that software,
而且除非公司或个人更新这些软件，

3034
02:21:32,970 --> 02:21:39,112
1999 might be mistaken for the year 1900 instead of 2000,
1999 可能会被误认为是 1900 年而不是 2000 年，

3035
02:21:39,112 --> 02:21:41,320
because all of the code just assumed that, of course,
因为所有代码都假设，当然，

3036
02:21:41,320 --> 02:21:42,850
we're talking about the 1900s.
我们说的是 1900 年代。

3037
02:21:42,850 --> 02:21:45,120
This code is not going to be running 50 years later,
这段代码不会在 50 年后运行，

3038
02:21:45,120 --> 02:21:46,762
but it was still in that case.
但它仍然是这种情况。

3039
02:21:46,762 --> 02:21:48,720
So people had to scramble, and they essentially
所以人们不得不争先恐后，他们基本上

3040
02:21:48,720 --> 02:21:53,310
had to solve this by using more digits, so upgrading from two to four.
不得不通过使用更多位数来解决这个问题，所以从两位数升级到四位数。

3041
02:21:53,310 --> 02:21:55,590
Nowadays, and really since the '70s too, we've
如今，实际上从 70 年代起，我们一直

3042
02:21:55,590 --> 02:21:59,190
used 32-bit integers to keep track of time,
使用 32 位整数来跟踪时间，

3043
02:21:59,190 --> 02:22:03,120
specifically keeping track of the number of seconds
具体来说，跟踪的是自 1970 年 1 月 1 日以来的秒数，

3044
02:22:03,120 --> 02:22:08,400
using an integer from January 1, 1970, the so-called epoch whereby
使用一个整数，自 1970 年 1 月 1 日起，也就是所谓的纪元，因此

3045
02:22:08,400 --> 02:22:11,800
that's just an arbitrary date early on where we just started counting time.
那只是一个早期的任意日期，我们从那时起就开始计算时间。

3046
02:22:11,800 --> 02:22:14,430
So all of the clocks in your Macs, PCs, and phones pretty much
所以你的 Mac、PC 和手机上的所有时钟基本上

3047
02:22:14,430 --> 02:22:17,280
just have a single integer that gets updated every second,
只有一个整数，每秒更新一次，

3048
02:22:17,280 --> 02:22:20,080
but it's just keeping track not of absolute time per se,
但它只是在跟踪时间本身，而不是绝对时间，

3049
02:22:20,080 --> 02:22:23,460
but how many seconds have passed since January 1, 1970,
而是自 1970 年 1 月 1 日以来，经过了多少秒，

3050
02:22:23,460 --> 02:22:25,710
just because that's the date humans chose.
仅仅是因为那是人类选择的日子。

3051
02:22:25,710 --> 02:22:28,650
The problem is you can only count as high as 4 billion,
问题是，你只能数到 40 亿，

3052
02:22:28,650 --> 02:22:31,950
give or take, with 32 bits and actually 2 billion, give or take,
左右，使用 32 位，实际上是 20 亿，左右，

3053
02:22:31,950 --> 02:22:34,180
if you support negative numbers, as well.
如果你也支持负数的话。

3054
02:22:34,180 --> 02:22:37,500
And the problem with that is that we're about to trip over the same issue
而问题是，我们很快就会再次遇到同样的问题

3055
02:22:37,500 --> 02:22:39,450
again in not too long from now.
不久之后。

3056
02:22:39,450 --> 02:22:45,760
This is the 2038 problem because in the year 2038, on that date, mark my words,
这就是 2038 年问题，因为在 2038 年，在那一天，记住我的话，

3057
02:22:45,760 --> 02:22:46,830
things could break again.
事情可能会再次崩溃。

3058
02:22:46,830 --> 02:22:47,430
Why?
为什么？

3059
02:22:47,430 --> 02:22:50,820
Because that 32-bit value is going to accidentally wrap
因为那个 32 位的值会意外地溢出

3060
02:22:50,820 --> 02:22:53,873
around back to a 0 or a negative value.
回到 0 或负值。

3061
02:22:53,873 --> 02:22:56,290
So we're going to go through the whole darn process again.
所以我们又要经历一遍整个过程。

3062
02:22:56,290 --> 02:22:59,190
Now, thankfully the solution, as you might expect, is kind of just
现在，谢天谢地，解决方案，正如你可能预期的那样，只是

3063
02:22:59,190 --> 02:23:01,470
to kick the can even further down the road
把问题推迟到更远的时间

3064
02:23:01,470 --> 02:23:07,050
and use 64 bits, which I think will get us another 290 million years of runway.
并使用 64 位，我认为这将为我们提供另外 2.9 亿年的运行时间。

3065
02:23:07,050 --> 02:23:08,290
It's more than twice.
它超过了两倍。

3066
02:23:08,290 --> 02:23:10,527
So it's not our problem anymore at that point.
所以到那时它就不再是我们问题了。

3067
02:23:10,527 --> 02:23:12,610
But that's fundamentally going to be the solution.
但从根本上来说，这将是解决方案。

3068
02:23:12,610 --> 02:23:15,160
But it will still be finite.
但它仍然是有限的。

3069
02:23:15,160 --> 02:23:18,240
So we're just deferring to our descendants
所以我们只是推迟到我们子孙

3070
02:23:18,240 --> 02:23:21,150
to actually deal with the issue some millions of years from now
来处理这个问题，可能是在数百万年后。

3071
02:23:21,150 --> 02:23:22,930
if these things are still running.
如果这些东西还在运行。

3072
02:23:22,930 --> 02:23:26,010
So if that does happen, here's the specific date
所以如果这种情况发生，这里有一个具体的日期

3073
02:23:26,010 --> 02:23:28,290
that, in 2038, all of a sudden our clocks will still
也就是在 2038 年，突然我们的时钟仍然会

3074
02:23:28,290 --> 02:23:32,400
think because a negative number will get subtracted to the current epoch time.
认为时间在进行，因为当前纪元时间会减去一个负数。

3075
02:23:32,400 --> 02:23:35,140
So it will think we're back in 1901.
所以它会认为我们回到了 1901 年。

3076
02:23:35,140 --> 02:23:38,170
So this has had some fun and very real world implications.
所以这带来了一些有趣的，非常现实的影响。

3077
02:23:38,170 --> 02:23:41,250
So for instance, this is the game Pac-Man, which you might have played.
例如，这是你可能玩过的游戏吃豆人。

3078
02:23:41,250 --> 02:23:44,020
It kind of came out around my day, back in time.
它是在我那个年代，也就是很久以前推出的。

3079
02:23:44,020 --> 02:23:48,950
And if you get to the 256th level, this unfortunately
如果你到达了第 256 关，不幸的是

3080
02:23:48,950 --> 02:23:50,700
is what happens because they didn't really
这就是会发生的事，因为他们并没有真正地

3081
02:23:50,700 --> 02:23:54,280
expect that players would spend all this much time playing Pac-Man apparently.
期望玩家会花这么多时间玩吃豆人。

3082
02:23:54,280 --> 02:23:56,370
And they didn't really have a condition saying,
他们并没有设定一个条件，

3083
02:23:56,370 --> 02:23:59,832
you win if you get to the 255th or 266th level.
如果你到达了第 255 关或第 266 关，你就赢了。

3084
02:23:59,832 --> 02:24:02,790
And so what happens here essentially is that the whole screen gets very
所以，这里实际上发生的是，整个屏幕变得非常

3085
02:24:02,790 --> 02:24:06,120
garbled because there's an integer in the original Pac-Man that
混乱，因为在最初的吃豆人游戏中，有一个整数

3086
02:24:06,120 --> 02:24:11,100
counts to 256, but that's too big, so it wraps back around to 0.
计数到 256，但这个数字太大了，所以它会回绕到 0。

3087
02:24:11,100 --> 02:24:14,700
And it doesn't know when to stop printing fruits on the screen,
它不知道何时停止在屏幕上打印水果，

3088
02:24:14,700 --> 02:24:16,260
as in this case, to collect.
就像在这种情况下，来收集。

3089
02:24:16,260 --> 02:24:19,470
Another example of this is actually from the original Donkey Kong
另一个例子实际上来自最初的 Donkey Kong

3090
02:24:19,470 --> 02:24:24,420
game, which looks something like this in my day, too, whereby in Donkey Kong,
游戏，在我那个年代看起来就像这样，在 Donkey Kong 中，

3091
02:24:24,420 --> 02:24:26,880
there was this mathematical formula, whereby
有一个数学公式，通过它

3092
02:24:26,880 --> 02:24:31,740
the number of seconds you have to solve the game was a function of 10 times
你用来通关游戏所需的时间是一个函数，是 10 乘以

3093
02:24:31,740 --> 02:24:34,500
your current level number plus the number 4.
你当前的关卡号再加上 4。

3094
02:24:34,500 --> 02:24:36,330
That dictated how many seconds you get.
这决定了你能得到多少秒。

3095
02:24:36,330 --> 02:24:39,480
So of course, the higher the level, you get more and more time
所以，当然，关卡越高，你获得的时间就越多

3096
02:24:39,480 --> 02:24:41,130
as the level climbs.
随着关卡的提升。

3097
02:24:41,130 --> 02:24:47,580
Unfortunately, once you hit level 22, the math ends up being 10 times
不幸的是，一旦你到达第 22 关，计算结果就变成了 10 乘以

3098
02:24:47,580 --> 02:24:51,690
22 plus 4, which gives you the number 260.
22 加上 4，结果是 260。

3099
02:24:51,690 --> 02:24:55,290
And they, too, were using 8-bit values, a single byte
他们也使用了 8 位的值，一个字节

3100
02:24:55,290 --> 02:25:00,520
to represent numbers, which means 260 is bigger than 256.
来表示数字，这意味着 260 比 256 大。

3101
02:25:00,520 --> 02:25:02,520
And the way that math worked out was, well,
而计算结果是，嗯，

3102
02:25:02,520 --> 02:25:08,250
260 minus 256, if it wraps back around, gave people four seconds to solve level
260 减去 256，如果它回绕，人们就有 4 秒钟来解决第

3103
02:25:08,250 --> 02:25:10,440
22, which is just impossible.
22 关，这几乎是不可能的。

3104
02:25:10,440 --> 02:25:12,480
Like, Mario can't even get up a couple of levels
就像，马里奥甚至不能从他所在的位置向上爬几关

3105
02:25:12,480 --> 02:25:15,040
or so from where he actually was.
或者更多。

3106
02:25:15,040 --> 02:25:17,400
So that, too, was sort of a well-known bug,
所以，这也是一个众所周知的错误，

3107
02:25:17,400 --> 02:25:20,680
as well, since that works out to be there.
因为结果就是那样。

3108
02:25:20,680 --> 02:25:25,260
Lastly, and this one is all the more real, in 2015,
最后，这是一个更为现实的例子，在 2015 年，

3109
02:25:25,260 --> 02:25:30,150
Boeing 787 was documented as having not a hardware bug but a software bug
波音 787 被记录为出现了一个软件错误，而不是硬件错误

3110
02:25:30,150 --> 02:25:31,560
in the following sense.
具体来说就是

3111
02:25:31,560 --> 02:25:37,060
"A model 787 airplane that has been powered continuously for 248 days
“一架 787 型飞机，如果连续运行 248 天

3112
02:25:37,060 --> 02:25:42,430
can lose all of its power due to the control unit simultaneously going
可能会因为控制单元同时进入

3113
02:25:42,430 --> 02:25:43,690
into failsafe mode.
安全模式而失去所有动力。

3114
02:25:43,690 --> 02:25:48,100
This condition was caused by a software counter that will overflow
这种情况是由软件计数器引起的，该计数器会在

3115
02:25:48,100 --> 02:25:51,700
after 248 days of continuous power.
连续供电 248 天后溢出。

3116
02:25:51,700 --> 02:25:55,720
Boeing at the time was in the process of developing a CPU software upgrade that
当时，波音正在开发一个 CPU 软件升级，

3117
02:25:55,720 --> 02:25:57,250
will remedy the unsafe condition."
将解决这个不安全状况。”

3118
02:25:57,250 --> 02:25:58,310
And people did the math.
人们做了计算。

3119
02:25:58,310 --> 02:26:02,440
It turns out that Boeing was probably using an integer that was 32 bits.
事实证明，波音可能使用了一个 32 位的整数。

3120
02:26:02,440 --> 02:26:06,650
And they were keeping track of time not in seconds but hundredths of seconds,
他们跟踪时间的单位不是秒，而是百分之一秒，

3121
02:26:06,650 --> 02:26:12,830
because if you do out the math, after a 32-bit value has reached 4 billion--
因为如果你算一下，当一个 32 位的值达到 40 亿--

3122
02:26:12,830 --> 02:26:18,650
or 2 billion one hundredths of a second, the number wraps around back to 0,
或者 20 亿个百分之一秒后，这个数字会回绕到 0，

3123
02:26:18,650 --> 02:26:19,840
or negative 2 billion.
或者负 20 亿。

3124
02:26:19,840 --> 02:26:23,480
And the implications was literally the plane's power would stop.
而结果就是飞机的动力会停止。

3125
02:26:23,480 --> 02:26:26,770
And if you can believe it, if you grew up with Windows, macOS, or whatnot,
如果你相信，如果你在 Windows、macOS 或其他操作系统下长大，

3126
02:26:26,770 --> 02:26:29,080
anyone want to conjecture what the solution was
有人想推测解决方案是什么

3127
02:26:29,080 --> 02:26:33,550
until Boeing updated their software?
直到波音更新了他们的软件？

3128
02:26:33,550 --> 02:26:35,295
STUDENT: Turn it off, turn it back on.
学生：关掉它，再打开它。

3129
02:26:35,295 --> 02:26:37,128
DAVID MALAN: Turn the plane off, and turn it
戴维·马兰：关掉飞机，然后打开它

3130
02:26:37,128 --> 02:26:41,280
back on because that has the effect of resetting its memory and therefore
因为它会重置它的内存，从而

3131
02:26:41,280 --> 02:26:43,200
all of its variables back to 0.
将它的所有变量重置为 0。

3132
02:26:43,200 --> 02:26:47,910
So this is ultimately to say as you dive into problem set 1, your first in C,
所以，总而言之，当你开始学习问题集 1，也就是你的第一个 C 语言问题集时，

3133
02:26:47,910 --> 02:26:51,360
you, too, will make quite a few mistakes when it comes to correctness.
你也会在正确性方面犯不少错误。

3134
02:26:51,360 --> 02:26:54,840
You, too, will encounter opportunities for better design and better style.
你也会遇到改进设计和风格的机会。

3135
02:26:54,840 --> 02:26:57,272
In the real world, there are very much these issues.
在现实世界中，这些问题非常普遍。

3136
02:26:57,272 --> 02:26:59,730
So even if you struggle, know that for better or for worse,
所以即使你遇到了困难，也要知道，无论好坏，

3137
02:26:59,730 --> 02:27:00,900
you're in very good company.
你并不孤单。

3138
02:27:00,900 --> 02:27:03,567
But some three months from now, you will be in much better shape
但三个月后，你会变得更好

3139
02:27:03,567 --> 02:27:06,210
because this was week 1, and this is CS50.
因为这是第一周，这里是 CS50。

3140
02:27:06,210 --> 02:27:07,710
[APPLAUSE]
[掌声]

3141
02:27:11,310 --> 02:27:14,360
[INTRIGUING MUSIC]
[引人入胜的音乐]

