1
00:00:00,000 --> 00:00:02,988
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,790 --> 00:01:03,500
SPEAKER 1: All right.
演讲者 1：好的。

3
00:01:03,500 --> 00:01:09,590
This is CS50, and this is week 7 on the day before All Hallows' Eve.
这是 CS50，现在是万圣节前夜的第 7 周。

4
00:01:09,590 --> 00:01:13,760
Today, we will introduce yet another language, the goal of which
今天，我们将介绍另一种语言，它的目标

5
00:01:13,760 --> 00:01:16,430
is not to introduce another language for language's sake,
不是为了语言而学习另一种语言，

6
00:01:16,430 --> 00:01:20,510
but to really begin to emphasize that when it comes to the world of software
而是为了真正开始强调，在软件世界里

7
00:01:20,510 --> 00:01:23,390
programming, engineering more generally, there's often
编程，更广泛的工程，通常

8
00:01:23,390 --> 00:01:25,170
different tools for different jobs.
不同的工作需要不同的工具。

9
00:01:25,170 --> 00:01:28,632
And if you were to try to use C to solve all of our future problems,
如果你试图用 C 语言来解决我们未来的所有问题，

10
00:01:28,632 --> 00:01:30,590
it would actually be painful, as you've already
那将非常痛苦，因为你已经

11
00:01:30,590 --> 00:01:35,360
seen how much more pleasant it is to solve certain problems with Python.
看到了用 Python 解决某些问题是多么愉快。

12
00:01:35,360 --> 00:01:37,460
But today, quite quickly, we'll realize that even
但今天，我们会很快意识到，即使

13
00:01:37,460 --> 00:01:40,440
Python's actually not the most pleasant way to solve a lot of problems,
Python 实际上并不是解决很多问题的最愉快方式，

14
00:01:40,440 --> 00:01:43,100
especially when it comes to data, data at scale.
尤其是在处理数据，大规模数据时。

15
00:01:43,100 --> 00:01:45,830
And, in fact, as we transition in the final weeks of CS50
实际上，随着我们在 CS50 的最后几周

16
00:01:45,830 --> 00:01:49,130
to the world of web programming, and if you so choose with your final project
过渡到 web 编程的世界，如果你选择用你的最终项目

17
00:01:49,130 --> 00:01:51,500
mobile programming, you'll actually need more tools
进行移动编程，你实际上需要更多工具

18
00:01:51,500 --> 00:01:54,150
in your tool kit than C and Python alone.
在你的工具箱中，而不是仅仅 C 和 Python。

19
00:01:54,150 --> 00:01:57,620
In fact, today we'll introduce a database-centric language called S-Q-L,
实际上，今天我们将介绍一种以数据库为中心的语言，叫做 S-Q-L，

20
00:01:57,620 --> 00:01:58,590
or SQL.
或 SQL。

21
00:01:58,590 --> 00:02:02,400
Next week, we'll explore markup languages, like HTML and CSS.
下周，我们将探索标记语言，比如 HTML 和 CSS。

22
00:02:02,400 --> 00:02:03,970
A bit of JavaScript, as well.
还有一点 JavaScript。

23
00:02:03,970 --> 00:02:07,290
And then we'll synthesize all of this together at the end of the class,
然后我们将在课程结束时将所有这些内容整合在一起，

24
00:02:07,290 --> 00:02:10,360
as some of you might, for your final projects, as well.
就像你们中的一些人可能会为你们的最终项目做的那样。

25
00:02:10,360 --> 00:02:13,120
But, before we do that, and talk about data,
但在我们这样做之前，以及谈论数据之前，

26
00:02:13,120 --> 00:02:15,310
let's actually start to gather some data.
让我们实际开始收集一些数据。

27
00:02:15,310 --> 00:02:19,770
So if you could visit this URL here on your phone, or a laptop.
所以如果你能访问你手机或笔记本电脑上的这个 URL。

28
00:02:19,770 --> 00:02:23,460
Or, if easier, here's a bar code version thereof.
或者，如果更方便，这里有一个条形码版本。

29
00:02:23,460 --> 00:02:25,980
You can point your camera at this bar code here,
你可以将你的相机对准这里这个条形码，

30
00:02:25,980 --> 00:02:29,220
and it's going to pull up a relatively short Google form that's
它将打开一个相对简短的 Google 表单，

31
00:02:29,220 --> 00:02:32,040
just going to ask you a couple of questions,
只问你几个问题，

32
00:02:32,040 --> 00:02:35,070
so that we can collect some actual live data
这样我们就可以收集一些实际的实时数据

33
00:02:35,070 --> 00:02:37,800
and actually play around with it, initially, in Python.
并实际在 Python 中玩玩它，一开始。

34
00:02:37,800 --> 00:02:41,020
So if you go to that URL there, you'll see a Google form.
所以如果你访问那个 URL，你会看到一个 Google 表单。

35
00:02:41,020 --> 00:02:44,577
And if you haven't been able to scan it quite yet, that's fine.
如果你还不能扫描它，没关系。

36
00:02:44,577 --> 00:02:47,160
Just kind of look over the shoulder of the person next to you.
只要看看你旁边的人的肩膀就行了。

37
00:02:47,160 --> 00:02:49,960
But you, or they, will see a little something like this.
但你，或者他们，会看到类似这样的东西。

38
00:02:49,960 --> 00:02:53,130
So among the questions will be, which is your favorite language?
所以问题之一是，你最喜欢的语言是什么？

39
00:02:53,130 --> 00:02:56,160
On the list, only thus far, is Scratch, C, and Python,
在列表中，到目前为止，只有 Scratch、C 和 Python，

40
00:02:56,160 --> 00:02:58,350
and below that you'll see another question asking
在下面你会看到另一个问题问

41
00:02:58,350 --> 00:03:02,960
about your favorite problem across the problem sets thus far.
关于你在这些问题集中最喜欢的那个问题。

42
00:03:02,960 --> 00:03:04,710
Each of them is radio buttons, which means
每个都是单选按钮，这意味着

43
00:03:04,710 --> 00:03:08,800
you'll be able to select one button for each of those questions.
你将能够为每个问题选择一个按钮。

44
00:03:08,800 --> 00:03:11,310
And, ultimately, what's going to be nice is
最终，令人高兴的是

45
00:03:11,310 --> 00:03:14,132
that if you've never used Google Forms before as an administrator,
如果你以前从未作为管理员使用过 Google 表单，

46
00:03:14,132 --> 00:03:17,340
all of that data is actually going to end up being, not only in Google Forms,
所有这些数据最终将不仅出现在 Google 表单中，

47
00:03:17,340 --> 00:03:19,525
but also, if you so choose, in Google Spreadsheets.
而且，如果你选择的话，还会出现在 Google 电子表格中。

48
00:03:19,525 --> 00:03:22,650
Which is an example, of course, of a spreadsheet software similar in spirit
这当然是一个电子表格软件的例子，其精神与

49
00:03:22,650 --> 00:03:26,940
to Apple Numbers on Macs or Microsoft Excel on different platforms.
Mac 上的 Apple Numbers 或不同平台上的 Microsoft Excel 相似。

50
00:03:26,940 --> 00:03:29,220
And Google Sheets is going to allow us to store
Google 电子表格将允许我们存储

51
00:03:29,220 --> 00:03:30,960
all of that data in rows and columns.
所有这些数据，以行和列的形式。

52
00:03:30,960 --> 00:03:33,090
And so, since Google made both of these products,
因此，由于 Google 制作了这两款产品，

53
00:03:33,090 --> 00:03:34,690
they integrated one with the other.
它们相互集成。

54
00:03:34,690 --> 00:03:39,930
So, in fact, if I, on my laptop here in another window, open
因此，实际上，如果我在我的笔记本电脑上，在另一个窗口中，打开

55
00:03:39,930 --> 00:03:41,280
this up-- let me flip over.
这个-- 让我翻过来。

56
00:03:41,280 --> 00:03:42,660
Here's the live spreadsheet.
这是实时电子表格。

57
00:03:42,660 --> 00:03:45,510
And we'll see that the very first person who buzzed in really
我们会看到，第一个按铃的人真的很

58
00:03:45,510 --> 00:03:48,090
liked Python, as did a lot of other people thereafter.
喜欢 Python，之后很多其他人也一样。

59
00:03:48,090 --> 00:03:52,390
But, Hello, World was your favorite in Python, which is great.
但，你好，世界是你在 Python 中最喜欢的，这很棒。

60
00:03:52,390 --> 00:03:54,330
There's a couple of votes for Scratch here.
这里有几票投给了 Scratch。

61
00:03:54,330 --> 00:03:58,110
If we scroll down, there's one hold out for C, who really liked Credit,
如果我们向下滚动，这里有一个坚持用 C 的人，他真的很喜欢 Credit，

62
00:03:58,110 --> 00:03:59,320
in this case here.
在这个例子中。

63
00:03:59,320 --> 00:04:03,250
And if we scroll down further, it looks like Python and Scratch are in there.
如果我们继续向下滚动，看起来 Python 和 Scratch 就在那里。

64
00:04:03,250 --> 00:04:05,727
A few more C's, and so on and so forth.
还有一些 C 语言，等等。

65
00:04:05,727 --> 00:04:08,310
So suppose that we wanted to, actually, now analyze this data.
所以假设我们现在想要分析这些数据。

66
00:04:08,310 --> 00:04:11,587
Now, any of you who have used Excel, or Numbers, or Google Spreadsheets
现在，你们中任何使用过 Excel、Numbers 或 Google 电子表格的人

67
00:04:11,587 --> 00:04:13,920
know that it comes with built in functions and formulas,
都知道它自带内置函数和公式，

68
00:04:13,920 --> 00:04:17,040
and we can do all of that, but suppose there was a huge amount of data.
我们也可以做所有这些，但假设有很多数据。

69
00:04:17,040 --> 00:04:19,920
Or, suppose that this data was not coming in via Google Sheets,
或者，假设这些数据不是通过 Google 电子表格获取的，

70
00:04:19,920 --> 00:04:23,130
but via your own web application, or your own mobile application,
而是通过你自己的 web 应用程序，或者你自己的移动应用程序，

71
00:04:23,130 --> 00:04:25,530
and it's just ending up in some kind of spreadsheet.
而且它最终只是出现在某种电子表格中。

72
00:04:25,530 --> 00:04:28,530
Well, wouldn't it be nice if we could actually analyze that kind of data
那么，如果我们可以用代码分析这种数据，那不是很好吗？

73
00:04:28,530 --> 00:04:29,250
with code.
用代码。

74
00:04:29,250 --> 00:04:30,570
And, in fact, you can.
实际上，你可以。

75
00:04:30,570 --> 00:04:35,220
And the simplest way to store a bunch of data isn't with anything fancy,
最简单的存储大量数据的方法不是用什么花哨的东西，

76
00:04:35,220 --> 00:04:39,450
in fact, but just a literal text file, something ending in .txt,
实际上，只是一个简单的文本文件，以 .txt 结尾，

77
00:04:39,450 --> 00:04:41,520
or, maybe more commonly, .csv.
或者，也许更常见的是 .csv。

78
00:04:41,520 --> 00:04:44,400
In fact, what we'd call a flat file database
实际上，我们称之为平面文件数据库

79
00:04:44,400 --> 00:04:48,820
is literally just code for a text file containing all of your data.
实际上只是包含所有数据的文本文件的代码。

80
00:04:48,820 --> 00:04:53,040
But your data typically has delimiters that separate some values from others.
但你的数据通常有分隔符，用来将某些值与其他值分开。

81
00:04:53,040 --> 00:04:55,050
And, in fact, the most common approach, daresay,
实际上，最常见的方法，敢说，

82
00:04:55,050 --> 00:04:59,430
is to use, indeed, comma-separated values, or, CSV files.
就是使用，实际上是逗号分隔的值，或者，CSV 文件。

83
00:04:59,430 --> 00:05:04,080
And what that means is that in simple text alone, just asking, maybe Unicode,
这意味着，仅用简单的文本，只要询问，也许是 Unicode，

84
00:05:04,080 --> 00:05:06,960
you sort of mimic the idea of rows and columns
你就模拟了行和列的概念

85
00:05:06,960 --> 00:05:09,570
by using newline characters, like backslash n,
通过使用换行符，比如反斜杠 n，

86
00:05:09,570 --> 00:05:11,260
to represent row after row after row.
来表示一行又一行。

87
00:05:11,260 --> 00:05:12,510
That's pretty straightforward.
这很简单。

88
00:05:12,510 --> 00:05:14,280
To just move the cursor to the next line.
只要将光标移动到下一行。

89
00:05:14,280 --> 00:05:18,930
And because text files aren't graphical, so there's no notion of vertical bars
因为文本文件不是图形化的，所以没有垂直条的概念

90
00:05:18,930 --> 00:05:21,510
that you can put between what you and I think of as columns,
你可以把它们放在你和我认为是列的之间，

91
00:05:21,510 --> 00:05:24,630
you literally just use a comma, or some other such symbol
你实际上只使用逗号，或其他类似的符号。

92
00:05:24,630 --> 00:05:27,212
to separate one value from another.
将一个值与另一个值分开。

93
00:05:27,212 --> 00:05:28,920
So, in fact, let me go ahead and do this.
所以，实际上，让我来做这件事。

94
00:05:28,920 --> 00:05:31,837
Even if you've never done this before, it turns out, in Google Sheets,
即使你以前从未做过，事实证明，在 Google 表格中，

95
00:05:31,837 --> 00:05:35,130
and also Excel and Numbers, you can export your data,
以及 Excel 和 Numbers，你可以导出你的数据，

96
00:05:35,130 --> 00:05:38,880
not in some proprietary Apple or Microsoft or Google format,
不是以苹果、微软或谷歌的专有格式，

97
00:05:38,880 --> 00:05:43,380
but in a globally portable format known as .csv.
而是以一种全球通用的格式，称为 .csv。

98
00:05:43,380 --> 00:05:44,970
So let me go up to file.
所以让我向上找到文件。

99
00:05:44,970 --> 00:05:47,037
I will go to download.
我会转到下载。

100
00:05:47,037 --> 00:05:49,620
And notice, I can export this in a bunch of different formats,
请注意，我可以将它导出为多种不同的格式，

101
00:05:49,620 --> 00:05:52,722
but the one I care about for today is going to be .csv.
但今天我关注的是 .csv。

102
00:05:52,722 --> 00:05:55,180
On my Mac, that's going to put it into my downloads folder.
在我的 Mac 上，它会把它放到我的下载文件夹中。

103
00:05:55,180 --> 00:05:57,722
And what I'm going to go ahead here and do, in just a moment,
而且我马上就会去做的是，

104
00:05:57,722 --> 00:06:00,690
is let me go ahead it and open up VS Code.
让我打开 VS Code。

105
00:06:00,690 --> 00:06:03,300
So, in short, I've downloaded this file.
简而言之，我已经下载了这个文件。

106
00:06:03,300 --> 00:06:04,980
Google gave it a long default file name.
谷歌给了它一个很长的默认文件名。

107
00:06:04,980 --> 00:06:06,900
I've renamed it to favorites.csv.
我已经将其重命名为 favorites.csv。

108
00:06:06,900 --> 00:06:10,200
Let me go ahead and actually open it now in VS Code here.
让我在 VS Code 中打开它。

109
00:06:10,200 --> 00:06:12,480
And this now is the exact same data.
现在这与之前的数据完全相同。

110
00:06:12,480 --> 00:06:14,800
If you're still submitting the form, I'm afraid you didn't make the cut off.
如果你仍在提交表单，恐怕你没有赶上截止时间。

111
00:06:14,800 --> 00:06:17,220
So we're not going to see more data ending up in this file
所以我们不会看到更多数据出现在这个文件中

112
00:06:17,220 --> 00:06:19,260
because I've literally downloaded a copy of it.
因为我已经下载了它的副本。

113
00:06:19,260 --> 00:06:21,240
But, indeed, if I scroll through this, we'll
但，事实上，如果我滚动浏览它，我们会

114
00:06:21,240 --> 00:06:25,050
see that it's got some 399 lines of data.
看到它有大约 399 行数据。

115
00:06:25,050 --> 00:06:28,080
Or, technically, 398 because the very first one
或者，从技术上讲，是 398，因为第一行

116
00:06:28,080 --> 00:06:30,990
is what we'd call a header row, which just describes
是所谓的标题行，它描述了

117
00:06:30,990 --> 00:06:32,820
what each of these columns means.
每列的含义。

118
00:06:32,820 --> 00:06:35,670
Now notice that even though the Google Sheets interface actually
现在请注意，即使 Google 表格界面实际上

119
00:06:35,670 --> 00:06:39,780
put all of this data in proper graphical rows and columns,
将所有这些数据放在适当的图形行和列中，

120
00:06:39,780 --> 00:06:42,510
you can still see the rows because they're just separate lines,
你仍然可以看到这些行，因为它们只是单独的线，

121
00:06:42,510 --> 00:06:45,900
and you can kind of see the columns by focusing on the comma
而且你可以通过关注逗号来看到这些列

122
00:06:45,900 --> 00:06:47,970
here, the comma here, the comma here.
这里，这里，这里。

123
00:06:47,970 --> 00:06:50,820
And then, also, the comma here, the comma here,
然后，还有这里，这里，

124
00:06:50,820 --> 00:06:52,540
the comma here, and so forth.
这里，等等。

125
00:06:52,540 --> 00:06:53,910
Now, a quick subtlety.
现在，一个微妙之处。

126
00:06:53,910 --> 00:06:59,490
Hello, World is a two-word problem name, and it itself has a comma in it.
Hello, World 是一个由两个词组成的题目名称，它本身包含一个逗号。

127
00:06:59,490 --> 00:07:06,090
What's to stop me from confusing the comma in Hello, World from the commas
什么可以阻止我把 Hello, World 中的逗号与

128
00:07:06,090 --> 00:07:09,410
that Google, apparently, inserted into this file?
谷歌显然插入到这个文件中的逗号混淆起来？

129
00:07:09,410 --> 00:07:09,910
Yeah.
是的。

130
00:07:09,910 --> 00:07:11,925
So, automatically, you all did not type this.
所以，你们并没有自动地输入这些内容。

131
00:07:11,925 --> 00:07:13,300
We did not type it into the form.
我们没有把它输入到表单中。

132
00:07:13,300 --> 00:07:16,750
But Google is smart enough, as is Apple and Microsoft, when
但谷歌很聪明，苹果和微软也是如此，当

133
00:07:16,750 --> 00:07:20,958
they export CSVs to somehow escape seemingly dangerous characters,
他们导出 CSV 时，会以某种方式转义看似危险的字符，

134
00:07:20,958 --> 00:07:22,750
or characters that could just break things.
或者可能会导致问题发生的字符。

135
00:07:22,750 --> 00:07:25,180
And, in this case, a convention in the CSV world
在这种情况下，CSV 世界中的一种惯例

136
00:07:25,180 --> 00:07:28,340
is just to quote any strings that themselves have commas
就是将任何包含逗号的字符串用引号括起来

137
00:07:28,340 --> 00:07:32,150
so that any program you're writing that reads this file doesn't get confused.
这样你编写的任何读取此文件的程序都不会感到困惑。

138
00:07:32,150 --> 00:07:35,260
So the only thing that came in automatically from Google
所以，来自 Google 的唯一自动添加的东西

139
00:07:35,260 --> 00:07:37,690
is just this timestamp here, based on the time
就是这里的这个时间戳，它基于

140
00:07:37,690 --> 00:07:39,370
of day in our own local timezone.
我们本地时区的当天时间。

141
00:07:39,370 --> 00:07:40,970
That was added automatically.
这是自动添加的。

142
00:07:40,970 --> 00:07:43,100
So we have three, and not just two columns.
所以我们有三个，而不是两个列。

143
00:07:43,100 --> 00:07:45,460
So with that said, we have three columns:
所以，综上所述，我们有三个列：

144
00:07:45,460 --> 00:07:47,980
timestamp, language, and problem.
时间戳，语言和问题。

145
00:07:47,980 --> 00:07:50,200
The latter two of which came from all of you.
后两个来自你们所有人。

146
00:07:50,200 --> 00:07:52,840
Let's actually write some code that analyzes this data.
让我们实际编写一些代码来分析这些数据。

147
00:07:52,840 --> 00:07:55,720
Let's figure out what the most popular something or other is here.
让我们找出这里最流行的东西。

148
00:07:55,720 --> 00:07:57,970
So I'll close the CSV file.
所以我会关闭 CSV 文件。

149
00:07:57,970 --> 00:08:02,140
Let me go ahead and use what seems to be folks favorite language, thus far,
让我使用到目前为止似乎是最受欢迎的语言，

150
00:08:02,140 --> 00:08:05,320
and write a file called favorites.py, for instance.
并编写一个名为 favorites.py 的文件，例如。

151
00:08:05,320 --> 00:08:08,440
And I'm going to use Python to open that CSV file,
我将使用 Python 打开那个 CSV 文件，

152
00:08:08,440 --> 00:08:12,180
analyze it, crunch some numbers, and output some statistics, if you will.
分析它，进行一些运算，并输出一些统计数据，如果你愿意的话。

153
00:08:12,180 --> 00:08:15,920
So the easiest way to manipulate CSV files, as you might have gleaned,
所以，正如你可能已经了解到的，操作 CSV 文件最简单的方法

154
00:08:15,920 --> 00:08:19,940
is not to just open the file yourself, look for commas, allocate memory,
不是自己打开文件，查找逗号，分配内存，

155
00:08:19,940 --> 00:08:22,220
or anything like that in C. In Python, you
或者在 C 中做类似的事情。在 Python 中，你

156
00:08:22,220 --> 00:08:27,230
can literally just import CSV, which is a Python module that
可以简单地导入 CSV，这是一个 Python 模块，

157
00:08:27,230 --> 00:08:29,570
gives you CSV related functionality.
它提供了与 CSV 相关的功能。

158
00:08:29,570 --> 00:08:32,390
In Python, there's a bunch of ways to open files.
在 Python 中，有很多方法可以打开文件。

159
00:08:32,390 --> 00:08:35,960
One way to open a file is like this in Python.
在 Python 中，其中一种打开文件的方法是这样的。

160
00:08:35,960 --> 00:08:40,039
You can say file equals open, similar to fopen in C.
你可以说 file 等于 open，类似于 C 中的 fopen。

161
00:08:40,039 --> 00:08:44,600
You can specify the name of the file you want to open, like favorites.csv,
你可以指定要打开的文件名，例如 favorites.csv，

162
00:08:44,600 --> 00:08:48,330
and you can explicitly say you want to open the file for reading,
并且可以明确地说你想打开文件以进行读取，

163
00:08:48,330 --> 00:08:50,240
quote unquote, "r," just like fopen.
引号，"r"，就像 fopen 一样。

164
00:08:50,240 --> 00:08:53,280
Strictly speaking, in Python read is implied.
严格来说，在 Python 中，读取是隐含的。

165
00:08:53,280 --> 00:08:55,580
So if you omit the second argument, it will still work.
所以，如果你省略第二个参数，它仍然会起作用。

166
00:08:55,580 --> 00:08:58,490
But for parity with fopen, I'll do the same here.
但为了与 fopen 保持一致，我在这里也会这样做。

167
00:08:58,490 --> 00:09:03,020
Then you can, maybe, do something with file, and then, at the end,
然后你就可以对文件做一些操作，然后，最后，

168
00:09:03,020 --> 00:09:05,070
you can close the file like this.
你可以像这样关闭文件。

169
00:09:05,070 --> 00:09:08,840
So in Python, there really is a mapping between fopen and fclose.
所以在 Python 中，fopen 和 fclose 之间确实存在映射关系。

170
00:09:08,840 --> 00:09:12,560
But in Python the functions are called open and close for short.
但在 Python 中，这些函数简称为 open 和 close。

171
00:09:12,560 --> 00:09:16,130
But a more common way, a more Pythonic way, so to speak, i.e.
但更常见的方法，更 Pythonic 的方法，可以这么说，也就是

172
00:09:16,130 --> 00:09:19,040
the way people tend to do it in Python, is actually
人们在 Python 中倾向于使用的方法实际上是

173
00:09:19,040 --> 00:09:22,610
to use a keyword that didn't exist in C, where you instead say with.
使用一个在 C 中不存在的关键字，你改用 with。

174
00:09:22,610 --> 00:09:26,990
And you say, with open this file name as a specific file name,
然后你说，用 open 这个文件名作为特定的文件名，

175
00:09:26,990 --> 00:09:28,970
and then indent it inside of that.
然后缩进它。

176
00:09:28,970 --> 00:09:30,950
Now you can do whatever you want with the file.
现在你可以对文件做任何你想做的事情。

177
00:09:30,950 --> 00:09:33,350
And the implication of using with, even though it's not
使用 with 的含义，即使它不是

178
00:09:33,350 --> 00:09:36,740
obvious from the keyword itself, is that the file will be automatically closed
从关键字本身就能看出来，就是文件会在之后自动关闭

179
00:09:36,740 --> 00:09:37,770
for you later.
为你。

180
00:09:37,770 --> 00:09:39,650
So this is just a minor Python convenience
所以这仅仅是 Python 的一个小便利

181
00:09:39,650 --> 00:09:42,020
so that you don't have to remember to close the file.
这样你就不必记得关闭文件了。

182
00:09:42,020 --> 00:09:44,030
Unless something goes wrong, it will just
除非出现错误，否则它将

183
00:09:44,030 --> 00:09:47,690
close automatically as soon as you're outside of this with block.
在你退出这个 with 块后立即自动关闭。

184
00:09:47,690 --> 00:09:49,460
So how do I go about reading a CSV?
那么我如何读取 CSV 呢？

185
00:09:49,460 --> 00:09:52,940
The simplest way is to actually give yourself a variable called,
最简单的方法是给自己一个叫做，

186
00:09:52,940 --> 00:09:53,900
maybe, reader.
也许，reader。

187
00:09:53,900 --> 00:09:56,780
Like if I want to read the CSV, I'll call my variable reader.
例如，如果我想读取 CSV 文件，我会将我的变量命名为 reader。

188
00:09:56,780 --> 00:10:02,270
Set that equal to the return value of a function that comes with Python CSV
将该变量设置为 Python CSV 模块中一个函数的返回值。

189
00:10:02,270 --> 00:10:07,080
module called reader, in lowercase, and you just pass in the file name.
该模块名为 reader，小写，您只需要传入文件名。

190
00:10:07,080 --> 00:10:09,560
So the first line there on line three opens the file
因此，第三行中的第一行代码打开了文件。

191
00:10:09,560 --> 00:10:11,570
and gives me access to the bytes there in.
并让我访问其中的字节。

192
00:10:11,570 --> 00:10:14,450
Line four now actually uses this library that
第四行现在实际使用这个库，这个库

193
00:10:14,450 --> 00:10:18,260
comes with Python to just go read it for me, figure out where the commas are,
来自 Python，它会帮我读取文件，找出逗号的位置，

194
00:10:18,260 --> 00:10:21,690
so that it can hand me, line after line, the data in the file.
以便它可以逐行地将文件中的数据交给我。

195
00:10:21,690 --> 00:10:24,320
Now the first piece of data in the file, though, was what?
现在，文件中的第一条数据是什么？

196
00:10:24,320 --> 00:10:27,080
What's the very first row?
第一行是什么？

197
00:10:27,080 --> 00:10:30,692
So it was that header row with timestamp, language, problem.
所以它是包含时间戳、语言、问题的头部行。

198
00:10:30,692 --> 00:10:32,900
I actually want to skip that because that's not data.
实际上，我想跳过它，因为它不是数据。

199
00:10:32,900 --> 00:10:36,870
That's what we might call metadata that's describing my actual data.
这可以被称作元数据，它描述了我的实际数据。

200
00:10:36,870 --> 00:10:39,670
So one way to deal with this, I can literally just say next reader.
所以，一种处理方法是，我可以直接说 next reader。

201
00:10:39,670 --> 00:10:42,170
And next, even though the semantics here are a little weird,
next，尽管这里的语义有点奇怪，

202
00:10:42,170 --> 00:10:46,100
it just means, no, no, give me the next line from that reader instead
它只是意味着，不，不，给我那个 reader 中的下一行，而不是

203
00:10:46,100 --> 00:10:47,550
of the first by default.
默认情况下给第一行。

204
00:10:47,550 --> 00:10:51,650
And now inside of this with block, I can do something like this.
现在，在这个 with 块中，我可以做一些类似的事情。

205
00:10:51,650 --> 00:10:56,810
For each row in that reader, let's do something super simple initially.
对于 reader 中的每一行，让我们先做一些非常简单的事情。

206
00:10:56,810 --> 00:11:00,380
Let's just print out row bracket one.
让我们只打印出 row 括号中的第一个元素。

207
00:11:00,380 --> 00:11:01,910
So row bracket one.
所以是 row 括号中的第一个元素。

208
00:11:01,910 --> 00:11:03,330
So what's going on here?
这里发生了什么？

209
00:11:03,330 --> 00:11:07,040
Well, the CSV reader in Python is going to return to you, inside
那么，Python 中的 CSV reader 将在循环内部返回给你，

210
00:11:07,040 --> 00:11:09,990
of this loop, one row after another.
在这个循环中，一行接一行。

211
00:11:09,990 --> 00:11:12,080
Each of those rows, though, has how many columns?
然而，每行有多少列？

212
00:11:12,080 --> 00:11:12,920
Three.
三列。

213
00:11:12,920 --> 00:11:15,470
The timestamp, the language, and the problem.
时间戳、语言和问题。

214
00:11:15,470 --> 00:11:19,430
And just like in C, our lists in Python are zero index.
就像在 C 语言中一样，Python 中的列表索引从 0 开始。

215
00:11:19,430 --> 00:11:20,720
So zero, one, two.
所以是 0、1、2。

216
00:11:20,720 --> 00:11:25,350
So if I'm printing out row bracket one, that's the second, or middle, column.
所以，如果我打印出 row 括号中的第一个元素，那就是第二列，也就是中间的那一列。

217
00:11:25,350 --> 00:11:29,220
So what's this going to print row after row?
所以，这将逐行打印出什么？

218
00:11:29,220 --> 00:11:32,340
Each of the languages that you all replied with.
你们每个人回复的每一种语言。

219
00:11:32,340 --> 00:11:32,940
So that's all.
就是这样。

220
00:11:32,940 --> 00:11:34,440
This isn't doing any kind of analytics yet.
这还没有进行任何分析。

221
00:11:34,440 --> 00:11:36,440
I'm just going through the motions to, at least,
我只是在走流程，至少，

222
00:11:36,440 --> 00:11:37,900
print out some data of interest.
打印出一些感兴趣的数据。

223
00:11:37,900 --> 00:11:38,692
So let me run this.
所以，让我运行它。

224
00:11:38,692 --> 00:11:41,550
Python of favorites.py, enter.
Python favorites.py，回车。

225
00:11:41,550 --> 00:11:43,270
And it happens super fast.
它运行得非常快。

226
00:11:43,270 --> 00:11:47,170
But if I scroll back in my terminal window, there is all of that raw data.
但是，如果我在终端窗口中滚动回退，就会看到所有这些原始数据。

227
00:11:47,170 --> 00:11:49,472
So this is to say, once you know the function names,
也就是说，一旦您知道函数名，

228
00:11:49,472 --> 00:11:51,180
once you know the keywords, it's actually
一旦您知道关键字，实际上

229
00:11:51,180 --> 00:11:54,090
pretty simple in Python to just get up and running with a file,
在 Python 中，用文件启动和运行非常简单，

230
00:11:54,090 --> 00:11:56,070
and start looking at the data therein.
并开始查看其中的数据。

231
00:11:56,070 --> 00:12:02,910
But it turns out that it's a little sub-optimal to use the reader alone.
但事实证明，仅仅使用 reader 效率不高。

232
00:12:02,910 --> 00:12:05,400
It turns out there's better ways to do this, and let
事实证明，有更好的方法来做这件事，并且让我

233
00:12:05,400 --> 00:12:06,780
me make this clear as follows.
说明一下。

234
00:12:06,780 --> 00:12:09,660
I don't strictly need a variable, but let me actually declare
我严格来说不需要一个变量，但让我实际声明

235
00:12:09,660 --> 00:12:13,560
a variable called favorite, set it equal to row bracket one,
一个名为 favorite 的变量，将其设置为 row 括号中的第一个元素，

236
00:12:13,560 --> 00:12:15,630
and then print out that favorite value.
然后打印出 favorite 的值。

237
00:12:15,630 --> 00:12:17,438
This is not doing anything new.
这并没有做任何新事情。

238
00:12:17,438 --> 00:12:19,230
It's just declaring an additional variable,
它只是声明了一个额外的变量，

239
00:12:19,230 --> 00:12:22,380
but I wanted to highlight the fact that I'm just kind of trusting that row
但我想要强调这样一个事实，即我只是在信任 row

240
00:12:22,380 --> 00:12:24,630
bracket one is the problem--
括号中的第一个元素是问题 -

241
00:12:24,630 --> 00:12:26,430
or, is the language I care about.
或者，是我关心的语言。

242
00:12:26,430 --> 00:12:27,660
Is language, is language.
是语言，是语言。

243
00:12:27,660 --> 00:12:30,790
But suppose one of you, or I, go into the Google spreadsheet,
但假设你们中的某个人，或者是我，进入 Google 表格，

244
00:12:30,790 --> 00:12:32,668
and like anyone might with a spreadsheet,
就像任何人在使用表格时一样，

245
00:12:32,668 --> 00:12:34,210
you might start moving things around.
您可能会开始移动一些东西。

246
00:12:34,210 --> 00:12:36,947
And you might swap some of the columns left and right.
您可能会交换一些列的位置。

247
00:12:36,947 --> 00:12:39,280
You might delete one of the columns, add something else.
您可能会删除一列，添加其他内容。

248
00:12:39,280 --> 00:12:41,830
In short, spreadsheets are arguably fragile
简而言之，电子表格可以说是脆弱的

249
00:12:41,830 --> 00:12:44,590
in that it's pretty easy in the GUI, the graphical user interface,
因为在 GUI（图形用户界面）中，很容易改变它们。

250
00:12:44,590 --> 00:12:46,040
to change them around.
改变它们。

251
00:12:46,040 --> 00:12:50,080
And so my code in Python, accordingly, is, arguably, fragile
因此，我的 Python 代码也相应地可以说是脆弱的

252
00:12:50,080 --> 00:12:53,770
because I'm just hoping that row bracket one is always the data
因为我只是希望 row 括号中的第一个元素始终是数据

253
00:12:53,770 --> 00:12:54,890
that I care about.
我关心的。

254
00:12:54,890 --> 00:12:56,450
So what would be marginally better?
那么，什么方法会稍微好一点？

255
00:12:56,450 --> 00:12:59,110
Well, let's actually use that header row instead.
那么，让我们实际使用头部行。

256
00:12:59,110 --> 00:13:02,920
And more common, arguably, in Python, is not to use a simple reader,
而且，在 Python 中，更常见的是不使用简单的 reader，

257
00:13:02,920 --> 00:13:05,650
but, instead, what we would call a Dictionary Reader.
而是使用我们所说的 Dictionary Reader。

258
00:13:05,650 --> 00:13:09,190
I'm going to change this to DictReader, capital D, capital R,
我要将它改为 DictReader，大写 D，大写 R，

259
00:13:09,190 --> 00:13:12,010
and that's it for the change to line four.
第四行的修改就到这里。

260
00:13:12,010 --> 00:13:14,197
On line five, I'm going to get rid of the next line
在第五行，我要删除 next 行

261
00:13:14,197 --> 00:13:16,030
because I don't want to skip the header now.
因为我现在不想跳过头部。

262
00:13:16,030 --> 00:13:19,210
What DictReader does, which reader does not,
DictReader 做了什么，而 reader 没有做的事情是，

263
00:13:19,210 --> 00:13:22,690
is it automatically analyzes that first line in the file,
它会自动分析文件中的第一行，

264
00:13:22,690 --> 00:13:25,510
figures out what are all of your columns called,
找出所有列的名称，

265
00:13:25,510 --> 00:13:30,220
and, thereafter, when you iterate over this reader what each of your rows
然后，当您遍历这个 reader 时，您每一行现在是什么 - 它不再是一个大小为 3 的列表，[0]、[1]、[2]。

266
00:13:30,220 --> 00:13:35,650
now is-- it's no longer a list of size three, bracket zero, bracket
现在是 - 它不再是一个大小为 3 的列表，[0]、[1]、[2]。

267
00:13:35,650 --> 00:13:36,490
one, bracket two.
1、2。

268
00:13:36,490 --> 00:13:39,670
Each row that you get back in this loop on line five
您在这个循环中获得的每一行，在第五行

269
00:13:39,670 --> 00:13:44,890
is now, wonderfully, a dictionary instead, the keys of which
现在，神奇的是，变成了一个字典，它的键

270
00:13:44,890 --> 00:13:46,090
are from the header field.
来自头部字段。

271
00:13:46,090 --> 00:13:47,650
Timestamp, language, problem.
时间戳、语言、问题。

272
00:13:47,650 --> 00:13:52,460
The values of which are whatever each of you typed in again and again.
它的值就是你们每个人反复输入的任何内容。

273
00:13:52,460 --> 00:13:53,890
So how do I change the code?
所以，我该如何更改代码？

274
00:13:53,890 --> 00:13:57,800
I no longer have these numeric indices because row is no longer a list,
我再也没有这些数字索引，因为 row 不再是一个列表，

275
00:13:57,800 --> 00:13:58,850
it's a dictionary.
它是一个字典。

276
00:13:58,850 --> 00:14:02,350
So if I literally want the language that you typed in,
所以，如果我想要你输入的语言，

277
00:14:02,350 --> 00:14:06,520
I can use row bracket, quote unquote, "language," treating row as a Dict
我可以使用 row 括号，“language”，将 row 视为一个 Dict

278
00:14:06,520 --> 00:14:09,010
not as a list anymore.
不再是列表。

279
00:14:09,010 --> 00:14:12,700
Now this is, again, more robust because if you move the columns around on me,
现在，这再次变得更加健壮，因为如果你把列在我的表格中移动，

280
00:14:12,700 --> 00:14:15,340
code is still going to work, at least so long as you don't
代码仍然会工作，至少只要你没有

281
00:14:15,340 --> 00:14:17,570
rename the columns at the very top.
重命名顶部的列。

282
00:14:17,570 --> 00:14:20,180
So that's still one assumption I'm making.
所以，我仍然假设这一点。

283
00:14:20,180 --> 00:14:20,680
All right.
好的。

284
00:14:20,680 --> 00:14:23,770
Well, beyond that, what could I actually do here?
除了这个，我在这里还能做什么呢？

285
00:14:23,770 --> 00:14:27,422
Well, just to be clear, I don't, strictly speaking, need this variable.
好吧，为了说清楚，严格来说，我不需要这个变量。

286
00:14:27,422 --> 00:14:28,880
So no need to highlight this again.
所以不需要再突出显示它了。

287
00:14:28,880 --> 00:14:30,755
So let me just simplify the code a little bit
所以让我简化一下代码

288
00:14:30,755 --> 00:14:33,220
and get rid of this variable, and instead just print out
去掉这个变量，然后直接打印出

289
00:14:33,220 --> 00:14:34,960
the language in that row.
那一行中的语言。

290
00:14:34,960 --> 00:14:40,360
As a quick check, let me rerun Python of favorites.py
作为一个快速检查，让我重新运行 favorites.py 的 Python 代码

291
00:14:40,360 --> 00:14:43,430
and it seems to still work, even though there's a lot of output.
它似乎仍然可以工作，即使有大量的输出。

292
00:14:43,430 --> 00:14:45,610
We're not going to check all 399 lines, but it
我们不会检查所有 399 行，但是

293
00:14:45,610 --> 00:14:48,160
looks like it printed out all of those popular languages.
看起来它打印出了所有那些流行的语言。

294
00:14:48,160 --> 00:14:50,120
Well, what more can we actually do?
那么，我们还能做些什么呢？

295
00:14:50,120 --> 00:14:52,420
Well, let's actually now start to crunch some numbers
好吧，让我们现在开始分析一些数字

296
00:14:52,420 --> 00:14:55,450
and figure out how many people like Scratch, how many people like
并找出有多少人喜欢 Scratch，有多少人喜欢

297
00:14:55,450 --> 00:14:56,890
C, how many people like Python.
C，有多少人喜欢 Python。

298
00:14:56,890 --> 00:14:58,580
Let's start to analyze this.
让我们开始分析这个。

299
00:14:58,580 --> 00:15:02,290
So maybe the most pedantic way to do this in Python
所以也许在 Python 中最迂腐的方法是

300
00:15:02,290 --> 00:15:07,113
would be to just create some variables and do all of the counting myself.
创建一些变量，然后自己进行所有的计数。

301
00:15:07,113 --> 00:15:08,780
So let me actually go ahead and do this.
所以让我实际操作一下。

302
00:15:08,780 --> 00:15:10,113
Let me delete this code for now.
让我现在先删除这段代码。

303
00:15:10,113 --> 00:15:12,370
And after opening the reader, let me create
在打开阅读器之后，让我创建

304
00:15:12,370 --> 00:15:14,980
a variable called Scratch and set it equal to zero,
一个名为 Scratch 的变量，并将其值设为零，

305
00:15:14,980 --> 00:15:19,060
a variable called C, set it equal to zero, a variable called Python,
一个名为 C 的变量，将其值设为零，一个名为 Python 的变量，

306
00:15:19,060 --> 00:15:23,290
set it equal to zero, just so that I have three counters, similar to what
将其值设为零，这样我就有三个计数器，类似于我们在零周、一周、以及我们计数任何东西的时候所做的

307
00:15:23,290 --> 00:15:26,620
we did in week zero, week one, anytime we counted anything Honestly,
诚实地说，

308
00:15:26,620 --> 00:15:29,600
this looks a little stupid, and it's not wrong.
这看起来有点蠢，但它并不错误。

309
00:15:29,600 --> 00:15:31,600
In fact, this is how you would do it in Python,
事实上，这就是你在 Python 中的处理方式，

310
00:15:31,600 --> 00:15:33,910
but Python also has some clever syntax.
但 Python 也有一些巧妙的语法。

311
00:15:33,910 --> 00:15:38,800
If you want to be really cool, you can do Scratch comma, c comma,
如果你想真正酷炫，你可以用 Scratch 逗号，c 逗号，

312
00:15:38,800 --> 00:15:43,932
Python equals zero, zero, zero, and do all three at once if you like that.
Python 等于零，零，零，如果你喜欢，可以一次完成所有三个。

313
00:15:43,932 --> 00:15:47,140
So it tightens up the code a little bit, even though the effect is ultimately
所以它让代码稍微紧凑一点，即使效果最终

314
00:15:47,140 --> 00:15:47,710
the same.
是一样的。

315
00:15:47,710 --> 00:15:52,010
Now let's go ahead and iterate over this file row by row by row.
现在，让我们继续逐行迭代这个文件。

316
00:15:52,010 --> 00:15:54,730
And if we see Scratch, increment the Scratch counter.
如果我们看到 Scratch，则增加 Scratch 计数器。

317
00:15:54,730 --> 00:15:56,320
If we see C, increment the C counter.
如果我们看到 C，则增加 C 计数器。

318
00:15:56,320 --> 00:15:59,000
If we see Python, increment the Python counter, instead.
如果我们看到 Python，则增加 Python 计数器。

319
00:15:59,000 --> 00:16:00,080
So how do I do this?
那么我该怎么做呢？

320
00:16:00,080 --> 00:16:03,220
Well, I could do something like, for each row in the reader,
好吧，我可以做类似于，对于阅读器中的每一行，

321
00:16:03,220 --> 00:16:07,180
just like before, let me go ahead and get that favorite variable
就像之前一样，让我继续获取那个 favourite 变量

322
00:16:07,180 --> 00:16:11,230
and set it equal to the language in that dictionary that just came back
并将其值设为返回的字典中的语言

323
00:16:11,230 --> 00:16:12,740
as part of this iteration.
作为此次迭代的一部分。

324
00:16:12,740 --> 00:16:19,060
And now I can do something like this, if favorite equals, equals "Scratch" then,
现在，我可以执行类似的操作，如果 favourite 等于“Scratch”，那么

325
00:16:19,060 --> 00:16:26,710
with my indentation, I can do Scratch plus equals one, elif favorite equals,
使用我的缩进，我可以进行 Scratch 加等于 1，如果 favourite 等于

326
00:16:26,710 --> 00:16:27,670
equals "C."
等于“C”。

327
00:16:27,670 --> 00:16:31,290
I can go ahead and increment C plus equals one.
我可以继续增加 C 加等于 1。

328
00:16:31,290 --> 00:16:34,440
Else-- and I don't think I want else, just to be safe.
否则，我认为我不想要 else，为了安全起见。

329
00:16:34,440 --> 00:16:37,410
Even though we only saw three options, I think just to be super safe,
即使我们只看到了三种选择，我认为为了超级安全，

330
00:16:37,410 --> 00:16:41,040
elif favorite equals, equals "Python," then let's go ahead
如果 favourite 等于“Python”，那么让我们继续

331
00:16:41,040 --> 00:16:42,210
and increment Python.
增加 Python。

332
00:16:42,210 --> 00:16:45,360
The one thing we can't do that we could do in C is the plus, plus trick.
我们在 C 中可以做到而在这里做不到的一件事是加加技巧。

333
00:16:45,360 --> 00:16:47,890
So plus equals is as close as we can get.
所以加等于是我们所能做到的最接近的。

334
00:16:47,890 --> 00:16:48,900
So what have I done?
所以，我做了什么？

335
00:16:48,900 --> 00:16:52,110
Inside of this loop, I've just incremented each of those counters
在这个循环中，我只是增加了每个计数器

336
00:16:52,110 --> 00:16:56,230
by one if I see Scratch, or C, or Python, again and again.
如果我看到 Scratch、C 或 Python，则每次增加 1。

337
00:16:56,230 --> 00:16:56,730
All right.
好的。

338
00:16:56,730 --> 00:17:00,060
Outside of the loop and outside of the with block,
在循环外部和 with 块外部，

339
00:17:00,060 --> 00:17:02,370
because once I'm done reading all of the rows,
因为一旦我读完所有行，

340
00:17:02,370 --> 00:17:06,493
I might as well let the with clause close the file automatically,
我也可以让 with 语句自动关闭文件，

341
00:17:06,493 --> 00:17:08,410
let's just go ahead and print out some values.
让我们直接打印出一些值。

342
00:17:08,410 --> 00:17:13,560
So I'm going to go ahead and print out Scratch colon, and then inside of there
所以我要打印出 Scratch 冒号，然后在里面

343
00:17:13,560 --> 00:17:16,290
let's print out whatever the value of that variable is.
打印出该变量的值。

344
00:17:16,290 --> 00:17:19,770
Let's then go ahead and print out C colon,
然后打印出 C 冒号，

345
00:17:19,770 --> 00:17:22,030
and then whatever the value of the C variable is.
然后打印出 C 变量的值。

346
00:17:22,030 --> 00:17:26,160
And then, lastly, let's print out Python colon and whatever the value is.
最后，打印出 Python 冒号和它的值。

347
00:17:26,160 --> 00:17:29,117
And now I made three typos here.
现在我在这里犯了三个错误。

348
00:17:29,117 --> 00:17:30,700
This is not going to print the values.
这不会打印出值。

349
00:17:30,700 --> 00:17:32,320
What do I need to do?
我需要做什么？

350
00:17:32,320 --> 00:17:34,030
Sorry?
抱歉？

351
00:17:34,030 --> 00:17:36,560
Yeah, I'm missing the f in front of each of these strings
是的，我在每个字符串前面缺少了一个 f

352
00:17:36,560 --> 00:17:38,470
so that I actually get formatted.
这样我才能真正得到格式化的输出。

353
00:17:38,470 --> 00:17:41,800
And that is to say, the variables get interpolated inside of the curly braces
也就是说，变量会被插入到大括号内

354
00:17:41,800 --> 00:17:43,220
like we saw last week.
就像我们上周看到的那样。

355
00:17:43,220 --> 00:17:43,720
All right.
好的。

356
00:17:43,720 --> 00:17:45,928
So, honestly, that's kind of a decent amount of code,
所以，说实话，这是一段相当不错的代码，

357
00:17:45,928 --> 00:17:49,630
like 18 or so lines of code, just to count the number of responses.
大约 18 行代码，只是为了统计响应次数。

358
00:17:49,630 --> 00:17:51,070
But let's see if I got it right.
但让我们看看我是否做对了。

359
00:17:51,070 --> 00:17:55,330
Let me open my terminal and run Python of favorites.py,
让我打开我的终端并运行 favorites.py 的 Python 代码，

360
00:17:55,330 --> 00:17:58,420
and now I see, by an overwhelming amount,
现在我看到了，压倒性的数量，

361
00:17:58,420 --> 00:18:04,660
folks like Python, followed by C, followed by Scratch, in that order.
人们喜欢 Python，其次是 C，然后是 Scratch，按这个顺序。

362
00:18:04,660 --> 00:18:06,910
But that was a decent amount of code to have to write,
但是那段代码需要写得相当多，

363
00:18:06,910 --> 00:18:10,540
and it turns out there's actually better ways of doing this, more Pythonic ways,
事实证明，实际上有更好的方法来做这件事，更 Pythonic 的方法，

364
00:18:10,540 --> 00:18:12,530
more programmatic ways of doing this.
更程序化的做法。

365
00:18:12,530 --> 00:18:15,760
And if we think back to one of our universal data structures.
如果我们回顾一下我们的通用数据结构。

366
00:18:15,760 --> 00:18:18,910
Think back to how we preached last week, and the week before,
回想一下我们上周和前一周的教诲，

367
00:18:18,910 --> 00:18:21,280
the value of these dictionaries, more generally.
字典的价值，更一般地说。

368
00:18:21,280 --> 00:18:23,317
Like the CSV module, clearly a fan of them,
就像 CSV 模块一样，显然是它们的粉丝，

369
00:18:23,317 --> 00:18:25,150
because that's what DictReader is giving us,
因为这就是 DictReader 给我们的，

370
00:18:25,150 --> 00:18:27,220
dictionary, after dictionary, after dictionary.
字典，接着是字典，再接着是字典。

371
00:18:27,220 --> 00:18:29,290
And this was the general idea of a dictionary.
这就是字典的一般概念。

372
00:18:29,290 --> 00:18:31,840
It associates keys with values, much like you
它将键与值关联起来，就像你在

373
00:18:31,840 --> 00:18:34,940
might in a two-column table on a chalkboard, or the like.
黑板上写一个两列的表格一样。

374
00:18:34,940 --> 00:18:39,340
Well, this is what I need if I want to keep track of how many people said
好吧，如果我想跟踪有多少人说

375
00:18:39,340 --> 00:18:42,250
Scratch, and C, and Python.
Scratch、C 和 Python。

376
00:18:42,250 --> 00:18:46,900
If I had a piece of chalk, I could just write Scratch, and C,
如果我有一块粉笔，我可以直接写 Scratch 和 C，

377
00:18:46,900 --> 00:18:48,670
and Python as three keys.
以及 Python 作为三个键。

378
00:18:48,670 --> 00:18:51,910
And then with my chalk and, maybe, an eraser, keep track of the values.
然后用我的粉笔和可能一块橡皮，记录下这些值。

379
00:18:51,910 --> 00:18:52,900
They all start at zero.
它们都从 0 开始。

380
00:18:52,900 --> 00:18:54,550
Then, I add one, add two, add three.
然后，我加一，加二，加三。

381
00:18:54,550 --> 00:18:56,800
Or, maybe, on a chalkboard, I actually use hash marks.
或者，可能在黑板上，我实际上使用的是井号。

382
00:18:56,800 --> 00:19:00,910
But a dictionary is kind of the perfect data structure for just associating
但是字典是一种非常适合用来关联的完美的数据结构

383
00:19:00,910 --> 00:19:05,770
something like Scratch, C, Python, with something else-- keys with values,
像 Scratch，C，Python 这样的东西，以及其他东西——键值对，

384
00:19:05,770 --> 00:19:06,890
respectively.
分别。

385
00:19:06,890 --> 00:19:09,250
So this is going to look a little weirder,
所以这看起来会有点奇怪，

386
00:19:09,250 --> 00:19:13,040
but it's going to be pretty conventional to do something like this instead.
但用这种方式做是比较常规的。

387
00:19:13,040 --> 00:19:15,550
Let me go back into VS Code.
让我回到 VS Code 中。

388
00:19:15,550 --> 00:19:17,360
I'll close my terminal window.
我将关闭我的终端窗口。

389
00:19:17,360 --> 00:19:20,680
And let me go ahead and actually delete a lot of this
让我继续删除掉这些代码

390
00:19:20,680 --> 00:19:22,630
because I can simplify this further.
因为我可以进一步简化它。

391
00:19:22,630 --> 00:19:26,500
Let me go ahead and now give myself, maybe, a variable just,
让我继续给自己一个变量，可能就

392
00:19:26,500 --> 00:19:30,698
generically, called counts, and set that equal to an empty dictionary.
一般性地叫做 counts，并将它设置为一个空字典。

393
00:19:30,698 --> 00:19:32,740
And you can actually do this in a couple of ways.
你实际上可以用几种方法做到这一点。

394
00:19:32,740 --> 00:19:34,727
You can literally write out dict with nothing
你可以直接写出 dict 并在里面什么都不写

395
00:19:34,727 --> 00:19:37,060
in parentheses, which will give you an empty dictionary,
在括号里，这将给你一个空字典，

396
00:19:37,060 --> 00:19:39,602
like the picture on the board, but a little more conventional
就像黑板上的图画一样，但更常规一点

397
00:19:39,602 --> 00:19:43,450
is to just use two keystrokes and use two curly braces with nothing inside.
就是使用两个键，使用两个花括号，里面什么都不写。

398
00:19:43,450 --> 00:19:47,390
That gives me an empty dictionary like this picture here.
这给了我一个像这里图画一样的空字典。

399
00:19:47,390 --> 00:19:49,160
Now my loop is going to be the same.
现在我的循环将保持不变。

400
00:19:49,160 --> 00:19:52,000
I'm going to do, for each row in the reader,
我将对 reader 中的每一行进行操作

401
00:19:52,000 --> 00:19:55,550
I'm going to go ahead and grab the favorite language for this person.
我将继续获取这个人的最喜欢的编程语言。

402
00:19:55,550 --> 00:19:58,652
So favorite equals row, quote unquote, "language."
所以 favorite 等于 row，引号引起来，"language"。

403
00:19:58,652 --> 00:20:00,860
But now I'm going to do something a little different.
但现在我要做一些不同的事情。

404
00:20:00,860 --> 00:20:02,680
There's two scenarios here.
这里有两种情况。

405
00:20:02,680 --> 00:20:07,690
Either, I have seen this language before and I want to increment it by one.
要么我已经见过这种语言，并且想要把它加一。

406
00:20:07,690 --> 00:20:11,950
Or, if I've never seen this language before because the loop just started,
要么，如果我之前从未见过这种语言，因为循环刚刚开始，

407
00:20:11,950 --> 00:20:16,950
what should I initialize the count for this language to?
我应该将这种语言的计数初始化为多少？

408
00:20:16,950 --> 00:20:18,840
So, one because I've only seen it once.
所以是 1，因为我只见过它一次。

409
00:20:18,840 --> 00:20:19,710
Exactly.
没错。

410
00:20:19,710 --> 00:20:22,470
So now let me go ahead and do exactly that.
所以现在让我继续做这件事。

411
00:20:22,470 --> 00:20:26,370
If this current favorite, that I am seeing in the row,
如果当前我最喜欢的，我在这一行中看到的，

412
00:20:26,370 --> 00:20:29,997
is already in the counts dictionary-- and in Python,
已经在 counts 字典中——在 Python 中，

413
00:20:29,997 --> 00:20:31,830
this is literally how you ask that question.
这就是你问这个问题的方式。

414
00:20:31,830 --> 00:20:33,840
If favorite in counts.
如果 favorite 在 counts 中。

415
00:20:33,840 --> 00:20:38,250
That will check, is there a key with this name, Scratch, C, or Python?
这将检查，是否有带这个名字的键，Scratch，C 或者 Python？

416
00:20:38,250 --> 00:20:42,390
If so, go into that location in the counts dictionary,
如果有，进入 counts 字典中的那个位置，

417
00:20:42,390 --> 00:20:46,500
index into it at the favorite location, because favorite is a string.
在 favorite 位置索引它，因为 favorite 是一个字符串。

418
00:20:46,500 --> 00:20:49,140
It's either, quote unquote, "Scratch," "C," or "Python,"
它是，引号引起来，"Scratch"，"C" 或者 "Python"，

419
00:20:49,140 --> 00:20:53,490
and just increment it by one like this.
然后像这样加一。

420
00:20:53,490 --> 00:20:54,780
Else, as you noted.
否则，如你所言。

421
00:20:54,780 --> 00:21:00,360
If it's not there implicitly, then counts bracket favorite should probably
如果它不在那里，那么 counts 中的 favorite 应该

422
00:21:00,360 --> 00:21:03,210
be set equal-- not to zero because we're literally
被设置为——不是 0，因为我们确实

423
00:21:03,210 --> 00:21:04,920
are seeing it in the current row.
在当前行看到了它。

424
00:21:04,920 --> 00:21:06,660
Let's initialize it to one.
让我们把它初始化为 1。

425
00:21:06,660 --> 00:21:08,460
And, thereafter, if we see it again, it's
然后，如果我们再次看到它，它就是

426
00:21:08,460 --> 00:21:11,610
going to be plus equals one, plus equals one, plus equals one.
加等于 1，加等于 1，加等于 1。

427
00:21:11,610 --> 00:21:15,330
So now outside of that loop, outside of the with block, let me do this.
所以现在在循环之外，在 with 块之外，让我做这个。

428
00:21:15,330 --> 00:21:18,200
For each favorite in those counts--
对于 counts 中的每个 favorite——

429
00:21:18,200 --> 00:21:20,920
And this, too, in Python is a trick if you want to iterate over
在 Python 中，这也是一个技巧，如果你想要遍历

430
00:21:20,920 --> 00:21:22,870
all of the keys in a dictionary.
字典中的所有键。

431
00:21:22,870 --> 00:21:26,560
That is, if you want to iterate over the left-hand column of all of these keys,
也就是说，如果你想要遍历所有这些键的左列，

432
00:21:26,560 --> 00:21:30,220
you literally can say, for something in that dictionary.
你可以直接说，对于字典中的某个东西。

433
00:21:30,220 --> 00:21:33,730
So for favorite in counts, this is giving me a variable called favorite
所以对于 counts 中的 favorite，这给了我一个叫做 favorite 的变量

434
00:21:33,730 --> 00:21:37,420
and updating it automatically top to bottom in that dictionary.
并自动从上到下更新该字典中的变量。

435
00:21:37,420 --> 00:21:40,600
Let's go ahead and print out an f string that's
让我们继续打印一个 f 字符串，它

436
00:21:40,600 --> 00:21:44,230
going to say whatever the name of that language is colon,
将显示该语言的名称，后面加冒号，

437
00:21:44,230 --> 00:21:50,950
and whatever the value of that language is in that there dictionary.
以及该语言在该字典中的值。

438
00:21:50,950 --> 00:21:54,040
So, again, logically the only thing that's new is this.
所以，再一次，逻辑上唯一的新东西是这个。

439
00:21:54,040 --> 00:21:57,940
I'm now using one dictionary instead of three variables
我现在使用一个字典而不是三个变量

440
00:21:57,940 --> 00:22:02,170
to keep track of three things, like updating this chalkboard with three
来跟踪三件事，就像用黑板更新三个

441
00:22:02,170 --> 00:22:04,043
different things, Scratch, C, Python.
不同的事，Scratch，C，Python。

442
00:22:04,043 --> 00:22:06,460
And the last thing I'm doing, which is a little different,
我做的最后一件事，有点不同，

443
00:22:06,460 --> 00:22:09,430
is once I have that dictionary, whether there's three languages,
就是，一旦我有了这个字典，无论有三种语言，

444
00:22:09,430 --> 00:22:11,597
or, maybe, tomorrow there'll be fourth because we're
或者，也许明天会有第四种，因为我们要

445
00:22:11,597 --> 00:22:12,970
going to introduce SQL today.
今天介绍 SQL。

446
00:22:12,970 --> 00:22:16,807
Well, this will iterate over all of those keys and print out the values.
这个会遍历所有这些键并打印出值。

447
00:22:16,807 --> 00:22:18,640
All right, so if I didn't do anything wrong,
好的，所以如果我没有做错什么，

448
00:22:18,640 --> 00:22:21,940
if I do Python of favorites.py and hit enter.
如果我运行 Python favorites.py 并按下回车键。

449
00:22:21,940 --> 00:22:23,043
There we have it.
结果出来了。

450
00:22:23,043 --> 00:22:25,210
And it happens to be in a different order this time.
这次的顺序不同了。

451
00:22:25,210 --> 00:22:28,090
That's because we saw Python first, we then saw Scratch,
那是因为我们先看到了 Python，然后看到了 Scratch，

452
00:22:28,090 --> 00:22:31,870
and, eventually, we saw C. But if we wanted to sort these differently,
最后看到了 C。但如果我们想用不同的方式排序，

453
00:22:31,870 --> 00:22:34,780
we actually could with some different code.
我们可以用一些不同的代码来实现。

454
00:22:34,780 --> 00:22:36,170
But, in short, what have we done?
但总之，我们做了什么？

455
00:22:36,170 --> 00:22:39,340
We've created this kind of structure in memory with three keys,
我们在内存中创建了这种结构，它包含三个键，

456
00:22:39,340 --> 00:22:42,100
Python, C, and Scratch, because each time
Python，C 和 Scratch，因为每次

457
00:22:42,100 --> 00:22:47,140
we encounter such a language from you all, we either set our counter to one
我们遇到你们每个人使用的一种语言，我们就会将计数器设置为 1

458
00:22:47,140 --> 00:22:50,110
or increment it by one instead.
或者加 1。

459
00:22:50,110 --> 00:22:56,320
Any questions on this code, or this general idea of using dictionaries as,
对于这段代码，或者使用字典作为

460
00:22:56,320 --> 00:23:00,490
like, a little cheat sheet for doing some math in this way?
像一个简易的速查表来进行一些数学运算的这种想法，你们有什么问题吗？

461
00:23:00,490 --> 00:23:04,200
Super common paradigm.
非常常见的范式。

462
00:23:04,200 --> 00:23:04,700
All right.
好的。

463
00:23:04,700 --> 00:23:06,890
Well, let me tweak this a little bit.
让我稍微调整一下这个。

464
00:23:06,890 --> 00:23:10,622
Right now, in my output, we're seeing Python, Scratch and C.
现在，在我的输出中，我们看到的是 Python，Scratch 和 C。

465
00:23:10,622 --> 00:23:13,580
Maybe, for the sake of discussion, suppose we want to sort this by key.
也许为了讨论，假设我们想按键排序。

466
00:23:13,580 --> 00:23:14,580
We can actually do that.
我们实际上可以做到。

467
00:23:14,580 --> 00:23:16,370
Let me close my terminal temporarily.
让我暂时关闭终端。

468
00:23:16,370 --> 00:23:19,037
And it turns out, in Python, there's a bunch of ways to do this,
事实证明，在 Python 中，有很多方法可以做到这一点，

469
00:23:19,037 --> 00:23:21,890
but the simplest way to sort a dictionary by key
但按键对字典进行排序的最简单方法是

470
00:23:21,890 --> 00:23:24,500
is literally to use a function called sorted
实际上，就是使用一个名为sorted的函数

471
00:23:24,500 --> 00:23:26,970
that comes with Python, that just does it for you.
这个函数是 Python 自带的，它会为你自动完成排序。

472
00:23:26,970 --> 00:23:29,720
And even if you pass it a dictionary, it will sort that dictionary
即使你传入一个字典，它也会对这个字典进行排序

473
00:23:29,720 --> 00:23:34,170
by the left-hand column so you can iterate it over alphabetically instead.
按照字典左侧的键进行排序，这样你就可以按字母顺序遍历它。

474
00:23:34,170 --> 00:23:36,110
So if I go back now to VS Code.
所以现在我回到 VS Code。

475
00:23:36,110 --> 00:23:39,710
If I open my terminal window and I rerun Python on favorites.py,
如果我打开我的终端窗口，然后重新运行 Python 文件 favorites.py，

476
00:23:39,710 --> 00:23:41,840
now that I've added the sorted call, we should now
现在我已经添加了 sorted 函数调用，我们现在应该

477
00:23:41,840 --> 00:23:45,470
see just because it's sorted alphabetically instead.
看到它会按字母顺序排序。

478
00:23:45,470 --> 00:23:49,195
Now that's not that useful, especially if we had lots of languages.
这样做并不太实用，尤其是当我们有许多语言时。

479
00:23:49,195 --> 00:23:51,320
You probably don't care about it being alphabetized
你可能并不关心它是否按字母顺序排序

480
00:23:51,320 --> 00:23:54,570
as much as you care about it being ranked by which is the most popular,
你可能更关心它是否按受欢迎程度排序，

481
00:23:54,570 --> 00:23:55,700
which is the least popular.
哪些最受欢迎，哪些最不受欢迎。

482
00:23:55,700 --> 00:23:58,220
And, for that, there's a bunch of ways to do this in Python.
要做到这一点， Python 中有很多方法。

483
00:23:58,220 --> 00:24:03,410
And, I think, the simplest way to sort by value the right-hand column instead
我认为，最简单的方法是按字典右侧的键的值进行排序，而不是

484
00:24:03,410 --> 00:24:06,900
of the left-hand column is probably to make this change instead.
按照左侧的键进行排序，我们可能应该进行以下修改。

485
00:24:06,900 --> 00:24:09,240
Let me close my terminal temporarily.
我暂时关闭终端。

486
00:24:09,240 --> 00:24:14,110
Let me still use the sorted function, which by default sorts by key,
我仍然使用 sorted 函数，它默认情况下按键进行排序，

487
00:24:14,110 --> 00:24:16,750
but let's change it to be as follows.
但让我们修改它，使其按照以下方式进行排序。

488
00:24:16,750 --> 00:24:21,960
Let's change it to sort by a function called counts.get,
让我们将其修改为按一个名为 counts.get 的函数进行排序，

489
00:24:21,960 --> 00:24:24,360
which is a little weird, but this comes back
这有点奇怪，但这与

490
00:24:24,360 --> 00:24:28,290
to last week's brief discussion of object-oriented programming, or oop.
上周我们简单讨论的面向对象编程 (OOP) 相关内容有关。

491
00:24:28,290 --> 00:24:30,150
Remember, in Python, that almost everything
请记住，在 Python 中，几乎所有东西

492
00:24:30,150 --> 00:24:31,860
is like an object of some sort.
都像某种类型的对象。

493
00:24:31,860 --> 00:24:36,930
An int is an object, a dictionary is an object, a string is an object.
一个整数是一个对象，一个字典是一个对象，一个字符串是一个对象。

494
00:24:36,930 --> 00:24:40,590
Which is to say that, not only do these things have values like, quote unquote,
也就是说，这些东西不仅有像“Hello, World” 或 50 这样的值，这些变量，这些对象，

495
00:24:40,590 --> 00:24:44,340
"Hello, World," or 50, these variables, these objects,
也具有内置的函数，即

496
00:24:44,340 --> 00:24:46,980
can also have functions built into them, a.k.a.
方法。

497
00:24:46,980 --> 00:24:47,670
methods.
方法。

498
00:24:47,670 --> 00:24:52,440
So it turns out that because counts is a dictionary, because I made it so,
事实证明，由于 counts 是一个字典，因为我创建了它，

499
00:24:52,440 --> 00:24:55,350
that counts dictionary, like any dictionary in Python,
这个 counts 字典，就像 Python 中的任何字典一样，

500
00:24:55,350 --> 00:24:57,150
comes with a function called get.
自带一个名为 get 的函数。

501
00:24:57,150 --> 00:25:01,290
And if you just tell the sorted function to use that built-in method,
如果你告诉 sorted 函数使用这个内置方法，

502
00:25:01,290 --> 00:25:05,400
it will actually, for every key, get its value, get its value, get its value,
它实际上会对每个键获取它的值，获取它的值，获取它的值，

503
00:25:05,400 --> 00:25:09,720
and sort effectively by the right-hand column instead of the left.
然后按照右侧的键的值进行排序，而不是按照左侧的键进行排序。

504
00:25:09,720 --> 00:25:13,140
Now we'll see down the line, perhaps, more sophisticated ways of using this,
我们稍后可能会看到使用它的更复杂的方法，

505
00:25:13,140 --> 00:25:15,990
but, for now, this just overrides the default behavior
但就目前而言，这只是覆盖了默认行为

506
00:25:15,990 --> 00:25:19,510
and sorts the dictionary, not by key, but by value instead.
对字典进行排序，不再是按键进行排序，而是按值进行排序。

507
00:25:19,510 --> 00:25:20,010
All right.
好的。

508
00:25:20,010 --> 00:25:24,120
So now watch this if I run Python of favorites.py once more.
所以，现在请看，如果我再次运行 Python 文件 favorites.py。

509
00:25:24,120 --> 00:25:28,140
Previously, it was in the order in which the languages appeared first
之前，它是按照语言在 CSV 文件中首次出现的顺序进行排列的，然后是按字母顺序排序。

510
00:25:28,140 --> 00:25:31,930
in the CSV file, then it was sorted alphabetically.
现在它应该按值进行排序。

511
00:25:31,930 --> 00:25:34,960
Now it should be sorted by value.
现在它应该按值进行排序。

512
00:25:34,960 --> 00:25:35,850
And, indeed.
没错。

513
00:25:35,850 --> 00:25:39,180
Scratch is the least with 40, C is the next with 78,
Scratch 最少，只有 40 个，C 次之，有 78 个，

514
00:25:39,180 --> 00:25:41,458
Python is the biggest with 280.
Python 最多，有 280 个。

515
00:25:41,458 --> 00:25:43,500
That's not much of a top 10, or a top three list.
这并不是一个很好的前十名或前三名列表。

516
00:25:43,500 --> 00:25:44,820
Let's actually reverse it.
我们把它反过来。

517
00:25:44,820 --> 00:25:46,800
And the easiest way in Python to do that is
在 Python 中，最简单的方法是

518
00:25:46,800 --> 00:25:50,130
to pass a third argument into sorted, and you would know this
在 sorted 函数中传递第三个参数，你可以通过阅读文档了解这一点

519
00:25:50,130 --> 00:25:51,750
by just reading the documentation.
你可以通过阅读文档了解这一点。

520
00:25:51,750 --> 00:25:56,370
You can literally say, reverse equals True, capital T,
你实际上可以写 reverse 等于 True，大写的 T，

521
00:25:56,370 --> 00:26:00,480
and now if I rerun this one last time, Python of favorites.py,
现在，如果我最后一次重新运行这个，Python 文件 favorites.py，

522
00:26:00,480 --> 00:26:04,110
I'll see the same values but with the whole thing reversed in order.
我将看到相同的值，但整个顺序被反转了。

523
00:26:04,110 --> 00:26:07,230
Long story short, even though this might feel like a slog,
长话短说，尽管这可能感觉很麻烦，

524
00:26:07,230 --> 00:26:11,070
like adding this and looking up this, so much easier than in C
比如添加这个，查找这个，这比在 C 中容易得多

525
00:26:11,070 --> 00:26:13,980
where you would have had to figure out, how does bubble sort work?
在 C 中，你必须弄清楚，冒泡排序是如何工作的？

526
00:26:13,980 --> 00:26:17,520
Let me implement bubble sort, selection sort, any of those sorting algorithms,
我要实现冒泡排序，选择排序，以及任何其他排序算法，

527
00:26:17,520 --> 00:26:18,660
or use some other library.
或者使用其他库。

528
00:26:18,660 --> 00:26:21,430
In Python, you just get a lot more for free, so to speak.
在 Python 中，你可以获得更多免费的东西，可以这么说。

529
00:26:21,430 --> 00:26:24,390
It's just built in once you get comfy with the documentation.
只要你熟悉文档，它就会内置在里面。

530
00:26:24,390 --> 00:26:29,370
And, to be clear, this is an argument, as is this, as is this.
需要说明的是，这是一个参数，这个也是，这个也是。

531
00:26:29,370 --> 00:26:33,540
But in Python, we have not only positional arguments, which
但在 Python 中，我们不仅有位置参数，它

532
00:26:33,540 --> 00:26:36,720
are based on what position they are in, left to right, just like C,
取决于它们的位置，从左到右，就像 C 中一样，

533
00:26:36,720 --> 00:26:39,900
you also have these named parameters whereby
你还有命名参数，它

534
00:26:39,900 --> 00:26:42,720
they have explicit names that you can use yourself,
具有明确的名称，你可以自己使用，

535
00:26:42,720 --> 00:26:45,930
to make clear that you're using this one but not this other one.
清楚地表明你正在使用这个参数，而不是另一个参数。

536
00:26:45,930 --> 00:26:50,980
More parameters in Python can be optional than in C. Phew.
与 C 不同，Python 中更多参数是可选的。呼。

537
00:26:50,980 --> 00:26:51,480
All right.
好的。

538
00:26:51,480 --> 00:26:54,727
Any questions about that technique yet?
关于这种技术，有任何问题吗？

539
00:26:54,727 --> 00:26:57,810
And if you're feeling like this is starting to take the fun out of Python,
如果你感觉这样开始让 Python 变得不那么有趣了，

540
00:26:57,810 --> 00:27:01,930
that's actually kind of the point of doing this the hard way.
这实际上是通过这种难方法来实现目的。

541
00:27:01,930 --> 00:27:02,430
All right.
好的。

542
00:27:02,430 --> 00:27:05,110
Well, let's do it one other way that's marginally better.
好吧，让我们试试另一种稍微好一点的方法。

543
00:27:05,110 --> 00:27:09,833
It turns out, in Python there really is this rich ecosystem of libraries,
事实证明，在 Python 中，确实存在一个丰富的库生态系统，

544
00:27:09,833 --> 00:27:12,750
the code that comes with the language itself, or, even, third parties.
是语言自带的代码，甚至可以来自第三方。

545
00:27:12,750 --> 00:27:17,040
And coming with the language is another module
语言自带另一个模块

546
00:27:17,040 --> 00:27:19,920
called the collections module, or package here,
叫做 collections 模块，或者说包，

547
00:27:19,920 --> 00:27:25,350
whereby if I use from collections, I can import something called Counter,
如果我使用 from collections，我可以导入一个名为 Counter 的东西，

548
00:27:25,350 --> 00:27:28,140
capital C. And it turns out, if this felt
大写的 C。事实证明，如果这样做

549
00:27:28,140 --> 00:27:30,450
a little bit painful to create a dictionary yourself,
创建字典有点麻烦，

550
00:27:30,450 --> 00:27:33,470
initialize it, maybe, to zero or one, like this.
对其进行初始化，可能为零或一，就像这样。

551
00:27:33,470 --> 00:27:36,547
Turns out, you have the same problem that people before you have had,
事实证明，你遇到了和你之前的人们一样的问题，

552
00:27:36,547 --> 00:27:38,130
and so there's another way to do this.
所以，还有另一种方法可以做到。

553
00:27:38,130 --> 00:27:42,150
You can create a variable called counts, set it equal to Counter, capital
你可以创建一个名为 counts 的变量，将其设置为 Counter，大写

554
00:27:42,150 --> 00:27:43,770
C, open paren, close paren.
C，左括号，右括号。

555
00:27:43,770 --> 00:27:46,140
And this is a different type of object.
这是一种不同类型的对象。

556
00:27:46,140 --> 00:27:48,300
It's a different type of object in Python, that
这是 Python 中不同类型的对象，它

557
00:27:48,300 --> 00:27:50,615
has counting capabilities built in.
具有内置的计数功能。

558
00:27:50,615 --> 00:27:53,490
And so if I actually want to use this counter instead, I can do this.
所以，如果我实际上想使用这个计数器，我可以这样做。

559
00:27:53,490 --> 00:27:57,930
For each row in the reader, let's go ahead and grab the favorite language
对于 reader 中的每一行，让我们获取最喜欢的语言

560
00:27:57,930 --> 00:28:00,540
from that row, just like before.
就像之前一样。

561
00:28:00,540 --> 00:28:04,530
And without doing any of that headache of like, if, elif, or any of this,
而无需进行任何类似if、elif或其他操作的麻烦事，

562
00:28:04,530 --> 00:28:09,060
you can literally just index into that counter using favorite,
你可以直接使用favorite索引到计数器中，

563
00:28:09,060 --> 00:28:14,340
quote unquote, "Scratch," or "C," or "Python," and increment it by one.
用引号括起来，例如“Scratch”或“C”或“Python”，然后将其递增1。

564
00:28:14,340 --> 00:28:17,680
What the Counter class is going to do for you, so to speak--
可以说，Counter类会为你做的事情是——

565
00:28:17,680 --> 00:28:20,190
Another example of object-oriented programming, and counts
面向对象编程的另一个例子，计数

566
00:28:20,190 --> 00:28:21,435
is now an object thereof.
现在是它的一个对象。

567
00:28:21,435 --> 00:28:25,107
What this whole feature of Counter is going to do for you is it's
Counter的整个功能将为你做的是，它

568
00:28:25,107 --> 00:28:26,940
going to automatically initialize everything
将自动初始化所有内容

569
00:28:26,940 --> 00:28:28,710
to zero, even if you've never seen it before,
为零，即使你以前从未见过它，

570
00:28:28,710 --> 00:28:30,940
and then you can just blindly start incrementing it.
然后你可以直接开始递增它。

571
00:28:30,940 --> 00:28:33,570
So, in short, there's just more pleasant ways, sometimes,
总之，有时在Python中还有更简单的方法，

572
00:28:33,570 --> 00:28:36,280
to do something in Python as well.
在Python中做一些事情。

573
00:28:36,280 --> 00:28:36,780
All right.
好的。

574
00:28:36,780 --> 00:28:42,750
How about, lastly, let's make things, maybe--
最后，我们来做一些事情，也许——

575
00:28:42,750 --> 00:28:44,340
Oh, actually, let's do this.
哦，实际上，我们来做这个。

576
00:28:44,340 --> 00:28:47,918
We can even simplify the sorting here.
我们甚至可以简化这里的排序。

577
00:28:47,918 --> 00:28:49,710
Let me actually take this one step further.
让我进一步地做一步。

578
00:28:49,710 --> 00:28:52,950
Instead of manually figuring out how to sort this, I'm going to do this.
与其手动弄清楚如何对它进行排序，我要这样做。

579
00:28:52,950 --> 00:29:02,650
For each favorite, and the count thereof in the counts variable's most
对于每个favorite以及在counts变量中最

580
00:29:02,650 --> 00:29:07,820
common function's return value, go ahead and print out this as well.
常见函数的返回值中对应的计数，打印出它。

581
00:29:07,820 --> 00:29:09,790
So in short, again, a bit new syntax.
总之，这又是一个新的语法。

582
00:29:09,790 --> 00:29:11,210
But what's going on here?
但这里发生了什么？

583
00:29:11,210 --> 00:29:14,410
Well, it turns out that this counts class and--
事实证明，这个counts类和——

584
00:29:14,410 --> 00:29:17,478
sorry, this Counter class, and, in turn, this counts variable,
抱歉，这个Counter类，以及这个counts变量，

585
00:29:17,478 --> 00:29:20,770
comes with a function built in that you would only know from the documentation.
自带一个函数，你只能从文档中知道。

586
00:29:20,770 --> 00:29:23,260
It's literally called most underscore common,
它字面意思是叫做most_common，

587
00:29:23,260 --> 00:29:31,700
and what it returns to you when you call it is a pair of key value, key value.
当你调用它时，它返回给你的是一对键值对。

588
00:29:31,700 --> 00:29:34,480
And so this, too, is a trick in Python that we did not have in C.
所以这在Python中也是一个技巧，我们在C语言中没有这个技巧。

589
00:29:34,480 --> 00:29:37,180
If you want to iterate over something, but grab
如果你想遍历某个东西，但抓取

590
00:29:37,180 --> 00:29:40,120
two variables at a time on each iteration like this,
每次迭代时同时获取两个变量，像这样，

591
00:29:40,120 --> 00:29:42,880
you separate them by commas and can get favorite count,
用逗号隔开它们，就可以得到favorite count，

592
00:29:42,880 --> 00:29:44,840
favorite count, favorite count.
favorite count，favorite count。

593
00:29:44,840 --> 00:29:50,260
So if I run this now, Python of favorites.py, this, too, just works.
所以如果我现在运行它，Python of favorites.py，这个也运行正常。

594
00:29:50,260 --> 00:29:53,440
And it's getting a little simpler, a little tighter than before
而且它比以前更简单，更紧凑。

595
00:29:53,440 --> 00:29:57,740
than if we had actually done it all manually.
如果我们手动完成所有步骤，就会比现在更复杂。

596
00:29:57,740 --> 00:30:01,310
Lastly, here is a code that's the shortest version thereof.
最后，这是最短的代码版本。

597
00:30:01,310 --> 00:30:03,650
We're down to like 14 or 15 lines.
我们已经缩减到大约14或15行代码。

598
00:30:03,650 --> 00:30:08,480
If I wanted to change this to analyze the most popular problem thus
如果我想更改它来分析到目前为止最流行的问题，

599
00:30:08,480 --> 00:30:12,620
far in the class, how do I go about changing the code
在课程中，我应该如何更改代码

600
00:30:12,620 --> 00:30:18,260
to print out, top to bottom, the most popular problem or problems?
来打印出从上到下最流行的问题或问题？

601
00:30:18,260 --> 00:30:19,280
What line should change?
哪一行应该更改？

602
00:30:19,280 --> 00:30:20,570
Yeah.
是的。

603
00:30:20,570 --> 00:30:22,070
So, yeah.
所以，是的。

604
00:30:22,070 --> 00:30:22,610
Line 10.
第10行。

605
00:30:22,610 --> 00:30:25,310
Because I've written this in kind of a general purpose way
因为我用一种通用方法写了它

606
00:30:25,310 --> 00:30:27,282
and using dictionaries with keys, it suffices
并且使用带有键的字典，这就足够了

607
00:30:27,282 --> 00:30:29,240
to change language to, quote unquote, "problem"
将language更改为“problem”

608
00:30:29,240 --> 00:30:31,325
because that was the third column from the CSV.
因为那是CSV中的第三列。

609
00:30:31,325 --> 00:30:33,200
And so now, if you're curious, let's actually
所以现在，如果你好奇，让我们实际上

610
00:30:33,200 --> 00:30:35,240
make my terminal window a bit bigger.
让我的终端窗口更大一些。

611
00:30:35,240 --> 00:30:37,820
Python of favorites.py, enter.
Python of favorites.py，回车。

612
00:30:37,820 --> 00:30:38,750
And, OK.
好的。

613
00:30:38,750 --> 00:30:40,910
Tragically, we peaked early with Hello, World--
不幸的是，我们太早地达到了Hello, World的巅峰——

614
00:30:40,910 --> 00:30:45,060
is the most popular problem thus far, followed by Filter, then Scratch.
到目前为止，这是最流行的问题，其次是Filter，然后是Scratch。

615
00:30:45,060 --> 00:30:45,560
OK.
好的。

616
00:30:45,560 --> 00:30:46,700
Peaked even earlier.
甚至更早地达到顶峰。

617
00:30:46,700 --> 00:30:51,660
Mario, DNA, and so forth, and a bunch of others thereafter.
Mario、DNA等等，以及之后一大堆其他的。

618
00:30:51,660 --> 00:30:55,477
So based on this sample size, here's the ranking of the problems thus far.
所以基于这个样本大小，这是到目前为止问题的排名。

619
00:30:55,477 --> 00:30:56,060
So, we got it.
所以，我们得到了它。

620
00:30:56,060 --> 00:30:59,570
More Hello, World problems in the weeks to come.
未来几周会有更多Hello, World问题。

621
00:30:59,570 --> 00:31:01,160
All right.
好的。

622
00:31:01,160 --> 00:31:04,520
Now that we've done that in that way, let's
既然我们已经用这种方式完成了，让我们

623
00:31:04,520 --> 00:31:07,070
just make this program slightly interactive
使这个程序稍微交互式

624
00:31:07,070 --> 00:31:11,070
and see how we can really take a fundamentally different approach.
看看我们如何才能真正采用一种完全不同的方法。

625
00:31:11,070 --> 00:31:12,620
I'm going to go into VS Code.
我要进入VS Code。

626
00:31:12,620 --> 00:31:15,798
I'm going to keep everything the same, except that, at the bottom,
我将保留所有内容不变，除了在底部，

627
00:31:15,798 --> 00:31:17,840
I'm going to get rid of this loop because I don't
我要去掉这个循环，因为我不

628
00:31:17,840 --> 00:31:20,120
want any more print out everything.
想要再打印出所有内容。

629
00:31:20,120 --> 00:31:22,040
I want to look up specific counts.
我想查阅特定计数。

630
00:31:22,040 --> 00:31:25,060
Like, how popular was this problem, how popular was this other problem?
比如，这个问题有多流行，另一个问题有多流行？

631
00:31:25,060 --> 00:31:28,310
And what I'm going to go ahead and do is to create a variable called favorite,
我要创建的变量叫做favorite，

632
00:31:28,310 --> 00:31:30,180
set it equal to--
将它设置为——

633
00:31:30,180 --> 00:31:32,060
I could use get string in the CS50 library,
我可以使用CS50库中的get_string，

634
00:31:32,060 --> 00:31:34,790
but we saw last week there's no need to for strings, certainly.
但我们上周看到，对于字符串，绝对没有必要。

635
00:31:34,790 --> 00:31:37,340
Let me just use the input function that comes with Python,
让我使用Python自带的input函数，

636
00:31:37,340 --> 00:31:39,890
and prompt the human for their favorite problem.
提示用户输入他们最喜欢的题目。

637
00:31:39,890 --> 00:31:45,020
And then let me go ahead and print out, for instance, an f string containing
然后，我将打印出一个包含

638
00:31:45,020 --> 00:31:51,920
whatever their favorite is, colon, and whatever the count is thereof
他们最喜欢的，冒号，以及该favorite的计数

639
00:31:51,920 --> 00:31:54,290
of that favorite, close quote.
的计数，结束引号。

640
00:31:54,290 --> 00:31:56,400
So let me open my terminal window.
所以让我打开我的终端窗口。

641
00:31:56,400 --> 00:31:59,300
Let me run Python of favorites.py, enter.
让我运行Python of favorites.py，回车。

642
00:31:59,300 --> 00:32:04,640
And if I type in Hello, World, looks like 65 people, indeed, like that one.
如果我输入Hello, World，看起来确实有65人喜欢它。

643
00:32:04,640 --> 00:32:06,860
If I run Python of favorites.py again.
如果我再次运行Python of favorites.py。

644
00:32:06,860 --> 00:32:09,350
I type in Scratch, now we see that one.
我输入Scratch，现在我们看到了它。

645
00:32:09,350 --> 00:32:12,570
If I type in anything else, I'm going to get its specific value.
如果我输入其他任何东西，我将获得它的特定值。

646
00:32:12,570 --> 00:32:18,050
So this is to say, not only can we write Python code to analyze some data pretty
也就是说，我们不仅可以用Python代码来分析数据，而且

647
00:32:18,050 --> 00:32:20,720
tightly versus the manual code we wrote out earlier,
相比我们之前写的手动代码来说，更加紧凑，

648
00:32:20,720 --> 00:32:23,238
you can also make these programs interactive as well.
你还可以使这些程序具有交互性。

649
00:32:23,238 --> 00:32:25,530
And this is going to be a super common paradigm, right,
这将是一个非常常见的范式，对吧，

650
00:32:25,530 --> 00:32:28,880
if you go into the world of consulting, analytics, data science, more
如果你进入咨询、分析、数据科学等领域，

651
00:32:28,880 --> 00:32:29,540
generally.
一般来说。

652
00:32:29,540 --> 00:32:34,310
Among your roles is going to be to analyze data, to ask questions of data,
你的职责之一将是分析数据，询问数据，

653
00:32:34,310 --> 00:32:37,610
get back the answer. be ask questions of data, get back the answer.
得到答案。询问数据，得到答案。

654
00:32:37,610 --> 00:32:40,190
Honestly, life gets pretty tedious, even though you've only
说实话，生活会变得相当单调，即使你只

655
00:32:40,190 --> 00:32:43,670
been programming in Python, perhaps, for like one week, a week and a half now.
用Python编程了一周，也许是一周半。

656
00:32:43,670 --> 00:32:46,880
When you have to write code to solve all of the world's problems--
当您需要编写代码来解决世界上所有问题时 -

657
00:32:46,880 --> 00:32:49,250
and there's this sort of tenant in programming,
在编程中，有一种原则

658
00:32:49,250 --> 00:32:53,270
that programmers tend to avoid writing code as much as they can
程序员尽可能避免编写代码

659
00:32:53,270 --> 00:32:55,190
because, ideally, you would solve problems
因为理想情况下，你会用

660
00:32:55,190 --> 00:32:58,640
with the right tool for the job, minimizing the number of lines of code
合适的工具来解决问题，从而最大限度地减少代码行数

661
00:32:58,640 --> 00:32:59,880
you actually write.
你实际上要写的。

662
00:32:59,880 --> 00:33:01,920
So how do we actually get to that point?
那么我们如何才能真正做到这一点呢？

663
00:33:01,920 --> 00:33:06,740
Well, instead of just dealing with CSV files, pure text, it turns out
好吧，事实证明，与其只是处理 CSV 文件，纯文本，

664
00:33:06,740 --> 00:33:09,200
there's an entire world of proper databases.
还存在一个完整的正规数据库的世界。

665
00:33:09,200 --> 00:33:12,080
Not flat file databases, where you store everything in text files,
不是平面文件数据库，您将所有内容存储在文本文件中，

666
00:33:12,080 --> 00:33:16,370
but a database program, a piece of software running on a computer,
而是一个数据库程序，一个运行在计算机上的软件，

667
00:33:16,370 --> 00:33:18,922
running on a server, that's always listening for you.
运行在服务器上，一直在等待您的指令。

668
00:33:18,922 --> 00:33:22,130
It's got a lot of memory, it's got a lot of space, and in turn a lot of data,
它拥有大量的内存，大量的存储空间，因此也拥有大量的数据，

669
00:33:22,130 --> 00:33:25,460
and it supports a database specific language
并且它支持数据库专用语言

670
00:33:25,460 --> 00:33:31,020
that makes it much easier, much faster to ask questions of the very same data.
这使得询问相同数据变得更加容易，更加快捷。

671
00:33:31,020 --> 00:33:33,290
It's a relational database in the sense, too,
它也是一种关系型数据库，

672
00:33:33,290 --> 00:33:35,480
that it's not even necessarily one spreadsheet,
因为它不一定是单个电子表格，

673
00:33:35,480 --> 00:33:37,430
one set of rows and columns.
一组行和列。

674
00:33:37,430 --> 00:33:41,960
You can have two sheets, three sheets, 30 sheets across which there might very
您可以拥有两个、三个、三十个表，它们之间可能存在

675
00:33:41,960 --> 00:33:44,840
well be relationships, or relations.
关系，或者关联。

676
00:33:44,840 --> 00:33:48,830
So S-Q-L, or SQL, is a database specific language,
因此，S-Q-L，或 SQL，是数据库专用语言，

677
00:33:48,830 --> 00:33:52,625
stands for Structured Query Language, that's a declarative language whereby
代表结构化查询语言，这是一种声明式语言，通过它

678
00:33:52,625 --> 00:33:54,500
you're not going to be in the habit with SQL,
在 SQL 中，您不会养成

679
00:33:54,500 --> 00:33:58,870
typically, of writing loops and conditionals, and this kind of thing.
编写循环和条件语句等习惯。

680
00:33:58,870 --> 00:34:02,260
You're instead going to describe the data that you want to get back,
相反，您将描述想要获取的数据，

681
00:34:02,260 --> 00:34:05,680
you're going to describe the question that you want the answer to,
您将描述想要得到答案的问题，

682
00:34:05,680 --> 00:34:08,650
and we'll do this using a relatively small grammar.
我们将使用一种相对简单的语法来做到这一点。

683
00:34:08,650 --> 00:34:11,620
That is to say, there's not that many keywords in SQL.
也就是说，SQL 中的关键字并不多。

684
00:34:11,620 --> 00:34:12,850
It's a pretty small language.
这是一门相当小的语言。

685
00:34:12,850 --> 00:34:16,120
But it's going to allow us to eliminate dozens of lines of Python code,
但它将使我们能够消除几十行 Python 代码，

686
00:34:16,120 --> 00:34:16,900
perhaps.
也许。

687
00:34:16,900 --> 00:34:19,429
SQL follows this CRUD paradigm.
SQL 遵循 CRUD 范式。

688
00:34:19,429 --> 00:34:23,230
So C-R-U-D, which simply means that in a relational database,
所以 C-R-U-D，简单来说，就是指在关系型数据库中，

689
00:34:23,230 --> 00:34:25,030
you can really only do four things.
您实际上只能做四件事。

690
00:34:25,030 --> 00:34:30,100
You can create data, read data-- that is, look at it or analyze it somehow.
您可以创建数据、读取数据 - 也就是说，以某种方式查看或分析它。

691
00:34:30,100 --> 00:34:32,540
Update the data, or delete the data.
更新数据或删除数据。

692
00:34:32,540 --> 00:34:33,770
So, CRUD, for short.
简而言之，就是 CRUD。

693
00:34:33,770 --> 00:34:36,673
And that really speaks to just how relatively simple
这实际上说明了即使我们只触及了其中一些

694
00:34:36,673 --> 00:34:39,340
the world is, even though we'll just scratch the surface of some
功能的表面，这个世界实际上是相对简单的。

695
00:34:39,340 --> 00:34:40,423
of its capabilities today.
我们今天将探索更多功能。

696
00:34:40,423 --> 00:34:42,560
And you'll explore more over time.
随着时间的推移，您将探索更多。

697
00:34:42,560 --> 00:34:45,340
Specifically, in SQL, there's going to be other keywords that
具体来说，在 SQL 中，还有一些其他关键字

698
00:34:45,340 --> 00:34:46,719
map to those four ideas.
对应于这四种概念。

699
00:34:46,719 --> 00:34:49,480
Technically, you don't just create data in the world of SQL,
从技术上讲，在 SQL 的世界里，您并不只是创建数据，

700
00:34:49,480 --> 00:34:53,270
you can also insert data, like inserting more rows into a sheet.
您还可以插入数据，例如向表中插入更多行。

701
00:34:53,270 --> 00:34:55,330
And it's not the word "read" that people use.
人们不会使用“read”这个词。

702
00:34:55,330 --> 00:34:56,739
People say to "select" data.
人们会说“select”数据。

703
00:34:56,739 --> 00:35:00,170
But they mean to read data, which is sort of the opposite of writing
但他们的意思是读取数据，这与写入

704
00:35:00,170 --> 00:35:01,220
or creating data.
或创建数据相反。

705
00:35:01,220 --> 00:35:04,070
But the U and the D are the same, except that there's also
但 U 和 D 是相同的，只不过还有一个

706
00:35:04,070 --> 00:35:07,580
a keyword in SQL known as DROP, which lets you very destructively,
一个名为 DROP 的 SQL 关键字，它可以让你非常破坏性地

707
00:35:07,580 --> 00:35:11,610
very dangerously delete entire database tables, as well.
非常危险地删除整个数据库表。

708
00:35:11,610 --> 00:35:15,500
So how do we do this, and what's the connection to our favorites data
那么我们如何做到这一点，以及它与我们最喜欢的  数据

709
00:35:15,500 --> 00:35:16,190
thus far?
有什么关系呢？

710
00:35:16,190 --> 00:35:18,920
Well, here is the syntax in this language called
好吧，这里是在这种名为

711
00:35:18,920 --> 00:35:22,880
SQL via which you can create a table.
SQL 的语言中创建表的语法。

712
00:35:22,880 --> 00:35:26,510
So the jargon is a little different, but the ideas are exactly the same
所以术语略有不同，但基本思路完全相同

713
00:35:26,510 --> 00:35:27,840
from the world of spreadsheets.
与电子表格的世界。

714
00:35:27,840 --> 00:35:33,720
What you call a sheet in a spreadsheet, the database world calls a table.
在电子表格中称为工作表的东西，在数据库世界中称为表。

715
00:35:33,720 --> 00:35:37,320
It's a table of rows and columns, but it's the exact same idea.
它是一个包含行和列的表，但基本思路完全相同。

716
00:35:37,320 --> 00:35:40,320
You're going to have discretion over what to call the table,
您可以自行决定如何命名表，

717
00:35:40,320 --> 00:35:42,710
just like you can call a spreadsheet something, or else,
就像您可以为电子表格命名一样，或者

718
00:35:42,710 --> 00:35:44,790
and you can also specify the types of data
您还可以指定要存储在行和列中的数据的类型。

719
00:35:44,790 --> 00:35:46,790
that you want to store in your rows and columns.
您想要存储在行和列中的数据类型。

720
00:35:46,790 --> 00:35:49,520
And it's going to go a little more deeply than just formatting it,
它将比简单地格式化更深入，

721
00:35:49,520 --> 00:35:51,687
like in Excel, and Numbers, and Google Spreadsheets,
就像在 Excel、Numbers 和 Google Spreadsheets 中一样，

722
00:35:51,687 --> 00:35:55,250
you can actually control, maybe, how big the data could be depending
您实际上可以控制，也许，数据的大小取决于

723
00:35:55,250 --> 00:35:57,140
on the database you're actually using.
您实际使用的数据库。

724
00:35:57,140 --> 00:35:59,990
In CS50, we're going to use a light version of SQL.
在 CS50 中，我们将使用一个轻量级的 SQL 版本。

725
00:35:59,990 --> 00:36:01,820
Literally, a language called--
准确地说，这是一种名为

726
00:36:01,820 --> 00:36:04,970
an implementation of SQL called SQLite, which has really
SQL 的实现，名为 SQLite，它实际上拥有

727
00:36:04,970 --> 00:36:08,360
all of the core functionality that you would see in the real world,
您在现实世界中看到的所有核心功能，

728
00:36:08,360 --> 00:36:10,702
and with larger, more scalable systems, but it's
以及在更大、更可扩展的系统中，但它是

729
00:36:10,702 --> 00:36:13,160
going to allow us to focus on a lot of the building blocks.
将使我们能够专注于许多构建块。

730
00:36:13,160 --> 00:36:17,010
And SQLite's actually really popular on Macs, PCs, and phones, nowadays.
如今，SQLite 在 Mac、PC 和手机上非常流行。

731
00:36:17,010 --> 00:36:20,450
A lot of the data that games and other applications on your phone might store,
手机上游戏和其他应用程序可能存储的许多数据，

732
00:36:20,450 --> 00:36:24,470
actually have a file, a binary file with zeros and ones,
实际上有一个文件，一个包含零和一的二进制文件，

733
00:36:24,470 --> 00:36:26,393
that's in the SQLite format.
它采用 SQLite 格式。

734
00:36:26,393 --> 00:36:29,060
So if you do a mobile app, for instance, for your final project,
因此，例如，如果您在最终项目中开发一个移动应用程序，

735
00:36:29,060 --> 00:36:32,220
you'll have an opportunity to play with something like this.
您将有机会尝试使用这种技术。

736
00:36:32,220 --> 00:36:34,760
Well, how do you actually run SQLite3?
那么，您如何实际运行 SQLite3 呢？

737
00:36:34,760 --> 00:36:37,500
It's just a command built into your code space.
它只是一个内置于您的代码空间的命令。

738
00:36:37,500 --> 00:36:40,400
So this is a program you could install on your own Mac, your own PC,
所以这是一个您可以安装在您自己的 Mac、您自己的 PC 上的程序，

739
00:36:40,400 --> 00:36:40,910
or the like.
或类似的设备上。

740
00:36:40,910 --> 00:36:43,280
We'll do everything as we've done before, in the cloud,
我们将在云中像之前一样执行所有操作，

741
00:36:43,280 --> 00:36:44,780
and actually use your code space.
并且实际上使用您的代码空间。

742
00:36:44,780 --> 00:36:48,170
And by that I mean, we can just start to play with this data now
我的意思是，我们现在就可以开始使用这些数据

743
00:36:48,170 --> 00:36:51,890
using SQL instead of Python.
使用 SQL 而不是 Python。

744
00:36:51,890 --> 00:36:52,710
So let me do this.
所以让我这样做。

745
00:36:52,710 --> 00:36:55,190
Let me open up my terminal window here, and let
让我打开我的终端窗口，并让

746
00:36:55,190 --> 00:36:58,010
me go ahead and maximize my terminal window just because we'll
我最大化我的终端窗口，因为我们现在将

747
00:36:58,010 --> 00:37:00,140
focus now on the files here.
专注于这些文件。

748
00:37:00,140 --> 00:37:03,530
Recall that I have a file called favorites.csv,
请记住，我有一个名为 favorites.csv 的文件，

749
00:37:03,530 --> 00:37:05,510
and that CSV file is just text.
那个 CSV 文件只是文本。

750
00:37:05,510 --> 00:37:08,300
But let me load it into a proper database
但我把它加载到一个合适的数据库中

751
00:37:08,300 --> 00:37:11,510
so I can actually use this other language called SQL on it.
这样我就可以用另一种叫做 SQL 的语言来使用它了。

752
00:37:11,510 --> 00:37:14,210
To do this, I'm going to run SQLite3, which
为了做到这一点，我将运行 SQLite3，它

753
00:37:14,210 --> 00:37:16,070
just means the third version of it, and I'm
只是代表它的第三个版本，而我正在

754
00:37:16,070 --> 00:37:18,950
going to create a new database called favorites.db.
创建一个叫做 favorites.db 的新数据库。

755
00:37:18,950 --> 00:37:21,380
That's just a convention, but it means here comes
这只是一个约定，但它意味着这里来了

756
00:37:21,380 --> 00:37:23,030
a database that I'm going to create.
一个我将要创建的数据库。

757
00:37:23,030 --> 00:37:25,370
Notice, I'm not using the tabbed code editor.
注意，我没有使用制表符代码编辑器。

758
00:37:25,370 --> 00:37:28,460
I'm not using the code command because the code command is generally
我没有使用代码命令，因为代码命令通常

759
00:37:28,460 --> 00:37:29,600
for text files.
用于文本文件。

760
00:37:29,600 --> 00:37:33,440
SQLite3 is going to create a binary file, zeros and ones, ultimately.
SQLite3 最终将创建一个二进制文件，即零和一。

761
00:37:33,440 --> 00:37:35,750
When I run that, it's going to ask me to verify yes.
当我运行它的时候，它会要求我验证“是”。

762
00:37:35,750 --> 00:37:37,400
I'm going to hit y and then enter.
我将按 y 然后回车。

763
00:37:37,400 --> 00:37:40,940
And now I'm at the SQLite prompt, which is not the dollar sign.
现在我处于 SQLite 提示符，它不是美元符号。

764
00:37:40,940 --> 00:37:43,730
It literally says SQLite with an angled bracket.
它字面上是 SQLite 带一个尖括号。

765
00:37:43,730 --> 00:37:49,220
Now, one time only, I want to go ahead and load favorites.csv
现在，我只想一次性地加载 favorites.csv

766
00:37:49,220 --> 00:37:53,150
into this database so I can actually play around with it using not Python,
到这个数据库中，这样我就可以用非 Python 的语言来玩它，

767
00:37:53,150 --> 00:37:54,982
but this new language called SQL.
而是这种叫做 SQL 的新语言。

768
00:37:54,982 --> 00:37:56,940
And the way I'm going to do this is as follows.
而我将这样做的方法如下。

769
00:37:56,940 --> 00:37:57,773
I'm going to do dot.
我将输入点。

770
00:37:57,773 --> 00:38:00,130
Mode csv, enter.
模式 csv，回车。

771
00:38:00,130 --> 00:38:03,430
And that just puts SQLite into CSV mode.
这只是将 SQLite 设置为 CSV 模式。

772
00:38:03,430 --> 00:38:05,650
It has different modes for different file formats.
它有不同的模式来处理不同的文件格式。

773
00:38:05,650 --> 00:38:09,700
I'm going to .import and then I'm going to specify the file that I want
我将要使用 .import 命令，然后我将指定我想

774
00:38:09,700 --> 00:38:11,800
to import, which is favorites.csv.
导入的文件，也就是 favorites.csv。

775
00:38:11,800 --> 00:38:13,030
And then this one's up to me.
然后这部分由我来决定。

776
00:38:13,030 --> 00:38:15,580
What is the name of the table I want to create?
我想创建的表格名称是什么？

777
00:38:15,580 --> 00:38:18,012
And table, again, is essentially synonymous with sheets.
表格，再次强调，基本上等同于表格。

778
00:38:18,012 --> 00:38:19,720
So I'm going to call everything the same.
所以我打算把所有东西都命名为相同。

779
00:38:19,720 --> 00:38:22,700
I'm going to call my table favorites as well.
我将把我的表格也命名为 favorites。

780
00:38:22,700 --> 00:38:25,420
So what this command is essentially going to do,
因此这个命令本质上将要做的，

781
00:38:25,420 --> 00:38:29,890
is all of those lines of Python code that open the file, read it row by row,
就是所有那些打开文件、逐行读取文件的 Python 代码行，

782
00:38:29,890 --> 00:38:31,028
and do something with it--
并对它做些处理——

783
00:38:31,028 --> 00:38:32,320
This is just built into SQLite.
这只是 SQLite 的内置功能。

784
00:38:32,320 --> 00:38:37,720
It's going to load the whole darn CSV into this new favorites.db file,
它将把整个 CSV 文件加载到这个新的 favorites.db 文件中，

785
00:38:37,720 --> 00:38:38,980
and then that's it for now.
然后现在就结束了。

786
00:38:38,980 --> 00:38:42,220
I'm going to go ahead and literally type .quit to get out of SQLite.
我将继续输入 .quit 以退出 SQLite。

787
00:38:42,220 --> 00:38:43,810
I'm back at my dollar sign prompt.
我回到了我的美元符号提示符。

788
00:38:43,810 --> 00:38:47,500
If I type ls, I have not only favorites.csv,
如果我输入 ls，我不仅有 favorites.csv，

789
00:38:47,500 --> 00:38:54,790
I also have favorites.db now as well, a brand new file, and in that file now is
现在我还有 favorites.db，一个全新的文件，而现在这个文件中是

790
00:38:54,790 --> 00:38:57,560
an optimized version of the CSV file.
CSV 文件的优化版本。

791
00:38:57,560 --> 00:39:00,860
In that DB file now is a version of the data that's
现在在这个 DB 文件中是数据的版本，它

792
00:39:00,860 --> 00:39:04,430
going to lend itself to CRUD operations, creating, reading, update,
将适合 CRUD 操作，即创建、读取、更新，

793
00:39:04,430 --> 00:39:08,810
and deleting, using this new language called SQL.
和删除，使用这种叫做 SQL 的新语言。

794
00:39:08,810 --> 00:39:10,478
All right, so how do I get into this?
好吧，那么我怎样才能进入这个呢？

795
00:39:10,478 --> 00:39:13,520
Well, let me clear my terminal window and pretend that I'm doing this now
好吧，让我清除我的终端窗口，并假装我现在正在做这个

796
00:39:13,520 --> 00:39:14,062
the next day.
第二天。

797
00:39:14,062 --> 00:39:15,478
I've already created the database.
我已经创建了数据库。

798
00:39:15,478 --> 00:39:16,670
That's a one time operation.
这是一个一次性的操作。

799
00:39:16,670 --> 00:39:18,545
Once you've got the data, now I'm going to go
一旦你获得了数据，我现在将继续

800
00:39:18,545 --> 00:39:24,080
ahead and again run SQLite3 favorites.db just to open the file again.
执行 SQLite3 favorites.db 来重新打开这个文件。

801
00:39:24,080 --> 00:39:27,260
But it's already now-- all of the data is in there.
但现在已经——所有数据都在里面了。

802
00:39:27,260 --> 00:39:32,420
Just as a teaser, let me go ahead and do this.
作为预告，让我继续执行这个操作。

803
00:39:32,420 --> 00:39:38,580
.schema is a SQLite command that just shows me the schema of this database
.schema 是一个 SQLite 命令，它只是向我展示了这个数据库的模式

804
00:39:38,580 --> 00:39:39,080
table.
表。

805
00:39:39,080 --> 00:39:41,130
And we'll see more about this in a little bit,
我们稍后会更多地了解这一点，

806
00:39:41,130 --> 00:39:44,630
but for now this is showing me, essentially,
但现在它本质上向我展示了，

807
00:39:44,630 --> 00:39:48,170
the SQL command that was automatically run
当我第一次导入这个数据库时，自动运行的 SQL 命令

808
00:39:48,170 --> 00:39:51,650
when I imported this database the first time around.
。

809
00:39:51,650 --> 00:39:54,680
And, for now, just notice that it mentions timestamp,
现在，请注意它提到了 timestamp，

810
00:39:54,680 --> 00:39:57,270
it mentions language, it mentions problem.
它提到了 language，它提到了 problem。

811
00:39:57,270 --> 00:39:59,790
Very loosely, it calls each of those texts.
非常宽松地，它把每一个都称为文本。

812
00:39:59,790 --> 00:40:02,370
So we're not trying very hard to distinguish one type of data
所以我们没有努力地去区分一种类型的数据

813
00:40:02,370 --> 00:40:02,912
from another.
和另一种。

814
00:40:02,912 --> 00:40:03,690
It's all text.
它们都是文本。

815
00:40:03,690 --> 00:40:06,790
But notice, create table If not exists favorites.
但请注意，create table If not exists favorites。

816
00:40:06,790 --> 00:40:09,420
This is essentially the create table syntax
这基本上就是 create table 语法

817
00:40:09,420 --> 00:40:11,490
that I alluded to earlier via which you can
我之前提到的，你可以用它来

818
00:40:11,490 --> 00:40:15,510
create a table in a SQLite database.
在一个 SQLite 数据库中创建表格。

819
00:40:15,510 --> 00:40:17,280
But more on that in just a bit.
但我们稍后会详细介绍。

820
00:40:17,280 --> 00:40:22,500
Here now is how we can actually get at the data in that database.
现在，我们要了解如何实际获取数据库中的数据。

821
00:40:22,500 --> 00:40:28,380
It turns out that we can select one or more columns from a database
事实证明，我们可以从数据库中选择一个或多个列

822
00:40:28,380 --> 00:40:30,180
table using syntax like this.
表，使用这样的语法。

823
00:40:30,180 --> 00:40:33,870
Literally, the keyword select, then the name of one or more columns
字面上是关键字 select，然后是一个或多个列的名称

824
00:40:33,870 --> 00:40:38,550
that are in that database, and then from the specific table that you care about.
存在于数据库中，然后是从你关心的特定表格中。

825
00:40:38,550 --> 00:40:41,760
And notice that in capital letters here are all of the SQL
注意，这里所有 SQL 的特定关键字都使用大写字母，特别是 select 和 from。

826
00:40:41,760 --> 00:40:44,760
specific keywords, select, and from, in particular.
。

827
00:40:44,760 --> 00:40:47,940
And in lowercase, by convention, here are the placeholders
按照惯例，这里的小写字母代表你或我创建的列和表格的占位符。

828
00:40:47,940 --> 00:40:51,270
for the columns that you, or I, have created, and the tables that you, or I,
。

829
00:40:51,270 --> 00:40:52,210
have created.
。

830
00:40:52,210 --> 00:40:53,820
So if I go back to SQLite here.
所以如果我回到 SQLite。

831
00:40:53,820 --> 00:40:57,090
Let me just clear with Control L, which will just freshen up the screen here
让我用 Control L 清理一下，这将使屏幕变得更新

832
00:40:57,090 --> 00:40:58,770
so we can focus on what's new.
以便我们可以关注新的内容。

833
00:40:58,770 --> 00:41:03,600
If I want to select everything from the table called favorites,
如果我想从名为 favorites 的表中选择所有内容，

834
00:41:03,600 --> 00:41:04,890
here's what I can do.
我可以这样做。

835
00:41:04,890 --> 00:41:09,570
Select star from favorites semicolon.
Select star from favorites 分号。

836
00:41:09,570 --> 00:41:12,660
And, do forgive me, semicolons are back for SQL, in this case.
请原谅，在这种情况下，SQL 中又出现了分号。

837
00:41:12,660 --> 00:41:16,680
But select star from favorites uses a syntax you might not be familiar with.
但 select star from favorites 使用的语法你可能不熟悉。

838
00:41:16,680 --> 00:41:18,660
Star here has nothing to do with pointers.
这里的星号与指针无关。

839
00:41:18,660 --> 00:41:20,100
Star is a wild card.
星号是一个通配符。

840
00:41:20,100 --> 00:41:22,290
It means give me everything, no matter what it's
它意味着给我所有东西，无论它叫什么，

841
00:41:22,290 --> 00:41:24,480
called, from this particular table.
从这个特定的表格中。

842
00:41:24,480 --> 00:41:27,030
When I hit enter, what we're going to see
当我按下回车键后，我们将看到

843
00:41:27,030 --> 00:41:30,810
is the entire contents of the favorite table
favorite 表的全部内容

844
00:41:30,810 --> 00:41:34,480
that's the result of having imported that CSV into this database.
这是将那个 CSV 文件导入到这个数据库的结果。

845
00:41:34,480 --> 00:41:37,380
So when I hit enter, there is all of that data.
所以当我按下回车键后，所有数据都会显示出来。

846
00:41:37,380 --> 00:41:40,110
And SQLite, just to be friendly, it's using
SQLite 为了友好，它使用

847
00:41:40,110 --> 00:41:44,220
what we might call ASCII art, just very simple text, like hyphens,
我们可能会称之为 ASCII 艺术，仅仅是非常简单的文本，比如连字符，

848
00:41:44,220 --> 00:41:47,310
and vertical bars, and pluses on the corner, to make it look pretty
还有竖线，还有角落里的加号，让它看起来很漂亮

849
00:41:47,310 --> 00:41:49,690
and make it look like it is a proper table.
并且让它看起来像一个合适的表格。

850
00:41:49,690 --> 00:41:52,620
But what you're really seeing is the contents of favorites.db,
但你真正看到的是 favorites.db 的内容，

851
00:41:52,620 --> 00:41:54,750
specifically in that table.
具体来说是在那个表里。

852
00:41:54,750 --> 00:41:57,130
Specifically, if I only care about languages,
具体来说，如果我只关心语言，

853
00:41:57,130 --> 00:41:59,130
let me try something more specific than star.
让我尝试比 star 更具体的东西。

854
00:41:59,130 --> 00:42:03,270
Select language from favorites semicolon.
从 favorites 中选择 language 然后加上分号。

855
00:42:03,270 --> 00:42:05,640
This is going to give me just a single column now,
这现在会给我一个单列，

856
00:42:05,640 --> 00:42:09,150
of all of the favorites that you selected for language specifically.
所有你专门为 language 选择的收藏夹。

857
00:42:09,150 --> 00:42:12,730
This is a little overwhelming to see all 399 or so pieces of data,
看到所有 399 条左右的数据有点让人难以承受，

858
00:42:12,730 --> 00:42:14,680
so let me actually truncate it a little bit.
所以让我实际缩短它一点。

859
00:42:14,680 --> 00:42:20,333
Let me do select language from favorites limit 10.
让我执行 select language from favorites limit 10。

860
00:42:20,333 --> 00:42:22,500
So we're about to see that there's little tricks you
所以我们即将看到，有一些小技巧你可以

861
00:42:22,500 --> 00:42:26,430
can use to tweak the behavior of the language
用来调整语言的行为

862
00:42:26,430 --> 00:42:28,500
in order to get back more or less data.
以便获取更多或更少的数据。

863
00:42:28,500 --> 00:42:31,110
In fact, it turns out there's a bunch of keywords
事实上，事实证明有很多关键字

864
00:42:31,110 --> 00:42:35,880
like these built into SQL, much like Google Spreadsheets, Apple Numbers,
像这些内置在 SQL 中，就像 Google 表格、Apple Numbers，

865
00:42:35,880 --> 00:42:38,293
Microsoft Excel, and certainly Python.
Microsoft Excel，当然还有 Python。

866
00:42:38,293 --> 00:42:41,460
There's a lot of functionality that you just get for free with the language.
有很多功能是你在语言中免费获得的。

867
00:42:41,460 --> 00:42:44,610
If you want to calculate an average, count the number of things in a file,
如果你想计算平均数，统计文件中的内容数量，

868
00:42:44,610 --> 00:42:48,090
get the unique or distinct values, force everything to lowercase,
获取唯一或不同的值，强制所有内容变为小写，

869
00:42:48,090 --> 00:42:50,380
force everything to uppercase, get the maximum value,
强制所有内容变为大写，获取最大值，

870
00:42:50,380 --> 00:42:53,505
minimum value-- much like spreadsheets, if you're familiar with that world,
最小值-- 就像电子表格，如果你熟悉那个世界，

871
00:42:53,505 --> 00:42:56,880
you get all of that functionality in SQL but also more.
你在 SQL 中获得所有这些功能，但还有更多。

872
00:42:56,880 --> 00:42:59,680
So, for instance, if I go back to my terminal window here.
所以，例如，如果我回到我的终端窗口。

873
00:42:59,680 --> 00:43:02,490
Let me go ahead and select the total number of favorites
让我继续选择这个表中收藏夹的总数

874
00:43:02,490 --> 00:43:06,150
in this table, the total number of rows that you all inputted.
在这个表里，你们所有人输入的行总数。

875
00:43:06,150 --> 00:43:10,320
So I could do select star from favorites semicolon,
所以我可以执行 select star from favorites 然后加分号，

876
00:43:10,320 --> 00:43:12,450
and then I could literally start counting these.
然后我就可以直接开始数这些。

877
00:43:12,450 --> 00:43:15,330
Like 1, 2, 3, 4-- there's clearly a better way.
像 1、2、3、4 - - 显然有更好的方法。

878
00:43:15,330 --> 00:43:19,480
And, indeed, on our list of functions was a count function.
而且，事实上，在我们的函数列表中有一个 count 函数。

879
00:43:19,480 --> 00:43:22,200
And so the way I can use that in SQL is like this.
所以在 SQL 中我可以用这种方法。

880
00:43:22,200 --> 00:43:25,230
Select count of star--
选择 count of star - -

881
00:43:25,230 --> 00:43:28,113
so pass star in as an argument to the count function.
所以把 star 作为参数传递给 count 函数。

882
00:43:28,113 --> 00:43:30,780
You don't care what columns you're counting just count them all.
你不在乎你在统计哪些列，只需要把它们都统计起来。

883
00:43:30,780 --> 00:43:33,440
From favorites semicolon.
从 favorites 中选择然后加分号。

884
00:43:33,440 --> 00:43:35,190
And now, you're actually going to get back
现在，你实际上会得到

885
00:43:35,190 --> 00:43:40,050
like a little baby table that has just one row, one column inside of which--
像一个小小表格，只有一行，一列，其中 - -

886
00:43:40,050 --> 00:43:43,410
one cell of which has the total actual count.
一个单元格中包含实际的总数。

887
00:43:43,410 --> 00:43:47,610
And it's 398 because 399, recall, included the actual header
它为 398 因为 399，回顾一下，包含了实际的标题

888
00:43:47,610 --> 00:43:49,480
row from the file.
文件中的一行。

889
00:43:49,480 --> 00:43:49,980
All right.
好的。

890
00:43:49,980 --> 00:43:52,260
So suppose you want to--
所以假设你想 - -

891
00:43:52,260 --> 00:43:54,480
actually, note that this is the exact same thing
事实上，请注意，这和

892
00:43:54,480 --> 00:43:58,840
as counting a specific column because every row
统计特定列是一样的，因为每一行

893
00:43:58,840 --> 00:44:00,670
has the same number of columns, three.
有相同数量的列，三列。

894
00:44:00,670 --> 00:44:03,790
We could just say select the count of languages,
我们可以直接说选择 count of languages，

895
00:44:03,790 --> 00:44:07,720
or select the count of problems.
或者选择 count of problems。

896
00:44:07,720 --> 00:44:10,023
All of those are going to give me back the same answer.
所有这些都会给我同样的答案。

897
00:44:10,023 --> 00:44:12,190
It is, therefore, conventional in SQL if you're just
因此，如果你只是在 SQL 中

898
00:44:12,190 --> 00:44:14,080
trying to count the number of rows, don't even
试图统计行数，甚至

899
00:44:14,080 --> 00:44:15,413
worry about what they're called.
不用担心它们叫什么。

900
00:44:15,413 --> 00:44:18,722
Just do count star to get back everything more simply.
直接执行 count star 来更简单地获取所有内容。

901
00:44:18,722 --> 00:44:21,430
All right, but what if we want to get back the distinct languages
好的，但如果我们想获取不同的语言

902
00:44:21,430 --> 00:44:23,972
and we didn't know a priori that this came from a Google form
并且我们不知道这是来自 Google 表格

903
00:44:23,972 --> 00:44:25,107
with three radio buttons?
有三个单选按钮？

904
00:44:25,107 --> 00:44:26,690
Well, we could do something like this.
好吧，我们可以这样做。

905
00:44:26,690 --> 00:44:33,130
We could select the distinct languages from the favorites table, enter.
我们可以从 favorites 表中选择不同的语言，回车。

906
00:44:33,130 --> 00:44:35,950
And that gives me Python, Scratch, C because distinct
然后它会给我 Python、Scratch、C 因为 distinct

907
00:44:35,950 --> 00:44:38,200
is one of the other functions that comes with SQL.
是 SQL 附带的另一个函数。

908
00:44:38,200 --> 00:44:40,990
This is, obviously, very easily countable with my human eyes,
这显然用我的肉眼很容易数，

909
00:44:40,990 --> 00:44:43,210
but if I wanted to do this more dynamically,
但如果我想更动态地做这件事，

910
00:44:43,210 --> 00:44:47,530
I could change this to be count the distinct languages.
我可以把它改成 count the distinct languages。

911
00:44:47,530 --> 00:44:50,200
And just like in C, just like in Python, just like in Scratch,
就像在 C 中一样，就像在 Python 中一样，就像在 Scratch 中一样，

912
00:44:50,200 --> 00:44:52,987
I can nest these functions and pass the output of one
我可以嵌套这些函数，将一个的输出

913
00:44:52,987 --> 00:44:54,070
into the input of another.
传递给另一个的输入。

914
00:44:54,070 --> 00:44:59,550
If I hit enter now, I now get three in this case here.
如果我现在按回车键，在这个例子中我得到 3。

915
00:44:59,550 --> 00:45:00,050
OK.
好的。

916
00:45:00,050 --> 00:45:04,580
Let me pause to see if there's any questions or confusion just yet.
让我停下来看看现在有没有问题或困惑。

917
00:45:04,580 --> 00:45:05,120
Yeah.
是的。

918
00:45:05,120 --> 00:45:07,000
[INDISTINCT SPEECH]
[模糊的语音]

919
00:45:07,000 --> 00:45:07,770
Does SQLite--
SQLite 是否 - -

920
00:45:07,770 --> 00:45:09,910
[INDISTINCT SPEECH]
[模糊的语音]

921
00:45:09,910 --> 00:45:11,980
SQLite3 is a program.
SQLite3 是一个程序。

922
00:45:11,980 --> 00:45:16,210
And it's an implementation of the SQLite language, which
它实现了 SQLite 语言，它

923
00:45:16,210 --> 00:45:18,820
itself is a lightweight version of what the world known
本身是世界所知的一种轻量级版本

924
00:45:18,820 --> 00:45:21,890
as SQL, which is a very convoluted way of saying
为 SQL，这是一种非常复杂的说法

925
00:45:21,890 --> 00:45:23,390
there's lots of humans in the world.
世界上有很多人类。

926
00:45:23,390 --> 00:45:25,420
Not everyone agrees what SQL should be.
并不是每个人都同意 SQL 应该是什么样子。

927
00:45:25,420 --> 00:45:28,720
Microsoft might disagree with Oracle, might disagree with other companies,
微软可能不同意 Oracle，可能不同意其他公司，

928
00:45:28,720 --> 00:45:29,390
as well.
也是。

929
00:45:29,390 --> 00:45:32,500
So there's a common subset of SQL in the world
所以世界上有一个 SQL 的通用子集

930
00:45:32,500 --> 00:45:35,200
that almost everyone knows, and learns, and uses,
几乎每个人都知道，学习和使用，

931
00:45:35,200 --> 00:45:37,900
but there are also some vendor specific features.
但也有一些供应商特定的特性。

932
00:45:37,900 --> 00:45:40,790
SQLite tries to distill things really into the essence,
SQLite 试图把事情真正提炼成本质，

933
00:45:40,790 --> 00:45:44,430
and so that's what you increasingly see on Android, on iOS, on Macs, and PCs,
所以这就是你越来越多地在 Android、iOS、Mac 和 PC 上看到的，

934
00:45:44,430 --> 00:45:44,930
as well.
也是。

935
00:45:44,930 --> 00:45:47,650
So we use it because it's relatively canonical.
所以我们使用它，因为它相对规范。

936
00:45:47,650 --> 00:45:49,330
Good question.
好问题。

937
00:45:49,330 --> 00:45:49,830
All right.
好的。

938
00:45:49,830 --> 00:45:53,550
So let's do a few other things by introducing a few other keywords
所以让我们通过引入一些其他关键字来做一些其他事情

939
00:45:53,550 --> 00:45:55,440
without trying all of these right now.
现在不要尝试所有这些。

940
00:45:55,440 --> 00:45:59,730
Here in this list is a bunch of new keywords
这里在这个列表中有一堆新关键字

941
00:45:59,730 --> 00:46:01,740
that are going to give us even finer control.
这将给我们更精细的控制权。

942
00:46:01,740 --> 00:46:04,920
And we saw limit already, and that just limits the output.
我们已经看到了 limit，它仅仅限制输出。

943
00:46:04,920 --> 00:46:08,010
But you can also have what are called predicates.
但你也可以拥有所谓的谓词。

944
00:46:08,010 --> 00:46:11,280
You can literally use the keyword where to start filtering the data,
你可以直接使用关键字“where”来开始筛选数据，

945
00:46:11,280 --> 00:46:14,640
without using an if, and an elif, and an elif, and an elif, and so forth.
而无需使用if、elif、elif、elif等等。

946
00:46:14,640 --> 00:46:17,640
You can just in one line express something conditionally,
你只需用一行代码就能有条件地表达某些东西，

947
00:46:17,640 --> 00:46:21,067
you can order the data, and you can even group similar data together.
你还可以对数据进行排序，甚至可以将类似的数据分组在一起。

948
00:46:21,067 --> 00:46:22,150
So what do I mean by this?
我的意思是？

949
00:46:22,150 --> 00:46:24,622
Let me go back to VS Code here, and let me play around
让我们回到VS Code，来试一试

950
00:46:24,622 --> 00:46:25,830
with a few different queries.
一些不同的查询。

951
00:46:25,830 --> 00:46:32,490
Let me select, maybe, the count of rows from favorites, which previously
也许，让我们从favorites中选择行数，之前

952
00:46:32,490 --> 00:46:38,250
was going to be 398 if I just get back all of the rows, but suppose I only
如果我获取所有行，将是398，但假设我只想

953
00:46:38,250 --> 00:46:41,190
want to know how many of you liked C. I can then say something
想知道有多少人喜欢C语言。我可以用

954
00:46:41,190 --> 00:46:46,500
like where the language in each row equals, quote unquote, "C,"
类似于“where language 在每行中等于”C“，”

955
00:46:46,500 --> 00:46:49,750
and the convention here is to use single quotes, though SQLite
这里的惯例是使用单引号，尽管SQLite

956
00:46:49,750 --> 00:46:51,790
is tolerant of other formats as well.
也支持其他格式。

957
00:46:51,790 --> 00:46:56,257
If I hit enter here, I'll see, indeed, as we saw with Python, the 78 number.
如果我在此处按回车键，我将看到，正如我们在Python中看到的那样，数字78。

958
00:46:56,257 --> 00:46:57,340
That, honestly, took what?
老实说，那需要什么？

959
00:46:57,340 --> 00:46:59,690
13, 14, 15 lines of code?
13、14、15行代码？

960
00:46:59,690 --> 00:47:04,990
Now I've distilled that kind of query into a single line of SQL code
现在我已经将这种查询压缩成了一行SQL代码，

961
00:47:04,990 --> 00:47:07,180
instead, by using this built in functionality.
而是通过使用这个内置功能。

962
00:47:07,180 --> 00:47:11,110
Suppose I really want to get specific, and how many of you really liked
假设我真的很想具体一点，有多少人真正喜欢

963
00:47:11,110 --> 00:47:14,500
Hello, World in C as your favorite?
“Hello World”用C语言作为你的最爱？

964
00:47:14,500 --> 00:47:16,510
Well, I could change this query.
我可以修改这个查询。

965
00:47:16,510 --> 00:47:19,330
And just like your dollar sign prompt, your shell,
就像你的美元符号提示符，你的shell一样，

966
00:47:19,330 --> 00:47:22,660
you can go up and down in your history in SQLite to save keystrokes.
你可以在SQLite的历史记录中上下移动以节省按键。

967
00:47:22,660 --> 00:47:24,520
You can use Boolean logic.
你可以使用布尔逻辑。

968
00:47:24,520 --> 00:47:27,790
And I can say language equals C AND, maybe,
我可以说“language等于C，并且，也许，

969
00:47:27,790 --> 00:47:31,490
problem equals, quote unquote, "Hello, World,"
problem等于“Hello, World”，”

970
00:47:31,490 --> 00:47:34,730
and the number of you that liked that problem was seven.
而喜欢这个题目的人数是七个。

971
00:47:34,730 --> 00:47:37,900
So really, really early on likes Hello, World in C.
所以，很多年前就有人喜欢用C语言写“Hello, World”。

972
00:47:37,900 --> 00:47:39,910
Now notice a couple of key differences.
现在请注意几个关键的不同点。

973
00:47:39,910 --> 00:47:43,900
One, I'm using AND, and not ampersand, ampersand like in C. I'm
第一，我使用的是AND，而不是像C语言中的那样使用“&”。我使用的是

974
00:47:43,900 --> 00:47:46,100
using single equal signs.
单等号。

975
00:47:46,100 --> 00:47:50,030
So SQL behaves like Scratch does, which is not like Python or C. Why?
因此SQL的行为方式与Scratch类似，这与Python或C不同。为什么？

976
00:47:50,030 --> 00:47:52,780
Different people have implemented different languages differently.
不同的人以不同的方式实现了不同的语言。

977
00:47:52,780 --> 00:47:57,310
Equals, equals, equality in the world of SQL
在SQL世界中，等于、等于，即相等

978
00:47:57,310 --> 00:47:59,120
for comparing things left and right.
用于比较左右两侧的事物。

979
00:47:59,120 --> 00:47:59,620
All right.
好的。

980
00:47:59,620 --> 00:48:01,870
Things are now going to get a little more interesting,
事情现在将变得更加有趣，

981
00:48:01,870 --> 00:48:05,140
but the whole goal of all of that Python code
但所有这些Python代码的最终目标

982
00:48:05,140 --> 00:48:09,650
was to analyze the ranking of languages and popularity thereof.
是分析语言的排名及其流行程度。

983
00:48:09,650 --> 00:48:12,400
Turns out in SQL, once you have the vocabulary,
事实证明，在SQL中，一旦你掌握了词汇，

984
00:48:12,400 --> 00:48:14,590
it's pretty easy to do something like that.
做这样的事情就非常简单了。

985
00:48:14,590 --> 00:48:15,560
I'm going to do this.
我将要这样做。

986
00:48:15,560 --> 00:48:19,120
I'm going to select all of the languages in the table,
我将选择表中的所有语言，

987
00:48:19,120 --> 00:48:23,020
but I'm also going to select the count thereof.
但我也会选择它们的计数。

988
00:48:23,020 --> 00:48:26,020
And then I'm going to do that from the favorites table,
然后我将从favorites表中进行操作，

989
00:48:26,020 --> 00:48:29,560
but I'm going to group by language because I
但我会按语言进行分组，因为我

990
00:48:29,560 --> 00:48:33,370
claimed a moment ago that group by is another one of our key phrases in SQL
刚才说过，group by 是SQL中的另一个关键词，

991
00:48:33,370 --> 00:48:35,120
that's going to let us group data.
它将让我们对数据进行分组。

992
00:48:35,120 --> 00:48:37,600
And what this effectively means is that if you've
它的实际含义是，如果你有

993
00:48:37,600 --> 00:48:41,530
got this table with a lot of duplicate languages, again, and again,
一个包含大量重复语言的表，一次又一次，

994
00:48:41,530 --> 00:48:45,130
and again, you can group by that column, and, essentially,
一次又一次，你就可以按该列进行分组，本质上

995
00:48:45,130 --> 00:48:48,850
smush all of the Python rows together, all of the Scratch rows together,
将所有Python行、所有Scratch行、

996
00:48:48,850 --> 00:48:52,930
all of the C rows together, but figure out how many of those
所有C行合并在一起，但找出有多少行

997
00:48:52,930 --> 00:48:55,240
rows just got smushed together.
被合并在一起了。

998
00:48:55,240 --> 00:48:57,910
Effectively, doing all of that dictionary legwork,
实际上，完成了我在13行

999
00:48:57,910 --> 00:49:01,090
or the counter legwork, that I did in 13--
15行Python代码中完成的所有字典工作或计数器工作。

1000
00:49:01,090 --> 00:49:02,990
15 lines of Python code.
15行Python代码。

1001
00:49:02,990 --> 00:49:06,700
So if I hit enter here, this now is the motivation
所以如果我在此处按回车键，这就是我们现在开始做的动机。

1002
00:49:06,700 --> 00:49:08,410
for what we're now starting to do.
我们现在开始做的事情。

1003
00:49:08,410 --> 00:49:11,860
I have distilled into a single line of code
我已经用一行代码

1004
00:49:11,860 --> 00:49:14,140
in a language called SQL what, indeed, took me
用一种叫做SQL的语言，完成了需要我

1005
00:49:14,140 --> 00:49:18,280
more than a dozen lines of Python code just to get back an answer.
使用超过十行Python代码才能得到答案的事情。

1006
00:49:18,280 --> 00:49:20,110
And I can do the same thing with problem.
我可以用problem做同样的事情。

1007
00:49:20,110 --> 00:49:23,230
I can just change language here, for instance, to problem instead.
例如，我只需将这里的language改为problem。

1008
00:49:23,230 --> 00:49:26,300
But, per this list, I can not only group things, I can order them.
但是，根据这个列表，我不仅可以对事物进行分组，还可以对它们进行排序。

1009
00:49:26,300 --> 00:49:29,440
So if you actually want to get a top 10, or a top three list, well let's
所以，如果你真的想得到一个前十名或前三名的列表，那就让我们

1010
00:49:29,440 --> 00:49:30,880
just change this query slightly.
稍微修改一下这个查询。

1011
00:49:30,880 --> 00:49:37,970
Before the semicolon, let me order by the count of those rows semicolon.
在分号之前，让我按这些行的计数进行排序，分号。

1012
00:49:37,970 --> 00:49:40,570
And now what I get is from smallest to largest.
现在我得到的是从小到大。

1013
00:49:40,570 --> 00:49:42,850
40, 78, 280.
40、78、280。

1014
00:49:42,850 --> 00:49:44,590
If you want to flip that, that's fine.
如果你想反转一下，那也没问题。

1015
00:49:44,590 --> 00:49:49,630
By default, order by uses ascending order, abbreviated A-S-C.
默认情况下，order by 使用升序，缩写为ASC。

1016
00:49:49,630 --> 00:49:53,810
If you want to do descending order, D-E-S-C, you can do that as well.
如果你想使用降序，DESC，你也可以这样做。

1017
00:49:53,810 --> 00:49:57,680
And now we have a top three list, from largest to smallest.
现在我们有了一个前三名的列表，从大到小。

1018
00:49:57,680 --> 00:50:01,360
Now, honestly, this is a bit of a mouthful to use count star over here,
老实说，这里使用count(*)有点拗口。

1019
00:50:01,360 --> 00:50:02,920
count star over here.
这里的count(*)。

1020
00:50:02,920 --> 00:50:06,580
There's a nicety in SQL, too, where you can create little aliases of sorts.
SQL中也有一些好处，你可以创建一些别名。

1021
00:50:06,580 --> 00:50:08,890
So if I use the same query again--
所以如果我再次使用相同的查询

1022
00:50:08,890 --> 00:50:10,850
let me scroll over to the left.
让我向左滚动一下。

1023
00:50:10,850 --> 00:50:13,990
I can actually use the keyword as here, and I
我实际上可以用这里的关键字“as”，并且

1024
00:50:13,990 --> 00:50:18,370
can rename this weird looking column, count star, to anything I want.
可以将这个看起来很奇怪的列，count(*)，重命名为我想要的任何东西。

1025
00:50:18,370 --> 00:50:19,930
I can rename it to n.
我可以将其重命名为n。

1026
00:50:19,930 --> 00:50:24,280
And then at the end of this query, I can order by n, essentially,
然后在该查询的末尾，我可以按n进行排序，本质上

1027
00:50:24,280 --> 00:50:26,990
creating a synonym, if you will, for one versus the other.
创建一个同义词，如果你愿意，用于一个与另一个之间的比较。

1028
00:50:26,990 --> 00:50:30,310
So if I hit enter now, same exact thing, but my little baby table
所以如果我现在按回车键，是一样的，但我的小表格

1029
00:50:30,310 --> 00:50:33,310
that came back-- not a technical term-- has two columns, one of which
返回了，这不是一个技术术语，它有两列，其中一列

1030
00:50:33,310 --> 00:50:36,580
is more simply called n now instead of count star.
现在被称为n，而不是count(*)。

1031
00:50:36,580 --> 00:50:40,330
It just makes it minorly more convenient in your actual SQL code
这只是让你的实际SQL代码稍微方便一些

1032
00:50:40,330 --> 00:50:44,110
to reference things that might actually be a little annoying to type.
来引用可能不太方便输入的东西。

1033
00:50:44,110 --> 00:50:47,200
Lastly, suppose we want to get a top one list,
最后，假设我们想得到一个前一名的列表，

1034
00:50:47,200 --> 00:50:49,000
and we just want the most popular language.
我们只想要最流行的语言。

1035
00:50:49,000 --> 00:50:51,790
Honestly, I can just do limit one, enter.
老实说，我只需要做limit 1，回车。

1036
00:50:51,790 --> 00:50:55,720
That gives me just this tiny little table, a temporary table, really,
这给了我一个非常小的表格，实际上是一个临时的表格，

1037
00:50:55,720 --> 00:50:56,860
with one row.
只有一行。

1038
00:50:56,860 --> 00:51:00,460
And, honestly, if I don't even care about what the language is,
老实说，如果我甚至不在乎语言是什么，

1039
00:51:00,460 --> 00:51:02,230
I can omit that entirely.
我可以完全省略它。

1040
00:51:02,230 --> 00:51:06,340
Just see how many people really like the most popular language.
看看有多少人真正喜欢最流行的语言。

1041
00:51:06,340 --> 00:51:07,660
280, in this case.
在这种情况下，是 280 人。

1042
00:51:07,660 --> 00:51:10,910
But, of course, it's more interesting to see what it actually is.
当然，更有趣的是看看它到底是什么。

1043
00:51:10,910 --> 00:51:13,420
So, in short, just by turning these knobs syntactically,
简而言之，只需通过语法上调整这些旋钮，

1044
00:51:13,420 --> 00:51:16,900
it's relatively easy to start getting at more and more data.
就可以相对容易地开始获取越来越多的数据。

1045
00:51:16,900 --> 00:51:19,270
And more answers there, too.
那里也有更多答案。

1046
00:51:19,270 --> 00:51:19,770
Phew.
呼。

1047
00:51:19,770 --> 00:51:24,270
Questions on this thus far?
到目前为止，对此有什么问题吗？

1048
00:51:24,270 --> 00:51:25,200
Any questions?
有什么问题吗？

1049
00:51:25,200 --> 00:51:26,040
No?
没有？

1050
00:51:26,040 --> 00:51:26,670
OK.
好的。

1051
00:51:26,670 --> 00:51:29,305
Well suppose that this week, for instance.
假设本周，例如。

1052
00:51:29,305 --> 00:51:31,680
One of our new problems is going to be called Fiftyville,
我们新的问题之一将被称为 Fiftyville，

1053
00:51:31,680 --> 00:51:33,960
and it's going to allow you to explore the world of SQL
它将允许您探索 SQL 的世界

1054
00:51:33,960 --> 00:51:35,793
in the context of a place called Fiftyville.
在一个叫做 Fiftyville 的地方。

1055
00:51:35,793 --> 00:51:38,350
Suppose that suddenly becomes your favorite problem.
假设它突然成为你最喜欢的难题。

1056
00:51:38,350 --> 00:51:40,920
Well, how can we go about adding more data to a database?
那么，我们如何向数据库添加更多数据呢？

1057
00:51:40,920 --> 00:51:43,720
Well, we've seen create table for creating the table,
我们已经看到了 create table 用于创建表格，

1058
00:51:43,720 --> 00:51:47,230
we've seen select for selecting data there from.
我们已经看到了 select 用于从那里选择数据。

1059
00:51:47,230 --> 00:51:50,340
Turns out there's also an insert into command
事实证明，还有一个 insert into 命令

1060
00:51:50,340 --> 00:51:54,210
that you can use to insert new data into a table.
你可以用它来插入新数据到表格中。

1061
00:51:54,210 --> 00:51:57,450
Now, I did this in bulk by just importing that whole CSV file,
现在，我通过导入整个 CSV 文件来批量完成此操作，

1062
00:51:57,450 --> 00:52:00,370
and SQLite3 did it all for me automatically.
SQLite3 为我自动完成了所有操作。

1063
00:52:00,370 --> 00:52:04,320
But in the real world, if you don't have a captive audience, every one of whom
但在现实世界中，如果你没有一个被俘虏的观众，每个人

1064
00:52:04,320 --> 00:52:06,540
is submitting the form at the same time--
都在同一时间提交表单——

1065
00:52:06,540 --> 00:52:09,300
but maybe it's an application that's running 24/7,
但也许它是一个 24/7 运行的应用程序，

1066
00:52:09,300 --> 00:52:13,210
you're going to get more and more data over time, just like Google itself.
随着时间的推移，你将获得越来越多的数据，就像谷歌本身一样。

1067
00:52:13,210 --> 00:52:16,290
So if you write code like this, you can insert one row
所以如果你写了这样的代码，你可以插入一行

1068
00:52:16,290 --> 00:52:20,530
at a time, one row at a time, and actually change the data in your table.
一次，一次一行，并真正更改表格中的数据。

1069
00:52:20,530 --> 00:52:24,820
So just as a check, let me do select star from favorites, enter.
所以，为了检查一下，让我执行 select star from favorites，回车。

1070
00:52:24,820 --> 00:52:26,500
Just to see all of the data.
只是为了查看所有数据。

1071
00:52:26,500 --> 00:52:31,030
And the last data we got was at 1:41 PM, and 21 seconds.
我们收到的最后一条数据是在下午 1:41，21 秒。

1072
00:52:31,030 --> 00:52:34,390
Suppose now I've decided I want to insert one new row.
假设现在我决定要插入一行新数据。

1073
00:52:34,390 --> 00:52:35,560
I can do this.
我可以这样做。

1074
00:52:35,560 --> 00:52:39,550
Insert into favorites-- and then I have to specify
Insert into favorites——然后我必须指定

1075
00:52:39,550 --> 00:52:41,710
what columns do I want to insert into.
我想插入哪些列。

1076
00:52:41,710 --> 00:52:47,230
I'm going to insert a new language column, and a new problem column.
我将插入一列新的语言，以及一列新的问题。

1077
00:52:47,230 --> 00:52:47,840
Timestamp?
时间戳？

1078
00:52:47,840 --> 00:52:48,340
I could.
我可以。

1079
00:52:48,340 --> 00:52:51,590
I don't really want to look up the time, so I'm going to leave that one blank.
我并不想查看时间，所以我将把那一项留空。

1080
00:52:51,590 --> 00:52:54,520
And I'm going to put in values as follows for this.
我将为其输入以下值。

1081
00:52:54,520 --> 00:52:57,850
SQL for the language, which wasn't even an option on the form earlier,
SQL 代表语言，之前在表单上甚至没有这个选项，

1082
00:52:57,850 --> 00:53:02,830
and Fiftyville for the name of the problem, semicolon.
而 Fiftyville 代表问题的名称，分号。

1083
00:53:02,830 --> 00:53:04,540
So there's a bit of dichotomy here.
所以这里有点矛盾。

1084
00:53:04,540 --> 00:53:07,690
In the first set of parentheses, you specify a comma separated list
在第一组括号中，您指定一个用逗号分隔的列表

1085
00:53:07,690 --> 00:53:09,910
of the columns that you want to put data into.
您想要将数据放入的列。

1086
00:53:09,910 --> 00:53:11,890
In the second set of parentheses, you actually
在第二组括号中，您实际上

1087
00:53:11,890 --> 00:53:15,680
specify the values that you want to put into those columns.
指定您想要放入这些列的值。

1088
00:53:15,680 --> 00:53:18,350
So when I hit enter nothing seems to happen,
所以当我按回车键时，似乎没有任何反应，

1089
00:53:18,350 --> 00:53:20,510
which, in general, is a good thing at my terminal.
一般来说，这是我的终端上的一件好事。

1090
00:53:20,510 --> 00:53:25,030
But if I now rerun select star from favorites, we will see--
但如果我现在重新运行 select star from favorites，我们将看到——

1091
00:53:25,030 --> 00:53:27,070
voila, a brand new row.
瞧，一个全新的行。

1092
00:53:27,070 --> 00:53:29,320
We don't know what time or date it was inputted at.
我们不知道它是在什么时候输入的。

1093
00:53:29,320 --> 00:53:33,130
In fact, we see an old friend, null, which indicates the absence of a value,
事实上，我们看到了一个老朋友，null，它表示缺少一个值，

1094
00:53:33,130 --> 00:53:37,610
but we do indeed see that SQL, in Fiftyville, is actually now in there.
但我们确实看到了 SQL，在 Fiftyville 中，实际上现在已经存在了。

1095
00:53:37,610 --> 00:53:42,340
So in the world of SQL, null has nothing to do with pointers or addresses.
所以在 SQL 的世界里，null 与指针或地址无关。

1096
00:53:42,340 --> 00:53:46,120
The world of SQL, it's just using the same word to represent the same idea,
SQL 的世界，它只是用同一个词来表达同一个意思，

1097
00:53:46,120 --> 00:53:48,700
that there's no data here, but it has nothing
这里没有数据，但这与

1098
00:53:48,700 --> 00:53:51,080
to do with actual memory addresses in this case.
这种情况下的实际内存地址无关。

1099
00:53:51,080 --> 00:53:53,830
But suppose that you don't want to do that, and, like, no, no, no.
但假设你不想那样做，而且，就像，不，不，不。

1100
00:53:53,830 --> 00:53:54,640
Let's just delete that.
我们直接删除它。

1101
00:53:54,640 --> 00:53:56,348
Fiftyville hasn't even been released yet,
Fiftyville 还没有发布，

1102
00:53:56,348 --> 00:53:58,720
nor have we even finished talking about SQL.
我们甚至还没有说完关于 SQL 的内容。

1103
00:53:58,720 --> 00:54:02,110
How do we delete data from a database table?
我们如何从数据库表中删除数据？

1104
00:54:02,110 --> 00:54:03,670
Well, there's a delete from command.
好吧，有一个 delete from 命令。

1105
00:54:03,670 --> 00:54:05,360
Let me go back to VS Code here.
让我回到这里的 VS Code。

1106
00:54:05,360 --> 00:54:08,080
Let me go ahead and clear my terminal just to keep things clean.
让我继续清理我的终端，以保持干净。

1107
00:54:08,080 --> 00:54:10,570
Let me go ahead and delete from favorites,
让我继续执行 delete from favorites，

1108
00:54:10,570 --> 00:54:14,290
and let me not hit enter here after a semicolon.
而且让我在分号后不要按回车键。

1109
00:54:14,290 --> 00:54:16,330
This is one of the most destructive things
这是你能做出的最具破坏性的行为之一

1110
00:54:16,330 --> 00:54:19,570
you can do as a database administrator.
作为一名数据库管理员。

1111
00:54:19,570 --> 00:54:21,550
If you Google around, there are horror stories
如果你在谷歌上搜索，你会发现一些恐怖故事

1112
00:54:21,550 --> 00:54:25,750
of interns in the real world executing commands like this at their companies.
关于实习生在现实世界中在他们公司执行这样的命令。

1113
00:54:25,750 --> 00:54:28,510
This will delete everything from favorites.
这将从 favorites 中删除所有内容。

1114
00:54:28,510 --> 00:54:31,660
So if you ever do this, remember, we told you not to today.
所以如果你这样做，记住，我们今天告诉过你不要这样做。

1115
00:54:31,660 --> 00:54:38,530
But if we add a where clause here, only delete rows where the timestamp column
但如果我们在这里添加一个 where 子句，只删除时间戳列为

1116
00:54:38,530 --> 00:54:41,433
is null, this is more reasonable.
null 的行，这是更合理的。

1117
00:54:41,433 --> 00:54:43,600
And, frankly, any companies you work for should also
坦率地说，你为之工作的任何公司也应该

1118
00:54:43,600 --> 00:54:45,767
have backups of their database, so we shouldn't even
拥有他们数据库的备份，所以我们甚至不应该

1119
00:54:45,767 --> 00:54:48,680
be reading about these horror stories, but such is the real world.
阅读这些恐怖故事，但现实世界就是这样。

1120
00:54:48,680 --> 00:54:52,960
So this is going to delete any row from the favorites table
所以这将删除 favorites 表中任何

1121
00:54:52,960 --> 00:54:57,260
where Timestamp, capital T, because that's how Google did it, is null.
时间戳，大写 T，因为这是谷歌的做法，为 null 的行。

1122
00:54:57,260 --> 00:54:58,570
I go ahead and hit enter.
我继续按回车键。

1123
00:54:58,570 --> 00:55:03,880
Nothing seems to happen, but if I do select star from favorites semicolon
似乎没有任何反应，但如果我执行 select star from favorites 分号

1124
00:55:03,880 --> 00:55:06,550
that now row is, again, gone.
现在那行又不见了。

1125
00:55:06,550 --> 00:55:11,410
So you can use these predicates, these where conditions, coupled with select,
所以你可以使用这些谓词，这些 where 条件，与 select 结合使用，

1126
00:55:11,410 --> 00:55:14,740
coupled with delete, and other operations as well.
与 delete 结合使用，以及其他操作。

1127
00:55:14,740 --> 00:55:16,520
What if I actually want to make a change?
如果我实际上想做一些更改呢？

1128
00:55:16,520 --> 00:55:18,910
So if you want to update existing data like this.
所以如果你想更新像这样的现有数据。

1129
00:55:18,910 --> 00:55:20,540
Well, we could do this.
好吧，我们可以这样做。

1130
00:55:20,540 --> 00:55:25,300
I could update this table I could set one column equal to this value
我可以更新这个表格，我可以将一列设置为这个值

1131
00:55:25,300 --> 00:55:27,230
where some condition is true.
只要某个条件为真。

1132
00:55:27,230 --> 00:55:28,638
So how might this work?
那么，这将如何运作呢？

1133
00:55:28,638 --> 00:55:30,430
Well, let me boldly claim that a lot of you
好吧，我要大胆地说，你们很多

1134
00:55:30,430 --> 00:55:33,070
are really going to like Fiftyville in the world of SQL,
都会在 SQL 的世界里喜欢 Fiftyville，

1135
00:55:33,070 --> 00:55:35,860
so all of these favorites are sort of passe now.
所以所有这些收藏现在都过时了。

1136
00:55:35,860 --> 00:55:36,890
So let's do this.
所以让我们这样做。

1137
00:55:36,890 --> 00:55:39,950
Let me go ahead and update the favorites table,
让我继续更新收藏表，

1138
00:55:39,950 --> 00:55:43,150
setting the language column equal to "SQL," quote unquote.
将语言列设置为 "SQL"，引号内。

1139
00:55:43,150 --> 00:55:47,650
And with a comma let me go ahead and also update the problem column to be
用逗号，让我继续更新问题列，使其为

1140
00:55:47,650 --> 00:55:49,810
equal to, quote unquote, "Fiftyville."
等于，引号内，"Fiftyville"。

1141
00:55:49,810 --> 00:55:52,930
I'm not going to have any kind of where here, which means this
我不会在这里有任何种类的 where，这意味着这

1142
00:55:52,930 --> 00:55:56,030
is just going to do its thing on all of the rows.
只会在所有行上做它的事情。

1143
00:55:56,030 --> 00:55:58,270
So if I hit enter nothing seems to have happened,
所以我按下回车，似乎没有发生任何事，

1144
00:55:58,270 --> 00:56:00,850
but if I now do select star from favorites,
但我现在如果执行 select star from favorites，

1145
00:56:00,850 --> 00:56:04,160
everyone's favorite is literally that problem.
每个人的最爱都是那个问题。

1146
00:56:04,160 --> 00:56:07,690
So this too is destructive, unlike the real digital world,
所以，这同样是具有破坏性的，不像真实的数字世界，

1147
00:56:07,690 --> 00:56:10,120
there's no Control Z, or undo that.
没有 Control Z 或者撤销操作。

1148
00:56:10,120 --> 00:56:13,480
You better have made a backup of your database, otherwise
你最好已经备份了你的数据库，否则

1149
00:56:13,480 --> 00:56:15,460
that's not a good thing.
那就不妙了。

1150
00:56:15,460 --> 00:56:17,830
In this case, I do have this CSV file, so I could just
在这种情况下，我确实有这个 CSV 文件，所以我可以

1151
00:56:17,830 --> 00:56:19,703
delete my favorites.db file.
删除我的 favorites.db 文件。

1152
00:56:19,703 --> 00:56:22,870
I could re-import the data, so I haven't really lost anything of importance,
我可以重新导入数据，所以实际上并没有丢失任何重要东西，

1153
00:56:22,870 --> 00:56:26,140
but you could in the case of the real world and any data
但在现实世界中，对于任何你实际处理的数据

1154
00:56:26,140 --> 00:56:27,470
you're actually working on.
来说，你可能会遇到这种情况。

1155
00:56:27,470 --> 00:56:29,410
So just to make the point, let me go ahead
所以，为了说明这一点，让我继续

1156
00:56:29,410 --> 00:56:33,250
and delete from favorites semicolon, enter.
并执行 delete from favorites 分号，回车。

1157
00:56:33,250 --> 00:56:34,660
Let me reselect.
让我重新选择。

1158
00:56:34,660 --> 00:56:36,710
There's no data there anymore.
那里已经没有数据了。

1159
00:56:36,710 --> 00:56:42,890
And in fact, if I do select count star from favorites,
实际上，如果我执行 select count star from favorites，

1160
00:56:42,890 --> 00:56:45,220
we'll see as much that the answer is, in fact, zero
我们会看到答案确实是零

1161
00:56:45,220 --> 00:56:48,040
because everything has now been deleted.
因为现在所有东西都被删除了。

1162
00:56:48,040 --> 00:56:51,340
Any questions, then, on that code there?
那么，对那段代码有什么问题吗？

1163
00:56:51,340 --> 00:56:51,950
No?
没有？

1164
00:56:51,950 --> 00:56:52,450
All right.
好的。

1165
00:56:52,450 --> 00:56:55,533
So if not too scared yet, let's go ahead and take our 10-minute break now.
所以，如果你现在还没有害怕，让我们去休息十分钟吧。

1166
00:56:55,533 --> 00:56:59,110
Halloween candy is served, and we'll be back in 10.
万圣节糖果已经准备好了，我们十分钟后回来。

1167
00:56:59,110 --> 00:57:01,060
All right.
好的。

1168
00:57:01,060 --> 00:57:05,750
So we are back, and before we dive back into SQL and some real world data,
所以我们回来了，在我们深入研究 SQL 和一些真实数据之前，

1169
00:57:05,750 --> 00:57:10,300
it turns out, unbeknownst to me, we've had a Halloween costume contest.
事实证明，在我不知情的情况下，我们已经举办了万圣节服装比赛。

1170
00:57:10,300 --> 00:57:14,560
So it's now time to announce the winners of this year's CS50 costume contest.
现在是宣布今年 CS50 服装比赛获奖者的时候了。

1171
00:57:14,560 --> 00:57:17,530
If our two winners would like to come on up who,
如果两位获奖者愿意上台，他们

1172
00:57:17,530 --> 00:57:19,495
I'm told during break, dressed up as me.
我听说在休息期间，他们扮成了我。

1173
00:57:19,495 --> 00:57:22,265
[APPLAUSE]
[掌声]

1174
00:57:25,620 --> 00:57:26,460
Come on over.
过来吧。

1175
00:57:26,460 --> 00:57:28,085
Would you like to introduce yourselves?
你们想自我介绍一下吗？

1176
00:57:28,085 --> 00:57:31,240
SPEAKER 2: Yes Hi, everyone.
演讲者 2：是的，大家好。

1177
00:57:31,240 --> 00:57:32,100
I'm David.
我叫大卫。

1178
00:57:32,100 --> 00:57:34,380
I am living in Matthews as a first year.
我是一年级学生，住在马修斯。

1179
00:57:34,380 --> 00:57:38,700
I'm planning on studying gov and computer science.
我打算学习政府和计算机科学。

1180
00:57:38,700 --> 00:57:39,820
SPEAKER 3: Hi, everyone.
演讲者 3：大家好。

1181
00:57:39,820 --> 00:57:40,740
I'm David.
我叫大卫。

1182
00:57:40,740 --> 00:57:43,020
I'm a second year in Mather, and I'm planning
我是一年级的学生，住在马瑟，我打算

1183
00:57:43,020 --> 00:57:44,745
on just studying computer science.
只学习计算机科学。

1184
00:57:44,745 --> 00:57:45,480
[LAUGHING]
[笑声]

1185
00:57:45,480 --> 00:57:46,605
SPEAKER 1: Well, thank you.
演讲者 1：好的，谢谢。

1186
00:57:46,605 --> 00:57:50,190
We have some Oreos for you.
我们有一些奥利奥饼干给你们。

1187
00:57:50,190 --> 00:57:51,497
Thank you, both, so much.
谢谢你们两位，非常感谢。

1188
00:57:51,497 --> 00:57:52,830
Did anyone else dress like this?
还有其他人也这样打扮吗？

1189
00:57:52,830 --> 00:57:55,437
We have two more Oreos, if you'd like?
如果你们想要，我们还有两块奥利奥饼干。

1190
00:57:55,437 --> 00:57:56,020
Intentionally?
是故意的吗？

1191
00:57:56,020 --> 00:57:58,082
[LAUGHING]
[笑声]

1192
00:57:58,082 --> 00:57:59,040
Oh, that's pretty good.
哦，这真不错。

1193
00:57:59,040 --> 00:57:59,540
OK.
好的。

1194
00:57:59,540 --> 00:58:00,750
Yes, we have one more winner.
是的，我们还有一位获奖者。

1195
00:58:00,750 --> 00:58:01,515
Come on down.
下来吧。

1196
00:58:01,515 --> 00:58:03,810
[LAUGHS]
[笑声]

1197
00:58:09,580 --> 00:58:10,317
Thank you.
谢谢。

1198
00:58:10,317 --> 00:58:10,900
SPEAKER 4: Hi.
演讲者 4：嗨。

1199
00:58:10,900 --> 00:58:12,010
SPEAKER 1: This is intentional?
演讲者 1：这是故意的吗？

1200
00:58:12,010 --> 00:58:12,590
SPEAKER 4: No.
演讲者 4：不是。

1201
00:58:12,590 --> 00:58:13,340
SPEAKER 1: Oh, OK.
演讲者 1：哦，好的。

1202
00:58:13,340 --> 00:58:14,410
[LAUGHING]
[笑声]

1203
00:58:14,410 --> 00:58:16,150
SPEAKER 4: Hello, my name is David.
演讲者 4：你好，我叫大卫。

1204
00:58:16,150 --> 00:58:18,490
I'm from Canada, and I'm a first year.
我来自加拿大，是一年级学生。

1205
00:58:18,490 --> 00:58:20,200
I'm not sure what I'm going to study.
我不确定我要学习什么。

1206
00:58:20,200 --> 00:58:20,783
SPEAKER 1: OK.
演讲者 1：好的。

1207
00:58:20,783 --> 00:58:21,800
Welcome, as well.
也欢迎你。

1208
00:58:21,800 --> 00:58:22,675
SPEAKER 4: Thank you.
演讲者 4：谢谢。

1209
00:58:22,675 --> 00:58:23,560
SPEAKER 1: All right.
演讲者 1：好的。

1210
00:58:23,560 --> 00:58:26,270
[APPLAUSE]
[掌声]

1211
00:58:27,732 --> 00:58:29,690
Up until now, we've played around with the data
到目前为止，我们一直在玩弄数据

1212
00:58:29,690 --> 00:58:33,695
that you all gave us, which was based, very simply, on your favorite language
你们都提供给我们，它们非常简单，基于你们喜欢的语言

1213
00:58:33,695 --> 00:58:34,820
and your favorite problems.
以及你们喜欢的难题。

1214
00:58:34,820 --> 00:58:38,030
But it turns out there's a lot of real world data in, indeed,
但事实证明，在现实世界中，确实有很多真实数据，

1215
00:58:38,030 --> 00:58:40,880
the real world, some of which is quite voluminous.
其中一些非常庞大。

1216
00:58:40,880 --> 00:58:44,720
And, indeed, there can be not just dozens, or hundreds, but thousands,
实际上，可能不止几十个、几百个，而是几千个，

1217
00:58:44,720 --> 00:58:47,962
hundreds of thousands, even millions of rows in the biggest of databases.
几十万，甚至几百万行数据，存在于最大的数据库中。

1218
00:58:47,962 --> 00:58:50,420
And so what we thought we'd do in the latter part of today,
所以，我们今天在后半部分想做的就是

1219
00:58:50,420 --> 00:58:53,360
is really, actually, get our hands dirty with a real world
真正动手实践，使用真实世界中的

1220
00:58:53,360 --> 00:58:57,020
data set from the Internet Movie Database, otherwise known as IMDb.
来自互联网电影数据库的数据集，也称为 IMDb。

1221
00:58:57,020 --> 00:59:01,010
And, in fact, if you go to imdb.com, you'll be able to answer,
实际上，如果你访问 imdb.com，你将能够通过他们的网页界面，

1222
00:59:01,010 --> 00:59:03,650
via their web interface, some of the very questions we'll
回答我们今天将要使用 SQL 独自分析的一些问题。

1223
00:59:03,650 --> 00:59:05,720
do today using SQL alone.
使用 SQL 独自分析一些问题。

1224
00:59:05,720 --> 00:59:10,520
But what you'll find, ultimately, is that what websites like imdb.com,
但你最终会发现，像 imdb.com 这样的网站，

1225
00:59:10,520 --> 00:59:13,880
or their mobile app versions thereof, are probably doing
或者它们的移动应用程序版本，可能正在做的是

1226
00:59:13,880 --> 00:59:17,420
is-- yes, giving you a nice pretty graphical interface to type queries,
是的，为你提供一个漂亮美观的图形界面来输入查询，

1227
00:59:17,420 --> 00:59:22,760
but underneath the hood they are passing your input into SQL queries,
但在幕后，它们将你的输入传递到 SQL 查询中，

1228
00:59:22,760 --> 00:59:25,800
or similar queries, that they formed most of.
或者类似的查询，它们构成了大部分。

1229
00:59:25,800 --> 00:59:28,320
They're just waiting for placeholders, like the keywords,
它们只是在等待占位符，例如关键词，

1230
00:59:28,320 --> 00:59:30,160
that you're actually searching for.
你实际上要搜索的内容。

1231
00:59:30,160 --> 00:59:33,420
So let's go ahead and experiment, maybe, with just some real-world data,
所以让我们先尝试一下，也许用一些真实世界的数据，

1232
00:59:33,420 --> 00:59:36,725
initially, before we consider how to actually store it at scale.
在考虑如何大规模存储之前。

1233
00:59:36,725 --> 00:59:38,850
So let me open up, just for the sake of discussion,
为了讨论起见，让我打开

1234
00:59:38,850 --> 00:59:41,190
an actual, empty spreadsheet, just so I have
一个实际的空电子表格，这样我就可以

1235
00:59:41,190 --> 00:59:43,650
some rows and columns to play with.
有一些行和列来玩。

1236
00:59:43,650 --> 00:59:47,790
And let me propose that we want to model TV shows from the real world.
我想建议我们想用真实世界的数据建模电视剧。

1237
00:59:47,790 --> 00:59:49,420
How can we go about doing this?
我们该如何做呢？

1238
00:59:49,420 --> 00:59:53,020
Well, maybe I could start in this first column A, so to speak,
好吧，也许我可以从第一列A开始，

1239
00:59:53,020 --> 00:59:54,600
and I could create a title column.
然后我可以创建一个标题列。

1240
00:59:54,600 --> 00:59:57,660
And then, maybe, a column for the star of that show.
然后，也许可以创建一个该剧主演的列。

1241
00:59:57,660 --> 01:00:00,060
And a very popular show, of course, is The Office.
当然，一个非常受欢迎的节目是《办公室》。

1242
01:00:00,060 --> 01:00:03,900
So I might put this into the second cell in that first column.
所以我可以把它放到第一列的第二个单元格里。

1243
01:00:03,900 --> 01:00:06,870
And under star, I could put someone like Steve Carell.
在主演下面，我可以放像史蒂夫·卡瑞尔这样的人。

1244
01:00:06,870 --> 01:00:10,200
But, of course, he wasn't the only star of the show.
当然，他不是唯一的主演。

1245
01:00:10,200 --> 01:00:11,740
There are others as well.
还有其他演员。

1246
01:00:11,740 --> 01:00:14,370
And so if I want to put in someone like Rainn Wilson,
所以如果我想放像 Rainn Wilson 这样的人，

1247
01:00:14,370 --> 01:00:16,210
well, maybe, I need a second star column.
好吧，也许我需要第二列主演。

1248
01:00:16,210 --> 01:00:17,640
So Rainn Wilson.
所以是 Rainn Wilson。

1249
01:00:17,640 --> 01:00:20,010
But even as early as the first season, there
但即使是在第一季的早期，也

1250
01:00:20,010 --> 01:00:24,420
was also another star in the credits, John Krasinski.
在片尾字幕中还有一个主演，John Krasinski。

1251
01:00:24,420 --> 01:00:25,440
So he was a star.
所以他也是一个主演。

1252
01:00:25,440 --> 01:00:29,280
Jenna Fischer was top credited in the first season.
Jenna Fischer 在第一季的片尾字幕中排名靠前。

1253
01:00:29,280 --> 01:00:30,990
So Jenna Fischer.
所以是 Jenna Fischer。

1254
01:00:30,990 --> 01:00:37,020
And then BJ Novak, Harvard alum, was also in the first season's opening
然后是哈佛校友 BJ Novak，也在第一季的开场

1255
01:00:37,020 --> 01:00:37,870
credits, as well.
片尾字幕中。

1256
01:00:37,870 --> 01:00:39,360
So we've got all--
所以我们有所有这些——

1257
01:00:39,360 --> 01:00:41,170
one, two, three, four, five of these folks.
这五个人。

1258
01:00:41,170 --> 01:00:42,630
Hopefully, I didn't misspell anyone's name,
希望我没有拼错任何人的名字，

1259
01:00:42,630 --> 01:00:45,030
but here's the beginnings of a real-world data set.
但这是一个真实世界的数据集的开端。

1260
01:00:45,030 --> 01:00:47,970
And we could imagine doing this for everyone's favorite shows,
我们可以想象对每个人最喜欢的节目都这样做，

1261
01:00:47,970 --> 01:00:49,630
adding more, and more rows.
不断添加更多的行。

1262
01:00:49,630 --> 01:00:52,650
But let's consider, as we often do, not just the correctness
但让我们考虑一下，就像我们经常做的那样，不仅要考虑

1263
01:00:52,650 --> 01:00:56,220
of this implementation, but the design.
这个实现的正确性，还要考虑设计。

1264
01:00:56,220 --> 01:00:57,990
It's pretty straightforward.
它很简单。

1265
01:00:57,990 --> 01:00:58,972
It's very readable.
它也很容易阅读。

1266
01:00:58,972 --> 01:01:00,430
So I think it's good in that sense.
所以我认为从这个意义上来说它很好。

1267
01:01:00,430 --> 01:01:03,510
But if you start to nitpick what's poorly designed,
但如果你开始挑剔设计不好的地方，

1268
01:01:03,510 --> 01:01:06,240
even in the world of spreadsheets, about what I've done here--
即使是在电子表格的世界里，关于我在这里所做的——

1269
01:01:06,240 --> 01:01:08,610
assuming that the next row is another show,
假设下一行是另一个节目，

1270
01:01:08,610 --> 01:01:12,110
the next row is another show, and so forth.
下一行是另一个节目，依此类推。

1271
01:01:12,110 --> 01:01:13,280
What's bad about this?
这里有什么不好吗？

1272
01:01:13,280 --> 01:01:13,780
Yeah?
是吗？

1273
01:01:13,780 --> 01:01:15,272
[INDISTINCT SPEECH]
[模糊不清的语音]

1274
01:01:15,272 --> 01:01:17,980
Yeah, so each row is going to have a different number of columns,
是的，所以每一行将有不同数量的列，

1275
01:01:17,980 --> 01:01:20,440
and even I, kind of, couldn't make up my mind from the get go.
甚至我一开始也拿不定主意。

1276
01:01:20,440 --> 01:01:22,000
Like, do I have just one star column?
比如，我只有一列主演吗？

1277
01:01:22,000 --> 01:01:22,500
Or two?
还是两列？

1278
01:01:22,500 --> 01:01:23,792
Or maybe now I'm up to 5?
或者现在我增加到 5 列？

1279
01:01:23,792 --> 01:01:25,750
For even bigger shows, and later in The Office,
对于更大规模的节目，以及在《办公室》的后期，

1280
01:01:25,750 --> 01:01:27,625
when more people got top billing, we're going
当更多的人获得了最高排名的角色时，我们将

1281
01:01:27,625 --> 01:01:29,770
to need more than five columns for stars.
需要超过五列的主演。

1282
01:01:29,770 --> 01:01:31,060
So that's fine.
所以这没问题。

1283
01:01:31,060 --> 01:01:34,682
We can clearly scroll to the right, and just keep adding more columns,
我们可以很清楚地向右滚动，并不断添加更多列，

1284
01:01:34,682 --> 01:01:36,640
but there should be something about that design
但是这个设计应该存在一些问题

1285
01:01:36,640 --> 01:01:38,890
that like rubs you the wrong way, like something
让你感觉不舒服，就像有什么东西

1286
01:01:38,890 --> 01:01:41,620
feels a little off if some rows have this many columns,
如果一些行有这么多列，感觉有点不对劲，

1287
01:01:41,620 --> 01:01:42,700
others have this many.
而其他的行又只有这么少。

1288
01:01:42,700 --> 01:01:45,520
The data would be very jagged along the right hand side.
数据在右侧会非常参差不齐。

1289
01:01:45,520 --> 01:01:48,320
It would be very sparse, which would be another way to describe it.
它会非常稀疏，这将是另一种描述方式。

1290
01:01:48,320 --> 01:01:50,000
There's probably a better way.
可能还有更好的方法。

1291
01:01:50,000 --> 01:01:53,440
So maybe I should flip the data around, and maybe
所以也许我应该翻转数据，也许

1292
01:01:53,440 --> 01:01:57,520
a better approach here would be to just have one column for stars.
这里更好的方法是只用一列来表示主演。

1293
01:01:57,520 --> 01:01:59,870
So let me do this.
所以让我这样做。

1294
01:01:59,870 --> 01:02:04,180
Let me just move Rainn Wilson over here, and John Krasinski over here,
让我把 Rainn Wilson 移到这里，把 John Krasinski 移到这里，

1295
01:02:04,180 --> 01:02:09,980
and Jenna Fischer over here, and BJ Novak over here, as well.
把 Jenna Fischer 移到这里，把 BJ Novak 移到这里。

1296
01:02:09,980 --> 01:02:13,850
I'll get rid of all of these superfluous, identically named columns.
我要删除所有这些多余的，名称相同的列。

1297
01:02:13,850 --> 01:02:17,840
And now this is sort of better because now I can have any number of stars
现在这样好多了，因为现在我可以有任意数量的主演

1298
01:02:17,840 --> 01:02:21,330
in the vertical, although it's a little weird to leave this blank.
在纵向，虽然留空有点奇怪。

1299
01:02:21,330 --> 01:02:23,850
So maybe I should of copy paste here.
所以也许我应该在这里复制粘贴。

1300
01:02:23,850 --> 01:02:27,920
So in some sense this is better, in that now I only
所以从某种意义上说，这更好，因为现在我只有

1301
01:02:27,920 --> 01:02:30,860
have one title column, one star column, and I can just
一列标题，一列主演，我可以只

1302
01:02:30,860 --> 01:02:34,790
keep adding row, row, row, for each show and its stars.
为每个节目及其主演不断添加行。

1303
01:02:34,790 --> 01:02:37,840
But what's now poorly designed about this?
但是现在这个设计有什么不好呢？

1304
01:02:37,840 --> 01:02:38,340
Yeah?
是吗？

1305
01:02:38,340 --> 01:02:39,970
[INDISTINCT SPEECH]
[模糊不清的语音]

1306
01:02:39,970 --> 01:02:40,470
Yeah.
是的。

1307
01:02:40,470 --> 01:02:41,580
I'm repeating the title.
我在重复标题。

1308
01:02:41,580 --> 01:02:44,220
And, in general, copy, paste, repeating yourself in code
一般来说，在代码中复制粘贴，重复自己

1309
01:02:44,220 --> 01:02:46,090
has generally been a bad thing.
通常不是一件好事。

1310
01:02:46,090 --> 01:02:49,110
It's generally gotten us in trouble if I make a change, or maybe
如果我进行更改，或者可能

1311
01:02:49,110 --> 01:02:50,550
a typographical error somewhere.
在某个地方出现打字错误。

1312
01:02:50,550 --> 01:02:52,050
Maybe it propagates elsewhere.
也许它会传播到其他地方。

1313
01:02:52,050 --> 01:02:54,450
And if nothing else, it's just a lot of wasted space.
除此之外，它只是浪费了很多空间。

1314
01:02:54,450 --> 01:02:57,300
If this is actually going to be stored in a database, in a CSV file,
如果这实际上要存储在数据库中，在 CSV 文件中，

1315
01:02:57,300 --> 01:03:00,300
why are you duplicating the same string again, and again, and again,
为什么要重复同一个字符串，一遍又一遍，

1316
01:03:00,300 --> 01:03:01,440
for large TV shows?
对于大型电视剧？

1317
01:03:01,440 --> 01:03:02,370
That's just wasteful.
这太浪费了。

1318
01:03:02,370 --> 01:03:04,780
It just doesn't seem wise.
这似乎并不明智。

1319
01:03:04,780 --> 01:03:06,970
So how can we eliminate that redundancy?
我们如何消除这种冗余呢？

1320
01:03:06,970 --> 01:03:10,260
Well, unfortunately, in the world of spreadsheets, things kind of now
不幸的是，在电子表格的世界里，事情现在

1321
01:03:10,260 --> 01:03:13,080
escalate quickly to be kind of annoying.
很快就会变得让人很烦。

1322
01:03:13,080 --> 01:03:16,150
But let me do it, nonetheless, with just a small bit of data.
但我还是要这样做，尽管只有一小部分数据。

1323
01:03:16,150 --> 01:03:18,250
Let me propose that we do this instead.
我想建议我们这样做。

1324
01:03:18,250 --> 01:03:21,977
Let me create not one sheet but maybe multiple sheets,
让我创建不只是一个工作表，而是多个工作表，

1325
01:03:21,977 --> 01:03:24,060
and assume that there's some kind of relationship,
并假设这些工作表之间存在某种关系，

1326
01:03:24,060 --> 01:03:25,680
or relation, across these sheets.
或者关系。

1327
01:03:25,680 --> 01:03:29,100
So, just to be pedantic, let me call this sheet, not the default sheet one,
所以，为了严谨，我将这个工作表称为，不是默认的工作表 1，

1328
01:03:29,100 --> 01:03:30,360
but let's call this shows.
而是把它叫做 shows。

1329
01:03:30,360 --> 01:03:34,750
And in this sheet, I'm going to have a title column for every show,
在这个工作表中，我将为每个节目创建一个标题列，

1330
01:03:34,750 --> 01:03:36,990
and I think I'm going to be proactive here.
我认为我应该主动点。

1331
01:03:36,990 --> 01:03:41,200
I'm going to start giving every show a unique ID number, much like Harvard
我要开始给每个节目一个唯一的 ID 号码，就像哈佛大学一样

1332
01:03:41,200 --> 01:03:43,150
affiliates have Harvard IDs, Yale affiliates
的附属机构拥有哈佛 ID，耶鲁附属机构

1333
01:03:43,150 --> 01:03:44,900
have Yale ID numbers, and so forth.
拥有耶鲁 ID 号码，等等。

1334
01:03:44,900 --> 01:03:48,280
Let's go ahead and give each show its own unique identifier,
让我们继续给每个节目一个唯一的标识符，

1335
01:03:48,280 --> 01:03:49,940
for reasons we'll soon see.
原因我们很快就会看到。

1336
01:03:49,940 --> 01:03:53,110
So for The Office let me, just for consistency
所以对于《办公室》，为了保持一致性

1337
01:03:53,110 --> 01:03:55,030
with the actual Internet Movie Database, I'm
与实际的互联网电影数据库，我

1338
01:03:55,030 --> 01:03:58,488
going to give it a unique number of 386676.
将给它一个唯一的数字 386676。

1339
01:03:58,488 --> 01:04:00,280
The specifics don't really matter, but that
具体的细节并不重要，但是那

1340
01:04:00,280 --> 01:04:03,010
happens to be what people in the real world actually do.
恰好是现实世界中人们实际做的事情。

1341
01:04:03,010 --> 01:04:05,950
But that's it for TV shows, even though I could imagine
但这就是关于电视节目的全部了，尽管我可以想象

1342
01:04:05,950 --> 01:04:07,490
there being many more in this sheet.
还有更多节目在这张表上。

1343
01:04:07,490 --> 01:04:10,840
Let me create another sheet now here, and I'll call it people.
现在让我在这里创建一个新的表格，我把它叫做“人物”。

1344
01:04:10,840 --> 01:04:15,490
And in the people sheet, let me keep track of all of those TV stars.
在“人物”表格中，让我记录下所有这些电视明星。

1345
01:04:15,490 --> 01:04:20,500
So one column will be name, another will be also called ID here,
所以一列将是姓名，另一列也将被称为 ID，

1346
01:04:20,500 --> 01:04:25,070
but it's going to be a person ID, not a show ID.
但它将是人物 ID，而不是节目 ID。

1347
01:04:25,070 --> 01:04:27,610
And here we have, for instance, Steve Carell.
例如，这里有史蒂夫·卡瑞尔。

1348
01:04:27,610 --> 01:04:29,570
We have Rainn Wilson.
还有雷恩·威尔逊。

1349
01:04:29,570 --> 01:04:31,870
We have John Krasinski.
还有约翰·卡拉辛斯基。

1350
01:04:31,870 --> 01:04:34,300
We have Jenna Fischer.
还有珍娜·费舍尔。

1351
01:04:34,300 --> 01:04:36,670
And we have BJ Novak.
还有 B.J.诺瓦克。

1352
01:04:36,670 --> 01:04:38,600
And, this is going to be a little tedious,
而且，这会有点繁琐，

1353
01:04:38,600 --> 01:04:41,070
but just to be consistent with reality, turns out
但为了与现实保持一致，事实证明

1354
01:04:41,070 --> 01:04:46,230
that according to IMDb Steve Carell's unique number in the world is 136797,
根据 IMDb，史蒂夫·卡瑞尔在世界上的唯一号码是 136797，

1355
01:04:46,230 --> 01:04:56,640
Rainn's is 933988, John's is 1024677, Jenna's is 278979,
雷恩的是 933988，约翰的是 1024677，珍娜的是 278979，

1356
01:04:56,640 --> 01:05:01,814
and, lastly, BJ Novak's is 1145983.
最后，B.J.诺瓦克的是 1145983。

1357
01:05:01,814 --> 01:05:02,650
Phew.
呼。

1358
01:05:02,650 --> 01:05:03,150
OK.
好的。

1359
01:05:03,150 --> 01:05:06,360
So now we have the same people, but they each have a unique ID number.
所以现在我们有相同的人，但他们每个人都有一个唯一的 ID 号码。

1360
01:05:06,360 --> 01:05:10,590
Lastly, let's associate those shows with those people in a way that
最后，让我们将这些节目与这些人联系起来，以一种

1361
01:05:10,590 --> 01:05:13,320
avoids the two problems we identified earlier, which
避免了我们之前提到的两个问题，即

1362
01:05:13,320 --> 01:05:16,650
was having a variable number of columns in one case
一个情况是拥有可变数量的列

1363
01:05:16,650 --> 01:05:18,960
versus redundancy in the second case.
与第二个情况中的冗余。

1364
01:05:18,960 --> 01:05:22,710
Let's really tighten things up so nothing is in duplicate
让我们真正地整理一下，这样就不会有重复

1365
01:05:22,710 --> 01:05:24,880
that doesn't actually need to be.
那些实际上不需要的。

1366
01:05:24,880 --> 01:05:28,890
So I'm going to create a third sheet here, and I'll call it stars,
所以我要在这里创建一个第三个表格，我把它叫做“明星”，

1367
01:05:28,890 --> 01:05:31,770
like the TV stars for these shows, and what I'm going to do
就像这些节目的电视明星一样，我要做的是

1368
01:05:31,770 --> 01:05:36,292
is have only two columns, a show ID, and a person ID.
只有两列，节目 ID 和人物 ID。

1369
01:05:36,292 --> 01:05:38,250
I could write these in different ways, but it's
我可以用不同的方式写这些，但这

1370
01:05:38,250 --> 01:05:41,740
conventional in the database world to use snake case, so to speak,
在数据库世界中，通常使用蛇形命名法，可以这么说，

1371
01:05:41,740 --> 01:05:46,150
where everything is lowercase, with underscores instead of spaces.
所有内容都小写，使用下划线代替空格。

1372
01:05:46,150 --> 01:05:49,390
And for show ID-- well, we're only mocking up one show for now,
对于节目 ID，现在我们只模拟一个节目，

1373
01:05:49,390 --> 01:05:54,100
but I'm going to go ahead and say 386676, which is The Office, I claimed.
但我会说 386676，也就是我之前说的《办公室》。

1374
01:05:54,100 --> 01:05:57,160
And now I'm going to go ahead and have all of those person IDs,
现在我要继续使用所有这些人物 ID，

1375
01:05:57,160 --> 01:06:00,230
and this time it's OK to copy paste, if only to save time.
这次可以复制粘贴，只是为了节省时间。

1376
01:06:00,230 --> 01:06:04,540
So I'm going to grab all of these five stars IDs, paste them there,
所以我将获取所有这五个明星 ID，并将它们粘贴到那里，

1377
01:06:04,540 --> 01:06:08,840
and I am going to indulge by duplicating the show ID,
我将纵容自己，复制节目 ID，

1378
01:06:08,840 --> 01:06:10,580
even though we didn't like that earlier.
尽管我们之前不喜欢这样。

1379
01:06:10,580 --> 01:06:14,380
Now this indeed has escalated quickly because none of these sheets
现在确实已经迅速升级，因为这些表格中的任何一个

1380
01:06:14,380 --> 01:06:17,590
are very useful to look at to the human eye because none of them
对人类眼睛来说都没有用，因为它们中的任何一个

1381
01:06:17,590 --> 01:06:18,910
has the complete picture.
都没有完整的画面。

1382
01:06:18,910 --> 01:06:22,600
We have shows in one, people in another, and then like this cryptic mapping
我们在一个表格里有节目，另一个表格里有人物，然后像这样神秘的映射

1383
01:06:22,600 --> 01:06:24,250
of numbers in the third.
数字在第三个表格里。

1384
01:06:24,250 --> 01:06:29,200
But I propose that this is the right way to implement data
但我认为这是实现数据的正确方法

1385
01:06:29,200 --> 01:06:32,530
if your goal is to have a canonical source of truth
如果你目标是要有一个关于每个节目和每个人的权威的真实来源

1386
01:06:32,530 --> 01:06:34,060
for every show and every person.
对于每个节目和每个人。

1387
01:06:34,060 --> 01:06:37,990
That is to say, you only say the show's name once in one place.
也就是说，你只在一个地方说一次节目的名字。

1388
01:06:37,990 --> 01:06:43,030
You only write the TV star's names once in one place.
你只在一个地方写一次电视明星的名字。

1389
01:06:43,030 --> 01:06:46,330
And you associate them, you relate one with the other,
你将它们关联起来，你将其中一个与另一个联系起来，

1390
01:06:46,330 --> 01:06:48,710
by way of this third sheet here.
通过这里第三个表格。

1391
01:06:48,710 --> 01:06:52,270
So if you've not seen it already, notice that if The Office has
所以，如果你还没有看到，请注意，如果《办公室》有

1392
01:06:52,270 --> 01:06:56,800
this unique ID, 386676, notice in the stars table,
这个唯一的 ID，386676，请注意在“明星”表格中，

1393
01:06:56,800 --> 01:06:59,620
that same value appears multiple times.
相同的数值出现了多次。

1394
01:06:59,620 --> 01:07:04,810
But what this third sheet is doing is associating that same show ID
但这个第三个表格的作用是将相同的节目 ID

1395
01:07:04,810 --> 01:07:08,510
with one, two, three, four, five different people.
与一、二、三、四、五个不同的人联系起来。

1396
01:07:08,510 --> 01:07:11,860
Now I can see that it's similar in spirit to what we already
现在我可以看到，它在精神上与我们之前

1397
01:07:11,860 --> 01:07:13,780
indicted as bad design a moment ago.
指责为糟糕的设计有点相似。

1398
01:07:13,780 --> 01:07:15,460
The Office, The Office, The Office.
《办公室》、《办公室》、《办公室》。

1399
01:07:15,460 --> 01:07:18,970
But think about our world of C. In the world of C, and really computers
但想想我们的 C 语言世界。在 C 语言世界，实际上是计算机

1400
01:07:18,970 --> 01:07:22,180
in general, data takes up finite amount of space, typically.
一般来说，数据通常占用有限的空间。

1401
01:07:22,180 --> 01:07:24,470
Like an integer is four bytes, 32 bits.
例如，一个整数是四个字节，32 位。

1402
01:07:24,470 --> 01:07:27,070
So even though, yes, I'm duplicating this value,
所以，即使，是的，我复制了这个值，

1403
01:07:27,070 --> 01:07:30,460
it's just the same four bytes, four bytes, four bytes.
它只是相同的四个字节，四个字节，四个字节。

1404
01:07:30,460 --> 01:07:36,340
It's not t-h-e space o-f-f-i-c-e, null character.
它不是 t-h-e space o-f-f-i-c-e，空字符。

1405
01:07:36,340 --> 01:07:38,755
It's not the same 11 bytes again, and again.
它不是相同 11 个字节再次重复。

1406
01:07:38,755 --> 01:07:41,380
It's just a number, and numbers tend to be much more efficient.
它只是一个数字，而数字往往更高效。

1407
01:07:41,380 --> 01:07:43,660
That computers can crunch numbers much more quickly.
计算机可以更快地处理数字。

1408
01:07:43,660 --> 01:07:47,920
Duplicating numbers is in general allowed, or smiled upon.
复制数字一般是允许的，或者说是被接受的。

1409
01:07:47,920 --> 01:07:50,660
Duplicating strings will get you into trouble.
复制字符串会让你陷入麻烦。

1410
01:07:50,660 --> 01:07:54,212
So with that said, is this a useful spreadsheet now?
综上所述，现在这算是一个有用的电子表格吗？

1411
01:07:54,212 --> 01:07:56,920
Would you want to be handed this in your job and asked questions?
你是否希望在你的工作中被递交这份表格，并被问问题？

1412
01:07:56,920 --> 01:07:59,020
Like, hey, who stars in The Office?
比如，嘿，谁主演了《办公室》？

1413
01:07:59,020 --> 01:08:01,390
You can answer it, but you have to look up one sheet,
你可以回答，但你必须查看一个表格，

1414
01:08:01,390 --> 01:08:02,950
then another, then a third.
然后另一个，然后第三个。

1415
01:08:02,950 --> 01:08:06,490
Or you need to use VLOOKUP, or special functions in Excel, or Google Sheets.
或者你需要使用 VLOOKUP，或者 Excel 或 Google 表格中的特殊函数。

1416
01:08:06,490 --> 01:08:08,823
I mean, you're just creating a lot of work for yourself.
我的意思是，你只是为自己创造了大量工作。

1417
01:08:08,823 --> 01:08:12,340
But, academically, if you will, systematically, this
但，从学术的角度来说，如果可以这么说，系统地，这

1418
01:08:12,340 --> 01:08:15,640
has a lot of merit because we've avoided all duplication.
有很多优点，因为我们避免了所有重复。

1419
01:08:15,640 --> 01:08:20,800
We've normalized the data, so to speak, by factoring out any duplication.
可以这么说，我们通过消除任何重复来规范化了数据。

1420
01:08:20,800 --> 01:08:22,700
So where are we going with this?
那么，我们该怎么继续呢？

1421
01:08:22,700 --> 01:08:25,720
Well, it turns out that we'll play now with some actual data
好吧，事实证明，我们现在将使用一些实际数据。

1422
01:08:25,720 --> 01:08:28,481
from the real world from the actual Internet Movie database.
从真实世界，从真实的互联网电影数据库中获取数据。

1423
01:08:28,481 --> 01:08:31,189
And in a moment, it's going to look a little something like this.
很快，它看起来会像这样。

1424
01:08:31,189 --> 01:08:34,689
This is an artist's rendition of five different-- sorry,
这是一张艺术家对五种不同的……抱歉，

1425
01:08:34,689 --> 01:08:36,800
six different tables.
六种不同的表格的描绘。

1426
01:08:36,800 --> 01:08:39,430
So not one, but six different tables that we
所以，不是一个，而是六个不同的表格，我们

1427
01:08:39,430 --> 01:08:43,479
created using freely available Internet Movie Database data.
使用免费的互联网电影数据库数据创建了这些表格。

1428
01:08:43,479 --> 01:08:47,904
They kindly provide, not CSVs, but TSVs, tab separated values,
它们很慷慨地提供了，不是 CSVs，而是 TSVs，即制表符分隔值，

1429
01:08:47,904 --> 01:08:49,779
which are essentially the same thing, but you
它们本质上是一样的，但你

1430
01:08:49,779 --> 01:08:51,729
look for tab characters instead of commas
需要查找制表符而不是逗号

1431
01:08:51,729 --> 01:08:55,120
in order to convert them, as we did, into our own format,
以便将它们转换为我们自己的格式，就像我们所做的那样，

1432
01:08:55,120 --> 01:08:56,800
SQLite in this case.
在本例中，为 SQLite 格式。

1433
01:08:56,800 --> 01:08:59,404
But we'll see that there is a file that we've
但我们会看到，我们已经

1434
01:08:59,404 --> 01:09:02,529
made available from today, which you can download off the course's website,
从今天起，可以在课程网站上下载的文件，

1435
01:09:02,529 --> 01:09:07,149
called shows.db, and it contains all of this same information.
名为 shows.db，它包含所有这些相同的信息。

1436
01:09:07,149 --> 01:09:10,660
And in that shows.db file there are indeed these six tables,
在 shows.db 文件中确实有这六个表格，

1437
01:09:10,660 --> 01:09:13,180
but let's focus on just two of them initially.
但让我们先关注其中两个。

1438
01:09:13,180 --> 01:09:16,038
IMDb, the Internet Movie Database, is all about rating TV shows,
IMDb，互联网电影数据库，主要是关于对电视剧进行评分，

1439
01:09:16,038 --> 01:09:18,580
and tracking that kind of information, so let's actually take
以及追踪这些信息，所以我们实际上要

1440
01:09:18,580 --> 01:09:20,497
a look at some of these ratings and figure out
看一下这些评分，并弄清楚

1441
01:09:20,497 --> 01:09:22,970
how we can actually answer actual questions.
我们如何才能真正回答实际问题。

1442
01:09:22,970 --> 01:09:24,760
So let me go over to VS Code.
所以，让我切换到 VS Code。

1443
01:09:24,760 --> 01:09:29,750
And let me run SQLite of shows.db, which is a file that already exists.
让我运行 shows.db 的 SQLite，这是一个已经存在的文件。

1444
01:09:29,750 --> 01:09:33,010
There's no CSVs, no TSVs, we did all of this for you already.
没有 CSVs，没有 TSVs，我们已经为你做好了这一切。

1445
01:09:33,010 --> 01:09:34,932
When I hit enter, I get my SQLite prompt.
当我按下回车键时，我得到了我的 SQLite 提示符。

1446
01:09:34,932 --> 01:09:36,640
And the first thing I like to do whenever
当我第一次使用 SQL 数据库时，我总是喜欢做的第一件事是……

1447
01:09:36,640 --> 01:09:39,189
I'm playing with a SQL database for the first time-- maybe
第一次接触 SQL 数据库——也许是

1448
01:09:39,189 --> 01:09:41,410
I got it from a class, or my boss, or the like--
从课堂上得到，或者从我的老板那里得到，或者类似的——

1449
01:09:41,410 --> 01:09:44,979
is just to wrap my mind around what's inside of the database
就是想一下数据库里面是什么

1450
01:09:44,979 --> 01:09:48,069
because you're not typically going to be provided with pictures like this.
因为你通常不会得到像这样的图片。

1451
01:09:48,069 --> 01:09:49,729
You're just going to be given a file.
你只会得到一个文件。

1452
01:09:49,729 --> 01:09:51,220
So let me just select some data.
所以，让我选择一些数据。

1453
01:09:51,220 --> 01:09:54,468
Let me select star from the shows table.
让我从 shows 表中选择星号。

1454
01:09:54,468 --> 01:09:57,010
I don't really want to see all of it, so let me just limit it
我不想看到所有内容，所以让我只限制它

1455
01:09:57,010 --> 01:09:59,390
to the first 10 shows in the table.
到表格中的前 10 个节目。

1456
01:09:59,390 --> 01:10:03,310
And here, we can infer what the shows table looks like.
从这里，我们可以推断出 shows 表格的样子。

1457
01:10:03,310 --> 01:10:07,270
Every show has an ID, a title, the year in which it debuted, apparently,
每个节目都有一个 ID，一个标题，以及它首映的年份，显然，

1458
01:10:07,270 --> 01:10:11,320
and the number of episodes as of last night when we exported the data.
以及昨晚我们导出数据时该剧集的集数。

1459
01:10:11,320 --> 01:10:15,010
So that seems to reflect this picture, and this is technically
所以，这似乎反映了这张图片，从技术上来说，这是

1460
01:10:15,010 --> 01:10:19,000
an entity relationship diagram, a standard way of depicting things.
实体关系图，一种描绘事物的标准方式。

1461
01:10:19,000 --> 01:10:21,670
And you'll see that in our picture shows, indeed,
你会发现，在我们图片中的 shows 中，确实

1462
01:10:21,670 --> 01:10:25,480
have an ID column, title column, year column, and episodes column.
拥有一个 ID 列、一个标题列、一个年份列和一个集数列。

1463
01:10:25,480 --> 01:10:26,840
Well what about these ratings?
那么这些评分呢？

1464
01:10:26,840 --> 01:10:29,650
Well, according to the picture, that has a show ID, a rating,
根据这张图片，它拥有一个节目 ID，一个评分，

1465
01:10:29,650 --> 01:10:30,830
and a votes column.
以及一个投票列。

1466
01:10:30,830 --> 01:10:34,690
So let's go back to VS Code here, and let's do select star
所以，让我们回到 VS Code 这里，让我们执行 select star

1467
01:10:34,690 --> 01:10:39,670
from ratings, limit 10, just to wrap our mind around some of the data.
从 ratings 表中选择，限制为 10 行，只是为了让我们更好地理解一些数据。

1468
01:10:39,670 --> 01:10:42,100
And there we have a show ID in the left, we
左边是节目 ID，我们

1469
01:10:42,100 --> 01:10:45,170
have rating in the middle, which seems to be like a floating point value,
中间是评分，它看起来像一个浮点值，

1470
01:10:45,170 --> 01:10:46,940
and then votes, which seems to be an integer.
然后是投票，它看起来像一个整数。

1471
01:10:46,940 --> 01:10:48,815
So we have some different types of data here.
所以，这里有一些不同类型的数据。

1472
01:10:48,815 --> 01:10:50,270
But there's a lot of data.
但是数据量很多。

1473
01:10:50,270 --> 01:10:51,610
In fact, if I do this now.
事实上，如果我现在这样做。

1474
01:10:51,610 --> 01:10:55,180
Select star from shows--
从 shows 表格中选择星号——

1475
01:10:55,180 --> 01:10:56,630
let's not select all of the data.
让我们不要选择所有数据。

1476
01:10:56,630 --> 01:11:00,670
Let's do select count stars from shows, and in this database
让我们执行 select count stars from shows，在这个数据库中

1477
01:11:00,670 --> 01:11:04,640
there are 214,000 shows in this database.
有 214,000 个节目。

1478
01:11:04,640 --> 01:11:08,780
So we're well past the 398 rows that we've been talking about thus far.
所以我们已经远远超过了我们之前一直在谈论的 398 行。

1479
01:11:08,780 --> 01:11:12,010
So it turns out, per this diagram, there's actually
所以事实证明，根据这个图表，实际上

1480
01:11:12,010 --> 01:11:16,360
a standard relationship between these two tables, shows and ratings
这两个表格之间存在一种标准关系，分别是 shows 和 ratings

1481
01:11:16,360 --> 01:11:18,880
respectively, and it's what we would call a one-to-one one
它们之间的关系是所谓的“一对一”关系

1482
01:11:18,880 --> 01:11:23,430
relationship whereby every show in this design has one rating.
也就是说，在这个设计中，每个节目都有一个评分。

1483
01:11:23,430 --> 01:11:25,180
And this is indicated, technically, if you
从技术上来说，这体现在，如果你

1484
01:11:25,180 --> 01:11:27,755
look at what the arrowheads look like on these diagrams.
看一下这些图表上的箭头形状。

1485
01:11:27,755 --> 01:11:30,130
This indicates that it's a one-to-one relationship, which
这表明它是一对一关系，也就是说

1486
01:11:30,130 --> 01:11:34,450
means every show has one rating, which means every row in the shows table
每个节目都有一个评分，这意味着 shows 表格中的每一行

1487
01:11:34,450 --> 01:11:36,970
has a corresponding row in the ratings table.
在 ratings 表格中都有对应的一行。

1488
01:11:36,970 --> 01:11:39,640
Strictly speaking, they could be in the same table.
严格地说，它们可以放在同一个表格中。

1489
01:11:39,640 --> 01:11:42,130
You could just join them together and make one wider table,
你可以将它们合并起来，创建一个更宽的表格，

1490
01:11:42,130 --> 01:11:44,800
but IMDb keeps the data separate so we too
但 IMDb 将数据分开，所以我们也

1491
01:11:44,800 --> 01:11:47,210
kept them separate in two separate tables here.
将它们分开存储在两个独立的表格中。

1492
01:11:47,210 --> 01:11:50,120
So what does this actually mean in practice?
那么，这在实践中究竟意味着什么？

1493
01:11:50,120 --> 01:11:54,590
Well, let's actually take a look in VS Code at the schema for these tables.
好吧，让我们在 VS Code 中查看这些表格的模式。

1494
01:11:54,590 --> 01:11:57,160
Let me clear my screen, and let me .schema,
让我清除屏幕，让我执行 .schema 命令，

1495
01:11:57,160 --> 01:12:01,570
but specifically look at the schema, or the design of, the shows table.
但具体看一下 shows 表格的模式，或设计。

1496
01:12:01,570 --> 01:12:06,640
So you can do .schema shows, and any command in SQLite with a dot is SQLite
所以你可以执行 .schema shows，在 SQLite 中，任何以点开头的命令都是 SQLite

1497
01:12:06,640 --> 01:12:08,050
specific.
特有的。

1498
01:12:08,050 --> 01:12:10,900
In the real world, if you're using other products like Oracle,
在现实世界中，如果你使用其他产品，例如 Oracle，

1499
01:12:10,900 --> 01:12:14,350
or Postgre, or MySQL, or others, they have different commands,
或 Postgre，或 MySQL，或其他，它们有不同的命令，

1500
01:12:14,350 --> 01:12:16,300
but anything else that we've been typing,
但我们一直在输入的其他任何内容，

1501
01:12:16,300 --> 01:12:20,260
especially the capitalized keywords, is indeed standard SQL.
特别是那些大写的关键词，确实是标准 SQL。

1502
01:12:20,260 --> 01:12:25,310
If I hit enter here, here is what the shows table apparently looks like.
如果我在此处按下回车键，这就是 shows 表格的外观。

1503
01:12:25,310 --> 01:12:28,480
In other words, here is the create table command that we, the staff,
换句话说，这就是我们，工作人员，

1504
01:12:28,480 --> 01:12:30,550
ran in order to create this table for you,
为了为你创建这个表格而运行的创建表格命令，

1505
01:12:30,550 --> 01:12:32,560
and then we imported a bunch of data into it.
然后我们导入了一堆数据到里面。

1506
01:12:32,560 --> 01:12:38,200
Every show has an ID, has a title, has a year, has a number of episodes.
每个节目都有一个 ID，一个标题，一个年份，以及集数。

1507
01:12:38,200 --> 01:12:39,610
But there's more detail here.
但是这里还有更多细节。

1508
01:12:39,610 --> 01:12:43,600
Apparently, the ID is an integer, the title is text, and it is not null,
显然，ID 是一个整数，标题是文本，并且它不能为空，

1509
01:12:43,600 --> 01:12:47,170
cannot be null, the year is numeric, whatever that means,
不能为 null，年份是数字，无论那意味着什么，

1510
01:12:47,170 --> 01:12:49,030
and the episodes is an integer.
集数是一个整数。

1511
01:12:49,030 --> 01:12:50,740
Well, that is now familiar.
好吧，现在我们很熟悉了。

1512
01:12:50,740 --> 01:12:51,830
And then primary key.
然后是主键。

1513
01:12:51,830 --> 01:12:53,622
So there's some other stuff going on there,
所以那里还有一些其他的东西，

1514
01:12:53,622 --> 01:12:57,760
which we'll come back to, but let me also do .schema ratings, enter,
我们稍后再回来，但让我也做一下 .schema ratings，回车，

1515
01:12:57,760 --> 01:13:00,280
and we'll see a couple of other data types here.
我们将在那里看到另外一些数据类型。

1516
01:13:00,280 --> 01:13:03,070
There's show ID, which is still an integer, but not null.
有一个 show ID，它仍然是一个整数，但不能为空。

1517
01:13:03,070 --> 01:13:05,560
Rating, which is a real number, a.k.a.
评分，是一个实数，也就是

1518
01:13:05,560 --> 01:13:07,840
float, but it, too, cannot be null.
浮点数，但它也不能为 null。

1519
01:13:07,840 --> 01:13:10,750
And then some number of votes, which is an integer, cannot be null.
然后是一些投票数，它是整数，不能为空。

1520
01:13:10,750 --> 01:13:12,560
And then there's mention of foreign key.
然后提到了外键。

1521
01:13:12,560 --> 01:13:16,300
So unlike our data set for the favorites a bit ago, which we just
所以，与我们之前为收藏夹创建的数据集不同，我们只是

1522
01:13:16,300 --> 01:13:20,530
did automatically, and imported, this database by us, and by IMDb,
自动创建并导入，这个数据库是由我们和 IMDb 创建的，

1523
01:13:20,530 --> 01:13:23,680
has been more thoughtfully designed, where there's actually
它经过了更周到的设计，那里实际上

1524
01:13:23,680 --> 01:13:27,640
some relationships across multiple tables, rather than previously
在多个表之间存在一些关系，而不是之前

1525
01:13:27,640 --> 01:13:28,420
just one.
只有一个。

1526
01:13:28,420 --> 01:13:32,300
Now in the world of SQL, we have indeed different data types.
现在在 SQL 世界中，我们确实有不同的数据类型。

1527
01:13:32,300 --> 01:13:35,140
For instance, we have these five primarily.
例如，我们主要有这五个。

1528
01:13:35,140 --> 01:13:37,750
One, cutely named BLOB, which is actually
一个是 BLOB，名字很可爱，实际上

1529
01:13:37,750 --> 01:13:41,990
Binary Large Object, which generally means like a file or some piece of data
是二进制大对象，它通常表示文件或一些数据

1530
01:13:41,990 --> 01:13:43,190
that's zeros and ones.
都是 0 和 1。

1531
01:13:43,190 --> 01:13:46,160
Though, generally, it's best to store files on file systems,
不过，通常最好将文件存储在文件系统中，

1532
01:13:46,160 --> 01:13:50,090
like in folders, on disks, so to speak, not in your database.
比如文件夹，磁盘上，这么说吧，而不是在你的数据库中。

1533
01:13:50,090 --> 01:13:51,440
There's integers we've seen.
我们已经看到了整数。

1534
01:13:51,440 --> 01:13:52,410
There's numeric.
还有数值型。

1535
01:13:52,410 --> 01:13:54,740
Which numeric is more like dates and times,
数值型更像是日期和时间，

1536
01:13:54,740 --> 01:13:58,340
things that are numbers, but not necessarily integers or floating point
是数字，但并不一定是整数或浮点数

1537
01:13:58,340 --> 01:13:58,970
values.
值。

1538
01:13:58,970 --> 01:14:01,460
There's reals, which do have decimal points in them.
有实数，它们确实有小数点。

1539
01:14:01,460 --> 01:14:02,780
And then there's just text.
然后就是文本。

1540
01:14:02,780 --> 01:14:06,290
In other SQL databases in the real world, in your future jobs,
在现实世界中的其他 SQL 数据库中，在你的未来工作中，

1541
01:14:06,290 --> 01:14:09,740
or your future classes that you might use SQL again in,
或者你在未来可能再次使用 SQL 的课程中，

1542
01:14:09,740 --> 01:14:14,960
there are even more data types in other databases: Oracle, MySQL, Postgre,
在其他数据库中，有更多的数据类型：Oracle、MySQL、Postgre，

1543
01:14:14,960 --> 01:14:15,605
and so forth.
等等。

1544
01:14:15,605 --> 01:14:17,480
But these are sort of representative of them.
但这些是它们的代表。

1545
01:14:17,480 --> 01:14:19,767
They just get more precise in other systems.
它们只是在其他系统中变得更加精确。

1546
01:14:19,767 --> 01:14:22,100
But there's also some keywords, that we've seen already,
但我们已经看到了一些关键字，

1547
01:14:22,100 --> 01:14:24,230
that you can specify when designing a database.
你可以在设计数据库时指定。

1548
01:14:24,230 --> 01:14:26,090
--that this column cannot be null.
-- 这列不能为空。

1549
01:14:26,090 --> 01:14:29,720
If you want to make sure that no one can insert or update
如果你想确保没有人可以插入或更新

1550
01:14:29,720 --> 01:14:32,030
data unbeknownst to you that is null, you
你不知道的数据为空，你

1551
01:14:32,030 --> 01:14:34,340
can impose that when creating the table.
可以在创建表时强制执行。

1552
01:14:34,340 --> 01:14:36,740
And unlike Excel, and Google Spreadsheets,
与 Excel 和 Google Spreadsheets 不同，

1553
01:14:36,740 --> 01:14:40,010
and Apple Numbers, which will generally let the human type in or not type
和 Apple Numbers，它们通常允许用户键入或不键入

1554
01:14:40,010 --> 01:14:43,520
in anything they want, with a database you have more protections
任何他们想要的东西，使用数据库，你可以有更多的保护

1555
01:14:43,520 --> 01:14:45,365
over the integrity of your data.
来保护你的数据完整性。

1556
01:14:45,365 --> 01:14:48,900
Moreover, you can specify that a column's values must be unique.
此外，你可以指定一列的值必须是唯一的。

1557
01:14:48,900 --> 01:14:50,750
If you want to avoid duplicates, like you
如果你想避免重复，就像你

1558
01:14:50,750 --> 01:14:54,740
don't want the same person to be able to register twice for your website thereby
不希望同一个人能够在你的网站上注册两次，从而

1559
01:14:54,740 --> 01:14:57,500
making sure they have one unique email address,
确保他们有一个唯一的电子邮件地址，

1560
01:14:57,500 --> 01:14:59,840
your database can help with that too.
你的数据库也可以帮助你实现这一点。

1561
01:14:59,840 --> 01:15:03,470
You don't have to rely on Python to check if it already exists.
你不需要依赖 Python 来检查它是否已经存在。

1562
01:15:03,470 --> 01:15:07,520
But there's this other feature of relational databases, that
但是关系型数据库还有另一个特性，

1563
01:15:07,520 --> 01:15:11,480
is databases that have multiple tables across which there are relationships,
就是那些有多个表，并且在多个表之间存在关系的数据库，

1564
01:15:11,480 --> 01:15:13,880
and that's these keywords we saw briefly a moment ago.
这些就是我们刚才简要提到的关键词。

1565
01:15:13,880 --> 01:15:16,620
Primary key, and foreign key.
主键和外键。

1566
01:15:16,620 --> 01:15:20,180
And we started to scratch this surface here.
我们开始接触到这个表面的东西。

1567
01:15:20,180 --> 01:15:22,490
It turns out what I was doing was actually
事实证明，我所做的事情实际上

1568
01:15:22,490 --> 01:15:25,340
best practice in the world of relational databases
是关系型数据库中的最佳实践

1569
01:15:25,340 --> 01:15:30,680
I gave or, really, IMDb gave every show in the world a unique ID.
我给了，或者说，IMDb 给了世界上每一档节目一个唯一的 ID。

1570
01:15:30,680 --> 01:15:36,470
And that unique ID, in this case 386676, is a numeric value, an integer,
这个唯一的 ID，在这个例子中是 386676，是一个数值，一个整数，

1571
01:15:36,470 --> 01:15:38,930
that uniquely identifies that TV show.
它唯一标识了这个电视剧。

1572
01:15:38,930 --> 01:15:43,370
In other words, this is the primary key for this table.
换句话说，这是这个表的  主键。

1573
01:15:43,370 --> 01:15:46,370
Technically a sheet, but I'm using that just because it's easier to type
从技术上讲，它是一个表格，但我之所以使用它，是因为它更容易输入

1574
01:15:46,370 --> 01:15:48,020
in than my black and white window.
比我的黑白窗口。

1575
01:15:48,020 --> 01:15:53,960
This ID column is the primary key for shows, as I was mocking up earlier.
正如我之前模拟的那样，这个 ID 列是 shows 的主键。

1576
01:15:53,960 --> 01:15:57,290
What is the primary key in the people sheet here?
这里 people 表的主键是什么？

1577
01:15:57,290 --> 01:15:58,580
It is also ID.
它也是 ID。

1578
01:15:58,580 --> 01:16:02,450
It's a different ID, but it's by convention often called the same thing.
它是一个不同的 ID，但按照惯例，它通常被称为相同的东西。

1579
01:16:02,450 --> 01:16:07,037
But this people column, called ID, is its primary key.
但是这个 people 列，被称为 ID，是它的主键。

1580
01:16:07,037 --> 01:16:08,870
And you can perhaps see where this is going.
你或许能看到这将走向何处。

1581
01:16:08,870 --> 01:16:13,910
Those same numbers also happen to appear in this third table,
那些相同的数字也恰好出现在第三个表格中，

1582
01:16:13,910 --> 01:16:17,180
but in that context, they're sort of foreign keys.
但在这种情况下，它们有点像外键。

1583
01:16:17,180 --> 01:16:21,420
They didn't come from this star sheet, but they are in this star sheet,
它们不是来自这个 star 表格，但它们在这个 star 表格中，

1584
01:16:21,420 --> 01:16:23,690
so they're sort of relatively foreign to it.
所以它们对它来说有点陌生。

1585
01:16:23,690 --> 01:16:29,030
So foreign keys is simply the presence of primary keys in some other table,
所以外键仅仅是其他表格中存在主键，

1586
01:16:29,030 --> 01:16:30,630
in some other data set.
在其他数据集中。

1587
01:16:30,630 --> 01:16:33,050
And so it's just a description of relativity,
所以这仅仅是对相对性的描述，

1588
01:16:33,050 --> 01:16:36,860
but the foreign key is the column that uniquely identifies your data.
但外键是唯一标识你的数据的列。

1589
01:16:36,860 --> 01:16:41,190
Foreign keys is just the appearance of those same numbers elsewhere.
外键仅仅是这些相同数字在其他地方的出现。

1590
01:16:41,190 --> 01:16:42,570
So what does this mean?
所以这意味着什么？

1591
01:16:42,570 --> 01:16:45,020
If we go back to VS Code here, you'll see
如果我们回到 VS Code，你会看到

1592
01:16:45,020 --> 01:16:48,860
that when we created this table using IMDb's real data,
当我们使用 IMDb 的真实数据创建这个表格时，

1593
01:16:48,860 --> 01:16:52,640
we specified that in our shows table, which is bigger than the one
我们指定了，在我们的 shows 表格中，它比我

1594
01:16:52,640 --> 01:16:56,180
I mocked up with Google Sheets there, has not only an ID and a title it,
用 Google Sheets 模拟的要大，它不仅包含一个 ID 和一个标题，

1595
01:16:56,180 --> 01:16:58,615
again, also has year in which the show debuted,
它还包含节目首播的年份，

1596
01:16:58,615 --> 01:16:59,990
and the total number of episodes.
以及剧集总数。

1597
01:16:59,990 --> 01:17:02,810
Because that's juicy data that comes from IMDb,
因为这是来自 IMDb 的有用数据，

1598
01:17:02,810 --> 01:17:04,670
beyond what I mocked up a moment ago.
超出了我刚才模拟的内容。

1599
01:17:04,670 --> 01:17:08,150
In the ratings table, meanwhile, there's a show ID,
而在 ratings 表格中，有一个 show ID，

1600
01:17:08,150 --> 01:17:12,360
which is also an integer, just like this ID, but as the name implies,
它也是一个整数，就像这个 ID 一样，但正如名字所暗示的那样，

1601
01:17:12,360 --> 01:17:17,810
this show ID column is actually going to be a foreign key that references
这个 show ID 列实际上将是一个外键，它引用

1602
01:17:17,810 --> 01:17:20,640
the shows tables ID column.
shows 表格的 ID 列。

1603
01:17:20,640 --> 01:17:23,420
So this is the relational in relational databases.
所以这就是关系型数据库中的关系。

1604
01:17:23,420 --> 01:17:25,530
These are two tables that have a relationship,
这两个表格之间存在着关系，

1605
01:17:25,530 --> 01:17:32,520
and that relationship is that show ID is referring to this actual ID here.
并且这种关系是，节目ID指的是这里的实际ID。

1606
01:17:32,520 --> 01:17:34,520
And it allows us essentially, conceptually,
它从本质上，从概念上，

1607
01:17:34,520 --> 01:17:37,350
to link these two tables together.
将这两张表链接在一起。

1608
01:17:37,350 --> 01:17:39,353
So what does this actually mean?
这到底意味着什么呢？

1609
01:17:39,353 --> 01:17:40,770
Well, let me go ahead and do this.
好吧，让我来做这件事。

1610
01:17:40,770 --> 01:17:42,140
Let me go back to VS Code here.
让我回到VS Code这里。

1611
01:17:42,140 --> 01:17:45,120
I'll clear my terminal, and let's play around with some of this data.
我会清除我的终端，让我们来玩玩这些数据。

1612
01:17:45,120 --> 01:17:48,080
So let's go ahead and do this just to experiment.
所以让我们来做这件事，仅仅是为了实验。

1613
01:17:48,080 --> 01:17:51,320
Select star from ratings where--
从ratings表中选择所有内容，where--

1614
01:17:51,320 --> 01:17:54,860
let's get all of the good shows where, just like Rotten Tomatoes,
让我们得到所有评分高的节目，就像烂番茄一样，

1615
01:17:54,860 --> 01:17:57,410
we'll do the cut off at 6.0 out of 10.
我们将以6.0分作为评分的截止点。

1616
01:17:57,410 --> 01:18:01,063
So where rating is greater than or equal to 6.0.
所以rating值大于或等于6.0。

1617
01:18:01,063 --> 01:18:03,230
And just so I don't overwhelm my screen, let me just
为了避免屏幕显示过载，我只要

1618
01:18:03,230 --> 01:18:05,370
limit this to the first 10 results.
将结果限制在前10个。

1619
01:18:05,370 --> 01:18:08,510
In other words, this is SQL syntax for selecting
换句话说，这是用于选择

1620
01:18:08,510 --> 01:18:12,920
all of the ratings that are at least 6.0 or higher from that table.
所有rating值至少为6.0或更高的条目，从该表中。

1621
01:18:12,920 --> 01:18:13,640
Enter.
回车。

1622
01:18:13,640 --> 01:18:15,350
And we see just the first 10 of them.
我们只看到了前10个。

1623
01:18:15,350 --> 01:18:18,540
Not the top 10 because we've not sorted or grouped or anything like that,
不是前10个最受欢迎的节目，因为我们没有进行排序或分组之类的操作。

1624
01:18:18,540 --> 01:18:20,490
but the first 10 in the table.
而是表中的前10个。

1625
01:18:20,490 --> 01:18:23,780
So what is interesting here is that we've
所以这里有趣的是我们

1626
01:18:23,780 --> 01:18:26,390
seen just some sampling of the data, if you will.
看到了数据的一些样本，如果你愿意的话。

1627
01:18:26,390 --> 01:18:28,790
But this isn't all that interesting here.
但这在这里并不十分有趣。

1628
01:18:28,790 --> 01:18:32,220
Let me actually distill this just to the show ID because, in other words,
让我实际将结果简化到节目ID，因为，换句话说，

1629
01:18:32,220 --> 01:18:34,190
I want to know 10 good shows to watch.
我想知道10个值得观看的优秀节目。

1630
01:18:34,190 --> 01:18:36,440
So let me just select show ID.
所以让我只选择节目ID。

1631
01:18:36,440 --> 01:18:39,480
So same result, but less data.
所以结果一样，但数据更少。

1632
01:18:39,480 --> 01:18:41,700
It's just that first column thereof.
它只是表中的第一列。

1633
01:18:41,700 --> 01:18:43,540
Now this is going to be a little annoying,
现在这会有点麻烦，

1634
01:18:43,540 --> 01:18:47,460
but if I want to find out the names of these shows--
但如果我想找出这些节目的名字--

1635
01:18:47,460 --> 01:18:50,400
think about the picture from whence we came.
想想我们之前看到的图表。

1636
01:18:50,400 --> 01:18:55,320
All of the show's names are in the shows table, but all of the show's ratings
所有节目的名字都在shows表中，但所有节目的评分

1637
01:18:55,320 --> 01:18:57,520
are in the ratings table.
都在ratings表中。

1638
01:18:57,520 --> 01:19:00,058
So even if I do select star from ratings,
所以即使我选择ratings表中的所有内容，

1639
01:19:00,058 --> 01:19:02,100
I'm never going to know what show I'm looking at.
我永远不会知道我正在查看哪个节目。

1640
01:19:02,100 --> 01:19:04,500
Like, what the heck is show ID 62614?
例如，节目ID 62614是什么鬼？

1641
01:19:04,500 --> 01:19:05,680
Well, I could do this.
好吧，我可以这样做。

1642
01:19:05,680 --> 01:19:14,370
I could select star from shows where the ID of the show equals 62614 semicolon.
我可以选择shows表中的所有内容，where节目的ID等于62614，分号。

1643
01:19:14,370 --> 01:19:15,240
Enter.
回车。

1644
01:19:15,240 --> 01:19:18,270
OK, so I could watch this show from 1981.
好的，所以我可以观看这个1981年的节目。

1645
01:19:18,270 --> 01:19:19,290
Let me do another one.
让我再看一个。

1646
01:19:19,290 --> 01:19:24,030
Select star from shows where ID equals 63881.
选择shows表中的所有内容，where ID等于63881。

1647
01:19:24,030 --> 01:19:26,710
So I'm just grabbing the second ID from here.
所以我只是从这里获取第二个ID。

1648
01:19:26,710 --> 01:19:27,210
OK.
好的。

1649
01:19:27,210 --> 01:19:29,530
So Catweazle, a kid's show from 1970.
所以是Catweazle，一个1970年的儿童节目。

1650
01:19:29,530 --> 01:19:30,030
All right.
好的。

1651
01:19:30,030 --> 01:19:31,120
So I'll watch that.
所以我会看那个节目。

1652
01:19:31,120 --> 01:19:32,620
So now let's do another one.
现在让我们再看一个。

1653
01:19:32,620 --> 01:19:33,810
I'll just copy this.
我只是复制一下。

1654
01:19:33,810 --> 01:19:37,530
Like suffice it to say, this is not the best way to look up data,
不难看出，这不是查找数据的最佳方式，

1655
01:19:37,530 --> 01:19:41,610
where I'm literally copying and pasting values from one query into the next.
我实际上是在将一个查询中的值复制粘贴到下一个查询中。

1656
01:19:41,610 --> 01:19:43,950
But this is where SQL gets a bit powerful.
但这就是SQL变得强大之处。

1657
01:19:43,950 --> 01:19:46,170
I can have nested queries.
我可以使用嵌套查询。

1658
01:19:46,170 --> 01:19:47,710
I can put one inside of the other.
我可以将一个查询嵌套在另一个查询中。

1659
01:19:47,710 --> 01:19:48,793
So let me instead do this.
所以让我尝试另一种方法。

1660
01:19:48,793 --> 01:19:51,130
Let me clear the screen, and let me instead do this.
让我清除屏幕，让我尝试另一种方法。

1661
01:19:51,130 --> 01:19:57,620
Select star from shows where the ID of the show
从shows表中选择所有内容，where节目的ID

1662
01:19:57,620 --> 01:20:01,160
is in the following list of IDs.
在以下ID列表中。

1663
01:20:01,160 --> 01:20:02,630
Select.
选择。

1664
01:20:02,630 --> 01:20:05,480
And, actually, I'll do this on a separate line.
实际上，我会在单独的一行上执行这个操作。

1665
01:20:05,480 --> 01:20:12,020
Select show ID from ratings where the rating value is
从ratings表中选择节目ID，where rating值是

1666
01:20:12,020 --> 01:20:15,800
greater than or equal to 6.0 semicolon.
大于或等于6.0，分号。

1667
01:20:15,800 --> 01:20:17,570
So I've separated this onto two lines.
所以我把代码分成了两行。

1668
01:20:17,570 --> 01:20:19,710
The dot, dot, dot is just a continuation character,
三个点只是一个续行符，

1669
01:20:19,710 --> 01:20:23,480
which means same query, multiple lines, but the parentheses are deliberate.
这意味着相同的查询，多行代码，但括号是故意使用的。

1670
01:20:23,480 --> 01:20:27,500
Just like grade school math, I want what's in parentheses to happen first.
就像小学数学一样，我希望括号中的内容优先执行。

1671
01:20:27,500 --> 01:20:29,930
And so what the database will do is we'll
所以数据库会做的是，我们将

1672
01:20:29,930 --> 01:20:33,740
select, as before, all of the show IDs from the ratings table
选择，如前所述，ratings表中的所有节目ID

1673
01:20:33,740 --> 01:20:36,713
where the rating value is at least 6.0 out of 10.
where rating值至少为6.0分。

1674
01:20:36,713 --> 01:20:38,630
And that's going to return to me, effectively,
这将有效地返回给我，

1675
01:20:38,630 --> 01:20:41,750
a list, some kind of collection of show IDs,
一个列表，某种节目ID的集合，

1676
01:20:41,750 --> 01:20:43,760
which previously I was copying and pasting,
我之前是复制粘贴的，

1677
01:20:43,760 --> 01:20:47,390
now the database will do the legwork for me.
现在数据库会为我完成这项工作。

1678
01:20:47,390 --> 01:20:51,410
It will now select everything from the shows table, where the ID of the show
它现在将从shows表中选择所有内容，where节目的ID

1679
01:20:51,410 --> 01:20:53,655
is in that list of values.
在这个值列表中。

1680
01:20:53,655 --> 01:20:56,280
And it's actually going to be more than 10 unless I go in there
实际上，除非我在那里添加限制，否则结果将超过10个。

1681
01:20:56,280 --> 01:20:58,690
and say limit 10, which I can do.
并添加限制10，这是我可以做的。

1682
01:20:58,690 --> 01:21:00,510
So let me go ahead and hit enter now.
所以让我现在按下回车键。

1683
01:21:00,510 --> 01:21:03,630
And now I see more useful information not just
现在我看到了更多有用的信息，不仅仅是

1684
01:21:03,630 --> 01:21:05,640
the ratings information, which in a vacuum
评分信息，它本身

1685
01:21:05,640 --> 01:21:07,320
tells me nothing about what to watch.
并不能告诉我应该看哪些节目。

1686
01:21:07,320 --> 01:21:12,360
Now I see the show ID, the title, the year, and the episodes.
现在我看到了节目ID、标题、年份和集数。

1687
01:21:12,360 --> 01:21:17,200
But notably, what is-- and if I want to distill this into just the title,
但值得注意的是，是什么-- 如果我想将结果简化为只有标题，

1688
01:21:17,200 --> 01:21:20,010
let me actually go back here and instead do
让我回到这里，并改为

1689
01:21:20,010 --> 01:21:25,140
select just the title from shows where the ID is in this whole list.
选择shows表中的标题，where ID在这个完整列表中。

1690
01:21:25,140 --> 01:21:28,210
And I'll re-execute it by just copying and pasting the same.
我将通过复制粘贴相同代码来重新执行它。

1691
01:21:28,210 --> 01:21:31,240
The only difference now is instead of star, I'm selecting title.
现在唯一的区别是，我选择的是标题，而不是所有内容。

1692
01:21:31,240 --> 01:21:34,080
Here's now how the data analyst at IMDb might
这就是IMDb的数据分析师可能会

1693
01:21:34,080 --> 01:21:38,430
be selecting 10 shows that are really good to watch, according to ratings.
根据评分选择10部非常值得观看的节目。

1694
01:21:38,430 --> 01:21:41,490
But what, of course, is missing from the output,
但当然，输出中缺少什么？

1695
01:21:41,490 --> 01:21:45,065
whether I do star or just title?
无论我选择所有内容还是仅标题？

1696
01:21:45,065 --> 01:21:45,690
What's missing?
缺少什么？

1697
01:21:45,690 --> 01:21:45,960
Yeah?
是吧？

1698
01:21:45,960 --> 01:21:46,860
AUDIENCE: Rating.
观众：评分。

1699
01:21:46,860 --> 01:21:47,940
- The actual rating.
- 实际评分。

1700
01:21:47,940 --> 01:21:51,000
I know these are at least 6.0, but which is 7.0?
我知道这些评分至少是6.0，但哪个是7.0？

1701
01:21:51,000 --> 01:21:52,050
Which is 10.0?
哪个是10.0？

1702
01:21:52,050 --> 01:21:55,270
It'd be nice to actually combine the data in some way.
实际上能够以某种方式将数据合并会很棒。

1703
01:21:55,270 --> 01:21:57,840
So we can actually do that, too, because it turns out
所以我们实际上也可以做到这一点，因为事实证明

1704
01:21:57,840 --> 01:22:00,960
that when you have two tables in the world of SQL, or even more,
在SQL的世界中，当你拥有两张表，甚至更多表时，

1705
01:22:00,960 --> 01:22:03,720
you can actually join them together.
你可以把它们组合在一起。

1706
01:22:03,720 --> 01:22:08,700
You can join them together, literally using a keyword called join.
你可以把它们组合在一起，使用一个名为“join”的关键字。

1707
01:22:08,700 --> 01:22:10,540
And you can do this as follows.
你可以按照以下步骤进行操作。

1708
01:22:10,540 --> 01:22:13,253
Let me propose, with a sample data set, these two tables.
让我用一个示例数据集，来展示这两个表格。

1709
01:22:13,253 --> 01:22:16,170
And dot, dot, dot just means we don't really care about the specifics.
省略号表示我们并不关心具体的细节。

1710
01:22:16,170 --> 01:22:17,800
We just care about the structure.
我们只关心结构。

1711
01:22:17,800 --> 01:22:21,000
So on the left here is a simplified version of my shows
左边是简化版的节目列表

1712
01:22:21,000 --> 01:22:24,270
table that has a show ID and a show title,
表格包含节目 ID 和节目标题，

1713
01:22:24,270 --> 01:22:27,990
but I've omitted year and episodes as just intellectually
但我省略了年份和集数，因为这些信息

1714
01:22:27,990 --> 01:22:30,180
distracting from the basic structure here.
会分散对基本结构的关注。

1715
01:22:30,180 --> 01:22:31,740
But they're there in the real table.
但在真实的表格中，这些信息是存在的。

1716
01:22:31,740 --> 01:22:34,890
On the right hand side here, we have the ratings table
右边是评分表格，

1717
01:22:34,890 --> 01:22:37,290
with just two of its columns, the show ID and the rating,
只有两列，节目 ID 和评分，

1718
01:22:37,290 --> 01:22:39,457
but I've omitted the votes because it doesn't really
但我省略了投票数量，因为这

1719
01:22:39,457 --> 01:22:40,750
add anything to the discussion.
不会对讨论有任何帮助。

1720
01:22:40,750 --> 01:22:42,600
But let me propose this.
但我想提议一下。

1721
01:22:42,600 --> 01:22:45,750
Notice that these two tables and these two rows
请注意这两个表格和其中的两行

1722
01:22:45,750 --> 01:22:47,790
therein definitely have commonalities.
肯定有一些共同点。

1723
01:22:47,790 --> 01:22:50,370
Like, they both have the same ID.
比如，它们都拥有相同的 ID。

1724
01:22:50,370 --> 01:22:54,150
In the left table it's 386676, a.k.a.
在左边表格中是 386676，也就是

1725
01:22:54,150 --> 01:22:55,860
The primary key of that row.
该行的主键。

1726
01:22:55,860 --> 01:23:01,200
But it's also appearing in duplicate in the right hand table, 386676,
但它也重复出现在了右边的表格中，也是 386676，

1727
01:23:01,200 --> 01:23:02,977
and in that context it's a foreign key.
在这种情况下，它是一个外键。

1728
01:23:02,977 --> 01:23:04,810
The point, though, is that they're the same.
关键是，它们是相同的。

1729
01:23:04,810 --> 01:23:08,320
So wouldn't it be nice if I could treat one table here, one table here,
所以如果我能把这里的一个表格和另一个表格

1730
01:23:08,320 --> 01:23:12,150
and if my fingertips represent these identical values, kind of like glue
用指尖代表这些相同的值，就像胶水一样

1731
01:23:12,150 --> 01:23:15,715
them together so I get one wider table with all of the information
把它们粘在一起，这样我就能得到一个更宽的表格，包含所有信息

1732
01:23:15,715 --> 01:23:18,090
together to satisfy your concern, that we don't even know
整合在一起，来满足你的疑问，我们甚至不知道

1733
01:23:18,090 --> 01:23:20,015
what the ratings are of those shows.
这些节目的评分是多少。

1734
01:23:20,015 --> 01:23:21,390
Well let me go ahead and do this.
好吧，我来做一下。

1735
01:23:21,390 --> 01:23:24,488
Just for artist's rendition, let me flip title and ID,
为了艺术表现，我将标题和 ID 位置交换一下，

1736
01:23:24,488 --> 01:23:25,780
which has no functional effect.
这不会影响功能。

1737
01:23:25,780 --> 01:23:28,488
It's just going to put the numbers closer together on the screen.
它只是让数字在屏幕上靠得更近。

1738
01:23:28,488 --> 01:23:32,610
Let me then literally highlight the fact that these two numbers are identical,
然后我将通过突出显示这两个数字是相同的，

1739
01:23:32,610 --> 01:23:35,190
and let me propose that we do the equivalent of this,
我提议我们做与之等效的操作，

1740
01:23:35,190 --> 01:23:38,910
we somehow join these two tables on that common value.
我们将这两个表格根据共同值进行连接。

1741
01:23:38,910 --> 01:23:40,995
Strictly speaking, I don't need both values
严格来说，我不需要这两个值

1742
01:23:40,995 --> 01:23:43,870
because they're duplicates, so I don't care if one of them goes away.
因为它们是重复的，所以我并不关心其中一个消失。

1743
01:23:43,870 --> 01:23:46,470
But what I'd really like to do is select, indeed,
但我真正想做的是选择，确实，

1744
01:23:46,470 --> 01:23:52,230
a temporary table that is the joined version of that original data.
一个包含原始数据合并版本的新表格。

1745
01:23:52,230 --> 01:23:54,840
And frankly, I don't really care as the user what the ID is.
坦白地说，作为用户，我不关心 ID 是什么。

1746
01:23:54,840 --> 01:23:57,690
Heck, all I care about is what show to watch and what its rating is.
实际上，我只关心要看什么节目以及它的评分。

1747
01:23:57,690 --> 01:23:59,370
Give me the title and the rating.
告诉我标题和评分。

1748
01:23:59,370 --> 01:24:01,590
All of these numbers are, again, metadata, things
这些数字都是元数据，是

1749
01:24:01,590 --> 01:24:05,490
that the computer cares about, but we humans probably do not.
计算机关心的东西，但我们人类可能并不关心。

1750
01:24:05,490 --> 01:24:07,890
So how can we implement that idea?
那么我们如何实现这个想法呢？

1751
01:24:07,890 --> 01:24:09,840
Of taking one data set that has a relationship
将一个与另一个数据集有关联的数据集

1752
01:24:09,840 --> 01:24:12,510
with this data set, and somehow combine it together?
进行整合？

1753
01:24:12,510 --> 01:24:14,170
Well let me go back to VS Code here.
好吧，我回到 VS Code 这里。

1754
01:24:14,170 --> 01:24:15,330
Let me clear my screen.
让我清理一下屏幕。

1755
01:24:15,330 --> 01:24:20,220
And this is going to be a bit cryptic at first, but it's very step by step.
一开始可能会有点难以理解，但它非常循序渐进。

1756
01:24:20,220 --> 01:24:21,010
Let me do this.
我来做一下。

1757
01:24:21,010 --> 01:24:25,890
Select star from shows, but not from shows alone.
从节目中选择所有内容，但不只是节目。

1758
01:24:25,890 --> 01:24:28,650
Let me join it with the ratings table.
我要将它与评分表连接起来。

1759
01:24:28,650 --> 01:24:32,400
So let me select everything from shows joined with ratings,
所以，我要从节目中选择所有内容，并与评分表连接起来，

1760
01:24:32,400 --> 01:24:35,910
but I need to tell the database, well, what do I want to join things on?
但我需要告诉数据库，我想要根据什么进行连接？

1761
01:24:35,910 --> 01:24:37,200
What are my fingertips?
我的指尖是什么？

1762
01:24:37,200 --> 01:24:40,030
Specifically, I want them to join on those common integers.
具体来说，我要根据这些共同的整数进行连接。

1763
01:24:40,030 --> 01:24:44,940
So I can literally say, on, and then I can specify one table on the left.
所以我可以直接说“on”，然后指定左边的一个表格。

1764
01:24:44,940 --> 01:24:51,030
Shows.id on the left should equal the ratings table's shows.id column
左边表格的 shows.id 列应该等于右边表格的 shows.id 列

1765
01:24:51,030 --> 01:24:52,470
on the right.
在右边。

1766
01:24:52,470 --> 01:24:57,120
Again, if I'm joining shows with ratings it's called ID in one,
再次，如果我要将节目与评分连接起来，在一个表格中它叫做 ID，

1767
01:24:57,120 --> 01:25:00,640
it's called show ID in the other, but it's the exact same thing.
而在另一个表格中它叫做 show ID，但它实际上是同一个东西。

1768
01:25:00,640 --> 01:25:03,210
In fact, if I rewind, this is where we came from.
事实上，如果我倒回，这是我们开始的地方。

1769
01:25:03,210 --> 01:25:05,290
Two tables with the same value.
两个具有相同值的表格。

1770
01:25:05,290 --> 01:25:10,170
So with this query here, if I go ahead and now specify not just that but let
所以有了这个查询，如果我现在不只是指定这些，而是让

1771
01:25:10,170 --> 01:25:14,760
me further say, where rating is greater than or equal to 6.0.
我进一步说，评分大于或等于 6.0。

1772
01:25:14,760 --> 01:25:16,500
And, heck, let's limit it to 10.
而且，让我们限制为 10 个。

1773
01:25:16,500 --> 01:25:21,420
Just fits on the screen, so it's more of a mouthful, but when I hit enter now
这样正好能显示在屏幕上，虽然有点长，但我现在按回车键

1774
01:25:21,420 --> 01:25:26,220
we have a wider table that indeed contains everything, star, from having
我们将得到一个更宽的表格，它确实包含所有内容，星号，来自连接

1775
01:25:26,220 --> 01:25:29,340
joined these two tables left and right.
这两个表格，左边和右边。

1776
01:25:29,340 --> 01:25:31,710
Now, again, I don't really care about much of this data,
现在，我仍然不关心其中的大部分数据，

1777
01:25:31,710 --> 01:25:34,410
like year and episodes and definitely not the IDs.
比如年份和集数，当然还有 ID。

1778
01:25:34,410 --> 01:25:36,070
So let me actually hit up.
所以，我实际上要按向上键。

1779
01:25:36,070 --> 01:25:38,070
Let me go to the beginning of the query, and let
让我回到查询的开头，然后让

1780
01:25:38,070 --> 01:25:41,640
me just select the title of the show and the rating of the show.
我选择节目标题和节目评分。

1781
01:25:41,640 --> 01:25:45,780
The query is getting a little long and it's wrapping, but it's the same query.
查询变得有点长，而且换行了，但它仍然是同一个查询。

1782
01:25:45,780 --> 01:25:49,500
Except, instead of star, I've done title comma rating.
除了星号之外，我使用的是标题，逗号，评分。

1783
01:25:49,500 --> 01:25:50,910
Now when I hit enter--
现在我按回车键——

1784
01:25:50,910 --> 01:25:54,190
like, this is the list that would have been nice to see the first time around.
就像，这是我第一次看到时希望看到的列表。

1785
01:25:54,190 --> 01:25:57,280
Show me 10 shows with a rating of 6.0 or higher,
给我展示 10 部评分大于或等于 6.0 的节目，

1786
01:25:57,280 --> 01:25:59,620
but remind me what the rating actually is so,
但请提醒我评分是多少，这样

1787
01:25:59,620 --> 01:26:03,580
maybe, I can prioritize the sevens, the eights, the nines, and even the tens,
或许，我能优先考虑评分为 7、8、9，甚至 10 的节目，

1788
01:26:03,580 --> 01:26:05,236
if any.
如果有的话。

1789
01:26:05,236 --> 01:26:11,760
Any questions about this technique of joining two tables?
关于这种连接两个表格的技术，有什么问题吗？

1790
01:26:11,760 --> 01:26:15,210
This sort of solves the problem that we created in the world of this sheet,
这在一定程度上解决了我们在表格中遇到的问题，

1791
01:26:15,210 --> 01:26:18,030
where I was just kind of playing around, where I sort of moved
我当时只是玩玩，将数据移动到了

1792
01:26:18,030 --> 01:26:20,280
all the data into its separate locations, which
不同的位置，这

1793
01:26:20,280 --> 01:26:21,750
is not at all pleasant to use.
一点也不方便使用。

1794
01:26:21,750 --> 01:26:25,590
But with SQL, with join, you can still get any of the data you want.
但通过 SQL 和 join，你仍然可以获取你想要的任何数据。

1795
01:26:25,590 --> 01:26:27,546
Yeah.
是的。

1796
01:26:27,546 --> 01:26:30,498
[INDISTINCT SPEECH]
[含糊不清的语音]

1797
01:26:34,450 --> 01:26:35,308
Correct.
没错。

1798
01:26:35,308 --> 01:26:37,600
So, yes, I should have called that out more explicitly.
所以，是的，我应该更明确地指出这一点。

1799
01:26:37,600 --> 01:26:41,472
In my query here, I was using dot notation, which we've seen in Python,
在我的查询中，我使用了点表示法，我们在 Python 中见过，

1800
01:26:41,472 --> 01:26:43,930
we've seen in C. It means something similar in spirit here,
我们在 C 中也见过。它在这里的含义在精神上是相似的，

1801
01:26:43,930 --> 01:26:45,972
but it has nothing to do with structured objects.
但它与结构化对象无关。

1802
01:26:45,972 --> 01:26:48,650
In this case, it has to do with tables and columns.
在本例中，它与表格和列有关。

1803
01:26:48,650 --> 01:26:53,320
So shows.id just makes clear that I want the ID column from the shows table
所以 shows.id 明确地表示我想要 shows 表格中的 ID 列

1804
01:26:53,320 --> 01:26:57,490
to line up with the show ID column from the ratings table.
与 ratings 表格中的 show ID 列对齐。

1805
01:26:57,490 --> 01:27:01,630
Strictly speaking, I don't need to do that because in this case
严格来说，我不需要这样做，因为在本例中

1806
01:27:01,630 --> 01:27:03,460
there is no ambiguity.
没有歧义。

1807
01:27:03,460 --> 01:27:06,340
One table has a column called ID, the other table
一个表格有一个名为 ID 的列，另一个表格

1808
01:27:06,340 --> 01:27:07,810
has a column called show ID.
有一个名为 show ID 的列。

1809
01:27:07,810 --> 01:27:10,840
So certainly the database can just figure this out for me.
所以数据库当然可以帮我解决这个问题。

1810
01:27:10,840 --> 01:27:15,730
But, for best practice, and for the sake of being explicit, using the dot
但是，为了最佳实践，为了明确起见，使用点

1811
01:27:15,730 --> 01:27:17,950
notation and table names can help, especially
表示法和表名可以有所帮助，尤其是

1812
01:27:17,950 --> 01:27:20,270
if there's some common language across them.
如果它们之间有一些共同的语言。

1813
01:27:20,270 --> 01:27:20,770
All right.
好的。

1814
01:27:20,770 --> 01:27:23,030
Well let's go back to the bigger data set here.
让我们回到这里更大的数据集。

1815
01:27:23,030 --> 01:27:25,060
These are all six tables in IMDb.
这些都是 IMDb 中的六个表格。

1816
01:27:25,060 --> 01:27:28,450
We focused for just a moment there on like shows and ratings alone,
我们只是简单地关注了节目和评分，

1817
01:27:28,450 --> 01:27:29,620
but what about genres.
但是类型呢？

1818
01:27:29,620 --> 01:27:33,250
So, genres, like comedy, and documentary, and drama, and so forth.
所以，类型，比如喜剧、纪录片、剧情等等。

1819
01:27:33,250 --> 01:27:37,190
Turns out that this actually implements a different type of relationship.
事实证明，这实际上实现了一种不同类型的关系。

1820
01:27:37,190 --> 01:27:39,530
Previously we saw a one-to-one relationship,
之前我们看到了一个一对一的关系，

1821
01:27:39,530 --> 01:27:42,080
but it turns out that IMDb supports what's
但事实证明，IMDb 支持所谓的

1822
01:27:42,080 --> 01:27:44,820
called a one-to-many relationship when it comes to genres.
一对多关系，在涉及类型时。

1823
01:27:44,820 --> 01:27:45,320
Why?
为什么？

1824
01:27:45,320 --> 01:27:48,650
Well, shows like The Office, I do think are generally considered comedy
好吧，像《办公室》这样的节目，我认为通常被认为是喜剧

1825
01:27:48,650 --> 01:27:51,650
and that's it, but there are certainly other TV shows
就是这样，但肯定还有其他电视剧

1826
01:27:51,650 --> 01:27:55,140
that might have multiple genres associated with them.
可能有多个类型与之相关。

1827
01:27:55,140 --> 01:27:59,160
Maybe it's comedy and a bit of romance thrown in, like rom-coms, and so forth,
也许是喜剧，还带有一些浪漫元素，比如浪漫喜剧等等，

1828
01:27:59,160 --> 01:28:03,980
so you could imagine some shows having two or three or more genres,
所以你可以想象一些节目有两种或三种或更多类型，

1829
01:28:03,980 --> 01:28:07,520
and so one-to-many means that one show can have many genres.
所以一对多意味着一个节目可以有多种类型。

1830
01:28:07,520 --> 01:28:11,450
One-to-one would mean one show can have one rating, as we've seen.
一对一意味着一个节目可以有一个评分，正如我们所见。

1831
01:28:11,450 --> 01:28:17,330
So why don't we go ahead and focus, maybe, on how about a query like this.
所以为什么我们不继续关注，也许，比如这样的查询。

1832
01:28:17,330 --> 01:28:19,577
Let me go back to VS Code here, clear my screen,
让我回到这里 VS Code，清除我的屏幕，

1833
01:28:19,577 --> 01:28:21,410
and let's just look at some of those genres.
让我们看看其中的一些类型。

1834
01:28:21,410 --> 01:28:25,700
Select star from genres and then I'll limit it to 10.
从 genres 中选择星号，然后我将其限制为 10。

1835
01:28:25,700 --> 01:28:28,590
And, again, I do this just to wrap my mind around a new data set.
同样，我这样做只是为了理解一个新的数据集。

1836
01:28:28,590 --> 01:28:30,740
I could look at the schema, but that tends to be more cryptic.
我可以查看模式，但这往往更难理解。

1837
01:28:30,740 --> 01:28:32,310
I just want to look at the raw data.
我只想看看原始数据。

1838
01:28:32,310 --> 01:28:32,810
OK.
好的。

1839
01:28:32,810 --> 01:28:37,227
It looks like here there are a bunch of genres: comedy, adventure, comedy.
看起来这里有一堆类型：喜剧、冒险、喜剧。

1840
01:28:37,227 --> 01:28:38,810
So two comedies, which is interesting.
所以两个喜剧，这很有趣。

1841
01:28:38,810 --> 01:28:40,100
Oh, interesting.
哦，有趣。

1842
01:28:40,100 --> 01:28:42,410
Family, action, sci-fi, family.
家庭、动作、科幻、家庭。

1843
01:28:42,410 --> 01:28:45,260
So the values here are duplicated, which it turns out
所以这里的值是重复的，事实证明

1844
01:28:45,260 --> 01:28:47,000
is not the best design of IMDb.
这不是 IMDb 最好的设计。

1845
01:28:47,000 --> 01:28:49,710
We literally just imported the data as they implement it.
我们只是按照他们的实现导入数据。

1846
01:28:49,710 --> 01:28:55,190
But notice that show ID 62614 is a comedy, but so is
但请注意，节目 ID 62614 是喜剧，但节目

1847
01:28:55,190 --> 01:29:00,950
show 63881, and so is show 65270.
63881 也是，节目 65270 也是。

1848
01:29:00,950 --> 01:29:04,320
So it turns out that in the real world sometimes data is somewhat messy.
所以事实证明，在现实世界中，有时数据会有点混乱。

1849
01:29:04,320 --> 01:29:06,830
There's duplication of comedy, comedy, comedy,
有重复的喜剧、喜剧、喜剧，

1850
01:29:06,830 --> 01:29:09,380
but such is the way IMDb's data is.
但这就是 IMDb 数据的现状。

1851
01:29:09,380 --> 01:29:12,694
But what's more interesting to me, for now, is notice this.
但对我来说，现在更有趣的是注意这一点。

1852
01:29:12,694 --> 01:29:16,530
This show ID in three rows is the same.
这三行中的节目 ID 是相同的。

1853
01:29:16,530 --> 01:29:19,700
So there's some show out there that's considered by the world
所以，那里有一些节目，被全世界认为是

1854
01:29:19,700 --> 01:29:22,257
to be an adventure, a comedy, and a family show.
冒险、喜剧和家庭节目。

1855
01:29:22,257 --> 01:29:23,340
So let's see what that is.
所以让我们看看那是什么。

1856
01:29:23,340 --> 01:29:26,880
Let me just highlight and copy that value, 63881, and do this.
让我只突出显示并复制那个值 63881，然后这样做。

1857
01:29:26,880 --> 01:29:31,378
Select star from shows where the ID of the show equals that value.
从节目中选择星号，其中节目的 ID 等于那个值。

1858
01:29:31,378 --> 01:29:33,170
And it turns out, we saw it briefly before,
事实证明，我们之前简要地看到了，

1859
01:29:33,170 --> 01:29:37,400
it's a show from the 1970s called Catweazle, which falls into all three
它是一个 1970 年代的节目，叫做《神奇猫》，它属于所有三个

1860
01:29:37,400 --> 01:29:38,880
of those categories.
类别。

1861
01:29:38,880 --> 01:29:43,880
So by using a one-to-many relationship, sort of depicted by this picture here,
所以通过使用一对多关系，就像这里这幅图所描绘的那样，

1862
01:29:43,880 --> 01:29:47,588
you can implement that same idea without having that jagged edge.
你可以实现同一个想法，而不需要那个锯齿状的边缘。

1863
01:29:47,588 --> 01:29:50,630
When we looked at the spreadsheet earlier, in an earlier version of this,
当我们之前查看电子表格时，在这个的早期版本中，

1864
01:29:50,630 --> 01:29:55,490
we had star, star, star, which we could do again, genre, genre, genre,
我们有星号、星号、星号，我们可以再次这样做，类型、类型、类型，

1865
01:29:55,490 --> 01:29:58,460
but now we instead have two separate tables
但现在我们有两个单独的表格

1866
01:29:58,460 --> 01:30:02,247
where this many-to-many relationship is implemented across.
其中这种多对多关系在它们之间实现。

1867
01:30:02,247 --> 01:30:03,830
So let's actually play around with it.
所以让我们实际操作一下。

1868
01:30:03,830 --> 01:30:07,640
Let me go back to VS Code here, and let's actually take
让我回到这里 VS Code，让我们实际看一下

1869
01:30:07,640 --> 01:30:10,520
a look at the schema for genres.
genres 的模式。

1870
01:30:10,520 --> 01:30:14,030
And we'll see that it's pretty small, as the picture suggests.
我们会发现它很小，正如图片所暗示的那样。

1871
01:30:14,030 --> 01:30:14,990
It's called genres.
它叫做 genres。

1872
01:30:14,990 --> 01:30:18,530
Every row has a show ID, which is an integer, cannot be null.
每一行都有一个节目 ID，它是一个整数，不能为空。

1873
01:30:18,530 --> 01:30:21,200
It has a genre, which is text, cannot be null.
它有一个类型，它是文本，不能为空。

1874
01:30:21,200 --> 01:30:25,190
And that show ID is a foreign key in this table that references an ID
而且那个节目 ID 是这个表格中的一个外键，它引用了 ID

1875
01:30:25,190 --> 01:30:26,690
column in the shows table.
shows 表格中的列。

1876
01:30:26,690 --> 01:30:29,240
So very similar in spirit, and so it really
所以精神上非常相似，所以它确实

1877
01:30:29,240 --> 01:30:32,090
is just kind of on the honor system that we're only
只是遵循了一种荣誉制度，我们只

1878
01:30:32,090 --> 01:30:34,670
putting one row for each show in ratings,
在 ratings 中为每个节目放一行，

1879
01:30:34,670 --> 01:30:39,150
but 0 or more shows in the genres table for shows, as well.
但在 genres 表格中也为节目放 0 行或更多行。

1880
01:30:39,150 --> 01:30:41,360
So what can we do once we want to tinker with genres?
所以当我们想修改类型时，我们可以做些什么？

1881
01:30:41,360 --> 01:30:42,420
Well, let me do this.
好吧，让我这样做。

1882
01:30:42,420 --> 01:30:49,587
How about we select the show ID from the genres table where the genre is comedy.
我们从 genres 表格中选择节目 ID，其中类型为喜剧怎么样？

1883
01:30:49,587 --> 01:30:51,170
Like, I'm in the mood for some comedy.
就像，我心情想看一些喜剧。

1884
01:30:51,170 --> 01:30:54,950
Let's see all of the available comedies, except let's just limit it to 10.
让我们看看所有可用的喜剧，除了我们只将其限制为 10。

1885
01:30:54,950 --> 01:30:59,150
Here are the show IDs for 10 comedies according to the Internet Movie
以下是互联网电影数据库中 10 部喜剧的节目 ID。

1886
01:30:59,150 --> 01:30:59,803
Database.
数据库。

1887
01:30:59,803 --> 01:31:01,220
Well, that's not very interesting.
好吧，这不太有趣。

1888
01:31:01,220 --> 01:31:03,350
I care about the title, so we can do that.
我关心标题，所以我们可以做到。

1889
01:31:03,350 --> 01:31:08,990
Select title from shows where the ID of the show is not equal to,
从节目中选择标题，其中节目的 ID 不等于，

1890
01:31:08,990 --> 01:31:12,710
but rather, in the following subquery, if you will.
但实际上是在接下来的子查询中，如果你愿意。

1891
01:31:12,710 --> 01:31:18,170
Select show ID from genres where genre equals, quote unquote,
从genres表中选择show ID，where genre 等于，引号开头，引号结尾，

1892
01:31:18,170 --> 01:31:21,900
"Comedy," limit 10, just to keep things simple.
“喜剧”，限制10条，为了简单起见。

1893
01:31:21,900 --> 01:31:25,460
So same query as before, but now I'm using it as a nested query
所以和之前一样的查询，但是现在我把它当做一个嵌套查询使用

1894
01:31:25,460 --> 01:31:28,730
to select the actual titles whose IDs match those their.
去选择那些ID匹配的实际标题。

1895
01:31:28,730 --> 01:31:29,540
Enter.
回车。

1896
01:31:29,540 --> 01:31:32,540
And there are those titles for 10 comedies,
这里就是10部喜剧的标题，

1897
01:31:32,540 --> 01:31:34,240
maybe a couple of which we've seen.
也许我们已经看过其中几部了。

1898
01:31:34,240 --> 01:31:35,480
Catweazel we've seen before.
我们之前看过Catweazel。

1899
01:31:35,480 --> 01:31:36,970
But what if we want to now--
但如果我们现在想—

1900
01:31:36,970 --> 01:31:38,380
let's see.
让我们看看。

1901
01:31:38,380 --> 01:31:42,085
Maybe we want to get all of the-- let's flip it around.
也许我们想获得所有— 让我们颠倒一下。

1902
01:31:42,085 --> 01:31:43,630
Catweazle keeps coming up.
Catweazle一直在出现。

1903
01:31:43,630 --> 01:31:47,170
Why don't we figure out, with a query, what all of its genres are?
为什么不用查询找出它所有的类型呢？

1904
01:31:47,170 --> 01:31:48,110
So Catweazle.
所以是Catweazle。

1905
01:31:48,110 --> 01:31:48,610
Let's see.
让我们看看。

1906
01:31:48,610 --> 01:31:55,450
So let's do select star from genres limit 10,
所以我们执行select star from genres limit 10，

1907
01:31:55,450 --> 01:31:57,430
because I know it's in the the first 10.
因为我知道它在前面的10条数据里。

1908
01:31:57,430 --> 01:31:59,950
This was, 63881 was Catweazle's ID.
这是，63881是Catweazle的ID。

1909
01:31:59,950 --> 01:32:00,880
So let's do this.
所以我们这样做。

1910
01:32:00,880 --> 01:32:06,860
So select genre from genres where the show ID equals that value.
所以选择genres表中的genre，where show ID等于那个值。

1911
01:32:06,860 --> 01:32:07,360
OK.
好的。

1912
01:32:07,360 --> 01:32:09,152
So there's the same query as we did before.
所以和之前一样。

1913
01:32:09,152 --> 01:32:10,480
Can we make this dynamic?
我们能把它做得更灵活吗？

1914
01:32:10,480 --> 01:32:11,650
Well, we can, too.
当然可以。

1915
01:32:11,650 --> 01:32:13,870
What if I instead, more dynamically do, select
如果我用更灵活的方式，选择

1916
01:32:13,870 --> 01:32:18,250
genre from genres where the show ID--
genre from genres where show ID—

1917
01:32:18,250 --> 01:32:19,180
and not in.
并且不在

1918
01:32:19,180 --> 01:32:23,020
If I'm looking for a specific show, now I can actually do equals.
如果我想找一部特定的节目，现在我可以直接用等于。

1919
01:32:23,020 --> 01:32:25,480
And in my subquery, I could do this, select ID
在我的子查询中，我可以这样做，选择ID

1920
01:32:25,480 --> 01:32:28,660
from shows where the title of the show equals,
from shows where title等于，

1921
01:32:28,660 --> 01:32:33,160
quote unquote, "Catweazel," semicolon, enter.
引号开头，引号结尾，“Catweazel”，分号，回车。

1922
01:32:33,160 --> 01:32:35,720
So, again, even though I'm typing these very quickly,
所以，再次强调，尽管我打字很快，

1923
01:32:35,720 --> 01:32:38,630
I'm really just composing similar, smaller ideas
我实际上只是把类似的，更小的想法

1924
01:32:38,630 --> 01:32:41,060
that we've seen before into larger and larger queries
组合成越来越大的查询

1925
01:32:41,060 --> 01:32:42,573
to just get at more of this data.
去获取更多数据。

1926
01:32:42,573 --> 01:32:44,490
So what's really going on underneath the hood?
所以，幕后究竟发生了什么？

1927
01:32:44,490 --> 01:32:46,160
Well, you can think of it like this.
你可以这样想。

1928
01:32:46,160 --> 01:32:50,060
If we've got this relationship between shows and genres,
如果节目和类型之间存在这种关系，

1929
01:32:50,060 --> 01:32:52,580
here's an excerpt from shows, and I didn't bother
这是从节目表中摘取的部分，我没有费心

1930
01:32:52,580 --> 01:32:54,170
showing the thousands of other shows.
展示成千上万的其他节目。

1931
01:32:54,170 --> 01:32:56,900
Here's an excerpt from genres on the right.
这是右边从类型表中摘取的部分。

1932
01:32:56,900 --> 01:33:00,530
What is that query-- what are we essentially trying to do?
那个查询到底— 我们想要做什么？

1933
01:33:00,530 --> 01:33:02,570
Well, let me flip this around here.
嗯，让我把这个翻转一下。

1934
01:33:02,570 --> 01:33:06,290
Let me highlight the fact that this is the same, this is the same,
让我强调一下，这个是一样的，这个也是一样的，

1935
01:33:06,290 --> 01:33:07,260
this is the same.
这个也是一样的。

1936
01:33:07,260 --> 01:33:10,040
So wouldn't it be nice if I could kind of get these all together?
如果我能把这些都整合在一起，是不是会很方便？

1937
01:33:10,040 --> 01:33:11,660
Well, if I join these tables, we're actually
如果我将这些表连接起来，我们实际上

1938
01:33:11,660 --> 01:33:13,370
going to notice an interesting artifact.
会注意到一个有趣的现象。

1939
01:33:13,370 --> 01:33:16,490
If I join them together, as we did before with ratings,
如果我将它们连接起来，就像我们之前对评分做的那样，

1940
01:33:16,490 --> 01:33:20,990
I'm going to need to fill in the gap there because this is not a table.
我需要填补那里的空白，因为这不是一张表。

1941
01:33:20,990 --> 01:33:24,860
Tables, by definition, always have the same number of rows and columns.
根据定义，表总是具有相同数量的行和列。

1942
01:33:24,860 --> 01:33:26,730
You can't have gaps in them like this.
你不能在表中出现这样的空白。

1943
01:33:26,730 --> 01:33:29,820
So the simplest thing to do is just to fill that in this way.
所以最简单的方法就是用这种方式填补空白。

1944
01:33:29,820 --> 01:33:33,170
But if I were to try to combine two tables that
但是，如果我尝试将两个表

1945
01:33:33,170 --> 01:33:36,320
have this one-to-many relationship, you're
具有这种一对多的关系，你就会

1946
01:33:36,320 --> 01:33:38,090
actually going to get duplication.
得到重复数据。

1947
01:33:38,090 --> 01:33:40,190
It's not duplication in the original tables,
它不是原始表中的重复数据，

1948
01:33:40,190 --> 01:33:43,850
but in the temporary tables, otherwise known as a result set,
而是在临时表中，也被称为结果集，

1949
01:33:43,850 --> 01:33:45,750
that's coming back to us.
它会返回给我们。

1950
01:33:45,750 --> 01:33:47,070
So what do I mean by this?
所以我的意思是什么？

1951
01:33:47,070 --> 01:33:50,060
Well, if we actually implement this same idea as before,
如果我们实际上像之前那样实现这个想法，

1952
01:33:50,060 --> 01:33:52,970
where we try to join these two tables, let
我们尝试将这两个表连接起来，让我们

1953
01:33:52,970 --> 01:33:55,640
me propose that we do it with this syntax.
提出用这种语法来做。

1954
01:33:55,640 --> 01:33:59,540
Let me do select star from shows join genres,
让我执行select star from shows join genres，

1955
01:33:59,540 --> 01:34:04,850
which is just like we did with ratings but now let's join it on shows.id
就像我们对评分做的那样，但现在我们把它连接到shows.id上

1956
01:34:04,850 --> 01:34:07,760
equals genres.show_ID.
等于genres.show_ID。

1957
01:34:07,760 --> 01:34:14,120
But let's just do this for Catweazel, where ID equals 63881, semicolon.
但我们只对Catweazel执行，where ID等于63881，分号。

1958
01:34:14,120 --> 01:34:16,250
With the ratings, it worked perfectly because it
对于评分来说，它工作得很好，因为它

1959
01:34:16,250 --> 01:34:19,920
was a one-to-one relationship, so the rows just got wider, if you will.
是一对一的关系，所以行只是变宽了，如果你愿意的话。

1960
01:34:19,920 --> 01:34:23,660
But now, because it's a one-to-many relationship, when
但现在，因为它是一对多的关系，当你

1961
01:34:23,660 --> 01:34:26,960
you execute these queries, you are going to get back duplicate data
执行这些查询时，你将会得到重复数据

1962
01:34:26,960 --> 01:34:28,400
but this is OK.
但这没关系。

1963
01:34:28,400 --> 01:34:30,740
It's considered OK because this is sort of ephemeral.
这被认为是可以接受的，因为这是一种短暂的现象。

1964
01:34:30,740 --> 01:34:32,540
These result sets, these temporary tables,
这些结果集，这些临时表，

1965
01:34:32,540 --> 01:34:34,700
exist just for us to look at the data, just
只存在是为了让我们查看数据，只是

1966
01:34:34,700 --> 01:34:36,440
for us to crunch the numbers somehow.
为了让我们以某种方式处理这些数字。

1967
01:34:36,440 --> 01:34:42,167
It's not actually stored in duplicate in the database itself.
它实际上并没有在数据库本身中重复存储。

1968
01:34:42,167 --> 01:34:44,000
If I wanted to tighten this further, though,
如果我想进一步缩小范围，

1969
01:34:44,000 --> 01:34:47,570
let me actually get rid of the star and let me just do title genre.
让我去掉星号，只执行title genre。

1970
01:34:47,570 --> 01:34:49,040
And, indeed, we can now see.
事实上，我们现在可以看到。

1971
01:34:49,040 --> 01:34:52,130
OK, Catweazel three times has three different categories.
好的，Catweazel出现了三次，有三个不同的类别。

1972
01:34:52,130 --> 01:34:54,440
But, generally, we don't even care about that so I
但是，一般来说，我们甚至不在乎，所以我可以

1973
01:34:54,440 --> 01:34:57,830
can even whittle this query down to just selecting genre,
把这个查询缩减到只选择genre，

1974
01:34:57,830 --> 01:35:00,500
and that, too, will just give me the result, effectively, hiding
这样也会给我结果，实际上，隐藏

1975
01:35:00,500 --> 01:35:01,550
the duplication.
重复数据。

1976
01:35:01,550 --> 01:35:04,957
But when you join data with a one-to-many relationship
但是，当你将一对多的数据连接在一起时，

1977
01:35:04,957 --> 01:35:07,790
you're temporarily going to get duplicates, which is actually useful
你会暂时得到重复数据，这实际上很有用

1978
01:35:07,790 --> 01:35:10,580
because it's very easy then to get at the show's title
因为这样很容易获得节目的标题

1979
01:35:10,580 --> 01:35:14,080
no matter where you are in some loop.
无论你在循环中的哪个位置。

1980
01:35:14,080 --> 01:35:14,620
All right.
好的。

1981
01:35:14,620 --> 01:35:15,912
Well, what more can we do here?
我们还能做什么呢？

1982
01:35:15,912 --> 01:35:19,470
Well let me propose that we revisit the main database, here with six tables,
让我建议我们重新审视一下主数据库，这里有六张表，

1983
01:35:19,470 --> 01:35:21,970
and let's look at, perhaps, the juiciest, and the one that's
让我们看看，也许，最吸引人的，也是最常用的

1984
01:35:21,970 --> 01:35:26,680
really what most people use IMDb for is to look up shows and people therein.
大多数人使用IMDb的目的是查询节目和节目中的演员。

1985
01:35:26,680 --> 01:35:28,300
Let's focus on these three tables.
让我们关注一下这三张表。

1986
01:35:28,300 --> 01:35:32,140
And we can infer, from this diagram, that there's now, for the first time,
我们可以从这个图中推断出，现在，第一次，

1987
01:35:32,140 --> 01:35:34,270
three tables involved in a relationship.
三张表参与到一个关系中。

1988
01:35:34,270 --> 01:35:38,710
There's people, there's shows, but I've proposed this intermediary stars
有演员，有节目，但我已经提出了这种中介明星

1989
01:35:38,710 --> 01:35:40,930
table, much like I temporarily, in Google Sheets,
表格，就像我在谷歌表格里临时做的那样，

1990
01:35:40,930 --> 01:35:44,120
gave us a third sheet to link the two together.
给了我们第三个表格来连接这两个表格。

1991
01:35:44,120 --> 01:35:46,810
This stars table we're about to see, it's purpose in life
我们即将看到的这个明星表格，它的生命意义

1992
01:35:46,810 --> 01:35:49,990
is to join two other tables together.
是将另外两个表格连接在一起。

1993
01:35:49,990 --> 01:35:54,670
And, in fact, it's only going to have two columns, show ID and person ID.
实际上，它只有两列，节目 ID 和演员 ID。

1994
01:35:54,670 --> 01:35:57,790
So what this is going to do for us is implement this idea,
所以，这对我们来说将实现这个想法，

1995
01:35:57,790 --> 01:35:59,360
many-to-many relationship.
多对多关系。

1996
01:35:59,360 --> 01:35:59,860
Why?
为什么？

1997
01:35:59,860 --> 01:36:02,810
Because any TV show can obviously have many people in it,
因为任何电视剧显然都可以有很多人参与，

1998
01:36:02,810 --> 01:36:06,670
but one person can presumably star in many different shows.
但一个人可能在许多不同的节目中担任主角。

1999
01:36:06,670 --> 01:36:09,680
Like, Steve Carell has been in multiple shows, not just The Office.
比如，史蒂夫·卡瑞尔出演过很多节目，不仅仅是《办公室》。

2000
01:36:09,680 --> 01:36:11,870
So when you have a many-to-many relationship,
所以，当你有这种多对多关系时，

2001
01:36:11,870 --> 01:36:16,655
you actually do need this third table to bridge the two any number of times.
你确实需要这个第三个表格来多次连接这两个表格。

2002
01:36:16,655 --> 01:36:19,280
But it's going to make our life a little more unpleasant to get
但这会让获取我们想要的数据变得更麻烦，

2003
01:36:19,280 --> 01:36:22,800
the data we want because it's going to add some additional steps, if you will.
因为它会增加一些额外的步骤，如果可以这么说。

2004
01:36:22,800 --> 01:36:24,300
So let me do this.
让我来做这个。

2005
01:36:24,300 --> 01:36:28,340
Suppose that I want to get everything I know about The Office.
假设我想获得关于《办公室》的一切信息。

2006
01:36:28,340 --> 01:36:30,800
Well, let's start with a single query here in VS Code.
好吧，让我们从 VS Code 中的单个查询开始。

2007
01:36:30,800 --> 01:36:35,780
Select star from shows where title equals, quote unquote, "The Office."
从节目表中选择“明星”，其中标题等于“The Office”。

2008
01:36:35,780 --> 01:36:37,130
And I should see--
我应该看到——

2009
01:36:37,130 --> 01:36:38,060
Oh, interesting.
哦，有趣。

2010
01:36:38,060 --> 01:36:41,810
Several attempts at creating a TV show called The Office over the years.
多年来，有好几次尝试制作一部名为《办公室》的电视剧。

2011
01:36:41,810 --> 01:36:45,740
You can, perhaps, infer the year in which the most popular of them began.
你可能可以推断出其中最受欢迎的那一部开始的年份。

2012
01:36:45,740 --> 01:36:46,910
2005?
2005？

2013
01:36:46,910 --> 01:36:49,580
So I presume this is the one we all know and have watched,
所以我想，这是我们都认识并看过的那一部，

2014
01:36:49,580 --> 01:36:54,200
at least in the US, which is this one, 386676, which matches the ID that I
至少在美国是这样，就是这一个，386676，这与我之前

2015
01:36:54,200 --> 01:36:55,770
very carefully used earlier.
非常小心使用的 ID 一致。

2016
01:36:55,770 --> 01:36:58,520
So let me actually be a little more deliberate,
所以，让我更认真一点，

2017
01:36:58,520 --> 01:37:02,690
where the title equals The Office and the year equals 2005.
其中标题等于《办公室》，年份等于 2005。

2018
01:37:02,690 --> 01:37:07,400
That query now gets us The Office that we all in the US and, perhaps, love.
这个查询现在让我们得到了我们所有人，在美国，可能都喜欢的《办公室》。

2019
01:37:07,400 --> 01:37:09,830
But now let's actually do something like, get
但现在让我们实际做一些事情，比如，获取

2020
01:37:09,830 --> 01:37:11,960
all of the people who starred in it, at least
所有在里面演主角的人，至少

2021
01:37:11,960 --> 01:37:14,650
according to IMDb, whoever had top billing.
根据 IMDb，无论是谁都有顶级账单。

2022
01:37:14,650 --> 01:37:16,370
So how can I do this?
我该怎么做呢？

2023
01:37:16,370 --> 01:37:20,350
Well, unfortunately, in the shows table there are no people,
不幸的是，在节目表中没有演员，

2024
01:37:20,350 --> 01:37:24,310
and there's no stars even, but I could do a nested query like this.
甚至也没有明星，但我可以做这样一个嵌套查询。

2025
01:37:24,310 --> 01:37:32,350
Why don't I select the person ID from the stars table where--
为什么不从明星表中选择演员 ID 呢？——

2026
01:37:32,350 --> 01:37:45,990
whoops, where the-- sorry, where show ID equals, and then in parentheses
哎呀，在哪里——抱歉，节目 ID 等于，然后在括号里

2027
01:37:45,990 --> 01:37:48,430
let me do that same query as before and for time's sake,
让我做之前一样的查询，为了节省时间，

2028
01:37:48,430 --> 01:37:52,260
I'll just copy paste so that we get back the one and only
我只会复制粘贴，这样我们就可以得到唯一一个

2029
01:37:52,260 --> 01:37:53,640
Office in that subquery.
在那个子查询中的《办公室》。

2030
01:37:53,640 --> 01:37:56,710
So what I'm going to do is take an intermediate step, a baby step,
所以，我要做的是迈出一小步，一小步，

2031
01:37:56,710 --> 01:37:57,240
if you will.
如果可以这么说。

2032
01:37:57,240 --> 01:38:00,992
Right now, I have found in the shows table The Office I care about.
现在，我在节目表中找到了我关心的《办公室》。

2033
01:38:00,992 --> 01:38:02,700
But if I want to get to the people table,
但如果我想进入演员表，

2034
01:38:02,700 --> 01:38:06,720
I have to take a step through the stars table, this intermediate table, just
我必须通过明星表，这个中间表，一步步地进行，

2035
01:38:06,720 --> 01:38:09,130
to get anywhere close to the names of those people.
才能接近那些人的名字。

2036
01:38:09,130 --> 01:38:11,070
So what can I get from the stars table?
那么，我能从明星表中得到什么？

2037
01:38:11,070 --> 01:38:14,040
Well, why don't I at least select all of the person
好吧，为什么不至少选择所有与

2038
01:38:14,040 --> 01:38:18,340
IDs in that table that are somehow associated with the same show ID?
同一个节目 ID 相关的演员 ID 呢？

2039
01:38:18,340 --> 01:38:20,340
So in VS Code, what I'm doing is this.
所以在 VS Code 中，我正在做的是这个。

2040
01:38:20,340 --> 01:38:23,340
Select person ID from that intermediate stars
从那个中间明星表中选择演员 ID，

2041
01:38:23,340 --> 01:38:27,690
table, where the show ID in question is whatever the show ID is for The Office.
其中所讨论的节目 ID 是《办公室》的节目 ID。

2042
01:38:27,690 --> 01:38:30,510
I could literally type 386676, but I'm trying
我可以直接输入 386676，但我正在尝试

2043
01:38:30,510 --> 01:38:33,630
to do this more dynamically so I've used a nested query instead.
更动态地进行，所以我使用了嵌套查询。

2044
01:38:33,630 --> 01:38:34,890
All right, this is correct.
好的，这是正确的。

2045
01:38:34,890 --> 01:38:36,760
Whoops, ironically.
哎呀，讽刺的是。

2046
01:38:36,760 --> 01:38:38,085
Where show ID--
节目 ID 在哪里——

2047
01:38:41,540 --> 01:38:42,440
Oh, thank you.
哦，谢谢。

2048
01:38:42,440 --> 01:38:43,610
Oh, who said that?
哦，谁说的？

2049
01:38:43,610 --> 01:38:44,570
OK.
好的。

2050
01:38:44,570 --> 01:38:45,110
Batman.
蝙蝠侠。

2051
01:38:45,110 --> 01:38:47,370
I owe Batman Oreos after class.
下课后我要给蝙蝠侠奥利奥饼干。

2052
01:38:47,370 --> 01:38:48,470
Thank you, Batman.
谢谢，蝙蝠侠。

2053
01:38:48,470 --> 01:38:50,330
That's de facto.
那是事实。

2054
01:38:50,330 --> 01:38:50,930
Yes.
是的。

2055
01:38:50,930 --> 01:38:52,355
Other good prize for that costume.
那个服装的其他好奖品。

2056
01:38:52,355 --> 01:38:53,330
[LAUGHS]
[笑声]

2057
01:38:53,330 --> 01:38:55,160
OK, so let me fix this.
好的，让我来修复这个。

2058
01:38:55,160 --> 01:38:55,910
My apologies.
抱歉。

2059
01:38:55,910 --> 01:38:58,790
So let's go ahead and select person ID from stars
所以，让我们继续从明星表中选择演员 ID，

2060
01:38:58,790 --> 01:39:02,390
where show ID equals, and this is where I messed up before.
其中节目 ID 等于，这是我之前搞错的地方。

2061
01:39:02,390 --> 01:39:05,510
I did select star from shows, but I can't
我确实从节目表中选择了明星，但我不能

2062
01:39:05,510 --> 01:39:09,410
look for a show ID equaling an entire row of information.
寻找与整行信息相等的节目 ID。

2063
01:39:09,410 --> 01:39:16,160
I instead need to do select ID from shows where the shows title equals,
相反，我需要做的是从节目表中选择 ID，其中节目标题等于，

2064
01:39:16,160 --> 01:39:20,510
quote unquote, "The Office" and the year of that show is 2005.
双引号，“The Office”，并且那个节目的年份是 2005。

2065
01:39:20,510 --> 01:39:25,340
And just to call this out, much like in C, I'm quoting strings,
我需要说明一下，就像在 C 语言中一样，我使用引号引用字符串，

2066
01:39:25,340 --> 01:39:26,780
but I'm not quoting numbers.
但我没有引用数字。

2067
01:39:26,780 --> 01:39:28,910
It's not necessary for something like 2005.
对于像 2005 这样的数字，这是不必要的。

2068
01:39:28,910 --> 01:39:33,410
And just to be super clear, too, I have generally adopted a style already today
为了超级清楚起见，今天我通常已经采用了这样一种风格

2069
01:39:33,410 --> 01:39:37,850
of capitalizing any SQL keywords, like select, like from, like where,
将所有 SQL 关键字的首字母大写，比如 select、from、where，

2070
01:39:37,850 --> 01:39:40,470
and so forth, and then using lowercase for everything else.
等等，然后将其他所有内容都使用小写。

2071
01:39:40,470 --> 01:39:42,180
Strictly speaking, that's not necessary.
严格来说，这并不是必需的。

2072
01:39:42,180 --> 01:39:44,130
Stylistically, we would encourage you to be
从风格上来说，我们鼓励你

2073
01:39:44,130 --> 01:39:46,592
in the habit of using uppercase for your SQL keywords
养成将 SQL 关键字用大写字母书写的习惯

2074
01:39:46,592 --> 01:39:48,300
because they just pop more on the screen.
因为它们在屏幕上更突出。

2075
01:39:48,300 --> 01:39:49,883
It sort of makes things more readable.
这会让代码更易读。

2076
01:39:49,883 --> 01:39:52,200
But strictly speaking, SQL itself does not care
但严格来说，SQL 本身并不关心

2077
01:39:52,200 --> 01:39:54,690
about that capitalization of keywords.
关键字的大小写。

2078
01:39:54,690 --> 01:39:56,490
All right, now let me cross my fingers.
好的，现在让我祈祷一下。

2079
01:39:56,490 --> 01:39:59,100
And now I get back this list of person IDs.
现在我得到了这个演员 ID 列表。

2080
01:39:59,100 --> 01:40:00,840
And, again, my goal was to figure out who
我的目标还是弄清楚谁

2081
01:40:00,840 --> 01:40:03,018
is in The Office that debuted in 2005.
是 2005 年首播的《办公室》中的演员。

2082
01:40:03,018 --> 01:40:06,060
This is not that interesting because I don't know who any of these people
这不太有趣，因为我不知道这些人是谁

2083
01:40:06,060 --> 01:40:08,820
are, but here's where we can do one additional step
但是，我们可以在这里再做一步

2084
01:40:08,820 --> 01:40:10,650
and nest a nested query.
嵌套一个嵌套查询。

2085
01:40:10,650 --> 01:40:15,000
So let me actually select the names from the people table
所以，我实际上是从人员表中选择姓名

2086
01:40:15,000 --> 01:40:18,720
where the ID of those people is in.
这些人的ID在里面。

2087
01:40:18,720 --> 01:40:20,820
And then on a new line, just to make it pretty,
然后在新的一行，为了美观起见，

2088
01:40:20,820 --> 01:40:26,770
where the ID equals this query, which I'll paste here,
其中ID等于这个查询，我将把它粘贴到这里，

2089
01:40:26,770 --> 01:40:31,260
and then that equals, and then another line and indent further,
然后它等于，然后是另一行，并进一步缩进，

2090
01:40:31,260 --> 01:40:32,602
this query here.
这里的查询。

2091
01:40:32,602 --> 01:40:35,310
So just to save time, I'm copying and pasting the previous query,
为了节省时间，我复制粘贴了之前的查询，

2092
01:40:35,310 --> 01:40:38,970
but I'm wrapping it with one outermost query, now, that's
但我现在用一个最外层的查询把它包起来，那就是

2093
01:40:38,970 --> 01:40:42,690
saying select names from people where the ID of those people
说从人员表中选择姓名，其中这些人的ID

2094
01:40:42,690 --> 01:40:47,940
is in this result set, where the ID of those shows is in this result set.
在该结果集中，其中这些节目的ID在该结果集中。

2095
01:40:47,940 --> 01:40:52,170
So the parentheses make clear, ideally, what's happening
所以括号理想地清楚地说明了正在发生的事情

2096
01:40:52,170 --> 01:40:53,790
and what order from inside out.
以及从内到外的顺序。

2097
01:40:53,790 --> 01:40:54,540
Enter.
输入。

2098
01:40:54,540 --> 01:40:58,860
And there we have it, at least according to IMDb, for the latest season,
至少根据IMDb的说法，这就是最新一季的，

2099
01:40:58,860 --> 01:41:04,350
like this is the top-billed stars that are in this here database.
就像这是在这个数据库中的主演。

2100
01:41:04,350 --> 01:41:04,860
All right.
好的。

2101
01:41:04,860 --> 01:41:06,302
So how can we do something else?
我们还能做些什么呢？

2102
01:41:06,302 --> 01:41:08,260
Well, let me just do it in the other direction.
好吧，让我反过来做。

2103
01:41:08,260 --> 01:41:11,177
Suppose we want to see all of Steve Carell shows, not just The Office.
假设我们想看看所有史蒂夫·卡瑞尔的节目，而不仅仅是《办公室》。

2104
01:41:11,177 --> 01:41:16,650
Select title from shows where the ID of the show is in.
从节目表中选择标题，其中节目的ID在里面。

2105
01:41:16,650 --> 01:41:18,990
And then here, I'm going to do select show
然后在这里，我将执行select show

2106
01:41:18,990 --> 01:41:24,150
ID from stars where person ID equals.
ID 从明星表中，其中人员ID等于。

2107
01:41:24,150 --> 01:41:26,490
And then here, indenting for clarity, I'm
然后在这里，为了清晰起见，我

2108
01:41:26,490 --> 01:41:28,740
going to select Steve Carell's ID by saying,
将通过说选择史蒂夫·卡瑞尔的ID，

2109
01:41:28,740 --> 01:41:32,850
select ID from people where the name of that person is,
从人员表中选择ID，其中该人员的姓名是，

2110
01:41:32,850 --> 01:41:35,040
quote unquote, "Steve Carell."
引号引起来，"史蒂夫·卡瑞尔"。

2111
01:41:35,040 --> 01:41:36,780
And so in this way,
所以用这种方法，

2112
01:41:36,780 --> 01:41:42,250
I'm writing the SQL query sort of in reverse.
我正在反向编写SQL查询。

2113
01:41:42,250 --> 01:41:44,102
I'm asking first what I care about.
我首先问的是我关心的问题。

2114
01:41:44,102 --> 01:41:45,810
But before I can even answer that, I have
但我甚至在回答这个问题之前，我有

2115
01:41:45,810 --> 01:41:48,510
to answer this nested query, what is Steve Carell's ID?
要回答这个嵌套查询，史蒂夫·卡瑞尔的ID是什么？

2116
01:41:48,510 --> 01:41:52,320
Once I have that, what are all the show IDs that person ID has been in?
一旦有了它，该人员ID参与过哪些节目ID？

2117
01:41:52,320 --> 01:41:55,740
And then, please tell me what the title of all of those shows is.
然后，请告诉我所有这些节目的标题是什么。

2118
01:41:55,740 --> 01:41:57,510
Let me go ahead and cross my fingers.
让我拭目以待。

2119
01:41:57,510 --> 01:41:58,200
And, voila.
看，就是它。

2120
01:41:58,200 --> 01:42:00,950
Some of these you might have heard of, some of you might not have,
你们中有些人可能听说过这些，有些人可能没有听说过，

2121
01:42:00,950 --> 01:42:03,750
but if you were to go on imdb.com and search for Steve Carell,
但如果你去imdb.com搜索史蒂夫·卡瑞尔，

2122
01:42:03,750 --> 01:42:08,445
you would presumably see this here list of shows that he's been in,
你可能会看到这个他参与过的节目列表，

2123
01:42:08,445 --> 01:42:11,410
in some particular order.
以某种特定的顺序。

2124
01:42:11,410 --> 01:42:15,330
Just to show you two other syntaxes, but let me not emphasize this
只是为了向你们展示另外两种语法，但我不想强调这一点

2125
01:42:15,330 --> 01:42:17,200
because it will look complicated.
因为它看起来很复杂。

2126
01:42:17,200 --> 01:42:19,500
There are other ways to solve this same problem.
还有其他方法可以解决同样的问题。

2127
01:42:19,500 --> 01:42:21,660
If you prefer the approach of joining, we
如果你更喜欢使用联接的方法，我们可以

2128
01:42:21,660 --> 01:42:25,720
can actually join not just two, but three tables together.
实际上不仅可以联接两个表，还可以联接三个表。

2129
01:42:25,720 --> 01:42:26,535
But question first.
但首先是问题。

2130
01:42:26,535 --> 01:42:28,310
[INDISTINCT SPEECH]
（不清楚的讲话）

2131
01:42:28,310 --> 01:42:29,810
No, just stretching first.
不，我只是先伸展一下。

2132
01:42:29,810 --> 01:42:35,120
So two final ways to execute the same idea, but the first of them that I just
所以执行同一个想法的最后两种方法，但我刚刚做的第一个

2133
01:42:35,120 --> 01:42:37,850
did is arguably, relatively, simpler.
可以说是相对简单的。

2134
01:42:37,850 --> 01:42:38,910
You could do this.
你可以这样做。

2135
01:42:38,910 --> 01:42:42,800
I could select the title from the shows table
我可以从节目表中选择标题

2136
01:42:42,800 --> 01:42:49,220
by joining it on the stars table on the shows ID column,
通过在节目ID列上将它与明星表联接起来，

2137
01:42:49,220 --> 01:42:52,820
equaling the stars tables show ID column.
等于明星表中的节目ID列。

2138
01:42:52,820 --> 01:42:58,460
And then I can further join it on the people table, on stars dot person ID
然后我可以进一步在人员表上联接它，在stars.person ID上

2139
01:42:58,460 --> 01:43:00,453
equaling people.id.
等于people.id。

2140
01:43:00,453 --> 01:43:03,620
This is a mouthful, and even I am kind of crossing my fingers that it didn't
这太复杂了，我甚至有点希望它在从我的打印稿中转录时没有

2141
01:43:03,620 --> 01:43:06,510
screw up when transcribing it from my printout here,
出错，

2142
01:43:06,510 --> 01:43:11,180
but what I'm effectively doing is joining one, two, three tables all
但我实际上是在将一个、两个、三个表全部

2143
01:43:11,180 --> 01:43:17,570
together by telling the database how to join the shows table, with the stars
联接起来，通过告诉数据库如何将节目表与明星表

2144
01:43:17,570 --> 01:43:19,070
table, and the people table.
以及人员表联接起来。

2145
01:43:19,070 --> 01:43:22,940
Specifically, the way to bridge that picture, per the diagram,
具体来说，根据图表，连接这些图片的方法是

2146
01:43:22,940 --> 01:43:28,890
is to specify that shows.id should be lined up with stars.show ID.
指定shows.id应该与stars.show ID对齐。

2147
01:43:28,890 --> 01:43:34,380
And stars.person ID should be lined up with people ID.
stars.person ID应该与people ID对齐。

2148
01:43:34,380 --> 01:43:35,008
And that's it.
就是这样。

2149
01:43:35,008 --> 01:43:37,050
That essentially allows us to connect these three
这本质上允许我们连接这三个

2150
01:43:37,050 --> 01:43:39,000
tables with their common fields.
表及其公共字段。

2151
01:43:39,000 --> 01:43:42,390
If I hit enter now, I'm going to get back, somewhat slowly
如果我现在按下回车键，我将得到一个相当慢的反馈

2152
01:43:42,390 --> 01:43:47,160
actually, a really long list, with some duplication,
实际上，是一个非常长的列表，包含一些重复的内容，

2153
01:43:47,160 --> 01:43:49,830
of all of those particular shows.
所有这些特定的节目。

2154
01:43:49,830 --> 01:43:52,182
Actually, all shows in the database because I
实际上，是数据库中的所有节目，因为我

2155
01:43:52,182 --> 01:43:53,640
didn't practice what I'm preaching.
没有实践我所宣扬的。

2156
01:43:53,640 --> 01:43:56,140
I wanted to search for just Steve Carell, what you're seeing
我想搜索史蒂夫·卡瑞尔，你看到的是

2157
01:43:56,140 --> 01:43:58,950
is the entirety of the tens of thousands of TV shows.
成千上万的电视剧。

2158
01:43:58,950 --> 01:44:00,360
Control C is your friend.
Ctrl+C 是你的朋友。

2159
01:44:00,360 --> 01:44:05,070
Let me go ahead and reload SQLite, and let me type that again.
让我继续重新加载SQLite，让我再打一遍。

2160
01:44:05,070 --> 01:44:06,690
Let me type that once more, sorry.
让我再说一遍，对不起。

2161
01:44:06,690 --> 01:44:13,320
Select title from shows, join stars on shows.id equals stars.show ID,
从节目表中选择标题，在shows.id等于stars.show ID的情况下，将stars与之联接，

2162
01:44:13,320 --> 01:44:20,872
join people on stars.person ID equals people ID where--
在stars.person ID等于people ID的情况下，将people与之联接，其中--

2163
01:44:20,872 --> 01:44:22,080
this was the part I left out.
这是我遗漏的部分。

2164
01:44:22,080 --> 01:44:24,990
Name equals Steve Carell.
姓名等于史蒂夫·卡瑞尔。

2165
01:44:24,990 --> 01:44:28,710
And if I didn't screw up by typing so fast-- enter.
如果我没有因为打字太快而弄错-- 回车。

2166
01:44:28,710 --> 01:44:31,500
Now we get, a little more slowly than before,
现在我们得到，比以前慢一点，

2167
01:44:31,500 --> 01:44:34,435
those same shows that Steve Carell starred in.
史蒂夫·卡瑞尔主演的那些节目。

2168
01:44:34,435 --> 01:44:36,810
So this is just to say there's another way of doing this.
所以，这只是说还有另一种方法可以做到这一点。

2169
01:44:36,810 --> 01:44:39,420
But maybe a third way, which is a little simpler than that,
但也许第三种方法，比那种方法简单一些，

2170
01:44:39,420 --> 01:44:41,250
explicitly joining them in that way.
以这种方式显式地将它们联接起来。

2171
01:44:41,250 --> 01:44:47,490
You can, alternatively, still do this, select title from shows, stars,
或者，你仍然可以这样做，从节目表、明星表中选择标题，

2172
01:44:47,490 --> 01:44:48,270
and people.
以及人员表。

2173
01:44:48,270 --> 01:44:51,480
You just literally enumerate, with commas, what three tables
你只需用逗号列出要联接的三个表。

2174
01:44:51,480 --> 01:44:52,920
you want to join somehow.
你想联接它们。

2175
01:44:52,920 --> 01:44:55,020
And then you can instead of using join, you
然后，你可以使用where子句而不是使用join，你

2176
01:44:55,020 --> 01:44:58,560
can just use where clauses to make sure they line up properly.
可以使用where子句来确保它们正确对齐。

2177
01:44:58,560 --> 01:45:03,630
You can say, where shows.id equals stars.show ID,
你可以说，在shows.id等于stars.show ID的情况下，

2178
01:45:03,630 --> 01:45:09,180
and people ID equals stars.person ID, and name
并且人员ID等于stars.person ID，并且姓名

2179
01:45:09,180 --> 01:45:11,760
equals, quote unquote, "Steve Carell."
等于，引号引起来，"史蒂夫·卡瑞尔"。

2180
01:45:11,760 --> 01:45:14,430
And I realize this is hard to keep track of everything now,
我意识到现在很难跟踪所有内容，

2181
01:45:14,430 --> 01:45:16,353
all these darn different ways to do this,
所有这些不同的方法

2182
01:45:16,353 --> 01:45:19,020
this is just to say that there's different approaches to solving
我只是想说，解决问题的方法有很多种

2183
01:45:19,020 --> 01:45:20,728
the same problem and for different people
对于同一个问题，不同的人可能有不同的方法

2184
01:45:20,728 --> 01:45:23,970
you might think about things a little more differently than someone else.
你可能比其他人考虑问题的方式更不一样

2185
01:45:23,970 --> 01:45:27,630
If I hit enter here, this too it's a little slower than the nested selects
如果我在这里按回车，这确实比嵌套选择慢一点

2186
01:45:27,630 --> 01:45:31,590
it seems, but it does, in fact, give us that same answer.
虽然看起来很慢，但事实上它确实给了我们相同的答案

2187
01:45:31,590 --> 01:45:34,440
And just for thoroughness, if I go back to our diagram.
为了完整起见，如果我回到我们的图表

2188
01:45:34,440 --> 01:45:38,700
Besides the tables we've seen, there's actually another writers table
除了我们看到的表格，实际上还有一个 writers 表格

2189
01:45:38,700 --> 01:45:39,480
in there, as well.
也在里面

2190
01:45:39,480 --> 01:45:42,480
If you're curious to see what writers is, let's just glance at that real
如果你好奇 writers 是什么，我们快速看一下

2191
01:45:42,480 --> 01:45:42,980
fast.
就好

2192
01:45:42,980 --> 01:45:47,010
In VS Code, let me do .schema writers, and it's actually almost the same
在 VS Code 中，让我执行 .schema writers，它实际上几乎与 stars 相同

2193
01:45:47,010 --> 01:45:48,330
as stars.
一样

2194
01:45:48,330 --> 01:45:52,440
Except this case, in writers, we are associating a show
除了在这种情况下，在 writers 中，我们将一个节目

2195
01:45:52,440 --> 01:45:54,750
with a person ID, both of which in this context
与一个人员 ID 关联，在这两种情况下

2196
01:45:54,750 --> 01:45:58,770
are foreign keys that indeed reference back shows and people ID.
都是外键，确实引用了 shows 和 people ID。

2197
01:45:58,770 --> 01:46:02,520
Which, again, if I do this schema stars, which we didn't see before,
同样，如果我执行 schema stars，我们之前没有看到

2198
01:46:02,520 --> 01:46:04,120
is structurally the same.
结构上是一样的

2199
01:46:04,120 --> 01:46:06,540
So the relationship is essentially embodied, in this case,
所以这种关系基本上体现在这里，在这种情况下

2200
01:46:06,540 --> 01:46:12,690
by IMDb, and in turn by us, by way of the tables name, TV stars or writers
由 IMDb 体现，反过来也由我们体现，通过表名，TV stars 或 writers

2201
01:46:12,690 --> 01:46:14,410
thereof.
体现出来

2202
01:46:14,410 --> 01:46:14,940
All right.
好吧

2203
01:46:14,940 --> 01:46:16,000
I know that's a lot.
我知道很多

2204
01:46:16,000 --> 01:46:19,720
Any questions before we take a higher level step back?
在我们退一步看之前有什么问题吗？

2205
01:46:19,720 --> 01:46:20,220
Yeah.
是的

2206
01:46:20,220 --> 01:46:22,992
[INDISTINCT SPEECH]
[模糊不清的语音]

2207
01:46:25,183 --> 01:46:25,850
A good question.
好问题

2208
01:46:25,850 --> 01:46:28,400
Does SQL provide any way to figure out the mapping between tables
SQL 提供了任何方法来找出表之间的映射

2209
01:46:28,400 --> 01:46:29,540
without looking at the database?
而不用查看数据库吗？

2210
01:46:29,540 --> 01:46:30,380
Short answer, no.
简短的答案是，没有

2211
01:46:30,380 --> 01:46:32,668
Like, this is the dia-- well, that's not quite fair.
比如，这是 dia-- 嗯，这不是很公平

2212
01:46:32,668 --> 01:46:34,460
Depending on the database you're using, you
取决于你使用的数据库，你

2213
01:46:34,460 --> 01:46:36,080
might be able to click a button, for instance,
也许可以点击一个按钮，例如

2214
01:46:36,080 --> 01:46:38,997
and get a nice pretty picture like this, that shows the relationships.
然后得到一个漂亮的照片，像这样，显示了关系

2215
01:46:38,997 --> 01:46:40,730
Indeed, we use software to generate this.
确实，我们使用软件来生成它

2216
01:46:40,730 --> 01:46:42,980
We didn't do this diagram, for instance, by hand.
比如，我们不是手工绘制这个图的

2217
01:46:42,980 --> 01:46:45,530
SQLite itself does not provide you with that.
SQLite 本身不提供给你这个

2218
01:46:45,530 --> 01:46:48,425
In SQLite the best you can do is run .schema.
在 SQLite 中，你能做的最好的事情就是运行 .schema

2219
01:46:48,425 --> 01:46:50,300
And if you don't specify a table name, you'll
如果你没有指定表名，你会

2220
01:46:50,300 --> 01:46:52,120
get everything from the table described.
得到表中描述的所有内容

2221
01:46:52,120 --> 01:46:53,870
Once you get comfortable with SQL, though,
但是，一旦你熟悉了 SQL

2222
01:46:53,870 --> 01:46:56,240
the idea is that you can read the text and sort of infer what
想法是你能阅读文本，然后推断出

2223
01:46:56,240 --> 01:46:57,080
the structure is.
结构是什么

2224
01:46:57,080 --> 01:46:58,850
But, yes, there are graphical programs can
但是，是的，有一些图形程序可以

2225
01:46:58,850 --> 01:47:00,710
generate prettier pictures like this, but it
生成更漂亮的图片，像这样，但是它

2226
01:47:00,710 --> 01:47:02,900
depends on the software you're using.
取决于你使用的软件

2227
01:47:02,900 --> 01:47:03,470
Yeah.
是的

2228
01:47:03,470 --> 01:47:06,600
[INDISTINCT SPEECH]
[模糊不清的语音]

2229
01:47:06,600 --> 01:47:10,590
SQL is not case sensitive with respect to its keywords.
SQL 对其关键字不区分大小写

2230
01:47:10,590 --> 01:47:13,920
But table names, and other things that you chose,
但表名和其他你选择的东西

2231
01:47:13,920 --> 01:47:16,452
you've got to be consistent with how you capitalize them.
你必须始终如一地使用大写字母

2232
01:47:16,452 --> 01:47:19,410
I've done everything in lowercase, but that tends to be one convention.
我所有内容都使用小写，但这是一种惯例

2233
01:47:19,410 --> 01:47:23,970
Other people might use camel case, where you alternate caps appropriately.
其他人可能使用驼峰式命名法，你可以在其中适当交替使用大写字母

2234
01:47:23,970 --> 01:47:26,737
All right, so let's take a higher level look at this,
好吧，让我们从更高层次看看这个

2235
01:47:26,737 --> 01:47:29,820
and also consider some of the actual real world problems that, tragically,
并考虑一些现实世界中的问题，不幸的是

2236
01:47:29,820 --> 01:47:32,200
are still with us in some form today.
今天仍然以某种形式存在

2237
01:47:32,200 --> 01:47:34,980
Notice that some of the queries we executed a bit ago
请注意，我们之前执行的一些查询

2238
01:47:34,980 --> 01:47:38,440
were actually relatively slow whereas I hit enter and got a lot of my results
实际上比较慢，而我按回车就得到了很多结果

2239
01:47:38,440 --> 01:47:38,940
like that.
像这样

2240
01:47:38,940 --> 01:47:41,130
Those last two queries, where I was joining
最后两个查询，我在其中连接

2241
01:47:41,130 --> 01:47:43,500
all of those tables looking for Steve Carell's shows
所有这些表格，查找史蒂夫·卡瑞尔的节目

2242
01:47:43,500 --> 01:47:45,138
were actually relatively slow.
实际上比较慢

2243
01:47:45,138 --> 01:47:46,680
And let's try to take a simpler case.
让我们尝试一个更简单的例子

2244
01:47:46,680 --> 01:47:47,310
Let me do this.
让我这样做

2245
01:47:47,310 --> 01:47:51,480
In SQLite you can actually time your queries by running .timer and then
在 SQLite 中，你可以通过运行 .timer 然后计时你的查询

2246
01:47:51,480 --> 01:47:52,330
turning it on.
打开它

2247
01:47:52,330 --> 01:47:55,620
This is just going to keep track now of how many seconds or milliseconds any
现在它只会记录任何

2248
01:47:55,620 --> 01:47:57,787
of your queries take if you're curious to figure out
查询需要多少秒或毫秒，如果你想知道

2249
01:47:57,787 --> 01:47:58,930
what's faster, what's slow.
什么更快，什么更慢

2250
01:47:58,930 --> 01:48:00,930
Let me do something relatively simple like this,
让我做一些相对简单的，像这样

2251
01:48:00,930 --> 01:48:04,860
select star from shows where the title of the show equals,
select star from shows where the title of the show equals

2252
01:48:04,860 --> 01:48:07,198
quote unquote, "The Office," semicolon.
引号，引号，"The Office"，分号

2253
01:48:07,198 --> 01:48:08,740
All right, that was pretty darn fast.
好吧，这很快

2254
01:48:08,740 --> 01:48:13,240
And it took 0.044 seconds in reality.
实际上它花费了 0.044 秒

2255
01:48:13,240 --> 01:48:16,210
If you care further, you can break this time down into user time,
如果你更关心，你可以将这段时间细分为用户时间

2256
01:48:16,210 --> 01:48:18,708
like spent in my account, versus system time, which means
比如花在我的账户上的时间，与系统时间相比，这意味着

2257
01:48:18,708 --> 01:48:20,500
spent in the operating system, essentially.
花在操作系统上的时间，本质上

2258
01:48:20,500 --> 01:48:28,120
But we'll focus on the real wall-clock time of 0.044 seconds.
但我们将关注 0.044 秒的实际时间

2259
01:48:28,120 --> 01:48:29,290
Pretty darn fast.
很快

2260
01:48:29,290 --> 01:48:32,770
But we can actually do better because it turns out in the world of SQL,
但实际上我们可以做得更好，因为在 SQL 的世界里

2261
01:48:32,770 --> 01:48:37,690
you can create what are called indexes, which is a fancy way of saying a data
你可以创建所谓的索引，这是一种花哨的说法，指的是数据

2262
01:48:37,690 --> 01:48:41,170
structure that makes it faster to perform queries,
结构，它使得执行查询更快

2263
01:48:41,170 --> 01:48:43,660
like selects, and even other queries as well.
比如 selects，以及其他查询

2264
01:48:43,660 --> 01:48:46,180
In an index, you can use syntax like this,
在索引中，你可以使用这样的语法

2265
01:48:46,180 --> 01:48:49,420
create index, the name of the index, on a specific table
create index，索引的名称，在特定表上

2266
01:48:49,420 --> 01:48:50,710
on the specific columns.
在特定列上

2267
01:48:50,710 --> 01:48:54,340
And what I mean by this is if you know that your application, like imdb.com
我的意思是，如果你知道你的应用程序，比如 imdb.com

2268
01:48:54,340 --> 01:48:58,480
or their mobile app, is going to search on certain columns frequently,
或他们的移动应用程序，将经常在某些列上进行搜索

2269
01:48:58,480 --> 01:49:01,240
you can prepare the database in advance to build up
你可以提前准备数据库，构建

2270
01:49:01,240 --> 01:49:04,450
some fancy data structures in memory so it can get back answers
一些内存中的花哨数据结构，这样它就可以更快地得到答案

2271
01:49:04,450 --> 01:49:06,080
even faster than that.
比那更快

2272
01:49:06,080 --> 01:49:08,200
So case in point, let me go back to VS Code
所以，举个例子，让我回到 VS Code

2273
01:49:08,200 --> 01:49:12,700
here, and let me create an index called, whatever, title index,
这里，让我创建一个名为，随便什么，title index 的索引

2274
01:49:12,700 --> 01:49:17,180
for instance on the shows table, specifically on the title column.
比如在 shows 表上，特别是在 title 列上

2275
01:49:17,180 --> 01:49:20,830
So that's simply the syntax for telling the database in advance,
所以这只是告诉数据库提前

2276
01:49:20,830 --> 01:49:23,350
index this column because I'm going to do a lot of searching
索引这列，因为我要做很多搜索

2277
01:49:23,350 --> 01:49:25,210
on it so I want the queries to be fast.
为了让查询速度快，我要做点什么。

2278
01:49:25,210 --> 01:49:26,020
Enter.
输入。

2279
01:49:26,020 --> 01:49:26,920
It took a moment.
等了一会。

2280
01:49:26,920 --> 01:49:30,010
It took almost half a second, but the index I only have to build once.
花了将近半秒钟，但索引我只用建一次。

2281
01:49:30,010 --> 01:49:32,320
Even though, technically, you have to maintain it over time if you're
即使从技术上讲，如果你需要

2282
01:49:32,320 --> 01:49:34,210
doing updates, deletes, and inserts.
进行更新、删除和插入操作，你需要维护它。

2283
01:49:34,210 --> 01:49:36,610
But now let me do the same query as before,
现在，让我执行之前相同的查询，

2284
01:49:36,610 --> 01:49:41,530
select star from shows where title equals, quote unquote, "The Office."
从 shows 表中选择星级，其中标题等于，双引号，“The Office”。

2285
01:49:41,530 --> 01:49:45,580
Previously, that query took 0.044 seconds.
之前，该查询耗时 0.044 秒。

2286
01:49:45,580 --> 01:49:47,080
When I hit enter now?
我现在按下回车键？

2287
01:49:47,080 --> 01:49:47,890
Boom.
啪。

2288
01:49:47,890 --> 01:49:50,770
I mean, it takes no time at all, or less time
我的意思是，它根本不需要时间，或者比

2289
01:49:50,770 --> 01:49:53,998
than it's even keeping track of in terms of significant digits.
它在有效数字方面记录的时间还要短。

2290
01:49:53,998 --> 01:49:57,040
Now, that might not seem like a big deal to us humans and our human eyes,
现在，这对于我们人类和我们的眼睛来说可能看起来并不重要，

2291
01:49:57,040 --> 01:49:59,620
but if you've got hundreds, thousands, millions of users,
但如果你有数百、数千、数百万的用户，

2292
01:49:59,620 --> 01:50:03,580
as maybe the real imdb.com has, you just saved yourself
就像真实的 imdb.com 一样，你就可以节省

2293
01:50:03,580 --> 01:50:05,900
a fortune in servers and complexity.
大量服务器和复杂性。

2294
01:50:05,900 --> 01:50:06,400
Why?
为什么？

2295
01:50:06,400 --> 01:50:08,320
Because the same server can, clearly, now
因为同一台服务器现在显然可以

2296
01:50:08,320 --> 01:50:12,400
handle way more people per unit of time, per second, because each query
每单位时间，每秒处理更多的人，因为每个查询

2297
01:50:12,400 --> 01:50:14,027
takes less and less time.
所用的时间越来越少。

2298
01:50:14,027 --> 01:50:16,360
I mean, we're all too familiar here and at Yale, surely,
我的意思是，我们在这里和耶鲁都太熟悉了，当然，

2299
01:50:16,360 --> 01:50:19,087
with certain University applications that are just so darn slow.
对于某些大学应用程序，它们实在是太慢了。

2300
01:50:19,087 --> 01:50:20,920
When you click a button and the stupid thing
当你点击一个按钮，这件愚蠢的事

2301
01:50:20,920 --> 01:50:23,740
spins and makes you wait and wait, a lot of the time that
旋转着让你等待，等待，很多时候，

2302
01:50:23,740 --> 01:50:27,820
can be explained by poor database design, or databases that might not
可以用数据库设计糟糕，或者数据库可能没有

2303
01:50:27,820 --> 01:50:29,200
have been indexed properly.
被正确索引来解释。

2304
01:50:29,200 --> 01:50:31,492
So when you're searching for some course, for instance,
所以，当你搜索某个课程时，例如，

2305
01:50:31,492 --> 01:50:33,310
in the course catalog, it's taking forever
在课程目录中，它需要永远的时间

2306
01:50:33,310 --> 01:50:35,170
because underneath the hood it's essentially
因为在幕后，它本质上

2307
01:50:35,170 --> 01:50:37,730
doing linear search over everything.
对所有内容进行线性搜索。

2308
01:50:37,730 --> 01:50:40,030
But, by contrast, in a relational database,
相反，在关系型数据库中，

2309
01:50:40,030 --> 01:50:42,670
when you create an index in advance because you
当你提前创建索引，因为你

2310
01:50:42,670 --> 01:50:45,640
have a hunch that maybe users are going to search on that column,
有一个预感，用户可能会搜索该列，

2311
01:50:45,640 --> 01:50:47,560
like show titles.
例如节目标题。

2312
01:50:47,560 --> 01:50:49,270
Essentially, you're building up in memory
本质上，你正在内存中构建

2313
01:50:49,270 --> 01:50:51,700
what's called a b-tree, which is not a binary tree.
一种被称为 B 树的结构，它不是二叉树。

2314
01:50:51,700 --> 01:50:54,370
It's still a tree, though, if you think back to week five.
不过它仍然是一棵树，如果你还记得第五周。

2315
01:50:54,370 --> 01:50:57,820
But it's a very short, fat tree instead, where
但它是一棵非常矮胖的树，每个

2316
01:50:57,820 --> 01:51:02,650
every node might have two, or three, or 30 children, which essentially
节点可能有两个、三个或 30 个子节点，这实际上

2317
01:51:02,650 --> 01:51:04,820
pulls the height of the tree way up.
拉高了树的高度。

2318
01:51:04,820 --> 01:51:07,990
Which is to say that when you search for some value in a b-tree,
也就是说，当你搜索 B 树中的某个值时，

2319
01:51:07,990 --> 01:51:10,040
it's invariably going to be in the leaves.
它总是会在叶节点中。

2320
01:51:10,040 --> 01:51:13,870
So the shorter the tree is, the fewer steps it takes to find the value
所以树越矮，找到你所关心的值的步骤就越少

2321
01:51:13,870 --> 01:51:14,750
you care about.
。

2322
01:51:14,750 --> 01:51:17,860
So when you run create table, that kind of data structure
所以，当你运行 create table 命令时，这种数据结构

2323
01:51:17,860 --> 01:51:21,680
is being magically created for you by the database
会由数据库为你神奇地创建，

2324
01:51:21,680 --> 01:51:25,540
so it's not a simple linear search through the entire column,
所以它不是对整列进行简单的线性搜索，

2325
01:51:25,540 --> 01:51:27,350
top to bottom.
从上到下。

2326
01:51:27,350 --> 01:51:31,330
So with that said, we can see this really with more complicated queries.
综上所述，我们可以通过更复杂的查询来真正地看到这一点。

2327
01:51:31,330 --> 01:51:33,260
And let me go back to VS Code here.
让我回到这里的 VS Code。

2328
01:51:33,260 --> 01:51:36,853
Let me propose to run that same, slow query before,
我想再次运行那个相同的慢查询，

2329
01:51:36,853 --> 01:51:39,520
even though it's fine if you're not comfortable with the syntax.
即使你不熟悉语法也没关系。

2330
01:51:39,520 --> 01:51:41,710
It was relatively slow, though, to watch.
不过，观看它还是比较慢的。

2331
01:51:41,710 --> 01:51:46,360
So let's do select title from shows stars and people
所以，让我们执行 select title from shows stars and people

2332
01:51:46,360 --> 01:51:56,500
where shows.id equals stars.show ID, and people.id equals stars.dot person ID,
where shows.id 等于 stars.show ID，并且 people.id 等于 stars.dot person ID，

2333
01:51:56,500 --> 01:51:59,050
and name equals Steve Carell.
并且 name 等于 Steve Carell。

2334
01:51:59,050 --> 01:52:00,820
So this was the last of those queries.
所以，这是最后一个查询。

2335
01:52:00,820 --> 01:52:03,280
That just searches for all of Steve Carell's TV shows
它只是搜索了 Steve Carell 的所有电视剧，

2336
01:52:03,280 --> 01:52:06,430
without using joins explicitly but by just enumerating
没有使用显式连接，而是枚举

2337
01:52:06,430 --> 01:52:10,210
all three tables in question, and then using where to cleverly connect
所有三个相关的表，然后使用 where 语句巧妙地连接

2338
01:52:10,210 --> 01:52:11,390
the dots, so to speak.
这些点，可以这么说。

2339
01:52:11,390 --> 01:52:12,770
But my timer is still on.
但我的计时器还在运行。

2340
01:52:12,770 --> 01:52:16,390
So notice now, when I hit enter, it doesn't just feel slow.
所以注意，当我按下回车键时，它不仅感觉很慢。

2341
01:52:16,390 --> 01:52:19,390
It actually took 2.763 seconds.
它实际上花了 2.763 秒。

2342
01:52:19,390 --> 01:52:20,410
Like, that's slow.
这太慢了。

2343
01:52:20,410 --> 01:52:21,250
That's expensive.
这太昂贵了。

2344
01:52:21,250 --> 01:52:22,650
That's going to annoy your users.
这会让你的用户感到厌烦。

2345
01:52:22,650 --> 01:52:25,900
That's going to annoy your students if the database is thinking, and thinking,
如果数据库一直在思考，思考，思考，并且花费了这么长时间，这会让你的学生感到厌烦。

2346
01:52:25,900 --> 01:52:27,730
and thinking, and taking that much time.
。

2347
01:52:27,730 --> 01:52:29,770
But let's note this.
但让我们注意到这一点。

2348
01:52:29,770 --> 01:52:34,080
That same query I just executed touched a bunch of columns,
我刚刚执行的同一个查询触及了许多列，

2349
01:52:34,080 --> 01:52:35,830
and it turns out that whenever you declare
事实证明，无论何时你在数据库中声明

2350
01:52:35,830 --> 01:52:40,330
a primary key in a database, at least in SQLite, you get an index for free.
主键，至少在 SQLite 中，你会免费获得一个索引。

2351
01:52:40,330 --> 01:52:43,060
Primary keys are automatically indexed, so searching
主键会自动索引，因此在该列中搜索

2352
01:52:43,060 --> 01:52:44,320
for a number in that column?
某个数字？

2353
01:52:44,320 --> 01:52:45,040
Super fast.
超级快。

2354
01:52:45,040 --> 01:52:48,580
Not linear search, it's something logarithmic, most likely, or, ideally,
不是线性搜索，它很可能是对数的，或者，理想情况下，

2355
01:52:48,580 --> 01:52:51,100
closer to something like constant time even.
更接近于常数时间。

2356
01:52:51,100 --> 01:52:54,940
Here, though, I'm touching not just shows.id,
但是，这里我不仅触及了 shows.id，

2357
01:52:54,940 --> 01:52:58,840
but I'm also filtering on stars.show ID, so a foreign key.
而且还在过滤 stars.show ID，所以这是一个外键。

2358
01:52:58,840 --> 01:53:01,000
Foreign keys are not indexed by default.
外键默认情况下不会被索引。

2359
01:53:01,000 --> 01:53:02,260
I'm looking at people ID.
我正在查看 people ID。

2360
01:53:02,260 --> 01:53:03,190
That's a primary key.
这是一个主键。

2361
01:53:03,190 --> 01:53:03,880
That's indexed.
它被索引了。

2362
01:53:03,880 --> 01:53:08,200
But stars.person ID, not indexed by default, is a foreign key.
但 stars.person ID 默认情况下不会被索引，这是一个外键。

2363
01:53:08,200 --> 01:53:11,890
Lastly, I'm filtering by name in the people table.
最后，我在 people 表中按 name 进行过滤。

2364
01:53:11,890 --> 01:53:17,140
Names are not indexed by default. So I'm touching three separate columns,
name 默认情况下不会被索引。因此，我触及了三个独立的列，

2365
01:53:17,140 --> 01:53:20,980
two foreign keys, one name field, that have no fancy tree
两个外键，一个 name 字段，它们没有精美的树

2366
01:53:20,980 --> 01:53:22,570
structure built for them.
结构为它们构建。

2367
01:53:22,570 --> 01:53:23,900
But I can do that.
但我可以做到。

2368
01:53:23,900 --> 01:53:27,190
Let me go down to my terminal here.
让我在这里进入我的终端。

2369
01:53:27,190 --> 01:53:30,550
Let me create one index called, say, person index, though, I
让我创建一个名为 person index 的索引，尽管我可以

2370
01:53:30,550 --> 01:53:35,750
could call it anything I want, on the stars table on the person ID column.
随意命名它，在 stars 表的 person ID 列上。

2371
01:53:35,750 --> 01:53:38,140
So that indexes that foreign key.
这样就会索引那个外键。

2372
01:53:38,140 --> 01:53:41,050
Took 1.7 seconds, but I only have to do it once.
花费了 1.7 秒，但我只需要做一次。

2373
01:53:41,050 --> 01:53:46,720
Create index, show index on the stars table show ID.
创建索引，在 stars 表的 show ID 上创建索引。

2374
01:53:46,720 --> 01:53:49,210
So another foreign key is getting its own index.
所以，另一个外键正在获得自己的索引。

2375
01:53:49,210 --> 01:53:51,490
Took 1.4 seconds, but it's a one time thing.
花了 1.4 秒，但这是唯一的一次。

2376
01:53:51,490 --> 01:53:54,070
And, lastly, let's index all of those actors names.
最后，让我们为所有这些演员的名字建立索引。

2377
01:53:54,070 --> 01:53:59,770
Create index called name index on the people table on the name column.
在 people 表的 name 列上创建一个名为 name index 的索引。

2378
01:53:59,770 --> 01:54:00,460
Enter.
输入。

2379
01:54:00,460 --> 01:54:04,520
That took 1.0 seconds, but a one time operation.
这花了 1.0 秒，但也是一次性操作。

2380
01:54:04,520 --> 01:54:07,850
So, essentially, I've built up like three of these trees in memory
所以，本质上，我在内存中构建了三棵这样的树

2381
01:54:07,850 --> 01:54:09,920
now, specifically for these columns.
现在，专门针对这些列。

2382
01:54:09,920 --> 01:54:15,160
So now recall, previously, that slow query.
所以现在回想一下，之前那个慢速查询。

2383
01:54:15,160 --> 01:54:18,610
If I scroll back up, that took, what was it?
如果我向上滚动，那花了，多少时间？

2384
01:54:18,610 --> 01:54:20,570
2.7 seconds?
2.7 秒？

2385
01:54:20,570 --> 01:54:21,070
I think.
我想。

2386
01:54:21,070 --> 01:54:23,330
2.7 seconds, previously.
之前是 2.7 秒。

2387
01:54:23,330 --> 01:54:29,080
But if I now run the same thing, select title from show
但如果我现在运行同样的东西，从 show 中选择 title

2388
01:54:29,080 --> 01:54:33,850
stars people where shows ID equals stars.show show ID,
stars people where shows ID 等于 stars.show show ID，

2389
01:54:33,850 --> 01:54:37,240
and people ID equals stars.person person ID,
并且 people ID 等于 stars.person person ID，

2390
01:54:37,240 --> 01:54:42,730
and name equals Steve, so close, Carell.
并且 name 等于 Steve，很接近，Carell。

2391
01:54:42,730 --> 01:54:47,320
Same query as before previously took 2.7 seconds, which was the most annoying
之前相同的查询花了 2.7 秒，这是最烦人的

2392
01:54:47,320 --> 01:54:47,890
of them yet.
之一。

2393
01:54:47,890 --> 01:54:49,420
Now, when I hit enter?
现在，当我按下回车键？

2394
01:54:49,420 --> 01:54:50,230
Boom.
砰。

2395
01:54:50,230 --> 01:54:55,240
0.001 seconds, which is the difference, again, between bunches
0.001 秒，这又是成堆的

2396
01:54:55,240 --> 01:55:00,970
of linear searches and, in this case, searching a fancier, week-five style,
线性搜索和，在本例中，使用更高级的、第五周风格的

2397
01:55:00,970 --> 01:55:02,650
b-tree, in this case.
b 树，在本例中。

2398
01:55:02,650 --> 01:55:04,010
So indexes matter.
所以索引很重要。

2399
01:55:04,010 --> 01:55:07,120
So what's then, maybe, the trade off here?
那么，也许，这里的权衡是什么？

2400
01:55:07,120 --> 01:55:09,680
Like, why not index every column in every table?
比如，为什么不为每个表中的每一列建立索引？

2401
01:55:09,680 --> 01:55:10,930
Because this is feeling great.
因为这感觉很棒。

2402
01:55:10,930 --> 01:55:14,110
Like, we're speeding things up by factors of 1,000, practically.
就像，我们实际上将速度提高了 1000 倍。

2403
01:55:14,110 --> 01:55:15,190
What's the trade off?
权衡是什么？

2404
01:55:15,190 --> 01:55:16,240
[INDISTINCT SPEECH]
[模糊不清的谈话]

2405
01:55:16,240 --> 01:55:18,010
Lots and lots of memory, or space.
大量的内存，或者空间。

2406
01:55:18,010 --> 01:55:20,200
Yeah, so you're just trading off space for time,
是的，所以你只是用空间换时间，

2407
01:55:20,200 --> 01:55:23,200
which we said a couple of weeks ago is an acceptable trade off depending
我们几周前说过，根据

2408
01:55:23,200 --> 01:55:24,610
on what resources you have.
你拥有的资源，这是一个可以接受的权衡。

2409
01:55:24,610 --> 01:55:28,160
But it's probably an overcorrection to index everything,
但为所有内容建立索引可能矫枉过正，

2410
01:55:28,160 --> 01:55:31,445
especially since it will slightly slow down inserts, updates, and deletes
尤其是在插入、更新和删除时，它会稍微减慢速度

2411
01:55:31,445 --> 01:55:34,570
because you have to maintain this tree structure so it doesn't devolve back
因为你必须维护这种树状结构，这样它就不会退化成

2412
01:55:34,570 --> 01:55:37,600
into a linked list or something linear.
链表或线性结构。

2413
01:55:37,600 --> 01:55:43,900
But, in fact, being selective about it is perhaps the best strategy.
但事实上，选择性地进行操作可能是最好的策略。

2414
01:55:43,900 --> 01:55:44,440
All right.
好的。

2415
01:55:44,440 --> 01:55:48,250
So that we can now solve some other problems more generally,
这样我们现在就可以更一般地解决其他问题，

2416
01:55:48,250 --> 01:55:49,780
let me just connect two dots.
让我把两点联系起来。

2417
01:55:49,780 --> 01:55:53,740
Even though we focused today on SQL, specifically for databases,
尽管我们今天专注于 SQL，特别是针对数据库，

2418
01:55:53,740 --> 01:55:56,590
you can actually combine one language with another
你实际上可以将一种语言与另一种语言结合起来

2419
01:55:56,590 --> 01:55:58,010
and solve different problems.
并解决不同的问题。

2420
01:55:58,010 --> 01:55:59,420
And so, in fact, let me do this.
所以，事实上，让我这样做。

2421
01:55:59,420 --> 01:56:02,530
Let me revisit our favorites.py from earlier,
让我重新审视我们之前的 favorites.py，

2422
01:56:02,530 --> 01:56:07,610
but let me actually now use the favorites database as follows.
但让我现在实际使用 favorites 数据库，如下所示。

2423
01:56:07,610 --> 01:56:09,980
Let me go into VS Code here.
让我进入这里的 VS Code。

2424
01:56:09,980 --> 01:56:16,810
Let me remove favorites.db because if you recall it made everyone's count
让我删除 favorites.db，因为如果你还记得，它使每个人的计数

2425
01:56:16,810 --> 01:56:18,760
previously--
之前——

2426
01:56:18,760 --> 01:56:19,510
became Fiftyville.
变成了 Fiftyville。

2427
01:56:19,510 --> 01:56:21,640
So let me remove that file.
所以让我删除那个文件。

2428
01:56:21,640 --> 01:56:26,140
Let me run SQLite3 on favorites.db again.
让我再次在 favorites.db 上运行 SQLite3。

2429
01:56:26,140 --> 01:56:27,940
Let me create the file anew.
让我新建一个文件。

2430
01:56:27,940 --> 01:56:30,490
Let me set the mode to CSV again.
让我再次将模式设置为 CSV。

2431
01:56:30,490 --> 01:56:34,630
Let me import that file called favorites.csv into an identical table
让我将名为 favorites.csv 的文件导入到相同的表中

2432
01:56:34,630 --> 01:56:36,160
as before called favorites.
与之前一样，称为 favorites。

2433
01:56:36,160 --> 01:56:37,150
And then quit.
然后退出。

2434
01:56:37,150 --> 01:56:40,970
So I've just reset things to my backup, if you will, from the CSV file.
所以，如果可以的话，我刚刚将事情重置为我从 CSV 文件中备份的内容。

2435
01:56:40,970 --> 01:56:43,300
So, I again have a favorites.db.
所以，我再次拥有一个 favorites.db。

2436
01:56:43,300 --> 01:56:48,033
Let me now minimize my terminal window here and reopen favorites.py,
现在让我最小化我的终端窗口，然后重新打开 favorites.py，

2437
01:56:48,033 --> 01:56:50,200
and let me just go ahead and get rid of that version
让我继续并将那个版本删除

2438
01:56:50,200 --> 01:56:53,830
entirely and focus this time on not talking to a CSV file,
完全，并将这次的重点放在不与 CSV 文件通信上，

2439
01:56:53,830 --> 01:56:55,780
opening it, iterating over the rows.
打开它，迭代行。

2440
01:56:55,780 --> 01:56:58,930
We can actually use Python to execute SQL queries
我们实际上可以使用 Python 来执行 SQL 查询

2441
01:56:58,930 --> 01:57:00,950
and kind of get the best of both worlds.
并获得两全其美。

2442
01:57:00,950 --> 01:57:03,160
So let me do this here.
所以让我在这里这样做。

2443
01:57:03,160 --> 01:57:09,580
Let me, from the CS50 Python library, import our own SQL functionality.
让我从 CS50 Python 库中导入我们自己的 SQL 功能。

2444
01:57:09,580 --> 01:57:12,052
And this is a training wheel we still provide for SQL
而这是一个我们仍然为 SQL 提供的训练轮

2445
01:57:12,052 --> 01:57:14,260
because it's just much easier than using the industry
因为它比使用行业标准的 SQL 库要容易得多

2446
01:57:14,260 --> 01:57:15,760
standard libraries for SQL.
标准的 SQL 库。

2447
01:57:15,760 --> 01:57:18,540
It just is painful for simple tasks.
对于简单的任务来说，这很痛苦。

2448
01:57:18,540 --> 01:57:21,380
So now, let me create a variable called db, for database.
所以现在，让我创建一个名为 db 的变量，代表数据库。

2449
01:57:21,380 --> 01:57:24,410
I'm going to set it equal to this SQL function that CS50 wrote.
我将把它设置为 CS50 编写的这个 SQL 函数。

2450
01:57:24,410 --> 01:57:28,730
And this is going to look weird, but the way you open a DB file in Python,
这看起来很奇怪，但是你在 Python 中打开一个 DB 文件的方式，

2451
01:57:28,730 --> 01:57:31,580
whether it's with CS50 library or someone else's, you
无论是使用 CS50 库还是其他人的库，你

2452
01:57:31,580 --> 01:57:36,560
say SQLite colon slash, slash, slash favorites.db.
说 SQLite 冒号斜杠，斜杠，斜杠 favorites.db。

2453
01:57:36,560 --> 01:57:38,780
So weird syntax, but it's commonplace.
很奇怪的语法，但这是很常见的。

2454
01:57:38,780 --> 01:57:41,900
Three slashes, not two like a URL is usually.
三个斜杠，而不是像 URL 那样通常的两个。

2455
01:57:41,900 --> 01:57:44,300
Now let's use a variable called favorite and set
现在让我们使用一个名为 favorite 的变量并设置

2456
01:57:44,300 --> 01:57:48,020
it equal to the return value of input by asking the human for their favorite TV
它等于通过询问用户最喜欢的电视节目而获得的输入的返回值

2457
01:57:48,020 --> 01:57:48,650
show.
节目。

2458
01:57:48,650 --> 01:57:51,860
And now, previously we opened up the CSV file,
现在，之前我们打开了 CSV 文件，

2459
01:57:51,860 --> 01:57:56,270
iterated over it looking for the show they typed in, show they typed in.
遍历它，寻找他们输入的节目，他们输入的节目。

2460
01:57:56,270 --> 01:57:59,060
Or, rather-- Oh, sorry, not the show.
或者——哦，对不起，不是节目。

2461
01:57:59,060 --> 01:58:01,610
The problem, or the problem that we typed in.
问题，或者我们输入的问题。

2462
01:58:01,610 --> 01:58:03,150
Let me instead do this.
让我改成这样。

2463
01:58:03,150 --> 01:58:07,290
Let me set, use a db variables, execute function,
让我设置，使用一个 db 变量，执行函数，

2464
01:58:07,290 --> 01:58:11,360
which comes with the CS50 library, and let me execute this SQL query.
它包含在 CS50 库中，让我执行这个 SQL 查询。

2465
01:58:11,360 --> 01:58:20,250
Select count star as n from favorites where problem equals question mark.
从 favorites 中选择 count star 作为 n，其中 problem 等于问号。

2466
01:58:20,250 --> 01:58:23,000
And the question mark is a little weird, but think of it, for now,
问号有点奇怪，但现在把它想象成

2467
01:58:23,000 --> 01:58:24,902
like C's percent s.
C 中的百分号 s。

2468
01:58:24,902 --> 01:58:26,750
Comma favorite.
逗号 favorite。

2469
01:58:26,750 --> 01:58:29,840
I'm going to plug in whatever the human typed in into that query where
我将把用户输入的任何内容插入到该查询中，其中

2470
01:58:29,840 --> 01:58:30,920
the question mark is.
问号所在。

2471
01:58:30,920 --> 01:58:34,340
So no percent s, I'm using a question mark in this world of SQL.
所以没有百分号 s，我在这个 SQL 世界中使用问号。

2472
01:58:34,340 --> 01:58:36,883
This is going to give me back a temporary table,
这将返回一个临时表，

2473
01:58:36,883 --> 01:58:39,800
and I'm going to store that temporary table in a variable called rows.
我将把该临时表存储在一个名为 rows 的变量中。

2474
01:58:39,800 --> 01:58:42,840
Because the temporary table is essentially zero or more rows,
因为临时表本质上是零行或多行，

2475
01:58:42,840 --> 01:58:44,660
so I'm going to name my variable rows.
所以我将我的变量命名为 rows。

2476
01:58:44,660 --> 01:58:48,170
And then if I want to get back the first and only row,
然后如果我想取回第一行也是唯一的一行，

2477
01:58:48,170 --> 01:58:51,860
I can literally do row equals rows bracket zero just to be pedantic,
我可以在字面上做 row 等于 rows 方括号 0，仅仅是为了吹毛求疵，

2478
01:58:51,860 --> 01:58:55,970
just to get, literally, the first row in that temporary table, or result set.
只是为了获取，实际上，临时表或结果集中的第一行。

2479
01:58:55,970 --> 01:58:59,810
And now if I want to print back the n column therein,
现在如果我想打印出其中的 n 列，

2480
01:58:59,810 --> 01:59:03,590
I can do print row, quote unquote, "n."
我可以做 print row, 引号开头和结尾，"n"。

2481
01:59:03,590 --> 01:59:06,420
So let me take a step back and do this.
所以让我退一步，做这件事。

2482
01:59:06,420 --> 01:59:12,710
Let me go into SQLite3 of favorites.db and let me literally type something
让我进入 favorites.db 的 SQLite3，让我实际上输入一些东西

2483
01:59:12,710 --> 01:59:13,580
like this.
像这样。

2484
01:59:13,580 --> 01:59:16,640
Here I'm in SQLite3 at the bottom and the problem I'm searching,
这里我在 SQLite3 的底部，而我正在搜索的问题，

2485
01:59:16,640 --> 01:59:19,520
for instance, is Scratch semicolon.
例如，是 Scratch 分号。

2486
01:59:19,520 --> 01:59:23,480
Notice that is how in SQL, in the command line of SQLite3,
请注意，这就是在 SQL 中，在 SQLite3 的命令行中，

2487
01:59:23,480 --> 01:59:24,960
I can get back the answer I want.
我可以取回我想要的答案。

2488
01:59:24,960 --> 01:59:26,960
But what if I want to make a Python program that
但如果我想创建一个 Python 程序，

2489
01:59:26,960 --> 01:59:29,480
queries the database for that value and then prints something out?
查询数据库以获取该值，然后打印一些内容？

2490
01:59:29,480 --> 01:59:31,790
In two weeks time, what if I want to do that to make
在两周时间内，如果我想这样做，以便

2491
01:59:31,790 --> 01:59:35,300
a web application, like imdb.com or a mobile app,
创建一个 web 应用程序，比如 imdb.com 或一个移动应用程序，

2492
01:59:35,300 --> 01:59:37,490
that writes code to generate a user interface
它编写代码来生成用户界面

2493
01:59:37,490 --> 01:59:39,320
but that pulls the data from a database?
但它从数据库中获取数据？

2494
01:59:39,320 --> 01:59:42,170
You're not going to have your human users using SQLite3,
你不会让你的用户使用 SQLite3，

2495
01:59:42,170 --> 01:59:44,280
you're going to generate the output for them.
你会为他们生成输出。

2496
01:59:44,280 --> 01:59:46,790
So let me close my terminal window here.
所以让我关闭这里的终端窗口。

2497
01:59:46,790 --> 01:59:49,190
Rather, let me close out of SQLite 3.
更确切地说，让我退出 SQLite 3。

2498
01:59:49,190 --> 01:59:53,840
Let me now run Python of favorites.py, enter.
现在让我运行 favorites.py 的 Python，回车。

2499
01:59:53,840 --> 01:59:56,450
I'm prompted for my favorite using the input function.
我被提示使用 input 函数输入我的最爱。

2500
01:59:56,450 --> 02:00:00,290
I type in Scratch and hit enter, and there's my 34.
我输入 Scratch 并按下回车键，这就是我的 34。

2501
02:00:00,290 --> 02:00:02,650
So this is an incredibly common practice,
所以这是一种非常常见的做法，

2502
02:00:02,650 --> 02:00:04,400
to use one language for what it's best at.
用一种语言来做它最擅长的事情。

2503
02:00:04,400 --> 02:00:07,430
Like SQL is best at reading data from databases,
就像 SQL 最擅长从数据库中读取数据，

2504
02:00:07,430 --> 02:00:11,060
Python is, maybe, best in this case for creating a user interface
Python 在这种情况下可能最适合创建用户界面

2505
02:00:11,060 --> 02:00:13,040
or, eventually, making a web application.
或者最终制作一个 web 应用程序。

2506
02:00:13,040 --> 02:00:16,560
But it's certainly fine to use one inside of the other.
但在另一个内部使用一个当然是可以的。

2507
02:00:16,560 --> 02:00:19,740
The documentation for this library, if and when you get curious,
这个库的文档，如果你感到好奇，

2508
02:00:19,740 --> 02:00:23,520
is it this URL here, along with a lot of CS50's own documentation.
就是这里这个 URL，以及 CS50 的大量文档。

2509
02:00:23,520 --> 02:00:26,340
But there are some problems, nonetheless, we
但尽管如此，我们还是遇到了一些问题

2510
02:00:26,340 --> 02:00:29,760
might encounter in this world, and we thought we'd end on these challenges.
可能在这个世界中遇到，我们认为我们会在这些挑战上结束。

2511
02:00:29,760 --> 02:00:33,420
It turns out that in the world of SQL, even though we haven't touched
事实证明，在 SQL 世界中，即使我们还没有接触

2512
02:00:33,420 --> 02:00:36,638
upon this yet, you're generally working not with like hundreds
到这一点，你通常不是处理数百个

2513
02:00:36,638 --> 02:00:39,180
of people and their favorite languages and problems, not even
人及其喜欢的语言和问题，甚至不是

2514
02:00:39,180 --> 02:00:42,600
thousands of movies, but like millions of things in the database,
成千上万的电影，而是数据库中的数百万个东西，

2515
02:00:42,600 --> 02:00:45,180
like Instagram posts or TikTok videos or the like.
比如 Instagram 帖子或 TikTok 视频等。

2516
02:00:45,180 --> 02:00:48,510
Those are huge databases with millions of rows.
这些是拥有数百万行的巨大数据库。

2517
02:00:48,510 --> 02:00:51,510
The problem with SQL and, really, databases in general,
SQL 和一般数据库的问题是，

2518
02:00:51,510 --> 02:00:54,030
is if you have thousands, millions of things
如果你有数千个，数百万个东西

2519
02:00:54,030 --> 02:00:57,765
happening at once, things can get out of order and your math can be wrong.
同时发生，事情可能会变得乱序，你的数学可能会出错。

2520
02:00:57,765 --> 02:00:59,890
You can lose track of how many likes something has.
你可能会失去对某件事有多少点赞的跟踪。

2521
02:00:59,890 --> 02:01:03,870
And so, for instance, as of last night this remains the most popular Instagram
因此，例如，截至昨晚，这仍然是世界上最受欢迎的 Instagram

2522
02:01:03,870 --> 02:01:06,000
post, to date, in the world.
帖子，迄今为止，在世界上。

2523
02:01:06,000 --> 02:01:08,368
It was clicked on by so many people.
它被这么多人点击过。

2524
02:01:08,368 --> 02:01:10,410
And you might think that's pretty straightforward
你可能会认为这很简单

2525
02:01:10,410 --> 02:01:13,230
to keep track click, click, click, but not
来跟踪点击，点击，点击，但不是

2526
02:01:13,230 --> 02:01:16,870
when there's millions of devices in the world and thousands of servers,
当世界上有数百万台设备和数千台服务器时，

2527
02:01:16,870 --> 02:01:20,000
probably, at Meta running Instagram's back end.
可能是在 Meta 运行 Instagram 的后端。

2528
02:01:20,000 --> 02:01:23,290
So how do you actually keep track of all of these likes?
那么你如何才能真正跟踪所有这些点赞呢？

2529
02:01:23,290 --> 02:01:26,980
Well, maybe, Meta is using code like this
好吧，也许 Meta 正在使用这样的代码

2530
02:01:26,980 --> 02:01:30,370
to implement the counter for likes on Instagram.
来实现 Instagram 上点赞的计数器。

2531
02:01:30,370 --> 02:01:33,160
Maybe they are using lines of code similar to what we just
也许他们正在使用与我们刚刚编写的代码类似的代码行

2532
02:01:33,160 --> 02:01:37,510
wrote db.execute select the current number of likes
写的 db.execute 选择当前点赞数

2533
02:01:37,510 --> 02:01:40,750
from the posts table where the ID of the post
从帖子表中，其中帖子的 ID

2534
02:01:40,750 --> 02:01:43,760
equals whatever the one is that the user clicked on.
等于用户点击的那个。

2535
02:01:43,760 --> 02:01:48,160
So the post a moment ago, presumably, has a unique ID, a primary key,
所以刚才的帖子，大概有一个唯一的 ID，一个主键，

2536
02:01:48,160 --> 02:01:51,160
and that number just gets plugged in here when Meta wants to figure out,
当 Meta 想弄清楚的时候，那个数字就被插到这里了，

2537
02:01:51,160 --> 02:01:53,140
all right, someone just clicked on this post.
好吧，有人刚刚点击了这个帖子。

2538
02:01:53,140 --> 02:01:56,320
Let's figure out what the current number of likes so we can add 1 to it
让我们弄清楚当前的点赞数，以便我们可以为它加 1

2539
02:01:56,320 --> 02:01:57,890
and update the database.
并更新数据库。

2540
02:01:57,890 --> 02:02:00,910
So this query here gives us a temporary table
所以这里的查询给了我们一个临时表

2541
02:02:00,910 --> 02:02:04,360
containing the current number of likes before you or someone else clicked.
包含你在点击之前或其他人点击之前的当前点赞数。

2542
02:02:04,360 --> 02:02:06,820
Maybe then we just declare a variable called
也许然后我们只是声明一个名为

2543
02:02:06,820 --> 02:02:09,772
likes to get at the first row's likes column.
likes 来获取第一行的点赞列。

2544
02:02:09,772 --> 02:02:11,980
So this is just Python syntax, similar to what I did,
所以这只是 Python 语法，类似于我做过的，

2545
02:02:11,980 --> 02:02:15,640
just to get the actual number you care about, like 34 or whatever million
只是为了获取你真正关心的数字，比如 34 或任何百万

2546
02:02:15,640 --> 02:02:16,480
it is here.
在这里。

2547
02:02:16,480 --> 02:02:20,650
But then suppose there's a second database query and a third line of code
但假设有一个第二个数据库查询和第三行代码

2548
02:02:20,650 --> 02:02:26,200
that updates the posts table setting the likes equal to this value
它更新帖子表，将点赞设置为这个值

2549
02:02:26,200 --> 02:02:29,030
where the ID of the post is this value.
其中帖子的 ID 是这个值。

2550
02:02:29,030 --> 02:02:32,870
So these question marks are similar, again, in spirit to printf's percent s.
所以这些问号在精神上类似于 printf 的百分号 s。

2551
02:02:32,870 --> 02:02:34,810
They're placeholders for things that are going
它们是即将被插入到逗号后面的东西的占位符。

2552
02:02:34,810 --> 02:02:37,070
to be plugged in after the commas.
插入逗号后面。

2553
02:02:37,070 --> 02:02:38,860
So if I want to update the number of likes
所以如果我想更新点赞数

2554
02:02:38,860 --> 02:02:41,080
to be whatever the current number is plus one,
使其等于当前数字加 1，

2555
02:02:41,080 --> 02:02:45,100
I put it there as a second argument and then I plug-in the ID of that post.
我把它放在那里作为第二个参数，然后我插入该帖子的 ID。

2556
02:02:45,100 --> 02:02:49,420
The problem, though, with large systems like the Metas, the Googles,
然而，像 Meta、Google 这样的大型系统的问题是，

2557
02:02:49,420 --> 02:02:51,640
the Microsofts, and others of the world, is
微软和其他世界上的公司，是

2558
02:02:51,640 --> 02:02:54,880
that they are executing code like this on multiple servers,
它们在多个服务器上执行类似这样的代码，

2559
02:02:54,880 --> 02:02:58,930
thousands of servers, that might be executing slightly out of order.
成千上万台服务器，它们可能略微乱序执行。

2560
02:02:58,930 --> 02:03:01,070
One might be faster, one might be slower.
一个可能更快，一个可能更慢。

2561
02:03:01,070 --> 02:03:04,990
Which is to say, even though these three lines of code
也就是说，即使这三行代码

2562
02:03:04,990 --> 02:03:07,240
represent what should happen when I click on that post
代表了我点击该帖子时应该发生的事情

2563
02:03:07,240 --> 02:03:09,670
and you click on that post and you click on that post,
你点击该帖子，你点击该帖子，

2564
02:03:09,670 --> 02:03:13,600
the lines of code chronologically might get shuffled a little bit.
代码行按时间顺序可能会稍微打乱。

2565
02:03:13,600 --> 02:03:16,090
Like, maybe, this line of code gets executed for me
比如，也许，这行代码会为我执行

2566
02:03:16,090 --> 02:03:18,100
and then it gets executed for you and then you,
然后它为你执行，然后为你执行，

2567
02:03:18,100 --> 02:03:20,900
and then the server moves on to the next line of code.
然后服务器移至下一行代码。

2568
02:03:20,900 --> 02:03:23,890
So it's sort of multitasking, handling lots of users at once.
所以它是一种多任务处理，一次处理大量用户。

2569
02:03:23,890 --> 02:03:27,940
The problem with this is that you run into a race condition of sorts,
问题在于你遇到了一种竞争条件，

2570
02:03:27,940 --> 02:03:30,820
where the servers are sort of racing to handle one user
服务器都在争先恐后地处理一个用户，

2571
02:03:30,820 --> 02:03:34,580
but other users requests are happening at the same time.
但其他用户的请求同时发生。

2572
02:03:34,580 --> 02:03:39,220
So the analogy that I was taught years ago in an operating systems
所以几年前我在操作系统课上学习到的类比

2573
02:03:39,220 --> 02:03:41,860
class actually pertains to something like a refrigerator here.
实际上与这里类似的冰箱有关。

2574
02:03:41,860 --> 02:03:43,360
So we have a mini refrigerator here.
所以我们这里有一个小型冰箱。

2575
02:03:43,360 --> 02:03:45,850
Suppose you've got one in your dorm or your house room,
假设你宿舍或房间里有一个，

2576
02:03:45,850 --> 02:03:48,340
and you come home one day.
有一天你回家。

2577
02:03:48,340 --> 02:03:51,860
And you really like milk, so you open the fridge and you look inside,
你真的很喜欢牛奶，所以你打开冰箱，朝里面看，

2578
02:03:51,860 --> 02:03:52,480
and there's--
然后——

2579
02:03:52,480 --> 02:03:53,590
Oh, we're out of milk.
哦，我们没牛奶了。

2580
02:03:53,590 --> 02:03:57,160
So you close the fridge, you walk out to CVS, or somewhere else,
于是你关上冰箱，走到 CVS 或其他地方，

2581
02:03:57,160 --> 02:03:58,600
and go to get more milk.
去买更多的牛奶。

2582
02:03:58,600 --> 02:04:01,240
Meanwhile, though, your roommate comes home, who in this story
然而，与此同时，你的室友回家了，在这个故事中

2583
02:04:01,240 --> 02:04:03,850
also likes milk, and so they decide that--
也喜欢牛奶，所以他们决定——

2584
02:04:03,850 --> 02:04:05,620
Oh, I'm out of milk in the fridge.
哦，我的冰箱里没牛奶了。

2585
02:04:05,620 --> 02:04:07,120
So they, maybe, head out.
所以他们也许就出门了。

2586
02:04:07,120 --> 02:04:10,660
Maybe they follow a different path to go get more milk as well.
也许他们走了一条不同的路去买更多的牛奶。

2587
02:04:10,660 --> 02:04:13,330
Some number of minutes pass, you both come home later on.
几分钟过去了，你们两个后来都回家了。

2588
02:04:13,330 --> 02:04:14,080
Like, Oh, darn it.
比如，哦，该死。

2589
02:04:14,080 --> 02:04:15,830
Now we have twice as much milk as we need.
现在我们有双倍于需要的牛奶。

2590
02:04:15,830 --> 02:04:17,247
We don't really like it that much.
我们并不真的那么喜欢它。

2591
02:04:17,247 --> 02:04:19,720
And some of it's going to go sour now, so it's wasted like.
现在有些牛奶会变酸，所以它就浪费了。

2592
02:04:19,720 --> 02:04:20,720
We've made a mistake.
我们犯了一个错误。

2593
02:04:20,720 --> 02:04:22,780
We should not have bought twice as much milk.
我们不应该买这么多牛奶。

2594
02:04:22,780 --> 02:04:27,220
Now, stupid story, but the point is that both of you
现在，愚蠢的故事，但重点是你们两个

2595
02:04:27,220 --> 02:04:30,250
made decisions based on the state of a variable.
根据变量的状态做出了决定。

2596
02:04:30,250 --> 02:04:33,790
But the problem was that variable was in the process of being
但问题是，当其他人查看它时，该变量正在更新过程中。

2597
02:04:33,790 --> 02:04:36,430
updated when someone else looked at it.
当其他人查看它时，该变量正在更新过程中。

2598
02:04:36,430 --> 02:04:39,470
The first person in the story was on their way to the store
故事中第一个人正在去商店的路上

2599
02:04:39,470 --> 02:04:41,560
so the variable was about to be incremented
所以变量即将增加

2600
02:04:41,560 --> 02:04:43,840
in terms of quantity of milk, but the other person
就牛奶的数量而言，但另一个人

2601
02:04:43,840 --> 02:04:46,430
didn't know that yet so they too tried to increment it.
还不知道，所以他们也试图增加它。

2602
02:04:46,430 --> 02:04:48,760
And, in that case, we ended up with too much milk.
在这种情况下，我们最终得到了太多的牛奶。

2603
02:04:48,760 --> 02:04:52,450
But suppose what might happen here is similar in spirit.
但假设这里可能会发生的事情在精神上是相似的。

2604
02:04:52,450 --> 02:04:56,560
Suppose that post, at some point in time, had just 1,000,000 likes.
假设该帖子在某个时间点只有 100 万个赞。

2605
02:04:56,560 --> 02:05:00,310
And suppose this line of code got executed for me, for you, and for you
假设这行代码为我执行，为你执行，为你执行

2606
02:05:00,310 --> 02:05:02,050
after all three of us clicked on it.
在我们三个人都点击它之后。

2607
02:05:02,050 --> 02:05:05,530
Well, the value of our likes variable in Meta servers
好吧，我们在 Meta 服务器中的点赞变量的值

2608
02:05:05,530 --> 02:05:08,020
might be 1,000,000, 1,000,000, and 1,000,000.
可能是 1,000,000、1,000,000 和 1,000,000。

2609
02:05:08,020 --> 02:05:11,470
They therefore update 1,000,000 to be 1,000,000 plus one.
因此，他们将 1,000,000 更新为 1,000,000 加一。

2610
02:05:11,470 --> 02:05:14,890
And so what they update the database to be is 1,000,001,
所以他们更新数据库到 1,000,001，

2611
02:05:14,890 --> 02:05:16,080
but they do it three times.
但他们做了三次。

2612
02:05:16,080 --> 02:05:18,690
1,000,001, 1,000,001, 1,000,001.
1,000,001、1,000,001、1,000,001。

2613
02:05:18,690 --> 02:05:21,900
But they've lost two of those likes because they
但他们丢失了其中的两个赞，因为他们

2614
02:05:21,900 --> 02:05:26,040
might have inspected the variable while some other server, some other user's
可能在检查变量时，其他服务器，其他用户的

2615
02:05:26,040 --> 02:05:28,510
like, was being processed.
点赞正在被处理。

2616
02:05:28,510 --> 02:05:31,350
So long story short, when you have lots of data
总之，当你在很多服务器上拥有大量数据时，

2617
02:05:31,350 --> 02:05:34,365
on lots of servers, all of which is happening very quickly,
所有这些都在非常快地发生，

2618
02:05:34,365 --> 02:05:36,240
you run into these so called race conditions.
你就会遇到这些所谓的竞争条件。

2619
02:05:36,240 --> 02:05:39,750
And code like this can be dangerous, even though it might not
像这样的代码可能是危险的，即使它可能不会

2620
02:05:39,750 --> 02:05:41,460
look incorrect at a glance.
乍一看就觉得不对。

2621
02:05:41,460 --> 02:05:44,280
Thankfully, in the world of SQL, though you won't generally
幸运的是，在 SQL 的世界里，尽管你通常不会

2622
02:05:44,280 --> 02:05:47,700
have to do this certainly for problem sets sake, there are solutions to this.
不得不这样做，当然是为了解决问题，对此有很多解决办法。

2623
02:05:47,700 --> 02:05:51,210
But too many engineers in the world don't know this, don't remember this,
但世界上太多的工程师不知道这一点，不记得这一点，

2624
02:05:51,210 --> 02:05:53,580
or don't appreciate this reality.
或者不理解这一现实。

2625
02:05:53,580 --> 02:05:55,920
There are keywords in certain databases that
在某些数据库中有一些关键字

2626
02:05:55,920 --> 02:05:59,610
let you instead begin a transaction, which means, essentially,
让你开始一个事务，这意味着，本质上，

2627
02:05:59,610 --> 02:06:02,970
that these three lines of code should either all
这三行代码要么全部

2628
02:06:02,970 --> 02:06:05,370
happen together or not at all.
一起发生，要么完全不发生。

2629
02:06:05,370 --> 02:06:06,660
They should be atomic.
它们应该是原子性的。

2630
02:06:06,660 --> 02:06:09,390
That is to say, they should all happen without interruption
也就是说，它们应该在没有中断的情况下发生

2631
02:06:09,390 --> 02:06:11,340
or they just shouldn't happen at all.
或者它们根本不应该发生。

2632
02:06:11,340 --> 02:06:16,000
And that ensures that the math does not go wrong
这样就能确保数学运算不会出错

2633
02:06:16,000 --> 02:06:18,820
because my like will get counted, and then you're like,
因为我的点赞会被统计，然后你就像，

2634
02:06:18,820 --> 02:06:22,390
and then you're like, as opposed to them being intermingled and lost
然后你就像，而不是它们混杂在一起并丢失

2635
02:06:22,390 --> 02:06:23,630
track of accordingly.
相应的记录。

2636
02:06:23,630 --> 02:06:26,590
So in Python, using the CS50 library, you
所以，在 Python 中，使用 CS50 库，你

2637
02:06:26,590 --> 02:06:30,280
could wrap these three lines of code by saying begin transaction
可以用“开始事务”来包装这三行代码

2638
02:06:30,280 --> 02:06:33,580
to the database, commit the transaction to the database,
到数据库，将事务提交到数据库，

2639
02:06:33,580 --> 02:06:37,867
and that relatively simple solution avoids this problem of race conditions.
这个相对简单的解决方案避免了竞争条件的问题。

2640
02:06:37,867 --> 02:06:38,950
But this, too, is a topic.
但这也是一个主题。

2641
02:06:38,950 --> 02:06:41,020
If you Google, invariably you'll see that this
如果你用谷歌搜索，你一定会发现，

2642
02:06:41,020 --> 02:06:46,000
is a problem that has hit various servers and apps over time.
这是一个困扰着各种服务器和应用程序的问题。

2643
02:06:46,000 --> 02:06:49,660
But there's one other problem that the world is still not very good at,
但还有一个问题，世界还没有很好地解决，

2644
02:06:49,660 --> 02:06:52,060
and that's known as a SQL injection attack.
那就是所谓的 SQL 注入攻击。

2645
02:06:52,060 --> 02:06:55,690
And it turns out that even with what we've been doing, even code like this
事实证明，即使我们一直在做，即使像这样的代码

2646
02:06:55,690 --> 02:07:00,160
here, is all too easily vulnerable to being hacked, if you will.
很容易被黑客攻击，如果你愿意的话。

2647
02:07:00,160 --> 02:07:04,670
That is misused in some way, unless you practice what I'm preaching,
也就是说，除非你实践我所宣扬的，

2648
02:07:04,670 --> 02:07:07,070
which is using placeholders like this.
就是使用像这样的占位符。

2649
02:07:07,070 --> 02:07:10,570
It turns out that it's very dangerous to take user input in, generally.
事实证明，接收用户输入通常很危险。

2650
02:07:10,570 --> 02:07:13,150
Like, most of your users might be nice, good people,
比如，你的大多数用户可能都很友善，都是好人，

2651
02:07:13,150 --> 02:07:16,330
but there's always going to be someone who's malicious or curious
但总会有恶意或好奇的人

2652
02:07:16,330 --> 02:07:19,670
or just execute something you don't expect, and things can go wrong.
或者只是执行一些你没有预料到的事情，事情就会出错。

2653
02:07:19,670 --> 02:07:21,940
So in the world of SQL, here's what can happen.
所以在 SQL 的世界里，这里可能会发生的事情。

2654
02:07:21,940 --> 02:07:24,890
For instance, here is the login screen for Yale accounts.
例如，这是耶鲁账户的登录界面。

2655
02:07:24,890 --> 02:07:27,220
Here's the comparable screen for Harvard accounts.
这是哈佛账户的类似界面。

2656
02:07:27,220 --> 02:07:29,803
And all of us are in their habit of using one of these screens
我们都习惯使用这些屏幕之一

2657
02:07:29,803 --> 02:07:31,150
or something similar or another.
或类似的东西。

2658
02:07:31,150 --> 02:07:34,450
You're often asked for a username or email address and a password.
你经常被要求提供用户名或电子邮件地址和密码。

2659
02:07:34,450 --> 02:07:38,950
But suppose that Harvard or Yale or Google or Microsoft or wherever,
但假设哈佛、耶鲁、谷歌、微软或其他地方，

2660
02:07:38,950 --> 02:07:42,280
are taking user input from forms like this, be it on the web
正在从类似这样的表单中获取用户输入，无论是网页

2661
02:07:42,280 --> 02:07:46,540
or on a mobile app, and they're just plugging your input into a SQL query
还是移动应用程序，他们只是将你的输入插入到一个 SQL 查询中

2662
02:07:46,540 --> 02:07:50,320
that they wrote in advance that just is waiting for your username or password
他们提前编写好的，它只是在等待你的用户名或密码

2663
02:07:50,320 --> 02:07:53,980
to be plugged in so they can ask a complete query of the database.
被插入，以便他们可以向数据库发出完整的查询。

2664
02:07:53,980 --> 02:07:57,850
It turns out that if I'm a bit malicious, or curious,
事实证明，如果我有点恶意，或者好奇，

2665
02:07:57,850 --> 02:08:01,810
I could, maybe, type in some funky syntax to fields like this
我可能会在这样的字段中输入一些奇怪的语法

2666
02:08:01,810 --> 02:08:04,570
that I know have special meaning to certain databases.
我知道这些语法对某些数据库有特殊含义。

2667
02:08:04,570 --> 02:08:09,490
And it turns out in the world of SQL, SQLite in particular, single quotes
事实证明，在 SQL 的世界中，尤其是 SQLite 中，单引号

2668
02:08:09,490 --> 02:08:10,570
are clearly important.
非常重要。

2669
02:08:10,570 --> 02:08:12,850
Because I've been using them all day long for strings,
因为我整天都在用它们来表示字符串，

2670
02:08:12,850 --> 02:08:16,745
and I didn't mention this yet, but the comment character in SQLite is dash,
我还没提到，但在 SQLite 中，注释字符是连字符，

2671
02:08:16,745 --> 02:08:17,245
dash.
连字符。

2672
02:08:17,245 --> 02:08:20,203
If you want the rest of a line to be ignored, you just say, dash, dash.
如果你想让剩下的行被忽略，你只需要输入连字符，连字符。

2673
02:08:20,203 --> 02:08:23,605
So it's not hash, it's not slash, slash, like in Python and C, respectively.
所以它不是井号，也不是斜杠，斜杠，就像 Python 和 C 中的符号一样。

2674
02:08:23,605 --> 02:08:26,210
It's dash, dash, or two hyphens.
是连字符，连字符，或两个连字符。

2675
02:08:26,210 --> 02:08:28,887
So suppose that I'm a hacker or a curious student,
所以假设我是一个黑客或一个好奇的学生，

2676
02:08:28,887 --> 02:08:30,970
and I want to see if Harvard knows what it's doing
我想看看哈佛是否知道自己在做什么

2677
02:08:30,970 --> 02:08:32,680
when it comes to SQL injection attacks.
在进行 SQL 注入攻击方面。

2678
02:08:32,680 --> 02:08:36,347
I could literally type in, maybe my username with a single quote
我可以直接输入，比如我的用户名，后面加一个单引号

2679
02:08:36,347 --> 02:08:37,180
and then dash, dash.
然后是连字符，连字符。

2680
02:08:37,180 --> 02:08:38,870
Well, why would I do this?
为什么我要这样做呢？

2681
02:08:38,870 --> 02:08:43,240
Well, suppose for the sake of discussion that some developer at Harvard,
为了讨论方便，假设哈佛大学的某个开发人员，

2682
02:08:43,240 --> 02:08:46,030
or any website, really, has written a line of code
或者任何网站，真的，已经写了一行代码

2683
02:08:46,030 --> 02:08:49,870
like this to check if the username and password just
像这样，用来检查刚刚输入的用户名和密码是否

2684
02:08:49,870 --> 02:08:52,760
typed in match what's in the database.
与数据库中的内容相匹配。

2685
02:08:52,760 --> 02:08:53,890
So how might I do this?
那么我应该怎么做呢？

2686
02:08:53,890 --> 02:08:57,410
And if so, let the user log in, show them their account, or whatever.
如果是这样，就让用户登录，向他们展示他们的账户，或者其他操作。

2687
02:08:57,410 --> 02:08:59,800
So here's the line of code in question.
这就是我们要讨论的那行代码。

2688
02:08:59,800 --> 02:09:05,050
Select star from users where username equals question mark and password
从用户表中选择所有列，其中用户名等于问号，密码

2689
02:09:05,050 --> 02:09:05,980
equals question mark.
等于问号。

2690
02:09:05,980 --> 02:09:07,040
This is correct.
这是正确的。

2691
02:09:07,040 --> 02:09:08,650
This is green because it's good.
它是绿色的，因为它是好的。

2692
02:09:08,650 --> 02:09:10,960
It is not vulnerable to attack because
它不容易受到攻击，因为

2693
02:09:10,960 --> 02:09:13,090
I'm using these placeholders here, which,
我在这里使用了占位符，它

2694
02:09:13,090 --> 02:09:15,370
even though we've implemented in the CS50 library,
尽管我们在 CS50 库中实现了它，

2695
02:09:15,370 --> 02:09:18,040
most SQL libraries support the same syntax.
大多数 SQL 库都支持相同的语法。

2696
02:09:18,040 --> 02:09:19,600
But it can vary by system.
但这可能会因系统而异。

2697
02:09:19,600 --> 02:09:20,890
This is safe.
这是安全的。

2698
02:09:20,890 --> 02:09:23,230
What is not safe is to use some of the stuff
不安全的是使用上周你学到的一些东西

2699
02:09:23,230 --> 02:09:25,750
you learned last week where you can just use f strings,
你上周学到的，你只需要使用 f 字符串，

2700
02:09:25,750 --> 02:09:29,680
or format your own strings and interpolate values with curly braces.
或者格式化你自己的字符串，并用花括号插入值。

2701
02:09:29,680 --> 02:09:31,930
For instance, suppose you took me at my word
例如，假设你相信我说的话

2702
02:09:31,930 --> 02:09:33,790
last week that you can do this in Python.
上周我说你可以在 Python 中这样做。

2703
02:09:33,790 --> 02:09:37,430
This code here, unfortunately, in yellow, is not safe.
不幸的是，这里的这段代码，以黄色显示，是不安全的。

2704
02:09:37,430 --> 02:09:39,190
Here's a format string in Python.
这里有一个 Python 中的格式化字符串。

2705
02:09:39,190 --> 02:09:41,140
Here's the beginning of a SQL query.
这里是一个 SQL 查询的开头。

2706
02:09:41,140 --> 02:09:43,810
Here's a placeholder for the user username.
这里是一个用户名的占位符。

2707
02:09:43,810 --> 02:09:45,730
Here's a placeholder for the user's password.
这里是一个用户密码的占位符。

2708
02:09:45,730 --> 02:09:49,400
And I've proactively, correctly, put single quotes around them.
我主动地，正确地，在它们周围加上了单引号。

2709
02:09:49,400 --> 02:09:53,410
The problem is if you just blindly plug users input
问题是，如果你只是盲目地将用户输入

2710
02:09:53,410 --> 02:09:58,390
into pre-made queries like this, they can finish your thought for you,
插入到这样的预制查询中，他们可以帮你完成你的想法，

2711
02:09:58,390 --> 02:10:01,280
in ways you don't expect, if you trust the users.
以你意想不到的方式，如果你信任用户。

2712
02:10:01,280 --> 02:10:03,910
For instance, if I plug in for my username,
例如，如果我将我的用户名插入，

2713
02:10:03,910 --> 02:10:07,600
mail in at harvard.edu, single quote, dash, dash.
mail in at harvard.edu，单引号，连字符，连字符。

2714
02:10:07,600 --> 02:10:09,200
Notice what happens.
注意发生了什么。

2715
02:10:09,200 --> 02:10:11,470
Here's the single quote from the query.
这是查询中的单引号。

2716
02:10:11,470 --> 02:10:13,100
Here's what I typed in.
这是我输入的内容。

2717
02:10:13,100 --> 02:10:14,150
But, wait a minute.
等等，等等。

2718
02:10:14,150 --> 02:10:17,560
It looks like this single quote that I typed in finishes
看起来我输入的这个单引号结束了

2719
02:10:17,560 --> 02:10:19,810
the thought that the developer started.
开发人员开始的想法。

2720
02:10:19,810 --> 02:10:22,527
The dash, dash means, heck, ignore the rest of that.
连字符，连字符表示，哎呀，忽略剩下的部分。

2721
02:10:22,527 --> 02:10:25,360
And, indeed, I've lifted grayed out because what effectively happens
实际上，我已经将灰色部分删除，因为实际上发生的事情是

2722
02:10:25,360 --> 02:10:29,510
is that only executed is what's in yellow here at the moment.
目前只有黄色的部分被执行。

2723
02:10:29,510 --> 02:10:30,010
Why?
为什么？

2724
02:10:30,010 --> 02:10:32,440
Because everything after that close quote,
因为那个结束引号之后的任何内容，

2725
02:10:32,440 --> 02:10:35,255
which finishes the developers thought, is just ignored.
它结束了开发人员的想法，都被忽略了。

2726
02:10:35,255 --> 02:10:38,380
So I mean, this is literally an example of how you can hack into a database
所以，我的意思是，这真的是一个例子，说明你可以如何通过 SQL 注入攻击数据库

2727
02:10:38,380 --> 02:10:39,910
by injecting SQL.
通过注入 SQL。

2728
02:10:39,910 --> 02:10:42,220
Like dash, dash is an example of SQL.
比如连字符，连字符就是一个 SQL 的例子。

2729
02:10:42,220 --> 02:10:45,280
Silly as it is, it's a comment that tells the database
虽然很愚蠢，但这是一种注释，告诉数据库

2730
02:10:45,280 --> 02:10:46,460
to ignore the password.
忽略密码。

2731
02:10:46,460 --> 02:10:47,450
So what does this mean?
所以这意味着什么呢？

2732
02:10:47,450 --> 02:10:50,770
Well, of course you're going to get rows back now because if you're only
好吧，当然你将得到行数据，因为如果你只

2733
02:10:50,770 --> 02:10:53,950
searching for someone by username, it doesn't matter what their password is,
通过用户名搜索某个人，他们的密码是什么并不重要，

2734
02:10:53,950 --> 02:10:57,460
what they typed in, you've essentially blacked out that part
他们输入了什么，你基本上已经屏蔽了那部分

2735
02:10:57,460 --> 02:10:59,530
and you're not even checking the password.
而且你甚至没有检查密码。

2736
02:10:59,530 --> 02:11:03,640
The effect then would be that you could log in as me or Carter or anyone else,
那么结果就是，你就可以以我、卡特或其他任何人的身份登录，

2737
02:11:03,640 --> 02:11:08,410
just by knowing their usernames if the Harvard developer wrote code
只要知道他们的用户名，如果哈佛的开发人员这样写代码

2738
02:11:08,410 --> 02:11:09,183
in this way.
这样。

2739
02:11:09,183 --> 02:11:12,100
And even though I'm pretty sure Harvard key does not suffer from this,
虽然我很确定哈佛的密钥没有受到这个问题的影响，

2740
02:11:12,100 --> 02:11:14,590
so many darn websites have in the past.
但很多网站在过去都受到过这个问题的影响。

2741
02:11:14,590 --> 02:11:17,733
And if you Google, SQL injection attacks-- search by
如果你在谷歌上搜索，SQL 注入攻击-- 通过搜索

2742
02:11:17,733 --> 02:11:20,150
and Google, for instance, the past month or the past year,
比如在谷歌上搜索过去一个月或过去一年，

2743
02:11:20,150 --> 02:11:22,940
you will tragically likely see results because humans
你很有可能会看到结果，因为人类

2744
02:11:22,940 --> 02:11:24,650
continue to make this mistake.
仍在犯同样的错误。

2745
02:11:24,650 --> 02:11:27,830
The solution though, ultimately, is actually just
不过，最终的解决方案实际上就是

2746
02:11:27,830 --> 02:11:30,710
use placeholders, just use the library that
使用占位符，使用那个可以

2747
02:11:30,710 --> 02:11:32,990
escapes potentially dangerous input.
转义潜在危险输入的库。

2748
02:11:32,990 --> 02:11:35,600
And this looks a little weird, but in C we
这看起来有点奇怪，但在 C 语言中，我们

2749
02:11:35,600 --> 02:11:38,000
saw that the escape character was a backslash?
发现转义字符是反斜杠？

2750
02:11:38,000 --> 02:11:41,690
And that made backslash n, or backslash something else, be treated specially.
这使得反斜杠 n，或者反斜杠其他字符，被特殊对待。

2751
02:11:41,690 --> 02:11:45,750
Weirdly, in SQL it tends to be just another single quote.
奇怪的是，在 SQL 中，它往往只是一个单引号。

2752
02:11:45,750 --> 02:11:48,450
So if you do quote, quote that actually means--
所以，如果你使用引号，引号实际上意味着——

2753
02:11:48,450 --> 02:11:49,580
I mean, a literal quote.
我的意思是，一个字面的引号。

2754
02:11:49,580 --> 02:11:52,010
It's not like the empty string, or nothing in between it.
它不像空字符串，或者它之间没有任何东西。

2755
02:11:52,010 --> 02:11:53,060
So it looks weird.
所以看起来很奇怪。

2756
02:11:53,060 --> 02:11:56,630
But, long story short, if you use a library like CS50,
但是，长话短说，如果你使用像 CS50 这样的库，

2757
02:11:56,630 --> 02:11:58,460
or anything in the real world that handles
或者任何在现实世界中处理

2758
02:11:58,460 --> 02:12:01,130
escaping of user input, the whole query you
用户输入的转义，你整个查询

2759
02:12:01,130 --> 02:12:04,910
can think of as being now good and green again because it doesn't matter what
可以认为现在又好又绿了，因为用户输入的内容无关紧要。

2760
02:12:04,910 --> 02:12:05,780
the human types in.
人类输入什么。

2761
02:12:05,780 --> 02:12:10,680
Any scary characters will be properly escaped by the database.
任何危险字符都会被数据库正确转义。

2762
02:12:10,680 --> 02:12:12,740
So it'll depend on the library you're using,
所以这将取决于你使用的库，

2763
02:12:12,740 --> 02:12:15,200
but it almost always is the syntax using question
但它几乎总是使用问号的语法

2764
02:12:15,200 --> 02:12:18,530
marks or some similar placeholder.
标记或一些类似的占位符。

2765
02:12:18,530 --> 02:12:19,130
All right.
好吧。

2766
02:12:19,130 --> 02:12:23,270
So with that said, you are now inducted into the Hall
所以，就这样，你现在被正式纳入名人堂

2767
02:12:23,270 --> 02:12:26,020
of People who know now a little something about databases.
那些现在了解一些关于数据库知识的人的殿堂。

2768
02:12:26,020 --> 02:12:28,520
We've only just scratched the surface of using the language,
我们只触及了使用这种语言的表面，

2769
02:12:28,520 --> 02:12:31,340
but it's now something we'll use to build up more and more interesting
但现在它将被用来构建越来越有趣

2770
02:12:31,340 --> 02:12:33,673
applications, especially for final projects when we soon
的应用程序，特别是对于最终项目，当我们很快

2771
02:12:33,673 --> 02:12:37,160
transition to web programming or mobile app development, if you go that route.
过渡到 Web 编程或移动应用程序开发，如果你选择这条路线。

2772
02:12:37,160 --> 02:12:41,540
But you'll soon be able to speak a language, literally and figuratively,
但你很快就能用一种语言说话，从字面上和比喻上来说，

2773
02:12:41,540 --> 02:12:44,310
that those before you have acquired as well.
这是一种你之前的人们也已经掌握的语言。

2774
02:12:44,310 --> 02:12:48,170
So you are now qualified to understand this sort of internet joke.
所以你现在有资格理解这种网络笑话。

2775
02:12:48,170 --> 02:12:51,020
This is someone who, if I Zoom in, was trying
这是一个试图，如果我放大，试图

2776
02:12:51,020 --> 02:12:55,820
to get out of paying some camera based tolls by tricking the state or the city
通过欺骗州政府或城市来逃避一些基于摄像头的收费。

2777
02:12:55,820 --> 02:12:58,130
into deleting or dropping their whole database.
来删除或删除他们的整个数据库。

2778
02:12:58,130 --> 02:13:01,100
Drop means delete the whole thing, not just the rows therein.
删除意味着删除整个东西，而不仅仅是其中的行。

2779
02:13:01,100 --> 02:13:02,270
OK, so maybe not that funny.
好吧，可能没那么有趣。

2780
02:13:02,270 --> 02:13:06,910
But this is now the note will end on, similar to other xkcd comics
但这就是现在这则笔记将要结束的地方，类似于其他 xkcd 漫画

2781
02:13:06,910 --> 02:13:07,910
we've introduced you to.
我们向你介绍过。

2782
02:13:07,910 --> 02:13:11,150
Every CS person out there has seen, knows this comic.
每个 CS 人都知道，都见过这个漫画。

2783
02:13:11,150 --> 02:13:14,150
So if you ever refer to, with a wink--
所以如果你曾经提到，带着一个眨眼——

2784
02:13:14,150 --> 02:13:17,090
if you ever refer to little Bobby tables with a wink,
如果你曾经带着一个眨眼提到小鲍比·表格，

2785
02:13:17,090 --> 02:13:20,795
if it's a computer scientist on the other end, they'll know whom you mean.
如果另一端是计算机科学家，他们就会知道你的意思。

2786
02:13:23,918 --> 02:13:25,330
[LAUGHING]
[笑声]

2787
02:13:25,330 --> 02:13:26,260
OK, there we go.
好吧，我们开始了。

2788
02:13:29,690 --> 02:13:30,230
All right.
好吧。

2789
02:13:30,230 --> 02:13:30,740
Tough crowd.
难对付的观众。

2790
02:13:30,740 --> 02:13:33,990
All right, Batman, come on down for your cookies, and we'll see you next time.
好了，蝙蝠侠，过来拿你的饼干，我们下次再见。

2791
02:13:33,990 --> 02:13:34,520
[APPLAUSE]
[鼓掌]

2792
02:13:34,520 --> 02:13:37,570
[MUSIC PLAYING]
[音乐播放]

