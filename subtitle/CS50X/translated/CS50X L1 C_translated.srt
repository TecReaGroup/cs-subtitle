1
00:00:00,000 --> 00:00:03,493
[INTRIGUING MUSIC]
[引人入胜的音乐]

2
00:01:01,377 --> 00:01:06,220
DAVID MALAN: All right, so this is CS50.
大卫·马兰：好的，这是 CS50。

3
00:01:06,220 --> 00:01:09,310
And this is week 1, zero index, so to speak.
这是第一周，可以说，从零开始。

4
00:01:09,310 --> 00:01:12,890
And it's not every day that you can say that you've learned a new language,
你并不每天都能说你学习了一门新的语言，

5
00:01:12,890 --> 00:01:14,260
but today is that day.
但今天是那一天。

6
00:01:14,260 --> 00:01:18,010
Today, we explore a more traditional and older language called C.
今天，我们将探索一种更传统、更古老的语言，叫做 C。

7
00:01:18,010 --> 00:01:22,450
And rest assured that even if what you're about to see-- no pun intended--
请放心，即使你将要看到的内容——我并没有说双关语——

8
00:01:22,450 --> 00:01:25,420
looks very cryptic, very unusual, particularly if you're
看起来非常神秘，非常不寻常，特别是如果你

9
00:01:25,420 --> 00:01:28,967
among those less comfortable, cling to the ideas from last week,
是那些不太舒服的人，那就坚持上周的思路，

10
00:01:28,967 --> 00:01:32,050
week zero, wherein we talked about some of those fundamentals of functions
第零周，我们讨论了一些函数的基础知识

11
00:01:32,050 --> 00:01:35,230
and loops and conditionals, all of which are coming back today.
循环和条件语句，所有这些今天都会回来。

12
00:01:35,230 --> 00:01:37,815
Indeed, whereas last week, and with problem set 0,
事实上，上周，以及在习题集 0 中，

13
00:01:37,815 --> 00:01:39,940
we focused on learning how to program with Scratch,
我们专注于学习如何用 Scratch 编程，

14
00:01:39,940 --> 00:01:44,770
which, again, you might have played with as a younger student days back.
你可能在小时候玩过。

15
00:01:44,770 --> 00:01:46,870
Today, we focus on C instead.
今天，我们将专注于 C 语言。

16
00:01:46,870 --> 00:01:50,260
But along the way, we're going to focus, as always, frankly,
但在此过程中，我们始终如一地关注，坦率地说，

17
00:01:50,260 --> 00:01:51,850
on learning how to solve problems.
学习如何解决问题。

18
00:01:51,850 --> 00:01:54,820
But among the goals for today and really on an entire class like this
但今天的目标，以及这门课的目标，

19
00:01:54,820 --> 00:01:58,610
is just to give you week after week all the more tools for your toolkit,
只是每周给你提供更多工具，

20
00:01:58,610 --> 00:02:00,680
so to speak, via which to do exactly that.
可以用这些工具来完成这些。

21
00:02:00,680 --> 00:02:03,860
So for instance today, we'll learn how to solve problems all the more
例如，今天，我们将学习如何用更多的方法来解决问题

22
00:02:03,860 --> 00:02:06,420
so with functions, as per last week.
使用函数，就像上周一样。

23
00:02:06,420 --> 00:02:07,910
We'll do the same with variables.
我们也会用变量做同样的事情。

24
00:02:07,910 --> 00:02:10,789
We'll do the same with conditionals, with loops, and with more.
我们也会用条件语句、循环等等做同样的事情。

25
00:02:10,789 --> 00:02:13,190
But we'll also learn at the end of today's class
但我们也会在今天课的最后学习

26
00:02:13,190 --> 00:02:14,970
really how not to solve problems.
如何不能解决问题。

27
00:02:14,970 --> 00:02:18,410
It turns out as powerful as Macs, PCs, cell phones are nowadays,
事实证明，尽管现在的 Mac、PC、手机功能强大，

28
00:02:18,410 --> 00:02:21,890
there's actually certain things that they can't do very well
但实际上，它们有些事情做不好，

29
00:02:21,890 --> 00:02:24,650
and information they can't represent very well.
它们无法很好地表示某些信息。

30
00:02:24,650 --> 00:02:28,760
And that actually leads to a lot of real-world problems, both past
这实际上会导致很多现实世界中的问题，无论是过去

31
00:02:28,760 --> 00:02:29,940
and surely future.
还是将来。

32
00:02:29,940 --> 00:02:33,540
So more on what we're not going to be able to do with programming before
所以，在学习更多关于编程无法做到的事情之前，

33
00:02:33,540 --> 00:02:34,040
long.
我们先来看看。

34
00:02:34,040 --> 00:02:36,600
But beyond that, let's come back to this picture here.
除此之外，让我们回到这张图片。

35
00:02:36,600 --> 00:02:38,900
So this was the very first program that I wrote,
这是我写的第一个程序，

36
00:02:38,900 --> 00:02:40,880
that you wrote presumably in some form.
你可能也以某种形式写过。

37
00:02:40,880 --> 00:02:43,400
And all it does is say "Hello, world."
它只做了一件事，就是说 "Hello, world"。

38
00:02:43,400 --> 00:02:47,660
But as promised, today, this puzzle piece, or these puzzle pieces together,
但正如承诺的那样，今天，这块拼图，或者说这些拼图放在一起，

39
00:02:47,660 --> 00:02:50,880
are going to very quickly start to look more like this.
会很快变得像这样。

40
00:02:50,880 --> 00:02:54,295
And I've deliberately color coded it in a way so that the text on the screen
我特意用颜色编码了它，这样屏幕上的文本

41
00:02:54,295 --> 00:02:55,920
now kind of resembles the puzzle piece.
现在有点像拼图了。

42
00:02:55,920 --> 00:02:59,540
So if I go back, notice that we had this, when green flag clicked puzzle
所以如果我回到这里，你会注意到，我们有这个，当绿旗被点击时，这块拼图

43
00:02:59,540 --> 00:03:02,780
piece, mostly in yellow with the green flag, that sort of kicks off
这块拼图主要是黄色的，上面有绿色的旗帜，它开始

44
00:03:02,780 --> 00:03:04,550
the whole process once you actually click
整个过程，一旦你点击

45
00:03:04,550 --> 00:03:07,640
the button at top right of Scratch's user interface.
Scratch 用户界面右上角的按钮。

46
00:03:07,640 --> 00:03:11,990
And then there's the purple block which actually is the verb, the action,
然后是紫色块，它实际上是动词，是动作，

47
00:03:11,990 --> 00:03:13,620
the function that does something.
执行某个功能的函数。

48
00:03:13,620 --> 00:03:16,820
So if I bring us back over to what we're about to see today,
所以让我们回到今天将要看到的内容，

49
00:03:16,820 --> 00:03:20,477
there's going to be some boilerplate, so to speak, some orange text here
屏幕上会有一些模板，可以说是橙色的文字，

50
00:03:20,477 --> 00:03:23,060
on the screen that for now you just type and take for granted,
现在你只需要输入并视作理所当然，

51
00:03:23,060 --> 00:03:25,430
like you need to write your code like that.
就像你必须那样写你的代码一样。

52
00:03:25,430 --> 00:03:27,435
But more interesting is going to be the purple.
但更有趣的是紫色部分。

53
00:03:27,435 --> 00:03:29,810
And we're going to see today that the function previously
我们今天将看到之前

54
00:03:29,810 --> 00:03:34,430
called "say" in Scratch is now called "printf" in this language called C.
在 Scratch 中叫做 "say" 的函数，现在在这门叫做 C 的语言中叫做 "printf"。

55
00:03:34,430 --> 00:03:37,520
But in white here, you'll see similar text to our white oval
但在这里的白色部分，你会看到类似于我们上周的白色椭圆的文字，

56
00:03:37,520 --> 00:03:40,550
last week, whereby that's where user input, like your input
上周，那是用户输入，就像你作为程序员的输入

57
00:03:40,550 --> 00:03:42,277
as the programmer, can actually go.
可以实际输入的地方。

58
00:03:42,277 --> 00:03:43,610
So there's a lot of distraction.
所以有很多干扰。

59
00:03:43,610 --> 00:03:44,930
And honestly, it's these kinds of things that
说实话，正是这些东西

60
00:03:44,930 --> 00:03:47,180
tend to distract and get frustrating early on when
在学习编程初期容易造成干扰，让人感到沮丧，

61
00:03:47,180 --> 00:03:48,780
learning to code for the first time.
第一次学习编程的时候。

62
00:03:48,780 --> 00:03:52,170
But the ideas, most importantly, are going to be the same.
但最重要的是，这些想法会是一样的。

63
00:03:52,170 --> 00:03:54,060
So how are we going to go about using this.
那么我们如何使用它呢？

64
00:03:54,060 --> 00:03:55,910
Well, it turns out, like last week, you're
事实证明，就像上周一样，你会

65
00:03:55,910 --> 00:03:58,190
going to start writing something called source code.
开始编写一些叫做源代码的东西。

66
00:03:58,190 --> 00:04:01,280
So code as we know it, quote, unquote, is more technically called
所以我们所知道的代码，引号内的“代码”，在技术上更准确地称为

67
00:04:01,280 --> 00:04:02,060
"source code."
“源代码”。

68
00:04:02,060 --> 00:04:04,460
That's what you and I as humans actually write.
那就是你我作为人类实际编写的东西。

69
00:04:04,460 --> 00:04:07,350
And indeed it might look a little something like we just saw.
而且确实它看起来有点像我们刚刚看到的。

70
00:04:07,350 --> 00:04:11,090
But unfortunately, computers only speak this, binary--
但不幸的是，计算机只能理解这种语言，二进制——

71
00:04:11,090 --> 00:04:15,660
zeros and ones-- more properly known as machine code, in other words,
零和一——更准确地说，是机器代码，换句话说，

72
00:04:15,660 --> 00:04:19,550
those same patterns of zeros and ones last week, someone guessed,
上周，有人猜到了那些相同的零和一的模式，

73
00:04:19,550 --> 00:04:23,090
print out "hello, world" on the screen because one of those patterns
在屏幕上打印出 "hello, world" 因为其中一个模式

74
00:04:23,090 --> 00:04:27,570
is an H. Another pattern is an E, an L, and L, and an O, and so forth.
是一个 H。另一个模式是 E、L、L、O 等等。

75
00:04:27,570 --> 00:04:31,880
And then other patterns of those zeros and ones are commands or instructions
然后，那些零和一的其他模式就是命令或指令

76
00:04:31,880 --> 00:04:37,280
to the computer that literally say, show H-E-L-L-O comma "world" on the screen.
对计算机来说，实际上就是说，在屏幕上显示 H-E-L-L-O 逗号 "world"。

77
00:04:37,280 --> 00:04:40,520
But machine code would not be nearly as much fun
但机器代码如果真的用零和一写的话，就没有那么有趣了

78
00:04:40,520 --> 00:04:43,070
to write if it were indeed in zeros and ones.
了。

79
00:04:43,070 --> 00:04:45,080
Entirely for us, ideally, you and I are going
理想情况下，完全是为了我们，你我都会

80
00:04:45,080 --> 00:04:49,100
to write source code, which conceptually is sort of up here, high level.
去编写源代码，从概念上讲，它就像是这里，高级别。

81
00:04:49,100 --> 00:04:52,790
But we're going to need a program to convert it to the lower-level machine
但我们需要一个程序来将其转换为低级别的机器

82
00:04:52,790 --> 00:04:56,240
code so that we don't spend our lives actually having to read and write
代码，这样我们就不用花一辈子的时间去读写

83
00:04:56,240 --> 00:04:59,000
zeros and ones, which back in the day, kind of in yesteryear,
零和一，在过去，也就是前几年，

84
00:04:59,000 --> 00:05:01,160
you kind of did with things called punch cards
你用的是叫做打孔卡的东西

85
00:05:01,160 --> 00:05:03,050
and holes on physical sheets of paper.
以及纸质卡片上的孔。

86
00:05:03,050 --> 00:05:06,440
We're beyond that because after years and years of innovation,
我们已经超越了那一步，因为经过多年的创新，

87
00:05:06,440 --> 00:05:09,462
folks have given us higher-level languages instead.
人们给了我们更高等级的语言。

88
00:05:09,462 --> 00:05:11,420
So here's what we're going to need to do today.
所以今天我们需要做的事情是。

89
00:05:11,420 --> 00:05:14,900
If at the end of the day you and I are writing source code
如果最终你我编写的是源代码

90
00:05:14,900 --> 00:05:18,260
but we want machine code as output, we need something
但我们想要机器代码作为输出，我们需要一些东西

91
00:05:18,260 --> 00:05:21,900
in the middle that's going to convert that source code to machine code.
在中间来将源代码转换为机器代码。

92
00:05:21,900 --> 00:05:23,900
You and I are not going to have to learn or talk
我们不必学习或谈论

93
00:05:23,900 --> 00:05:25,672
about really any more zeros and ones.
关于更多关于零和一的知识。

94
00:05:25,672 --> 00:05:28,880
And the type of program we're going to start using today and introduce you to
今天我们要开始使用并介绍给你的程序类型

95
00:05:28,880 --> 00:05:30,080
is called a compiler.
叫做编译器。

96
00:05:30,080 --> 00:05:34,130
So a compiler is a program that translates one language to another.
所以编译器是一个将一种语言翻译成另一种语言的程序。

97
00:05:34,130 --> 00:05:35,720
And it can be any two languages.
可以是任意两种语言。

98
00:05:35,720 --> 00:05:39,770
But today, and often, we'll talk about it in the context of source code
但是今天，通常情况下，我们会从源代码的角度来讨论它

99
00:05:39,770 --> 00:05:40,890
to machine code.
到机器码。

100
00:05:40,890 --> 00:05:45,325
So this is Apple or Google or Microsoft or folks from other companies
所以这是苹果、谷歌、微软或其他公司的员工

101
00:05:45,325 --> 00:05:48,200
or even volunteers who have written software that do this conversion.
甚至还有志愿者编写了执行这种转换的软件。

102
00:05:48,200 --> 00:05:51,230
You and I are essentially going to download a free compiler
我们实际上要下载一个免费的编译器

103
00:05:51,230 --> 00:05:55,040
and use it to actually get our computer to understand the source
并使用它来让我们的计算机真正理解源代码

104
00:05:55,040 --> 00:05:58,595
code that you and I write in these higher-level languages.
我们用这些高级语言编写的代码。

105
00:05:58,595 --> 00:05:59,970
So where are we going to do that?
所以我们要在哪里做呢？

106
00:05:59,970 --> 00:06:01,845
Well, we could actually give you instructions
好吧，我们实际上可以给你一些说明

107
00:06:01,845 --> 00:06:05,340
and you could download the appropriate free open-source software
你可以下载相应的免费开源软件

108
00:06:05,340 --> 00:06:06,607
onto your own Mac or PC.
到你的Mac或PC上。

109
00:06:06,607 --> 00:06:09,690
The reality is that creates so many technical support headaches because we
现实情况是，这会导致很多技术支持方面的麻烦，因为我们

110
00:06:09,690 --> 00:06:11,280
all have slightly different computers.
大家的电脑都略有不同。

111
00:06:11,280 --> 00:06:14,640
We all have slightly different versions of Windows or macOS or Linux
我们都有稍微不同的 Windows、macOS 或 Linux 版本

112
00:06:14,640 --> 00:06:15,840
or other operating systems.
或其他操作系统。

113
00:06:15,840 --> 00:06:19,260
And that, too, tends to be a distraction at the beginning of any course
这在任何课程的开始阶段，也往往会让人分心

114
00:06:19,260 --> 00:06:20,730
like this or learning programming.
比如这门课，或者学习编程。

115
00:06:20,730 --> 00:06:22,680
So we're going to use the cloud instead.
所以我们要使用云来替代。

116
00:06:22,680 --> 00:06:28,530
We're going to use a URL of the form https://cs50.dev.
我们将使用 https://cs50.dev 格式的 URL。

117
00:06:28,530 --> 00:06:32,040
And what this will do for you is put inside of your browser window
这将为你做的就是把你的浏览器窗口里

118
00:06:32,040 --> 00:06:36,390
absolutely everything you need for the course, but it's going to use software,
放进去你需要的所有课程内容，但它会使用软件，

119
00:06:36,390 --> 00:06:39,810
software called Visual Studio code, otherwise known as VS Code,
叫做 Visual Studio Code 的软件，也被称为 VS Code，

120
00:06:39,810 --> 00:06:41,730
that's actually free itself.
它本身是免费的。

121
00:06:41,730 --> 00:06:43,200
It's very popular in industry.
它在行业内非常流行。

122
00:06:43,200 --> 00:06:45,420
It's what "real" programmers use every day.
这是“真正的”程序员每天都在使用的。

123
00:06:45,420 --> 00:06:47,560
But it's a cloud-based version thereof.
但它是一个基于云的版本。

124
00:06:47,560 --> 00:06:50,250
And so everything will just work for you out of the box.
所以一切都将为你开箱即用。

125
00:06:50,250 --> 00:06:52,530
But toward the end of CS50, the goal is going
但在 CS50 的最后，目标是

126
00:06:52,530 --> 00:06:55,200
to be to get you off of CS50's infrastructure,
让你摆脱 CS50 的基础设施，

127
00:06:55,200 --> 00:06:59,040
to get you to download this freely available software onto your own Mac
让你下载这个免费的软件到你的 Mac 上

128
00:06:59,040 --> 00:07:02,170
or PC if you so choose so that those training wheels, so to speak,
或者你的 PC 上，如果你愿意的话，这样那些辅助轮，这么说吧，

129
00:07:02,170 --> 00:07:02,840
can come off.
就可以取下来了。

130
00:07:02,840 --> 00:07:05,170
And then even if you never take another class again,
然后即使你再也不上其他课程了，

131
00:07:05,170 --> 00:07:07,780
you don't need any class's infrastructure moving forward.
你不需要任何课程的基础设施。

132
00:07:07,780 --> 00:07:10,960
You'll have everything you want and need on your own Mac or PC.
你将拥有你在自己的 Mac 或 PC 上需要的一切。

133
00:07:10,960 --> 00:07:13,250
But for now, it'll save us a bit of time.
但现在，这将为我们节省一些时间。

134
00:07:13,250 --> 00:07:16,750
So in just a bit, I'm going to go to that URL myself on my computer.
所以过一会儿，我将在我自己的电脑上访问那个 URL。

135
00:07:16,750 --> 00:07:19,552
And I and you will see a user interface that
你和我都会看到一个用户界面，它

136
00:07:19,552 --> 00:07:21,010
looks a little something like this.
看起来有点像这样。

137
00:07:21,010 --> 00:07:23,170
The colors might be different based on your settings.
颜色可能会根据你的设置而有所不同。

138
00:07:23,170 --> 00:07:24,800
Fonts might be different, and so forth.
字体也可能不同，等等。

139
00:07:24,800 --> 00:07:27,590
But in general, it consists of a few different regions.
但总的来说，它包含几个不同的区域。

140
00:07:27,590 --> 00:07:31,750
So over here at the top is where we are going to start writing code today.
所以这里上方是我们今天将开始编写代码的地方。

141
00:07:31,750 --> 00:07:34,930
So it's a tabbed interface like any number of programs nowadays.
所以它是一个带标签的界面，就像现在许多程序一样。

142
00:07:34,930 --> 00:07:38,058
And this is that same C code we saw a moment ago.
而这是我们刚才看到的相同的C代码。

143
00:07:38,058 --> 00:07:40,600
So this is where, in a moment, I'm going to start to type it.
所以这里，一会儿，我将开始输入。

144
00:07:40,600 --> 00:07:43,330
Over here at the bottom is what we're going to call
这里下方是我们所说的

145
00:07:43,330 --> 00:07:45,438
a terminal window, or a console.
终端窗口或控制台。

146
00:07:45,438 --> 00:07:47,980
And the terminal window is where we're going to type commands
而终端窗口是我们输入命令的地方

147
00:07:47,980 --> 00:07:50,500
for compiling our code, for running our code.
用于编译我们的代码，用于运行我们的代码。

148
00:07:50,500 --> 00:07:54,860
And we'll see today a contrast between a graphical-user interface,
我们今天将看到图形用户界面之间的对比，

149
00:07:54,860 --> 00:07:57,370
or GUI, which has menus and icons and things
或GUI，它有菜单、图标和各种东西

150
00:07:57,370 --> 00:08:01,270
you click and are very familiar with, versus a command-line interface,
你可以点击，你非常熟悉，与命令行界面相比，

151
00:08:01,270 --> 00:08:02,200
or CLI.
或CLI。

152
00:08:02,200 --> 00:08:04,270
And so we're using both of these together.
所以我们同时使用这两者。

153
00:08:04,270 --> 00:08:08,007
And command-line interface just means, down here, you only use your keyboard.
命令行界面只是意味着，在下方，你只使用键盘。

154
00:08:08,007 --> 00:08:10,340
You can click, click, click if you want with your mouse.
如果你愿意，可以用鼠标点击、点击、点击。

155
00:08:10,340 --> 00:08:13,423
It's not going to generally do much because a command-line interface takes
它通常不会做太多，因为命令行界面接受

156
00:08:13,423 --> 00:08:14,540
commands at the keyboard.
键盘上的命令。

157
00:08:14,540 --> 00:08:16,840
So in a weird sense, it's going to feel like taking
所以从某种奇怪的意义上说，这将感觉像是

158
00:08:16,840 --> 00:08:20,620
a step backwards from the Macs, the PCs, the iPhones, and Android phones we all
从我们所有人使用的Mac、PC、iPhone和Android手机倒退一步

159
00:08:20,620 --> 00:08:22,660
have, which are very graphical.
这些都是非常图形化的。

160
00:08:22,660 --> 00:08:26,120
But it turns out, once you become a "computer" person or a programmer,
但事实证明，一旦你成为一个“计算机”人或程序员，

161
00:08:26,120 --> 00:08:29,680
you can be a lot more productive, a lot more efficient, I dare say,
你可以更有成效，更有效率，我敢说，

162
00:08:29,680 --> 00:08:31,990
by learning to harness the command-line interface
通过学习利用命令行界面

163
00:08:31,990 --> 00:08:35,169
and using both types of interfaces for what each is good at.
并为每个界面擅长的事情使用这两种类型的界面。

164
00:08:35,169 --> 00:08:36,730
So more on that in just a bit.
稍后会详细介绍。

165
00:08:36,730 --> 00:08:41,289
Over here at left, you're going to see soon a folder interface like Mac OS
这里左侧，你很快就会看到一个类似Mac OS的文件夹界面

166
00:08:41,289 --> 00:08:45,010
or Windows where any of the files or folders we create in CS50
或Windows，我们在CS50中创建的任何文件或文件夹

167
00:08:45,010 --> 00:08:46,310
are going to end up, as well.
也会出现在这里。

168
00:08:46,310 --> 00:08:47,990
So it gives you the best of both worlds.
所以它让你拥有两个世界的精华。

169
00:08:47,990 --> 00:08:51,310
You can point and click on the left, or you can type commands at the bottom,
你可以在左侧点选，也可以在下方输入命令，

170
00:08:51,310 --> 00:08:52,420
as we'll soon see.
我们很快就会看到。

171
00:08:52,420 --> 00:08:54,670
And then along here is the so-called activity bar,
然后这里就是所谓的活动栏，

172
00:08:54,670 --> 00:08:58,500
where there's just VS Code-specific features but also CS50-specific
这里只有VS Code特有的功能，但也包含CS50特有的功能。

173
00:08:58,500 --> 00:08:59,000
features.
功能。

174
00:08:59,000 --> 00:09:01,420
And if you're in your own version of CS50.dev,
如果你在自己的CS50.dev版本中，

175
00:09:01,420 --> 00:09:03,580
you click through in the dot dot dot menu
你可以点击省略号菜单

176
00:09:03,580 --> 00:09:05,320
or zoom out so you can see everything.
或者缩小，这样你就可以看到所有内容。

177
00:09:05,320 --> 00:09:08,530
You'll see CS50's own rubber duck, virtually speaking,
你会看到CS50自己的橡皮鸭，虚拟地说，

178
00:09:08,530 --> 00:09:10,870
that will be there throughout the course to answer
它将在整个课程中出现，以回答

179
00:09:10,870 --> 00:09:13,460
any and all of your questions, as well.
你所有的问题。

180
00:09:13,460 --> 00:09:15,190
So more on that soon, too.
很快也会有更多关于这方面的信息。

181
00:09:15,190 --> 00:09:18,040
So here's the code that I propose that we write first,
所以这是我建议我们首先编写的代码，

182
00:09:18,040 --> 00:09:21,800
just like we wrote our very first Scratch program to say "hello, world."
就像我们编写第一个Scratch程序来说“hello, world.”一样。

183
00:09:21,800 --> 00:09:23,650
So let's go ahead and do exactly this.
所以让我们继续做这件事。

184
00:09:23,650 --> 00:09:25,870
I'm going to switch over to this screen here,
我将切换到这个屏幕，

185
00:09:25,870 --> 00:09:29,980
where I've already logged into CS50.dev on my computer.
我已经在我的电脑上登录了CS50.dev。

186
00:09:29,980 --> 00:09:33,760
And just to keep the focus on the code, I've hidden the activity bar.
为了将重点放在代码上，我已经隐藏了活动栏。

187
00:09:33,760 --> 00:09:36,140
I've hidden the File Explorer, so to speak.
可以说，我已经隐藏了文件资源管理器。

188
00:09:36,140 --> 00:09:39,740
So you're seeing here the area where all of my tabs are about to go
所以你在这里看到的是我的所有标签即将出现的地方

189
00:09:39,740 --> 00:09:42,490
and the terminal window, where all of my commands are going to go.
以及终端窗口，我的所有命令都将在这里运行。

190
00:09:42,490 --> 00:09:44,710
But I've just simplified the UI to keep our focus
但我只是简化了用户界面，以保持我们关注

191
00:09:44,710 --> 00:09:46,910
on the interesting parts for now.
现在有趣的的部分。

192
00:09:46,910 --> 00:09:53,140
So how do I go about actually writing and compiling and running some code?
那么，我如何实际编写、编译和运行一些代码呢？

193
00:09:53,140 --> 00:09:55,690
Well, the teaser is going to be these three steps.
好吧，预告将是这三个步骤。

194
00:09:55,690 --> 00:09:58,510
One of these is a command called, aptly, Code.
其中一个命令叫做，恰如其分地，Code。

195
00:09:58,510 --> 00:10:02,260
And Code is just going to let me to open or create a new file,
Code 只是允许我打开或创建一个新文件，

196
00:10:02,260 --> 00:10:03,930
like a file called "hello.c."
例如一个名为“hello.c”的文件。

197
00:10:03,930 --> 00:10:06,960
Make is going to be, for now, my compiler that
Make 目前将是我的编译器，

198
00:10:06,960 --> 00:10:11,280
allows me to make the program, that is convert source code into machine
允许我创建程序，即将源代码转换为机器代码

199
00:10:11,280 --> 00:10:13,710
code, so from C to zeros and ones.
代码，所以从 C 转换为零和一。

200
00:10:13,710 --> 00:10:15,570
And then weirdly, but we'll soon see why,
然后奇怪的是，但我们很快就会明白为什么，

201
00:10:15,570 --> 00:10:19,810
./hello is going to be the command to run my actual code,
./hello 将是运行我的实际代码的命令，

202
00:10:19,810 --> 00:10:23,760
so the textual equivalent of like double-clicking on a Mac or a PC icon
所以相当于在 Mac 或 PC 上双击图标

203
00:10:23,760 --> 00:10:25,890
or tapping an icon on your phone.
或点击手机上的图标。

204
00:10:25,890 --> 00:10:26,670
So that's it.
就是这样。

205
00:10:26,670 --> 00:10:30,810
These three commands are going to allow me to write, to compile, and to run
这三个命令将允许我编写、编译和运行

206
00:10:30,810 --> 00:10:32,070
code ultimately.
最终代码。

207
00:10:32,070 --> 00:10:33,340
So let's go ahead and do that.
所以让我们继续做下去。

208
00:10:33,340 --> 00:10:35,170
I'm back in my VS Code interface.
我回到了我的 VS Code 界面。

209
00:10:35,170 --> 00:10:39,000
I'm going to go ahead and run "code hello.c."
我将继续运行“code hello.c”。

210
00:10:39,000 --> 00:10:40,900
And notice a couple of details here.
注意这里的一些细节。

211
00:10:40,900 --> 00:10:44,790
So one, there's this weird dollar sign, which has nothing to do with currency,
所以，一个是这个奇怪的美元符号，它与货币无关，

212
00:10:44,790 --> 00:10:48,000
but it's just a common convention in the programming world
而它只是编程世界中的一个通用约定

213
00:10:48,000 --> 00:10:50,520
to represent your prompt.
代表你的提示符。

214
00:10:50,520 --> 00:10:53,190
So if a TF, if I ever say, go to your prompt,
所以，如果 TF，如果我曾经说过，去你的提示符，

215
00:10:53,190 --> 00:10:55,170
we really mean, go to your terminal window.
我们实际上指的是，去你的终端窗口。

216
00:10:55,170 --> 00:10:56,100
Go to the dollar sign.
去美元符号。

217
00:10:56,100 --> 00:10:58,285
And the dollar sign is where you type the command.
而美元符号是您输入命令的地方。

218
00:10:58,285 --> 00:11:01,160
Sometimes it's a different symbol, but a dollar sign is conventional.
有时它是一个不同的符号，但美元符号是约定俗成的。

219
00:11:01,160 --> 00:11:03,950
Now that I've typed "code" space "hello.c,"
现在我已经输入了“code”空格“hello.c”，

220
00:11:03,950 --> 00:11:05,450
I'm going to go ahead and hit Enter.
我将继续按下 Enter 键。

221
00:11:05,450 --> 00:11:07,158
And maybe not surprisingly, this gives me
也许并不令人惊讶，这给了我

222
00:11:07,158 --> 00:11:10,850
a brand new tab, a new file if you will, called "hello.c."
一个全新的标签，如果你愿意，一个新的文件，叫做“hello.c”。

223
00:11:10,850 --> 00:11:15,290
And just like Word documents have their own file extension, like DOC, DOCX,
就像 Word 文档有自己的文件扩展名，例如 DOC、DOCX，

224
00:11:15,290 --> 00:11:22,050
and Excel files have .XLSX and PDFs have .PDF and GIFs have .GIF and so forth,
Excel 文件有 .XLSX，PDF 文件有 .PDF，GIF 文件有 .GIF，等等，

225
00:11:22,050 --> 00:11:26,780
so do C files have a file extension by convention that is .C.
所以 C 文件也按照惯例有文件扩展名，即 .C。

226
00:11:26,780 --> 00:11:28,350
Now, a couple of minor points.
现在，一些小细节。

227
00:11:28,350 --> 00:11:30,710
Notice that, by convention, I'm almost always
注意，按照惯例，我几乎总是

228
00:11:30,710 --> 00:11:32,630
going to name my files in lowercase.
将我的文件命名为小写。

229
00:11:32,630 --> 00:11:36,440
By convention, I'm never going to use spaces in my file names.
按照惯例，我永远不会在文件名中使用空格。

230
00:11:36,440 --> 00:11:39,080
And my file extension, too, is going to be lowercase.
我的文件扩展名也是小写。

231
00:11:39,080 --> 00:11:41,840
Long story short, accidentally hitting the spacebar
长话短说，意外地按下空格键

232
00:11:41,840 --> 00:11:44,180
or using file names with spaces just tends
或者使用包含空格的文件名，往往

233
00:11:44,180 --> 00:11:47,130
to make life harder when you're in a command-line environment.
在命令行环境中，会让生活更难。

234
00:11:47,130 --> 00:11:49,530
So just beware silly, stupid things like that.
所以要注意像这样愚蠢的事情。

235
00:11:49,530 --> 00:11:51,410
So all lowercase, no spaces for now.
现在都是小写，没有空格。

236
00:11:51,410 --> 00:11:54,380
So my cursor is literally blinking because the program
我的光标不停地闪烁，因为程序

237
00:11:54,380 --> 00:11:55,825
wants me to write some code.
想要我写一些代码。

238
00:11:55,825 --> 00:11:57,200
I'm going to do this from memory.
我要凭记忆写。

239
00:11:57,200 --> 00:12:00,607
It'll take you presumably some time to acquire the same instincts.
你可能需要一些时间才能获得相同的直觉。

240
00:12:00,607 --> 00:12:02,940
But I'm going to go ahead and type this first line here,
但我现在先输入第一行，

241
00:12:02,940 --> 00:12:06,390
pronounced "include standard io.h"--
读作“include standard io.h”——

242
00:12:06,390 --> 00:12:07,590
more on that soon--
稍后会详细介绍——

243
00:12:07,590 --> 00:12:11,190
int main(void), with some parentheses thrown in.
int main(void)，加了一些括号。

244
00:12:11,190 --> 00:12:13,740
Notice what's about to happen here is a little interesting.
注意即将发生的事情有点意思。

245
00:12:13,740 --> 00:12:15,750
In the code I want to type, I want what we'll
在我的代码中，我想要我们所说的

246
00:12:15,750 --> 00:12:18,210
call curly braces, the sort of squiggles that you
花括号，就是你

247
00:12:18,210 --> 00:12:20,460
don't use often in English, at least, but are there
在英语中并不经常使用，但它们就在

248
00:12:20,460 --> 00:12:21,750
on your keyboard somewhere.
你的键盘上。

249
00:12:21,750 --> 00:12:25,350
But notice what VS Code does, and a lot of programming environments,
但注意 VS Code 的操作，以及许多编程环境，

250
00:12:25,350 --> 00:12:27,480
is it finishes part of my thought.
它会完成我的一部分想法。

251
00:12:27,480 --> 00:12:30,330
So I'm only going to type a left curly brace,
所以我只需要输入一个左花括号，

252
00:12:30,330 --> 00:12:32,950
but notice I actually get two of them.
但注意我实际上得到了两个。

253
00:12:32,950 --> 00:12:36,820
And if I hit Enter, notice that not only does it scooch one down a bit,
如果我按下回车，注意它不仅向下移动了一点，

254
00:12:36,820 --> 00:12:40,350
it also indents my cursor because, just like with pseudocode last week,
它还缩进了我的光标，就像上周的伪代码一样，

255
00:12:40,350 --> 00:12:43,320
whenever you're doing something logically that should only
当你在逻辑上做某事时，它应该只

256
00:12:43,320 --> 00:12:45,930
happen if the thing above it happens, similarly
发生在它上面发生的情况下，类似地

257
00:12:45,930 --> 00:12:48,900
is indentation going to be a thing when we actually write code.
缩进将成为我们真正编写代码时的一件事。

258
00:12:48,900 --> 00:12:51,870
So VS Code and programs like it just try to save us
所以 VS Code 和类似的程序只是试图为我们节省

259
00:12:51,870 --> 00:12:54,450
keystrokes so I don't have to waste time hitting the spacebar
按键，所以我不用浪费时间按下空格键

260
00:12:54,450 --> 00:12:57,900
or hitting Tab or wasting my human time like that.
或按下 Tab 键，或浪费我的人类时间。

261
00:12:57,900 --> 00:13:00,180
All right, so with that said, I'm going to go ahead
好吧，话虽如此，我将继续

262
00:13:00,180 --> 00:13:02,430
and type the last of these lines, "printf,"
输入最后一行，"printf"，

263
00:13:02,430 --> 00:13:05,860
where the F is going to mean "formatted," and then a parentheses.
其中 F 代表“格式化”，然后是一个括号。

264
00:13:05,860 --> 00:13:07,290
And notice it gave me two.
注意它给了我两个。

265
00:13:07,290 --> 00:13:08,910
It gave me the second one for free.
它免费给了我第二个。

266
00:13:08,910 --> 00:13:10,270
Sometimes it will get confused.
有时它会感到困惑。

267
00:13:10,270 --> 00:13:13,560
And you can certainly override this, delete it, and start over.
你当然可以覆盖它，删除它，然后重新开始。

268
00:13:13,560 --> 00:13:16,680
And now, unlike Scratch, in C, It turns out
现在，与 Scratch 不同，在 C 语言中，事实证明

269
00:13:16,680 --> 00:13:18,870
I'm going to need to use double quotes anytime
我需要随时使用双引号

270
00:13:18,870 --> 00:13:22,860
I'm using an English word or phrase or any human language for that matter.
我使用英语单词或短语，或者任何人类语言。

271
00:13:22,860 --> 00:13:25,050
"Hello" comma "world."
“Hello” 逗号 “world”。

272
00:13:25,050 --> 00:13:29,310
And then at the very end of my line, much like English uses periods,
然后在我的行末，就像英语使用句号一样，

273
00:13:29,310 --> 00:13:32,160
I'm going to use a semicolon in C.
我会在 C 语言中使用分号。

274
00:13:32,160 --> 00:13:35,340
So that's a lot of talking, but it's not much coding.
所以说了很多，但代码并不多。

275
00:13:35,340 --> 00:13:37,290
It's technically six lines of code.
从技术上讲是六行代码。

276
00:13:37,290 --> 00:13:40,600
But honestly, the only interesting one intellectually, as we'll soon see,
但老实说，从智力上来说，唯一有趣的是，正如我们很快就会看到的，

277
00:13:40,600 --> 00:13:41,670
is really line 5.
实际上是第五行。

278
00:13:41,670 --> 00:13:44,580
Like, that is the equivalent of that, say, block.
就像，它等同于那个，比如，块。

279
00:13:44,580 --> 00:13:46,500
Now here's where I'll cross my fingers, hoping
现在，我祈祷

280
00:13:46,500 --> 00:13:48,750
that I didn't make any typographical errors.
我没有犯任何打字错误。

281
00:13:48,750 --> 00:13:50,700
It's going to automatically save for me.
它会自动为我保存。

282
00:13:50,700 --> 00:13:53,790
And I'm going to go back to my terminal window where now I'm
我将回到我的终端窗口，在那里我正在

283
00:13:53,790 --> 00:13:56,670
going to do that second command, "make" space "hello."
接下来执行第二个命令，"make" 空格 "hello"。

284
00:13:56,670 --> 00:14:00,180
Common mistake-- you do not say "make hello.c," because you
常见的错误是，不要说“make hello.c”，因为你

285
00:14:00,180 --> 00:14:01,350
already made that file.
已经创建了这个文件。

286
00:14:01,350 --> 00:14:04,950
You say "make hello," which is the name of the program that in this case I do
你要说“make hello”，这是程序的名称，在本例中，我想

287
00:14:04,950 --> 00:14:06,600
want to create.
创建它。

288
00:14:06,600 --> 00:14:07,830
And Make is smart.
而 Make 很智能。

289
00:14:07,830 --> 00:14:09,550
It's going to look in my folder.
它会查看我的文件夹。

290
00:14:09,550 --> 00:14:12,060
And if it sees a file called "hello.c," it's
如果它看到一个名为 "hello.c" 的文件，它会

291
00:14:12,060 --> 00:14:14,910
going to convert that source code to machine code
将该源代码转换为机器码

292
00:14:14,910 --> 00:14:18,510
and save the results in a simpler shorter-named file just called
并将结果保存在一个更简单、更短名称的文件中，名为

293
00:14:18,510 --> 00:14:20,650
"hello," like an icon on your desktop.
"hello"，就像你桌面上一个图标一样。

294
00:14:20,650 --> 00:14:22,650
Now, hopefully nothing will happen.
现在，希望不会发生任何事情。

295
00:14:22,650 --> 00:14:25,560
And that is a good thing, quite paradoxically.
这其实是一件好事，听起来很矛盾。

296
00:14:25,560 --> 00:14:28,350
If you do anything wrong when programming, odds are you're
如果你在编程时犯了任何错误，很可能你会

297
00:14:28,350 --> 00:14:31,738
going to see one or many more lines of error sort of yelling
看到一行或多行错误信息，就像在

298
00:14:31,738 --> 00:14:33,030
at you that you made a mistake.
告诉你你犯了错误。

299
00:14:33,030 --> 00:14:35,950
Seeing nothing happen is actually a good sign.
什么都没有发生其实是一个好兆头。

300
00:14:35,950 --> 00:14:40,470
So the last command, to run my code, recall our three steps here.
所以最后一个命令，运行我的代码，回顾一下我们之前的三个步骤。

301
00:14:40,470 --> 00:14:46,260
We've written code to create the file, Make to compile the file from source
我们写了代码创建文件，使用 Make 将文件从源代码

302
00:14:46,260 --> 00:14:47,140
code to machine code.
编译成机器码。

303
00:14:47,140 --> 00:14:49,320
So lastly is "./hello."
所以最后是“./hello”。

304
00:14:49,320 --> 00:14:53,130
So this now is the equivalent of my double-clicking on a Mac or PC
所以这现在相当于我在 Mac 或 PC 上双击

305
00:14:53,130 --> 00:14:55,650
or single tapping on a phone.
或者在手机上单点。

306
00:14:55,650 --> 00:14:57,360
Enter.
回车。

307
00:14:57,360 --> 00:14:58,893
[SIGHS] So close!
[叹气] 真是太接近了！

308
00:14:58,893 --> 00:15:00,060
All right, it's pretty good.
好吧，还不错。

309
00:15:00,060 --> 00:15:02,970
I got the H-E-L-L-O comma space "world."
我得到了 H-E-L-L-O，逗号，空格，"world"。

310
00:15:02,970 --> 00:15:05,770
But there's something a little stupid about my output.
但我的输出有一点不太聪明。

311
00:15:05,770 --> 00:15:09,565
What might rub some of you aesthetically the wrong way?
什么东西可能会让你们觉得有点不美观？

312
00:15:09,565 --> 00:15:10,065
Yeah?
是吗？

313
00:15:10,065 --> 00:15:11,460
STUDENT: The dollar sign.
学生：美元符号。

314
00:15:11,460 --> 00:15:14,430
DAVID MALAN: Yeah, so the dollar sign looks like I was like, "hello,
大卫·马兰：是的，所以美元符号看起来就像我在说，“hello，

315
00:15:14,430 --> 00:15:16,390
world" dollar sign in my output.
world”，输出时带了一个美元符号。

316
00:15:16,390 --> 00:15:21,100
But no, that's just kind of a remnant of my prompt starting with a dollar sign.
但不是，这只是我的提示以美元符号开头的一个残留。

317
00:15:21,100 --> 00:15:23,767
And this is a little nitpicky, but this just doesn't feel right,
这有点吹毛求疵，但感觉不太对，

318
00:15:23,767 --> 00:15:24,558
doesn't look right.
看起来也不对。

319
00:15:24,558 --> 00:15:25,600
It's not quite correct.
它不太正确。

320
00:15:25,600 --> 00:15:27,030
So how can I go about fixing this?
那么我该如何解决这个问题？

321
00:15:27,030 --> 00:15:29,100
Well, here's where, at least initially, it's
好吧，至少现在，

322
00:15:29,100 --> 00:15:33,660
going to take some introduction to just new syntax in C to fix this.
需要引入一些 C 语言中的新语法来解决这个问题。

323
00:15:33,660 --> 00:15:35,850
The simplest instinct might be to do this.
最简单的想法可能是这样做。

324
00:15:35,850 --> 00:15:37,590
Well, let me just hit Enter like that.
好吧，让我像这样按回车键。

325
00:15:37,590 --> 00:15:40,095
But this should soon, if not already, rub you
但这很快，如果没有的话，也会让你

326
00:15:40,095 --> 00:15:41,970
the wrong way because in general, we're going
感到不对劲，因为总的来说，我们

327
00:15:41,970 --> 00:15:44,550
to see that programming in C and in Python
会发现，在 C 语言和 Python 语言中

328
00:15:44,550 --> 00:15:46,920
and other languages tends to be line-based.
和其他语言中，编程往往是基于行的。

329
00:15:46,920 --> 00:15:49,763
Like, you should really start and finish your thought on one line.
就像，你应该真正地在一行代码中开始并完成你的想法。

330
00:15:49,763 --> 00:15:51,930
So if you're in the habit of hitting Enter like this
所以，如果你习惯于像这样按回车键

331
00:15:51,930 --> 00:15:54,360
and finishing your thought on the next line,
并在下一行完成你的想法，

332
00:15:54,360 --> 00:15:57,250
generally programming languages don't like that.
通常情况下，编程语言不喜欢这样做。

333
00:15:57,250 --> 00:16:00,030
So this is, in fact, not going to do what we expect.
事实上，这并不会按我们预期的那样执行。

334
00:16:00,030 --> 00:16:02,390
And just to show you as much, I'm going to do this.
为了让你看得更清楚，我将这样做。

335
00:16:02,390 --> 00:16:04,430
Let me go back to my terminal window here.
让我回到我的终端窗口。

336
00:16:04,430 --> 00:16:07,670
I'm going to rerun "make hello" after making that change.
我将修改后重新运行"make hello"。

337
00:16:07,670 --> 00:16:08,380
Enter.
回车。

338
00:16:08,380 --> 00:16:11,830
And there we have it, like the first of our erroneous outputs.
这就是第一个错误输出。

339
00:16:11,830 --> 00:16:12,940
And it's yelling at me.
它在对我大喊。

340
00:16:12,940 --> 00:16:15,075
It's missing a terminating character.
它缺少一个终止符。

341
00:16:15,075 --> 00:16:17,950
And there's some red in here, some green, drawing my attention to it.
这里有一些红色和绿色，吸引我的注意力。

342
00:16:17,950 --> 00:16:20,598
Sometimes these error messages will be straightforward.
有时这些错误消息会很直白。

343
00:16:20,598 --> 00:16:23,390
Sometimes you're going to rack your brain a bit to figure them out.
有时你需要费点脑筋才能弄明白它们。

344
00:16:23,390 --> 00:16:24,970
But for now I've kind of spoiled it.
但现在我已经说破了。

345
00:16:24,970 --> 00:16:27,200
Obviously Enter is not the right solution.
显然，回车不是正确的解决方案。

346
00:16:27,200 --> 00:16:30,200
So let me clear my terminal window just to hide that error.
让我清除我的终端窗口，以便隐藏那个错误。

347
00:16:30,200 --> 00:16:32,050
Let me delete this.
让我删除这个。

348
00:16:32,050 --> 00:16:36,850
And let me propose now that I add this incantation here.
现在，我建议在这里添加这个咒语。

349
00:16:36,850 --> 00:16:39,610
So backslash n, it turns out, is going to be
事实证明，反斜杠 n 将会

350
00:16:39,610 --> 00:16:43,000
the sort of magical way of ensuring that you actually get
一种确保你真正获得的魔术方法

351
00:16:43,000 --> 00:16:45,830
a new line at the end of your output.
你输出中的最后一行。

352
00:16:45,830 --> 00:16:49,930
So let me go ahead now and rerun "make hello," because I've changed my code.
所以我现在重新运行“make hello”，因为我已经修改了代码。

353
00:16:49,930 --> 00:16:55,390
I need to now reconvert, recompile the source code to new machine.
我现在需要重新转换，重新编译源代码到新的机器。

354
00:16:55,390 --> 00:16:56,290
"./hello."
"./hello."

355
00:16:56,290 --> 00:17:00,580
And now, there is the canonical "hello, world" program
现在，我们有了规范的“hello，world”程序

356
00:17:00,580 --> 00:17:03,330
that I hoped to write in the first place.
我一开始就想写这个程序。

357
00:17:03,330 --> 00:17:05,863
So for now, don't worry about the include.
现在，不用担心包含。

358
00:17:05,863 --> 00:17:07,280
Don't worry about the standard io.
不用担心标准输入输出。

359
00:17:07,280 --> 00:17:10,369
Don't worry about int or main or void or the curly braces.
不用担心int、main、void或者花括号。

360
00:17:10,369 --> 00:17:12,508
Focus primarily on line 5 here.
主要关注这里的第5行。

361
00:17:12,508 --> 00:17:14,300
And over the course of today and next week,
在今天和下周，

362
00:17:14,300 --> 00:17:16,520
we'll start to tease apart the other characters
我们将开始拆解其他字符

363
00:17:16,520 --> 00:17:18,680
that, for now, you should take at face value.
这些字符现在你可以先照单全收。

364
00:17:18,680 --> 00:17:22,200
Questions, though, on any of the steps we've just done?
关于我们刚刚执行的任何步骤，有什么问题吗？

365
00:17:22,200 --> 00:17:22,700
Yeah?
有吗？

366
00:17:22,700 --> 00:17:27,580
STUDENT: Why is the backslash n inside the apostrophes?
学生：为什么反斜杠 n 在单引号内？

367
00:17:27,580 --> 00:17:31,940
DAVID MALAN: Sure, why is the backslash n inside of the quotation marks,
大卫·马兰：当然，为什么反斜杠 n 在引号内？

368
00:17:31,940 --> 00:17:32,570
if you will?
如果你愿意这么说的话？

369
00:17:32,570 --> 00:17:35,350
So short answer is that's just where it needs
简短的回答是，它就应该放在那里

370
00:17:35,350 --> 00:17:40,600
to be because inside of the quotes is the input that you want printf
因为在引号内是你想要 printf 输出的内容

371
00:17:40,600 --> 00:17:42,320
to output to the screen.
到屏幕上。

372
00:17:42,320 --> 00:17:46,030
So if you want printf, this function, to output a new line,
所以如果你希望 printf 函数输出一个新行，

373
00:17:46,030 --> 00:17:50,470
it must be included in the quoted text that you give it.
它必须包含在你给它的引号文本中。

374
00:17:50,470 --> 00:17:53,555
STUDENT: So the backslash n [INAUDIBLE].
学生：所以反斜杠 n [听不清]。

375
00:17:53,555 --> 00:17:54,430
DAVID MALAN: Exactly.
大卫·马兰：没错。

376
00:17:54,430 --> 00:17:58,840
Backslash n is a special pattern that "printf no" means, OK, I should
反斜杠 n 是一种特殊模式，代表 “printf no” 意思，好的，我应该

377
00:17:58,840 --> 00:18:01,060
move the cursor to the next line.
将光标移到下一行。

378
00:18:01,060 --> 00:18:02,330
Good question.
好问题。

379
00:18:02,330 --> 00:18:04,010
Other questions on any of these steps?
关于这些步骤，还有其他问题吗？

380
00:18:04,010 --> 00:18:04,510
Yeah?
有吗？

381
00:18:04,510 --> 00:18:05,562
STUDENT: [INAUDIBLE]
学生：[听不清]

382
00:18:05,562 --> 00:18:06,770
DAVID MALAN: A good question.
大卫·马兰：好问题。

383
00:18:06,770 --> 00:18:10,120
So what if you actually want to print backslash n?
那么，如果你真的想打印反斜杠 n 呢？

384
00:18:10,120 --> 00:18:12,140
Things get a little tricky there.
事情就变得有点棘手了。

385
00:18:12,140 --> 00:18:15,920
Let me go ahead and propose that we do this.
让我来提议我们这样做。

386
00:18:15,920 --> 00:18:18,490
So it turns out-- and this is often the case in programming--
结果是——在编程中经常出现这种情况——

387
00:18:18,490 --> 00:18:20,890
when you want a literal character to appear,
当你想要一个字面字符出现时，

388
00:18:20,890 --> 00:18:23,347
you actually put another backslash in front of it.
你实际上要在它前面放另一个反斜杠。

389
00:18:23,347 --> 00:18:25,430
But this is not going to be something we do often.
但这不是我们经常做的事情。

390
00:18:25,430 --> 00:18:27,340
But there is in fact a solution to that.
但实际上有一个解决方案。

391
00:18:27,340 --> 00:18:30,145
But let me propose that beyond that now we compare it
但我建议，除此之外，现在我们把它

392
00:18:30,145 --> 00:18:31,520
against what we've actually done.
与我们实际做的事情进行比较。

393
00:18:31,520 --> 00:18:35,260
So here is the first Scratch program we wrote with the green flag there.
所以这是我们用绿色的旗帜编写的第一个 Scratch 程序。

394
00:18:35,260 --> 00:18:37,690
Here, recall, is the mental model that I proposed
这里，请回忆，是我提出的心理模型

395
00:18:37,690 --> 00:18:41,950
we have for almost everything we do whereby functions are just
我们几乎对所有我们做的事情都有，函数仅仅是

396
00:18:41,950 --> 00:18:45,820
an implementation, say, in code of algorithms, step-by-step instructions
一个实现，比如，在代码中的算法，一步一步的指令

397
00:18:45,820 --> 00:18:47,150
for solving problems.
用于解决问题。

398
00:18:47,150 --> 00:18:49,300
The inputs to functions, recall from last week,
函数的输入，回忆上周，

399
00:18:49,300 --> 00:18:52,330
are called arguments, or in some contexts parameters.
被称为参数，或者在某些情况下叫做参数。

400
00:18:52,330 --> 00:18:55,130
And sometimes functions can have side effects.
而有时函数会有副作用。

401
00:18:55,130 --> 00:18:58,280
Like last time with Scratch, there was the speech bubble
就像上次用 Scratch 时一样，有一个气泡

402
00:18:58,280 --> 00:19:00,440
that magically appeared next to the cat's mouth
神奇地出现在猫的嘴巴旁边

403
00:19:00,440 --> 00:19:02,930
as a sort of side effect of using the Say block.
作为使用说块的副作用。

404
00:19:02,930 --> 00:19:07,310
So just like this then, we had the white oval as input.
所以就像这样，我们有白色椭圆作为输入。

405
00:19:07,310 --> 00:19:09,590
The Say block was the function last week.
上周，说块是函数。

406
00:19:09,590 --> 00:19:11,790
And then we had this here, side effect.
然后我们有了这个，副作用。

407
00:19:11,790 --> 00:19:14,550
Well, how do we compare these things left to right?
那么，我们如何从左到右比较这些东西？

408
00:19:14,550 --> 00:19:16,010
Well, here's the Say block at left.
好的，这是左边的说块。

409
00:19:16,010 --> 00:19:17,990
Let's compare now to the C code at right.
现在让我们把它与右边的 C 代码进行比较。

410
00:19:17,990 --> 00:19:22,400
Notice a couple of things to adapt from Scratch to C. Print
注意从 Scratch 到 C 的一些调整。打印

411
00:19:22,400 --> 00:19:23,970
is almost the name of the function.
几乎是函数的名字。

412
00:19:23,970 --> 00:19:26,780
It is technically "printf," for reasons we'll eventually see.
严格来说是“printf”，原因我们最终会看到。

413
00:19:26,780 --> 00:19:32,210
Notice the parentheses in C are kind of evocative of the oval in Scratch.
注意 C 中的括号有点让人联想到 Scratch 中的椭圆。

414
00:19:32,210 --> 00:19:36,140
And that's probably why MIT chose an oval, because a lot of languages
这也许就是 MIT 选择椭圆的原因，因为很多语言

415
00:19:36,140 --> 00:19:37,850
use parentheses in this way.
以这种方式使用括号。

416
00:19:37,850 --> 00:19:42,050
You still write "hello, world" just as we did last week in Scratch.
你仍然像上周在 Scratch 中一样写“hello, world”。

417
00:19:42,050 --> 00:19:45,800
But per our demo thus far, you do need the double quotes--
但根据我们到目前为止的演示，你需要双引号——

418
00:19:45,800 --> 00:19:49,220
and double quotes, not single quotes-- double quotes on the left and right.
双引号，而不是单引号——左右两边都有双引号。

419
00:19:49,220 --> 00:19:52,580
And in order to get that new line, you need the backslash n.
为了得到换行，你需要反斜杠 n。

420
00:19:52,580 --> 00:19:54,630
And one more thing is missing.
还有一件事是缺失的。

421
00:19:54,630 --> 00:19:55,130
Yeah?
是吗？

422
00:19:55,130 --> 00:19:55,460
STUDENT: Semicolon.
学生：分号。

423
00:19:55,460 --> 00:19:57,920
DAVID MALAN: The semicolon to finish your thought.
大卫·马兰：分号来结束你的想法。

424
00:19:57,920 --> 00:20:00,020
So all of these sort of stupid things now
所以所有这些愚蠢的事情现在

425
00:20:00,020 --> 00:20:03,395
that honestly you will forget initially if you've never programmed before,
说真的，如果你以前没有编程过，你一开始会忘记，

426
00:20:03,395 --> 00:20:05,270
but you'll soon-- within days, within weeks--
但你很快——在几天之内，几周之内——

427
00:20:05,270 --> 00:20:08,330
develop the muscle memory where all of that stuff just jumps off,
形成肌肉记忆，在那里所有这些东西都会跳出来，

428
00:20:08,330 --> 00:20:10,700
jumps off the page right at you.
直接从页面上跳出来。

429
00:20:10,700 --> 00:20:14,420
All right, so this backslash n is generally known,
好的，所以这个反斜杠 n 通常被称为，

430
00:20:14,420 --> 00:20:16,920
just so you know, as an escape sequence.
你应该知道，作为一个转义序列。

431
00:20:16,920 --> 00:20:20,420
And so backslash n allows us to specify a character that
所以反斜杠 n 允许我们指定一个字符，

432
00:20:20,420 --> 00:20:21,890
might otherwise be hard to type.
否则可能难以键入。

433
00:20:21,890 --> 00:20:26,150
But let's tease apart some of the other things atop that function already.
但让我们先来了解一下该函数顶部的其他一些内容。

434
00:20:26,150 --> 00:20:28,880
So include stdio.h.
所以包含 stdio.h。

435
00:20:28,880 --> 00:20:33,290
It turns out that in C, a lot of the functionality that
事实证明，在 C 语言中，很多功能

436
00:20:33,290 --> 00:20:36,900
comes with the language is tucked away in separate files.
都是隐藏在单独的文件中的。

437
00:20:36,900 --> 00:20:40,650
So if you want to use certain functions, you have to tell the compiler,
所以如果你想使用某些函数，你必须告诉编译器，

438
00:20:40,650 --> 00:20:43,430
hey, I want to do some standard input and output.
嘿，我想进行一些标准输入和输出。

439
00:20:43,430 --> 00:20:45,680
Like, I want to print some things on the screen.
比如，我想在屏幕上打印一些东西。

440
00:20:45,680 --> 00:20:48,980
And that's because, for now, you can think of printf
这是因为，就目前而言，你可以把 printf

441
00:20:48,980 --> 00:20:52,340
as living in this file, stdio.h.
看作是存在于这个文件 stdio.h 中。

442
00:20:52,340 --> 00:20:53,870
That's a bit of a white lie for now.
这现在有点像善意的谎言。

443
00:20:53,870 --> 00:20:57,890
But in stdio.h is essentially a declaration for printf
但是 stdio.h 本质上是对 printf 的声明，

444
00:20:57,890 --> 00:21:01,820
that will teach the compiler how to print things to the screen.
它会告诉编译器如何将内容打印到屏幕上。

445
00:21:01,820 --> 00:21:05,090
So "hash include" here simply tells the compiler
所以这里的 "井号包含" 只是告诉编译器，

446
00:21:05,090 --> 00:21:07,790
before it does anything else essentially go ahead and find
在它做任何其他事情之前，基本上继续查找

447
00:21:07,790 --> 00:21:10,700
on the local hard drive a file called stdio.h
本地硬盘驱动器上的一个名为 stdio.h 的文件

448
00:21:10,700 --> 00:21:14,330
and copy/paste it there so I know now about printf.
并将其复制粘贴到那里，这样我就会知道 printf 了。

449
00:21:14,330 --> 00:21:19,673
So this thing, this .h file, is what we'll technically call a header file.
所以这个东西，这个 .h 文件，我们技术上会称之为头文件。

450
00:21:19,673 --> 00:21:21,590
And if you've ever heard this word, especially
如果你曾经听说过这个词，尤其是

451
00:21:21,590 --> 00:21:24,800
if you have programmed before, it represents essentially what
如果你以前编写过程序，它基本上代表了我们

452
00:21:24,800 --> 00:21:26,390
we'll start calling a library.
将开始称为库。

453
00:21:26,390 --> 00:21:29,330
So a library in the world of programming is just code
所以编程世界中的库就是代码，

454
00:21:29,330 --> 00:21:31,740
that someone else wrote that you can use.
是由其他人编写的，你可以使用。

455
00:21:31,740 --> 00:21:33,968
It's usually free and open source, which means
它通常是免费的开源软件，这意味着

456
00:21:33,968 --> 00:21:36,260
you can literally see the code that someone else wrote,
你可以直观地看到其他人编写的代码，

457
00:21:36,260 --> 00:21:37,670
or sometimes you pay for it.
或者有时你需要为此付费。

458
00:21:37,670 --> 00:21:40,370
Sometimes it's closed source, which maybe Microsoft wrote it.
有时它是闭源的，比如微软编写的。

459
00:21:40,370 --> 00:21:43,850
They won't show you the code, but they will let you use the zeros and ones.
他们不会向你展示代码，但他们会让你使用 0 和 1。

460
00:21:43,850 --> 00:21:46,670
So libraries are super useful because honestly
所以库非常有用，因为说实话，

461
00:21:46,670 --> 00:21:49,700
even I don't really know how printf works.
即使我也不知道 printf 是如何工作的。

462
00:21:49,700 --> 00:21:52,340
I've taken for granted for 25 years that if I use printf,
我 25 年来一直认为，如果我使用 printf，

463
00:21:52,340 --> 00:21:53,780
stuff prints on the screen.
内容就会打印在屏幕上。

464
00:21:53,780 --> 00:21:56,330
But someone smarter than me had to actually write
但是，比我更聪明的人必须实际编写

465
00:21:56,330 --> 00:22:00,860
the code in C that figures out how to get the H, the E, the L-L-O, and so
用 C 语言编写的代码，它会弄清楚如何获取 H、E、L-L-O 等等，

466
00:22:00,860 --> 00:22:05,320
forth onto the Mac screen, the PC screen, the phone screen, or somewhere
到 Mac 屏幕、PC 屏幕、手机屏幕或其他地方。

467
00:22:05,320 --> 00:22:05,820
else.
其他地方。

468
00:22:05,820 --> 00:22:08,510
So libraries allow us to stand on each other's shoulders
所以库允许我们站在彼此的肩膀上，

469
00:22:08,510 --> 00:22:10,910
and so that someone else can do the hard work,
这样其他人就可以完成艰苦的工作，

470
00:22:10,910 --> 00:22:14,550
and we can now solve problems that are more interesting to us,
而我们现在可以解决对我们更有趣的问题，

471
00:22:14,550 --> 00:22:18,060
not the basic commodity stuff that everyone might want in their code.
而不是每个人可能在他们的代码中想要的那些基本商品。

472
00:22:18,060 --> 00:22:20,480
So again, library is code that someone else wrote.
所以再说一次，库是其他人编写的代码。

473
00:22:20,480 --> 00:22:23,540
A header file in C is just a file ending in ".h"
C 语言中的头文件只是一个以 ".h" 结尾的文件，

474
00:22:23,540 --> 00:22:25,440
that gives you access to the same.
它可以让你访问相同的东西。

475
00:22:25,440 --> 00:22:28,040
And so for instance, if you to learn more about these,
所以，例如，如果你想了解更多关于这些的信息，

476
00:22:28,040 --> 00:22:31,410
there are, what are called in the world of programming, manual pages.
在编程世界中，有一些被称为手册页面的东西。

477
00:22:31,410 --> 00:22:37,190
And these are textual files, like a documentation of sorts,
它们是文本文件，就像某种文档，

478
00:22:37,190 --> 00:22:39,860
via which you can just learn how a function works
通过它，你可以学习一个函数是如何工作的

479
00:22:39,860 --> 00:22:42,830
or how you can use its inputs or arguments.
或者如何使用它的输入或参数。

480
00:22:42,830 --> 00:22:45,660
The reality is they're written for folks who aren't in CS50.
现实情况是，它们是为那些不在 CS50 的人写的。

481
00:22:45,660 --> 00:22:48,410
They're written for folks who aren't just learning how to program.
它们是为那些不仅仅学习如何编程的人写的。

482
00:22:48,410 --> 00:22:51,330
They're written for and by folks who have been programming for years.
它们是为那些已经编程多年的人写的，也是由他们写的。

483
00:22:51,330 --> 00:22:53,510
And so frankly, they're a little hard to understand.
坦白地说，它们有点难理解。

484
00:22:53,510 --> 00:22:58,690
And so CS50 has its own version thereof at this URL, manual.cs50.io,
因此，CS50 有它自己的版本，网址为 manual.cs50.io，

485
00:22:58,690 --> 00:23:03,260
where you'll see not only the official documentation for C, the language,
在那里，你不仅能看到 C 语言的官方文档，

486
00:23:03,260 --> 00:23:07,360
but also staff-written simplifications in layperson's terms
还能看到员工用通俗易懂的语言写的简化版

487
00:23:07,360 --> 00:23:10,720
what all of the various popular functions are, what their inputs,
以及各种流行函数是什么，它们的输入是什么，

488
00:23:10,720 --> 00:23:12,130
and what their outputs are.
以及它们的输出是什么。

489
00:23:12,130 --> 00:23:17,990
So for instance, under stdio.h, you can actually go to that website.
例如，在 stdio.h 下，你可以访问那个网站。

490
00:23:17,990 --> 00:23:21,970
You can go to a URL like this, where stdio.h is in there.
你可以访问类似这样的 URL，其中包含 stdio.h。

491
00:23:21,970 --> 00:23:24,348
And you can actually see the documentation therefore.
你实际上可以看到它的文档。

492
00:23:24,348 --> 00:23:25,640
So let me go ahead and do this.
所以让我来做这件事。

493
00:23:25,640 --> 00:23:27,640
I'm going to go ahead in my browser here,
我在我的浏览器里这样做，

494
00:23:27,640 --> 00:23:31,240
I'm going to go to manual.cs50.io.
我将访问 manual.cs50.io。

495
00:23:31,240 --> 00:23:33,880
And let me go ahead here and select those functions
让我在这里选择那些函数

496
00:23:33,880 --> 00:23:36,220
that are frequently used in CS50.
在 CS50 中经常使用。

497
00:23:36,220 --> 00:23:39,820
And under stdio.h, you'll see a bunch of functions,
在 stdio.h 下，你会看到很多函数，

498
00:23:39,820 --> 00:23:42,730
only one of which we've even discussed called printf.
其中只有一个我们讨论过，叫做 printf。

499
00:23:42,730 --> 00:23:44,560
I'm going to click on printf there.
我将点击那里的 printf。

500
00:23:44,560 --> 00:23:46,573
And you'll see an interface that at first glance
你会看到一个界面，乍一看

501
00:23:46,573 --> 00:23:48,490
might be a little overwhelming, but it's going
可能有点让人不知所措，但它会

502
00:23:48,490 --> 00:23:50,300
to start to look more and more familiar.
越来越熟悉。

503
00:23:50,300 --> 00:23:54,620
So first of all, you'll see that if you want to use printf under Synopsis,
首先，你会看到，如果你想在概述中使用 printf，

504
00:23:54,620 --> 00:23:56,690
you need to include this header file.
你需要包含这个头文件。

505
00:23:56,690 --> 00:23:59,960
Like, you literally copy and paste that line into your own code.
就像，你真的把那行代码复制粘贴到你的代码里。

506
00:23:59,960 --> 00:24:03,440
You'll also see this, which for now is a bit arcane,
你还会看到这个，目前来说有点神秘，

507
00:24:03,440 --> 00:24:07,890
but this is kind of a hint as to what the function is going to look like.
但它有点提示了这个函数的样子。

508
00:24:07,890 --> 00:24:09,043
But more on that soon.
但更多内容很快就会讲到。

509
00:24:09,043 --> 00:24:11,460
But more importantly, you can read a description about it.
但更重要的是，你可以阅读它的描述。

510
00:24:11,460 --> 00:24:14,390
And because these descriptions, when you're in less comfortable mode,
因为这些描述，当你处于不太舒服的状态时，

511
00:24:14,390 --> 00:24:17,432
are written by me and the course's teaching fellows, teaching assistants,
是由我和这门课的助教、助教写的，

512
00:24:17,432 --> 00:24:20,970
and course assistants, you'll find them to be much more in layperson's terms.
以及课程助理写的，你会发现它们更通俗易懂。

513
00:24:20,970 --> 00:24:23,340
And so long story short, rely on this site
所以长话短说，当你想要学习如何使用某个函数时，

514
00:24:23,340 --> 00:24:25,580
once you want to learn how to use some function
依赖这个网站

515
00:24:25,580 --> 00:24:27,960
and also what other functions exist.
以及了解其他函数的存在。

516
00:24:27,960 --> 00:24:29,970
In fact, if I go back to the main page here,
事实上，如果我回到这里的主页，

517
00:24:29,970 --> 00:24:33,890
you'll see that there are all of these functions like are frequently
你会看到所有这些函数，就像经常

518
00:24:33,890 --> 00:24:35,000
used in CS50.
在 CS50 中使用。

519
00:24:35,000 --> 00:24:37,190
And there's hundreds more that come with C.
还有数百个 C 语言自带的函数。

520
00:24:37,190 --> 00:24:40,340
But learning a programming language is not about learning all of those
但学习一门编程语言不是要学习所有这些函数，

521
00:24:40,340 --> 00:24:45,020
but rather just getting a sense of where you find answers to questions when
而是当你想要尝试新的东西时，了解在哪里找到问题的答案。

522
00:24:45,020 --> 00:24:47,760
you do want to try something new.
当你想要尝试新的东西时。

523
00:24:47,760 --> 00:24:50,330
But what is important to know for CS50 today
但今天对 CS50 来说重要的是，

524
00:24:50,330 --> 00:24:55,600
is that we have our own header file called cs50.h which has functions
我们有一个名为cs50.h的头文件，其中包含函数

525
00:24:55,600 --> 00:24:57,910
that we have written just to make life easier
我们编写的这些函数只是为了让生活更轻松

526
00:24:57,910 --> 00:24:59,675
in the first few weeks of the class.
在课程的前几周。

527
00:24:59,675 --> 00:25:02,050
These are training wheels that we'll eventually take off.
这些是辅助轮，我们最终会把它卸掉。

528
00:25:02,050 --> 00:25:04,270
But it turns out in C, especially if you've
但在C语言中，尤其是如果你之前已经

529
00:25:04,270 --> 00:25:07,120
programmed before, it's actually really hard and annoying just
编写过程序，实际上真的很困难和烦人，仅仅

530
00:25:07,120 --> 00:25:11,900
to get input from users, to get them to type a word or a number or something
从用户那里获取输入，让他们输入一个单词或数字或其他东西

531
00:25:11,900 --> 00:25:12,400
else.
其他。

532
00:25:12,400 --> 00:25:15,850
Like, C does not make this easy, in part because it's one of the earliest
就像，C语言并没有让这个变得容易，部分原因是它是最早的语言之一

533
00:25:15,850 --> 00:25:17,800
languages that wasn't zeros and ones.
不是0和1。

534
00:25:17,800 --> 00:25:20,050
So you have to do a lot of the heavy lifting yourself.
所以你必须自己做很多繁重的工作。

535
00:25:20,050 --> 00:25:23,200
But we'll put on these training wheels today and for a few weeks
但是我们今天和接下来的几周会使用这些辅助轮

536
00:25:23,200 --> 00:25:28,150
so that we can focus really on the intellectually interesting ideas of C
这样我们就可以真正专注于C语言中智力上有趣的想法

537
00:25:28,150 --> 00:25:30,970
and programming without getting bogged down in certain weeds
以及编程，而不会陷入某些杂草丛生的细节

538
00:25:30,970 --> 00:25:33,160
that we will come back to before long.
我们很快就会回来。

539
00:25:33,160 --> 00:25:36,820
So for instance, CS50's own documentation is there at that URL.
例如，CS50自己的文档就在那个URL上。

540
00:25:36,820 --> 00:25:40,550
But within the library are these functions,
但在库中是这些函数，

541
00:25:40,550 --> 00:25:44,440
a function called get_string to get a string of text.
一个名为get_string的函数，用于获取字符串文本。

542
00:25:44,440 --> 00:25:47,330
"String" is a synonym for just text in a programming language.
“字符串”在编程语言中只是文本的同义词。

543
00:25:47,330 --> 00:25:50,170
So get_string will prompt the human for a string of text.
所以get_string会提示用户输入一个字符串文本。

544
00:25:50,170 --> 00:25:52,660
Get_int is shorthand for "get integer," if you
Get_int是“获取整数”的简写，如果你

545
00:25:52,660 --> 00:25:54,890
want to get a number from the user.
想从用户那里获取一个数字。

546
00:25:54,890 --> 00:25:58,550
Get_float is a little more arcane-- get a floating point number,
Get_float稍微难懂一点——获取一个浮点数，

547
00:25:58,550 --> 00:26:00,780
like a real number with a decimal point in it.
就像带有小数点的实数。

548
00:26:00,780 --> 00:26:03,690
And dot, dot, dot, there are others, as well.
等等，还有其他。

549
00:26:03,690 --> 00:26:08,180
So this is to say within CS50, we've got some user-friendly functions via which
所以这意味着在CS50中，我们有一些用户友好的函数，通过这些函数

550
00:26:08,180 --> 00:26:09,563
we can actually get some input.
我们可以实际获取一些输入。

551
00:26:09,563 --> 00:26:12,230
And let's go ahead and use one of these, for instance get_string
让我们继续使用其中之一，例如get_string

552
00:26:12,230 --> 00:26:15,950
because recall that last week our second program in Scratch
因为还记得上周我们在Scratch中的第二个程序

553
00:26:15,950 --> 00:26:18,920
was this one here, where we didn't just say "hello, world."
就是这个，我们不仅仅是说“hello, world”。

554
00:26:18,920 --> 00:26:21,110
We said "hello, David," or "hello, Carter,"
我们说“hello, David”或“hello, Carter”

555
00:26:21,110 --> 00:26:24,590
"hello, Julia," whoever it was typing their name in.
“hello, Julia”，无论是谁在输入他们的名字。

556
00:26:24,590 --> 00:26:28,910
But to do that, we needed this Ask block in Scratch.
但是要做到这一点，我们需要Scratch中的“问”模块。

557
00:26:28,910 --> 00:26:30,470
And then we used the Say block.
然后我们使用“说”模块。

558
00:26:30,470 --> 00:26:34,050
And then we used the Join block to make all of this work.
然后我们使用“连接”模块来使这一切正常工作。

559
00:26:34,050 --> 00:26:36,352
So let's translate this program now into C
所以让我们现在把这个程序翻译成C语言

560
00:26:36,352 --> 00:26:39,560
because it's a little more interesting and representative of the kind of code
因为它更有趣，并且代表了我们将要编写的代码类型

561
00:26:39,560 --> 00:26:40,670
we'll start to write.
我们将开始编写。

562
00:26:40,670 --> 00:26:42,950
But we need a slightly different mental model.
但我们需要一个稍微不同的思维模型。

563
00:26:42,950 --> 00:26:47,450
Still have a function here, which is the implementation in code of an algorithm.
这里仍然有一个函数，它是算法的代码实现。

564
00:26:47,450 --> 00:26:49,910
We still have some inputs called arguments.
我们仍然有一些被称为参数的输入。

565
00:26:49,910 --> 00:26:53,330
But previously, I said that the Say block and, in turn,
但之前我说“说”模块，反过来，

566
00:26:53,330 --> 00:26:56,870
printf have side effects, which is just something visually, typically,
printf有副作用，这仅仅是视觉上，通常是

567
00:26:56,870 --> 00:26:58,340
that happens on the screen.
出现在屏幕上。

568
00:26:58,340 --> 00:27:02,900
Other functions actually have, what we called last week, return values.
其他函数实际上拥有，我们上周称之为，返回值。

569
00:27:02,900 --> 00:27:08,540
And this is kind of analogous to a function maybe doing something for you,
这类似于一个函数可能为你做一些事情，

570
00:27:08,540 --> 00:27:11,990
writing down the answer on a slip of paper, and then handing you,
将答案写在纸条上，然后递给你，

571
00:27:11,990 --> 00:27:14,180
the programmer, the slip of paper to do whatever
作为程序员，你就可以对纸条上的答案做任何事

572
00:27:14,180 --> 00:27:16,430
you want with it without just broadcasting it
你想怎样就怎样，不用像在屏幕上用对话框一样广播出去。

573
00:27:16,430 --> 00:27:19,190
to the world with, like, a speech bubble on the screen.
就像在屏幕上用对话框一样广播出去。

574
00:27:19,190 --> 00:27:22,610
So a return value is germane for a program like this
所以，对于像这样的程序来说，返回值非常重要

575
00:27:22,610 --> 00:27:26,960
because recall when we used the Ask block and I typed in my name,
因为还记得我们使用“询问”模块的时候，我在里面输入了自己的名字，

576
00:27:26,960 --> 00:27:30,650
where did my name end up initially?
我的名字最初在哪里？

577
00:27:30,650 --> 00:27:32,217
It didn't go on the screen yet.
它还没有出现在屏幕上。

578
00:27:32,217 --> 00:27:33,050
Where did it end up?
它最终在哪里？

579
00:27:33,050 --> 00:27:33,967
STUDENT: In an answer.
学生：在“答案”里。

580
00:27:33,967 --> 00:27:35,900
DAVID MALAN: In an "answer" puzzle piece.
大卫·马兰：在一个“答案”拼图块里。

581
00:27:35,900 --> 00:27:39,320
And that special oval puzzle piece I claimed at the time
我当时说，那个特殊的椭圆形拼图块

582
00:27:39,320 --> 00:27:43,250
represents a return value, so the metaphorical piece of paper
代表着返回值，所以，这块纸条（打个比方）

583
00:27:43,250 --> 00:27:46,410
that the answer is written down on so that I can then use it later.
用来写答案，这样我以后就能用它。

584
00:27:46,410 --> 00:27:48,740
So that's what we want to get to now in C,
所以，这就是我们现在在 C 语言中要达成的目标，

585
00:27:48,740 --> 00:27:51,832
a return value that I can then do anything I want,
一个返回值，这样我就能用它做任何想做的事，

586
00:27:51,832 --> 00:27:54,290
whether it's print it to the screen, change it in some way,
无论是打印到屏幕上，还是以某种方式更改它，

587
00:27:54,290 --> 00:27:56,430
save it in a database, or anything else.
把它保存到数据库里，或者做其他任何事情。

588
00:27:56,430 --> 00:27:58,670
So here, for instance, is what we did with Scratch,
所以，举个例子，我们在 Scratch 中是这样做的，

589
00:27:58,670 --> 00:28:02,510
the input to the Say block-- or the Ask block was "what's your name," quote,
“说出”模块的输入，或者说“询问”模块的输入是 “你的名字是？”，引号，

590
00:28:02,510 --> 00:28:03,140
unquote.
引号。

591
00:28:03,140 --> 00:28:05,120
The function, of course, is the Ask function.
当然，这个函数就是“询问”函数。

592
00:28:05,120 --> 00:28:07,310
And the return value was "answer."
返回值是 “答案”。

593
00:28:07,310 --> 00:28:10,880
If we now consider how we might translate this to C,
如果我们现在考虑如何将它翻译成 C 语言，

594
00:28:10,880 --> 00:28:12,770
it's going to look a little weird at first.
乍一看可能有点奇怪。

595
00:28:12,770 --> 00:28:15,680
But it's going to follow a pattern today, next week, the week
但它会遵循一个模式，今天，下周，下下周

596
00:28:15,680 --> 00:28:18,090
after any time we do code like this.
无论我们何时编写类似的代码，都会遵循这个模式。

597
00:28:18,090 --> 00:28:23,480
So get_string, I claim, is going to be the most analogous function in C
所以，我认为，get_string 将是 C 语言中与“询问”模块最类似的函数

598
00:28:23,480 --> 00:28:24,650
to the Ask block.
类似于“询问”模块。

599
00:28:24,650 --> 00:28:28,400
And to be clear, this is a CS50-specific thing, training wheels of sorts.
需要明确的是，这是 CS50 独有的东西，是某种辅助工具。

600
00:28:28,400 --> 00:28:31,520
But we'll show you in a few weeks what this function is doing and how you
但我们会在几周内向你们展示这个函数的功能，以及如何在对语言本身感到舒适后

601
00:28:31,520 --> 00:28:35,750
cannot use it moving forward once you're comfortable with the language itself.
不再使用它。

602
00:28:35,750 --> 00:28:37,820
Notice I've put parentheses, left and right,
请注意，我在左右两侧添加了括号，

603
00:28:37,820 --> 00:28:39,950
as sort of a placeholder for user input.
作为用户输入的占位符。

604
00:28:39,950 --> 00:28:43,118
And that user input is going to be "what's your name?"
而用户输入将是“你的名字是？”

605
00:28:43,118 --> 00:28:45,410
But I can't just put "what's your name" in parentheses.
但我不能直接在括号里写“你的名字是？”

606
00:28:45,410 --> 00:28:47,327
What do I minimally need to add in there, too?
我至少还需要添加什么？

607
00:28:47,327 --> 00:28:48,020
STUDENT: Quotes.
学生：引号。

608
00:28:48,020 --> 00:28:50,353
DAVID MALAN: Yeah, so the double quotes, left and right.
大卫·马兰：没错，左右两侧都要加上双引号。

609
00:28:50,353 --> 00:28:52,250
So let me go ahead and add those in.
所以，让我添加一下。

610
00:28:52,250 --> 00:28:55,040
I left a space here, not for a new line.
我在此留了一个空格，不是为了换行。

611
00:28:55,040 --> 00:28:56,990
I could move the cursor to the next line.
我可以将光标移到下一行。

612
00:28:56,990 --> 00:29:00,440
But I minimally at least want to move the cursor at least one space over
但我至少要将光标向右移动一个空格

613
00:29:00,440 --> 00:29:03,140
just so it looks pretty, so that when I'm prompted for my name,
这样看起来会更美观，当我被要求输入名字时，

614
00:29:03,140 --> 00:29:05,810
there's a space between the question and my answer.
问题和答案之间会有一个空格。

615
00:29:05,810 --> 00:29:07,280
But it could also be backslash n.
也可以是反斜杠 n。

616
00:29:07,280 --> 00:29:09,830
That's just an aesthetic choice on my part.
这只是我个人的审美选择。

617
00:29:09,830 --> 00:29:14,037
But what do I do with the answer that comes back from get_string?
但我如何处理从 get_string 返回的答案？

618
00:29:14,037 --> 00:29:16,370
This is where the text is going to look different today.
这就是文本在今天看起来不同的原因。

619
00:29:16,370 --> 00:29:21,770
In C, you start to use an equals sign from left to right respectively.
在 C 语言中，你开始使用等于号，从左到右依次排列。

620
00:29:21,770 --> 00:29:26,540
And on the left, you put the name of the variable in which you
在左侧，你放入变量的名称，用于

621
00:29:26,540 --> 00:29:29,730
want to store that return value.
存储那个返回值。

622
00:29:29,730 --> 00:29:32,030
So a return value is kind of a conceptual thing.
所以返回值是一种概念性的东西。

623
00:29:32,030 --> 00:29:33,900
You can do with it what you want.
你可以用它做任何你想做的事情。

624
00:29:33,900 --> 00:29:36,590
And if I want to store it longer term in a variable,
如果我想长期将它存储在一个变量中，

625
00:29:36,590 --> 00:29:40,580
like x or y or z in math class, I can just give it a name here-- x
就像数学课上的 x、y 或 z 一样，我可以在这里给它一个名称——x

626
00:29:40,580 --> 00:29:45,410
or y or z or, more reasonably, "answer," or any other English word.
或者 y 或 z，或者更合理地，"answer"，或者任何其他英文单词。

627
00:29:45,410 --> 00:29:49,850
No spaces, generally lowercase, same heuristics as before, but this means
一般来说，没有空格，小写字母，与之前的启发式方法相同，但这意味着

628
00:29:49,850 --> 00:29:53,010
now, ask the user, what's their name?
现在，问用户，他们的名字是什么？

629
00:29:53,010 --> 00:29:55,620
Whatever they type in, go ahead and store it from right
无论他们输入什么，都从右

630
00:29:55,620 --> 00:29:58,470
to left in this variable called "answer."
到左存储在这个名为“answer”的变量中。

631
00:29:58,470 --> 00:29:59,880
But C's not done with us yet.
但 C 语言还没有完成。

632
00:29:59,880 --> 00:30:02,130
If you've learned Python or certain other languages,
如果你学过 Python 或其他一些语言，

633
00:30:02,130 --> 00:30:04,470
you'd kind of be done writing code at this point.
你基本上就已经完成代码编写了。

634
00:30:04,470 --> 00:30:09,840
In C, though, you additionally have to tell the compiler what type of variable
然而，在 C 语言中，你还需要告诉编译器你想要使用哪种类型的变量

635
00:30:09,840 --> 00:30:11,080
you want to use.
。

636
00:30:11,080 --> 00:30:13,590
So if it's a string of text, you say "string."
所以，如果是文本字符串，就说“string”。

637
00:30:13,590 --> 00:30:17,668
If it's an integer, a number, you say "int," as we might have seen before.
如果是整数，也就是数字，就说“int”，就像我们之前可能看到过的一样。

638
00:30:17,668 --> 00:30:18,960
So it's a little more pedantic.
所以它更加迂腐。

639
00:30:18,960 --> 00:30:22,320
It's more annoying, frankly, the more onus on you and me, the programmers.
坦率地说，它更烦人，对我们这些程序员来说，负担更重。

640
00:30:22,320 --> 00:30:24,120
But this just helps the compiler know how
但这只是帮助编译器知道如何

641
00:30:24,120 --> 00:30:26,260
to store it in the computer's memory.
在计算机的内存中存储它。

642
00:30:26,260 --> 00:30:29,838
And I'm so close to being done with this line of code, but what's missing?
我已经快完成这行代码了，但还缺少什么？

643
00:30:29,838 --> 00:30:30,630
STUDENT: Semicolon.
学生：分号。

644
00:30:30,630 --> 00:30:31,713
DAVID MALAN: So semicolon.
大卫·马兰：所以是分号。

645
00:30:31,713 --> 00:30:34,980
And mark my words, if you've never programmed before, sometime this week,
记住我的话，如果你以前从未编程过，本周的某个时候，

646
00:30:34,980 --> 00:30:37,290
this semester, you will forget a semicolon.
这个学期，你会忘记写分号。

647
00:30:37,290 --> 00:30:38,678
You will raise your hand.
你会举手。

648
00:30:38,678 --> 00:30:41,970
You'll get frustrated because you can't understand why your code's not working.
你会感到沮丧，因为你无法理解为什么你的代码无法运行。

649
00:30:41,970 --> 00:30:44,370
You will run into stupid issues like that.
你会遇到这样的愚蠢问题。

650
00:30:44,370 --> 00:30:46,385
But do take faith that they are stupid issues.
但相信它们是愚蠢的问题。

651
00:30:46,385 --> 00:30:49,260
It doesn't mean it's not clicking for you or you're not a programmer.
这并不意味着你没有理解或者你不是一名程序员。

652
00:30:49,260 --> 00:30:53,020
It just takes time to see these things if it's a new language to you.
如果你学习的是一门新的语言，理解这些东西需要时间。

653
00:30:53,020 --> 00:30:54,960
So there now is my semicolon.
所以现在我的分号已经写上了。

654
00:30:54,960 --> 00:30:58,110
All right, let's go ahead then and do something
好了，让我们继续做一些

655
00:30:58,110 --> 00:31:02,100
with that return value using the second of the big puzzle pieces in Scratch.
关于返回值的事情，使用 Scratch 中第二大块拼图。

656
00:31:02,100 --> 00:31:06,720
So when I wanted to say, "hello, David," or whatever the human's name is,
所以当我想要说“你好，大卫”，或者说任何人的名字的时候，

657
00:31:06,720 --> 00:31:09,850
I kind of stacked my puzzle pieces like this.
我把我的拼图块堆叠起来，就像这样。

658
00:31:09,850 --> 00:31:13,350
This is actually similar to Python and maybe some other languages some of you
这实际上类似于 Python，也许还有一些其他语言，你们中的一些人

659
00:31:13,350 --> 00:31:13,980
have learned.
已经学习过。

660
00:31:13,980 --> 00:31:15,990
But C is a little bit different.
但 C 语言略有不同。

661
00:31:15,990 --> 00:31:21,750
And the closest analog to this Scratch solution is going to look like this.
与这个 Scratch 解决方案最相似的方案将看起来像这样。

662
00:31:21,750 --> 00:31:25,080
I still use printf because printf is the equivalent of Say.
我仍然使用 printf，因为 printf 等同于 Say。

663
00:31:25,080 --> 00:31:32,022
Inside of my parentheses, I'm going to go ahead and say, weirdly, "hello, %s."
在我的括号内，我将说，奇怪的是，“hello，%s”。

664
00:31:32,022 --> 00:31:35,580
So there's no real analog in C of Join.
所以C语言中没有类似于Join的函数。

665
00:31:35,580 --> 00:31:41,970
Instead, there's a way to specially format text using printf, hence the F
相反，可以使用printf函数以特殊格式化文本，因此F

666
00:31:41,970 --> 00:31:42,900
in "printf."
是“printf”中的。

667
00:31:42,900 --> 00:31:45,630
And what you do in printf is you type whatever English word
在printf中，你可以输入任何你想输入的英文单词

668
00:31:45,630 --> 00:31:47,280
or human words that you want.
或者你想输入的任何人类语言的单词。

669
00:31:47,280 --> 00:31:50,110
You then use %s a placeholder.
然后使用 %s 作为占位符。

670
00:31:50,110 --> 00:31:54,450
If you want a string of text to be added to your own text,
如果你想将一段文本添加到自己的文本中，

671
00:31:54,450 --> 00:31:55,935
you literally write "%s."
你只需要输入"%s"。

672
00:31:55,935 --> 00:31:59,640
And let me anticipate a question from the crowd-- how do you print out %s?
让我来预判一个来自人群的问题——如何打印出 %s？

673
00:31:59,640 --> 00:32:03,690
There's a solution to that, too, if you literally ever want to print out %s.
当然也有解决方法，如果你真的想打印出 %s。

674
00:32:03,690 --> 00:32:07,390
But it's deliberately a weird choice of characters
但它有意选择了一些奇怪的字符

675
00:32:07,390 --> 00:32:10,140
so that the probability that we ever need to type this ourselves
这样一来，我们自己需要输入这些字符的可能性

676
00:32:10,140 --> 00:32:12,870
is just low that no one really worries too much about it.
就很低，所以没人会真正为此感到担忧。

677
00:32:12,870 --> 00:32:14,550
All right, but that's not quite enough.
好了，但这还不够。

678
00:32:14,550 --> 00:32:19,890
In addition to saying "hello", comma, space, placeholder %s--
除了输入"hello", 逗号, 空格, 占位符 %s--

679
00:32:19,890 --> 00:32:23,880
and just for vocabulary sake, that's a format code.
顺带一提，那是一个格式代码。

680
00:32:23,880 --> 00:32:26,250
Again, "format" being the F in printf.
再次强调，“format”是printf中的F。

681
00:32:26,250 --> 00:32:29,010
I still need my double quotes around the whole thing.
我仍然需要在整个内容周围使用双引号。

682
00:32:29,010 --> 00:32:31,290
In this case, to match my previous program,
在这种情况下，为了与我之前的程序匹配，

683
00:32:31,290 --> 00:32:33,270
I am going to go ahead and add the backslash n
我将添加反斜杠n

684
00:32:33,270 --> 00:32:35,910
to move the cursor to the next line.
将光标移动到下一行。

685
00:32:35,910 --> 00:32:39,840
And now I've left a crazy amount of room here, but that's deliberate.
现在我在这里留下了大量的空间，但这是故意的。

686
00:32:39,840 --> 00:32:42,240
Does anyone have an instinct for what I'm probably
有人能猜到我接下来可能会

687
00:32:42,240 --> 00:32:47,180
going to want to add after the quotes but still inside of the parentheses?
在引号之后，但仍然在括号内的内容吗？

688
00:32:47,180 --> 00:32:48,310
STUDENT: The answer.
学生：答案。

689
00:32:48,310 --> 00:32:49,840
DAVID MALAN: So answer itself.
大卫·马兰：所以是答案本身。

690
00:32:49,840 --> 00:32:54,010
I need to somehow tell printf with a second input,
我需要用一个额外的输入告诉printf，

691
00:32:54,010 --> 00:32:58,870
otherwise known as an argument, what I want to substitute for that %s.
也就是一个参数，我想用什么来替换 %s。

692
00:32:58,870 --> 00:33:02,650
And so I put a comma and then the name of the variable
所以我放了一个逗号，然后是变量的名称

693
00:33:02,650 --> 00:33:06,028
that I want printf to figure out how to plug in here.
我想让printf计算出如何将它插入这里。

694
00:33:06,028 --> 00:33:09,070
So honestly it's a little annoying, and this is kind of a dated approach.
老实说，这有点烦人，而且这是一种过时的做法。

695
00:33:09,070 --> 00:33:11,620
Newer, more modern languages, like we'll see later
更新、更现代的语言，比如我们稍后会看到的

696
00:33:11,620 --> 00:33:13,630
in the course, Python and JavaScript, actually
课程中的Python和JavaScript，实际上

697
00:33:13,630 --> 00:33:15,950
have much more user-friendly ways of doing it.
有更友好的方法来实现它。

698
00:33:15,950 --> 00:33:19,390
But once you wrap your mind around the heuristics, the rules here,
但是一旦你理解了这些启发式方法，这些规则，

699
00:33:19,390 --> 00:33:23,470
it's just formatting a string by plugging in whatever you want
它只是通过将你想要的任何内容插入

700
00:33:23,470 --> 00:33:26,470
into this format string, so to speak.
这个格式字符串来格式化字符串，可以这么说。

701
00:33:26,470 --> 00:33:28,810
And again, the comma here is important.
再次强调，这里的逗号很重要。

702
00:33:28,810 --> 00:33:33,220
This signifies that it takes one input at left and a second input at right.
这表示它在左侧接收一个输入，在右侧接收第二个输入。

703
00:33:33,220 --> 00:33:34,420
But notice this comma.
但请注意这个逗号。

704
00:33:34,420 --> 00:33:35,950
There's technically two commas.
从技术上来说，有两个逗号。

705
00:33:35,950 --> 00:33:40,480
But I'm not claiming that this function takes three inputs.
但我不是说这个函数接收三个输入。

706
00:33:40,480 --> 00:33:41,680
Why?
为什么？

707
00:33:41,680 --> 00:33:43,975
This comma I'm pointing out doesn't mean the same.
我指出的这个逗号并不意味着相同的意思。

708
00:33:43,975 --> 00:33:46,690
STUDENT: It's because that comma's part of the quotation marks
学生：因为那个逗号是引号的一部分

709
00:33:46,690 --> 00:33:48,070
and it's been part of the string.
并且是字符串的一部分。

710
00:33:48,070 --> 00:33:48,700
DAVID MALAN: Exactly.
大卫·马兰：没错。

711
00:33:48,700 --> 00:33:51,867
This comma that I'm pointing to is part of the quotation marks and therefore
我指出的这个逗号是引号的一部分，因此

712
00:33:51,867 --> 00:33:53,910
part of my string of English text.
这是我英文文本的一部分。

713
00:33:53,910 --> 00:33:55,400
So this is just English grammar.
所以这仅仅是英语语法。

714
00:33:55,400 --> 00:33:57,140
This is sort of C syntax.
这有点像 C 语言语法。

715
00:33:57,140 --> 00:33:59,810
And again, these are the sort of annoying little details
而且，这些是那种让人头疼的小细节

716
00:33:59,810 --> 00:34:03,795
that we're using the same symbol for different things, but context matters.
我们用相同的符号来表示不同的东西，但上下文很重要。

717
00:34:03,795 --> 00:34:06,170
So just stare at your code, look carefully left to right,
所以仔细盯着你的代码，从左到右仔细观察，

718
00:34:06,170 --> 00:34:10,080
and generally the answer will pop out, no pun intended.
通常答案会跳出来，没有双关语的意思。

719
00:34:10,080 --> 00:34:13,244
OK, questions now on this syntax before we actually write it and run it?
好的，现在在我们实际编写并运行之前，对这个语法有什么问题吗？

720
00:34:13,244 --> 00:34:13,744
Yeah?
是的？

721
00:34:13,744 --> 00:34:18,290
STUDENT: Why is the backslash n not after the answer?
学生：为什么反斜杠 n 不在答案之后？

722
00:34:18,290 --> 00:34:20,940
DAVID MALAN: Why is the backslash n not after the answer?
大卫·马兰：为什么反斜杠 n 不在答案之后？

723
00:34:20,940 --> 00:34:24,230
So the way functions work, including printf,
函数的工作方式，包括 printf，

724
00:34:24,230 --> 00:34:28,310
is that you pass to them one argument inside of the parentheses.
就是你向它们传递一个括号内的参数。

725
00:34:28,310 --> 00:34:32,690
And then if you have a second argument, you put it after this comma here.
然后如果你有一个第二个参数，你把它放在这个逗号之后。

726
00:34:32,690 --> 00:34:36,920
But the way printf works is that its first argument is always a string
但是 printf 的工作方式是，它的第一个参数始终是一个字符串

727
00:34:36,920 --> 00:34:39,330
that you want to be formatted for you.
你想要格式化的内容。

728
00:34:39,330 --> 00:34:43,340
So anything you want printed on the screen has to go in those quotes.
所以你想在屏幕上打印的任何东西都必须放在这些引号中。

729
00:34:43,340 --> 00:34:45,560
And you can perhaps extrapolate from this.
也许你可以从这里推断出来。

730
00:34:45,560 --> 00:34:50,389
If I actually wanted to say multiple things in this sentence, so "hello,"
如果我确实想在这句话中说很多东西，比如 "hello"，

731
00:34:50,389 --> 00:34:55,670
maybe first name, last name, I could actually do "hello" comma, %s, space,
也许是名，姓，我可以做 "hello" 逗号，%s，空格，

732
00:34:55,670 --> 00:34:59,960
%s, if I had two variables, one called First Name, one called Last Name.
%s，如果我有两个变量，一个叫做名，一个叫做姓。

733
00:34:59,960 --> 00:35:04,890
But then I would need another comma for a third input to the function.
但是，我需要另一个逗号作为函数的第三个输入。

734
00:35:04,890 --> 00:35:07,790
And so it's very general purpose in that sense.
所以从这个意义上说，它非常通用。

735
00:35:07,790 --> 00:35:08,720
Questions?
有问题吗？

736
00:35:08,720 --> 00:35:09,702
Yeah?
是的？

737
00:35:09,702 --> 00:35:15,370
STUDENT: Can you abstract this further by [INAUDIBLE] the "hello" [INAUDIBLE]??
学生：你能通过 [听不清] "hello" [听不清] 来进一步抽象它吗？

738
00:35:15,370 --> 00:35:19,870
DAVID MALAN: OK, so can you abstract away the format string itself, "hello,"
大卫·马兰：好的，所以你能将格式字符串本身抽象出来吗， "hello"，

739
00:35:19,870 --> 00:35:20,560
comma answer?
逗号答案？

740
00:35:20,560 --> 00:35:23,770
Short answer, yes, but not nearly as easily in C
简短的答案是，是的，但 C 语言远不如其他语言那样容易。

741
00:35:23,770 --> 00:35:25,280
as you can in other languages.
像其他语言那样容易。

742
00:35:25,280 --> 00:35:26,920
So that's why we're keeping it simple for now.
所以我们现在把它保持简单。

743
00:35:26,920 --> 00:35:29,200
But you're going to love something like Python or JavaScript,
但你会喜欢像 Python 或 JavaScript 这样的东西，

744
00:35:29,200 --> 00:35:31,090
where a lot of this complexity goes away.
很多复杂性消失了。

745
00:35:31,090 --> 00:35:34,300
But you'll see also in Python and JavaScript and other languages,
但你也会在 Python 和 JavaScript 以及其他语言中看到，

746
00:35:34,300 --> 00:35:37,610
they still are inspired by syntax like this.
它们仍然受到像这样的语法的启发。

747
00:35:37,610 --> 00:35:41,350
So just understanding it now will be useful for multiple languages
所以现在理解它将对多种语言有用

748
00:35:41,350 --> 00:35:42,670
down the line.
在未来。

749
00:35:42,670 --> 00:35:45,190
All right, so let's actually do something with this code
好的，让我们用这段代码做点什么

750
00:35:45,190 --> 00:35:48,670
rather than just talk about what it might be doing for us.
而不是仅仅讨论它可能为我们做了什么。

751
00:35:48,670 --> 00:35:52,400
Let me go over to, for instance, VS Code again.
让我再次回到 VS Code。

752
00:35:52,400 --> 00:35:56,920
And I'm going to go ahead now and remove this middle line of printf.
我现在将继续删除这行 printf 代码。

753
00:35:56,920 --> 00:35:59,337
I'm still in my same file called "hello.c."
我仍然在我的同一个名为 "hello.c" 的文件中。

754
00:35:59,337 --> 00:36:02,170
I'm going to clear my terminal window just to eliminate distraction.
我将清除我的终端窗口，以消除干扰。

755
00:36:02,170 --> 00:36:04,097
And to do that, I can literally type "clear."
为此，我可以直接输入 "clear"。

756
00:36:04,097 --> 00:36:05,680
But this is just for aesthetic's sake.
但这只是为了美观。

757
00:36:05,680 --> 00:36:07,240
That's not functionally that useful.
这在功能上并不实用。

758
00:36:07,240 --> 00:36:10,363
Or you can hit Control L to achieve the same on your keyboard.
或者你可以按下 Control L 在你的键盘上实现同样的效果。

759
00:36:10,363 --> 00:36:13,030
But I'm going to go back to line 5 here, where I previously just
但是我要回到第 5 行，我之前只是

760
00:36:13,030 --> 00:36:14,990
said "hello, world."
说了“你好，世界”。

761
00:36:14,990 --> 00:36:17,390
And I'm going to do this instead.
而我将改为这样做。

762
00:36:17,390 --> 00:36:20,330
I'm going to give myself a variable called string.
我将给自己一个名为字符串的变量。

763
00:36:20,330 --> 00:36:22,760
Sorry, I'm going to give myself a variable called
对不起，我将给自己一个名为

764
00:36:22,760 --> 00:36:25,280
answer, the type of which is string.
答案的变量，其类型为字符串。

765
00:36:25,280 --> 00:36:28,220
I'm going to set it equal to whatever the return
我将把它设置为 get_string 函数的返回值

766
00:36:28,220 --> 00:36:33,290
value is of get_string, asking an English question, "what's your name?"
，它会询问一个英文问题，“你叫什么名字？”

767
00:36:33,290 --> 00:36:36,290
with just a single space just to move the cursor over,
后面只加一个空格，以便将光标移过去，

768
00:36:36,290 --> 00:36:38,430
followed by a semicolon.
后面跟一个分号。

769
00:36:38,430 --> 00:36:41,300
Then I'm going to go ahead and say printf, quote,
然后我要继续说 printf，引号，

770
00:36:41,300 --> 00:36:48,680
unquote, "hello, placeholder, backslash n,"
引号，“你好，占位符，反斜杠 n”，

771
00:36:48,680 --> 00:36:50,900
comma, and then what goes here again?
逗号，然后这里又是什么？

772
00:36:50,900 --> 00:36:51,680
STUDENT: Answer.
学生：答案。

773
00:36:51,680 --> 00:36:53,420
DAVID MALAN: This is where answer goes.
大卫·马兰：答案应该放在这里。

774
00:36:53,420 --> 00:36:56,430
And then I just need a semicolon on the right of that.
然后我只需要在它右边放一个分号。

775
00:36:56,430 --> 00:36:58,042
But I think now that I'm done.
但我认为我现在已经完成了。

776
00:36:58,042 --> 00:36:59,750
But let me point out a couple of details.
不过，让我指出几个细节。

777
00:36:59,750 --> 00:37:01,940
This got very colorful, very pretty quickly.
它很快就变得五颜六色，非常漂亮。

778
00:37:01,940 --> 00:37:05,610
And it's not like the black and white code I had on the screen a moment ago.
这不像我刚才屏幕上的黑白代码。

779
00:37:05,610 --> 00:37:10,160
This is because what programs like VS Code do for us is it "pretty" prints,
这是因为像 VS Code 这样的程序为我们做了“美观”打印，

780
00:37:10,160 --> 00:37:13,980
or rather it syntax highlights our code for us.
或者更确切地说，它为我们语法高亮显示代码。

781
00:37:13,980 --> 00:37:17,060
So syntax highlighting means just add some colors to the code
所以语法高亮显示意味着只是在代码中添加一些颜色

782
00:37:17,060 --> 00:37:19,080
so that different ideas pop out.
以便不同的想法脱颖而出。

783
00:37:19,080 --> 00:37:22,760
So you'll notice, for instance, that printf here, get_string here
所以你会注意到，例如，这里的 printf，这里的 get_string

784
00:37:22,760 --> 00:37:26,210
are in purple because they represent functions, just like the Say block.
都是紫色的，因为它们代表函数，就像“说”块一样。

785
00:37:26,210 --> 00:37:28,460
Here, "what's your name?", quote, unquote, in VS Code
这里，“你叫什么名字？”，引号，引号，在 VS Code 中

786
00:37:28,460 --> 00:37:29,990
is a light blue instead of white.
是浅蓝色而不是白色。

787
00:37:29,990 --> 00:37:33,230
But it's still going to be consistent if I use strings of text elsewhere,
但如果我在其他地方使用文本字符串，它仍然是一致的。

788
00:37:33,230 --> 00:37:33,810
as well.
也是。

789
00:37:33,810 --> 00:37:35,453
So I didn't type anything special.
所以我没有输入任何特殊的东西。

790
00:37:35,453 --> 00:37:37,370
This isn't like Microsoft Word or Google Docs,
这不像 Microsoft Word 或 Google Docs，

791
00:37:37,370 --> 00:37:39,578
where I'm highlighting and changing colors of things.
我在那里高亮显示并改变事物颜色。

792
00:37:39,578 --> 00:37:41,180
This is all happening automatically.
这一切都是自动发生的。

793
00:37:41,180 --> 00:37:44,060
But it's just unicode text.
但它只是 Unicode 文本。

794
00:37:44,060 --> 00:37:46,340
It's just being interpreted automatically
它只是被自动解释

795
00:37:46,340 --> 00:37:51,080
and having these colors applied so that things pop out more usefully visually.
并应用这些颜色，以便事物在视觉上更有效地突出显示。

796
00:37:51,080 --> 00:37:52,985
Now, I've unfortunately made a mistake.
现在，我不幸地犯了一个错误。

797
00:37:52,985 --> 00:37:55,610
But I'm going to deliberately induce this one because you, too,
但我要故意诱发这个错误，因为你也会

798
00:37:55,610 --> 00:37:57,130
will probably make this mistake.
很可能犯这个错误。

799
00:37:57,130 --> 00:37:58,880
I'm going to go ahead and run "make hello"
我将继续运行“make hello”

800
00:37:58,880 --> 00:38:00,380
again, because I've changed my code.
再次，因为我修改了我的代码。

801
00:38:00,380 --> 00:38:03,740
So I have to regenerate the machine code from the new source code.
所以我必须从新的源代码重新生成机器代码。

802
00:38:03,740 --> 00:38:06,950
But unfortunately, when I hit Enter now, my God,
但不幸的是，当我按下回车键时，我的天啊，

803
00:38:06,950 --> 00:38:08,790
the errors don't even fit on the screen.
这些错误甚至无法显示在屏幕上。

804
00:38:08,790 --> 00:38:09,990
So let me make this bigger.
所以让我把它放大一点。

805
00:38:09,990 --> 00:38:12,157
I'm going to click the little caret symbol here just
我将点击这里的小插入符号

806
00:38:12,157 --> 00:38:14,360
to make my terminal bigger for just a moment.
以便将我的终端放大一会儿。

807
00:38:14,360 --> 00:38:17,090
And you'll see that there's more lines of errors
你会看到还有更多行的错误

808
00:38:17,090 --> 00:38:19,370
than there are of code that I actually wrote,
比我真正写下的代码还要多，

809
00:38:19,370 --> 00:38:22,730
often which is written pretty arcanely, again, for programmers who've
这些代码通常写得非常深奥，再次强调，是为那些

810
00:38:22,730 --> 00:38:24,830
been writing code for 10, 20 years.
已经写了 10 年、20 年代码的程序员写的。

811
00:38:24,830 --> 00:38:27,210
But there are some details that pop out.
但有一些细节很突出。

812
00:38:27,210 --> 00:38:30,620
So notice the problem is definitely with hello.c.
所以请注意，问题肯定出在 hello.c 上。

813
00:38:30,620 --> 00:38:36,180
So great, it is my fault. This syntax here means that line 5 is the problem.
太好了，是我的错。这里的语法意味着第 5 行有问题。

814
00:38:36,180 --> 00:38:38,810
And this next 5 means character 5.
而接下来的 5 代表第 5 个字符。

815
00:38:38,810 --> 00:38:42,860
So you can literally triangulate your bug, your mistake by going to line 5
所以你可以通过找到第 5 行

816
00:38:42,860 --> 00:38:45,440
and then over five, and it's somewhere in that area.
然后向右移动 5 个字符，错误就在这个区域。

817
00:38:45,440 --> 00:38:49,280
Specifically, "the area is use of undeclared identifier string.
具体来说，是“区域是使用未声明的标识符 string”。

818
00:38:49,280 --> 00:38:51,320
Did you mean standard in?"
你是想说标准输入吗？”

819
00:38:51,320 --> 00:38:52,460
I don't think I did.
我不这么认为。

820
00:38:52,460 --> 00:38:56,120
Like, I do want string, and then there's some other complexity here.
比如，我确实想要 string，但这里还有一些其他复杂性。

821
00:38:56,120 --> 00:39:00,860
But what's important here is not the specifics of this error but really
但这里重要的是不是这个错误的具体内容，而是

822
00:39:00,860 --> 00:39:04,010
the implication that it doesn't recognize the word
它无法识别“string”或“get_string”这两个词，

823
00:39:04,010 --> 00:39:06,590
"string" or "get_string."
这一点。

824
00:39:06,590 --> 00:39:08,355
Now, why might this be?
为什么会出现这种情况呢？

825
00:39:08,355 --> 00:39:08,855
Yeah?
是吧？

826
00:39:08,855 --> 00:39:14,195
STUDENT: You said that in order to [INAUDIBLE]
学生：你说过为了 [听不清]

827
00:39:14,195 --> 00:39:15,070
DAVID MALAN: Exactly.
大卫·马兰：没错。

828
00:39:15,070 --> 00:39:17,740
Because we are using get_string, which I claimed
因为我们正在使用 get_string，我声称

829
00:39:17,740 --> 00:39:19,930
is a CS50 thing that we'll use for a few weeks,
这是 CS50 的东西，我们会用几周，

830
00:39:19,930 --> 00:39:22,910
C does not know about it out of the box, so to speak.
但 C 语言并不知道它，就好像它没有自带这个功能一样。

831
00:39:22,910 --> 00:39:26,080
I have to teach the compiler that get_string exists,
我必须告诉编译器 get_string 存在，

832
00:39:26,080 --> 00:39:29,620
just like I taught the compiler that printf exists by including
就像我告诉编译器 printf 存在一样，通过包含

833
00:39:29,620 --> 00:39:31,010
the appropriate header file.
相应的头文件。

834
00:39:31,010 --> 00:39:35,200
And in this case, quite simply, it's called includeCS50.h.
在这种情况下，很简单，它叫做 includeCS50.h。

835
00:39:35,200 --> 00:39:38,890
That now teaches the compiler, oh, someone else
这现在告诉编译器，哦，其他人

836
00:39:38,890 --> 00:39:42,220
wrote this function already, get_string, and with it this type of variable
已经写了这个函数，get_string，以及这种类型的变量

837
00:39:42,220 --> 00:39:43,190
called "string."
叫做“string”。

838
00:39:43,190 --> 00:39:45,430
So now if I go back to my terminal window
所以现在如果我回到我的终端窗口

839
00:39:45,430 --> 00:39:49,510
and rerun the exact same command, "make hello"-- maybe crossing my fingers--
并重新运行完全相同的命令，“make hello”——也许我会祈祷一下——

840
00:39:49,510 --> 00:39:52,060
now nothing in fact goes wrong because the compiler
现在实际上不会出错，因为编译器

841
00:39:52,060 --> 00:39:55,210
has been brought up to speed with all of the functionality it needs.
已经了解了它需要的所有功能。

842
00:39:55,210 --> 00:39:59,410
And now if I do ./hello, Enter, there it is, what's my name?
现在如果我运行 ./hello，按回车，它就出现了，你的名字是什么？

843
00:39:59,410 --> 00:40:01,330
And notice the cursor is one space over just
请注意，光标只是向右移动了一个空格，

844
00:40:01,330 --> 00:40:03,550
because I thought that looked prettier than having the cursor right
因为我认为这样看起来比光标紧挨着问号更漂亮。

845
00:40:03,550 --> 00:40:05,110
next to the question mark.
紧挨着问号。

846
00:40:05,110 --> 00:40:07,840
D-A-V-I-D as my input, and Enter.
我输入 D-A-V-I-D，按回车。

847
00:40:07,840 --> 00:40:11,890
And "hello, David."
然后就显示“hello, David”。

848
00:40:11,890 --> 00:40:16,780
Questions on any of this code thus far?
到目前为止，对任何代码有疑问吗？

849
00:40:16,780 --> 00:40:18,630
Questions?
有问题吗？

850
00:40:18,630 --> 00:40:20,800
Any of the code.
任何代码都可以。

851
00:40:20,800 --> 00:40:21,370
No?
没有？

852
00:40:21,370 --> 00:40:25,630
All right, so let's introduce some other functionality into the mix.
好的，让我们把一些其他的功能引入进来。

853
00:40:25,630 --> 00:40:28,570
It turns out that there are other types of data,
事实证明，还有其他类型的数据，

854
00:40:28,570 --> 00:40:31,270
other types of variables in the world, not just strings
其他类型的变量，不仅仅是字符串，

855
00:40:31,270 --> 00:40:33,790
but indeed, per before, we have things called
事实上，像之前一样，我们有叫做

856
00:40:33,790 --> 00:40:38,260
integers, "int" for short, floating point values, "float" for short,
整数，简称为 “int”，浮点数，简称为 “float”，

857
00:40:38,260 --> 00:40:39,590
and a few others as well.
以及其他一些。

858
00:40:39,590 --> 00:40:41,530
So rather than only focus on string, let's
与其只关注字符串，不如让我们

859
00:40:41,530 --> 00:40:43,330
get a little more interesting with numbers
用数字来点缀一下

860
00:40:43,330 --> 00:40:46,660
here and see what we can do with something like integers, again
看看我们能用整数做些什么，再一次

861
00:40:46,660 --> 00:40:51,130
"int" for short, by taking a look at not get_string, as before, but now
简称“int”，不再像之前那样查看 get_string 函数，而是

862
00:40:51,130 --> 00:40:52,630
how about get_int.
看看 get_int 函数。

863
00:40:52,630 --> 00:40:56,110
And for this, I'm going to give us a few other tools in our toolkit,
为此，我将为我们的工具箱提供一些其他的工具，

864
00:40:56,110 --> 00:40:59,986
those format codes to which I alluded earlier, like %s,
我之前提到的那些格式代码，比如 %s，

865
00:40:59,986 --> 00:41:01,640
fortunately are pretty straightforward.
幸运的是，它们非常简单直观。

866
00:41:01,640 --> 00:41:04,930
And here is a list of most of the popular format codes
这里列出了大多数常用的格式代码

867
00:41:04,930 --> 00:41:07,510
that you might ever care about with printf.
你可能永远会关心 printf 函数的格式代码。

868
00:41:07,510 --> 00:41:10,180
In particular, we saw %s for string.
特别是，我们看到了 %s 代表字符串。

869
00:41:10,180 --> 00:41:13,060
And you can perhaps guess which one we're going to use for integers.
也许你可以猜出我们会用哪个格式代码来表示整数。

870
00:41:13,060 --> 00:41:13,932
STUDENT: %i.
学生：%i。

871
00:41:13,932 --> 00:41:16,640
DAVID MALAN: Yeah, so %i is what we're going to use for integers.
大卫·马兰：是的，所以我们用 %i 来表示整数。

872
00:41:16,640 --> 00:41:17,710
And this is the kind of thing that you can
而这种信息你可以

873
00:41:17,710 --> 00:41:20,420
consult in the manual pages or a slide like this.
在手册页面或类似这样的幻灯片中找到。

874
00:41:20,420 --> 00:41:22,850
There's only a few of them that you might frequently use.
其中只有几个你可能会经常使用。

875
00:41:22,850 --> 00:41:26,480
But let's go ahead and use integers in a more interesting context, not
但让我们在更有趣的上下文中使用整数，而不是

876
00:41:26,480 --> 00:41:27,440
just using functions.
仅仅使用函数。

877
00:41:27,440 --> 00:41:29,510
But let's revisit this idea of conditionals.
但让我们重新审视条件语句的概念。

878
00:41:29,510 --> 00:41:32,750
And conditionals in Scratch were like these proverbial forks in the road.
Scratch 中的条件语句就像谚语中所说的岔路口。

879
00:41:32,750 --> 00:41:36,420
Like, do you want to do this thing or this thing or this other thing?
就像，你想要做这件事，还是做那件事，或者做另外一件事？

880
00:41:36,420 --> 00:41:38,750
It's a way of making decisions in a program, which
这是一种在程序中做出决策的方式，它

881
00:41:38,750 --> 00:41:42,170
is going to be super useful and pretty much omnipresent in any problems
将非常有用，并且几乎无处不在我们试图解决的任何问题中

882
00:41:42,170 --> 00:41:43,320
that we try to solve.
我们试图解决。

883
00:41:43,320 --> 00:41:45,290
So let me give you a few more building blocks
所以让我给你展示一些 C 语言中的构建块

884
00:41:45,290 --> 00:41:48,140
in C by doing the side-by-side comparison again.
通过再次进行并排比较。

885
00:41:48,140 --> 00:41:53,750
So here in Scratch is how we might say if two variables, x and y,
所以，在 Scratch 中，我们可以这样说，如果两个变量，x 和 y，

886
00:41:53,750 --> 00:41:57,110
one is less than the other, then go ahead and say, quote, unquote,
其中一个小于另一个，那么就继续说，引号引起来，

887
00:41:57,110 --> 00:41:58,250
"x is less than y."
“x 小于 y”。

888
00:41:58,250 --> 00:41:59,730
So kind of a stupid program.
所以这是一个有点愚蠢的程序。

889
00:41:59,730 --> 00:42:02,300
But just to show you the basic syntax for Scratch,
但只是为了向你展示 Scratch 的基本语法，

890
00:42:02,300 --> 00:42:07,160
this is how you would ask the question, if x is less than y, then say this.
这就是你如何提出这个问题，如果 x 小于 y，那么就说这句话。

891
00:42:07,160 --> 00:42:08,570
So Say is the function.
所以 Say 是函数。

892
00:42:08,570 --> 00:42:09,920
"If" is the conditional.
“If” 是条件语句。

893
00:42:09,920 --> 00:42:14,307
And the green thing here we called, what?
而这里的绿色部分我们称之为，什么？

894
00:42:14,307 --> 00:42:15,140
What did we call it?
我们称之为？

895
00:42:15,140 --> 00:42:15,560
Yeah?
对吗？

896
00:42:15,560 --> 00:42:16,040
STUDENT: A Boolean.
学生：布尔值。

897
00:42:16,040 --> 00:42:18,000
DAVID MALAN: A Boolean or a Boolean expression,
大卫·马兰：布尔值或布尔表达式，

898
00:42:18,000 --> 00:42:20,167
which is just a fancy way of saying a question whose
这只是一个花哨的说法，表示一个问题的

899
00:42:20,167 --> 00:42:25,580
answer is true or false, yes or no, 1 or 0, however you want to think about it.
答案是真或假，是或否，1 或 0，无论你如何思考它。

900
00:42:25,580 --> 00:42:28,560
In C, the code is going to look like this.
在 C 语言中，代码将看起来像这样。

901
00:42:28,560 --> 00:42:32,480
So it'll take a little bit of habit, a little bit of muscle memory to develop.
所以这需要一些习惯，需要一些肌肉记忆的培养。

902
00:42:32,480 --> 00:42:35,880
But you're going to say "if," then in parentheses,
但你要说“if”，然后在括号里，

903
00:42:35,880 --> 00:42:39,530
you're going to say "x less than y," assuming x and y are variables.
你要说“x 小于 y”，假设 x 和 y 是变量。

904
00:42:39,530 --> 00:42:41,690
You're then going to use these curly braces.
然后你将使用这些大括号。

905
00:42:41,690 --> 00:42:45,110
And then if you want to say, quote, unquote, "x is less than y"
然后，如果你想说，引号引起来，“x 小于 y”

906
00:42:45,110 --> 00:42:50,140
in C, what function should we use here presumably?
在 C 语言中，我们应该在这里使用哪个函数呢？

907
00:42:50,140 --> 00:42:51,430
So printf.
所以是 printf。

908
00:42:51,430 --> 00:42:54,803
So printf, quote, unquote, "x is less than y."
所以是 printf，引号，"x is less than y"。

909
00:42:54,803 --> 00:42:57,220
So it's a bit of a mouthful, but again notice the pattern.
它看起来有点复杂，但再次注意这个模式。

910
00:42:57,220 --> 00:42:58,750
Name of the function is printf.
函数的名称是 printf。

911
00:42:58,750 --> 00:43:02,320
In the parentheses, left and right, is the argument to printf,
在括号中，左右括号之间是传递给 printf 的参数，

912
00:43:02,320 --> 00:43:04,750
which is, quote, unquote, "x is less than y."
也就是引号，"x is less than y"。

913
00:43:04,750 --> 00:43:07,730
And again, just for aesthetics, to move the cursor to the next line,
同样，仅仅为了美观，为了将光标移动到下一行，

914
00:43:07,730 --> 00:43:10,522
which you don't have to worry about in Scratch because everything's
在 Scratch 中你不需要担心这个问题，因为所有的内容

915
00:43:10,522 --> 00:43:14,000
in speech bubbles, we're adding a backslash n, as well.
都在气泡中，我们也添加一个反斜杠 n。

916
00:43:14,000 --> 00:43:16,390
So notice that these curly braces, as they're
所以请注意，这些花括号，就像它们

917
00:43:16,390 --> 00:43:18,850
called, much like the orange puzzle piece here,
被称为的那样，就像这里橙色的拼图一样，

918
00:43:18,850 --> 00:43:21,520
are kind of hugging the code like this.
像这样包围着代码。

919
00:43:21,520 --> 00:43:24,760
And I'll note that technically speaking in C,
我还要指出，从技术上讲，在 C 语言中，

920
00:43:24,760 --> 00:43:28,990
If you only have one line of code inside of your conditional,
如果你在你的条件语句中只有一行代码，

921
00:43:28,990 --> 00:43:31,360
you can actually omit the curly braces altogether.
你可以完全省略花括号。

922
00:43:31,360 --> 00:43:34,190
And the code will still work if you have one single line of code.
如果你只有一行代码，代码仍然可以运行。

923
00:43:34,190 --> 00:43:34,690
Why?
为什么？

924
00:43:34,690 --> 00:43:36,190
Just saves people some keystrokes.
只是为了让大家省点按键。

925
00:43:36,190 --> 00:43:38,470
If you have two lines, three lines, or more in there,
如果你有两行、三行或更多行代码，

926
00:43:38,470 --> 00:43:39,670
you need the curly braces.
你需要花括号。

927
00:43:39,670 --> 00:43:41,920
But I'll always draw it with the curly braces in class
但我上课时总是用花括号来画它

928
00:43:41,920 --> 00:43:44,980
so it resembles Scratch as closely as possible.
这样它就尽可能地像 Scratch 一样。

929
00:43:44,980 --> 00:43:47,230
As an aside to some of you who have programmed before,
顺便说一句，对于那些之前已经编程过的人，

930
00:43:47,230 --> 00:43:49,340
you might be cringing now because like you really
你现在可能很痛苦，因为你真的

931
00:43:49,340 --> 00:43:52,610
like your curly brace to be over here instead of here, that,
喜欢把你的花括号放在这里而不是那里，那是

932
00:43:52,610 --> 00:43:53,900
too, is a stylistic choice.
也是一种风格的选择。

933
00:43:53,900 --> 00:43:55,790
And we'll talk, too, about this in the class.
我们也会在课堂上讨论这个问题。

934
00:43:55,790 --> 00:43:58,910
Aesthetically, stylistically there are certain decisions we can make.
从美学和风格上来说，我们有一些决定可以做。

935
00:43:58,910 --> 00:44:03,530
But generally in a class, in a company, you as a student or an employee
但一般来说，在课堂上，在公司里，你作为一名学生或员工，

936
00:44:03,530 --> 00:44:07,890
would simply standardize on one set of rules, so to speak.
只需简单地统一一套规则，也可以这么说。

937
00:44:07,890 --> 00:44:12,200
So we'll use these rules for formatting our code in class consistently.
所以我们将在课堂上始终使用这些规则来格式化我们的代码。

938
00:44:12,200 --> 00:44:16,792
All right, any questions on this snippet of C code?
好了，这段 C 代码有什么问题吗？

939
00:44:16,792 --> 00:44:18,250
All right, a couple of others then.
好了，再看另外几个。

940
00:44:18,250 --> 00:44:21,420
So here is how, in Scratch, we might have a two-way fork in the road.
所以，在 Scratch 中，我们可能会有一个岔路口。

941
00:44:21,420 --> 00:44:26,340
If x is less than y, say x is less than y, else say x is not less than y.
如果 x 小于 y，就说 x 小于 y，否则就说 x 不小于 y。

942
00:44:26,340 --> 00:44:28,870
In C, It's going to look pretty much the same.
在 C 语言中，它看起来几乎是一样的。

943
00:44:28,870 --> 00:44:32,697
But notice I'm adding an "else" keyword here with another set of curly braces.
但请注意，我在此处添加了一个“else”关键字，并带有一组新的花括号。

944
00:44:32,697 --> 00:44:34,530
I'm going to have a couple of more printf's.
我将再添加几个 printf。

945
00:44:34,530 --> 00:44:37,600
But in C, even though it's clearly keyboard based,
但在 C 语言中，即使它明显是基于键盘的，

946
00:44:37,600 --> 00:44:41,500
it's just text, no more puzzle pieces, it's kind of the same shape,
它只是文本，不再有拼图，它形状也差不多，

947
00:44:41,500 --> 00:44:44,440
so to speak, and it's definitely the same idea.
可以这么说，而且它绝对是同一个想法。

948
00:44:44,440 --> 00:44:46,150
So it's following a pattern.
所以它遵循一个模式。

949
00:44:46,150 --> 00:44:49,990
What about a three-way fork in the road, if x is less than y,
那么三叉路口呢，如果 x 小于 y，

950
00:44:49,990 --> 00:44:53,160
then say x is less than y, else if x is greater
就说 x 小于 y，否则如果 x 大于

951
00:44:53,160 --> 00:45:01,012
than y, say x is greater than y, else if x equals y, then say x is equal to y.
y，就说 x 大于 y，否则如果 x 等于 y，就说 x 等于 y。

952
00:45:01,012 --> 00:45:02,970
Well, you can probably see where this is going.
好吧，你可能已经猜到它会往哪里发展了。

953
00:45:02,970 --> 00:45:06,070
On the right-hand side, it looks almost the same.
在右边，它看起来几乎是一样的。

954
00:45:06,070 --> 00:45:09,360
In fact, if I add in the printf's, it's really almost the same,
事实上，如果我加上 printf 语句，它真的几乎是一样的，

955
00:45:09,360 --> 00:45:10,620
at least logically.
至少从逻辑上来说。

956
00:45:10,620 --> 00:45:16,320
But there is at least one curiosity, seemingly a typo
但至少有一个奇怪的地方，看起来像个打字错误

957
00:45:16,320 --> 00:45:17,765
but it's not this time.
但这次不是。

958
00:45:17,765 --> 00:45:18,265
Yeah?
是吗？

959
00:45:18,265 --> 00:45:19,390
STUDENT: The double equals.
学生：双等于号。

960
00:45:19,390 --> 00:45:23,860
DAVID MALAN: Yeah, the double equal signs does not match Scratch,
大卫·马兰：是的，双等号在 Scratch 中并不匹配，

961
00:45:23,860 --> 00:45:28,150
but it's not in fact a bug or a mistake in C. Anyone
但它实际上不是 C 语言中的错误。任何人都

962
00:45:28,150 --> 00:45:33,610
have an intuition for why I did use two equal signs instead of one here?
能直觉地知道我为什么在这里用两个等号而不是一个等号吗？

963
00:45:33,610 --> 00:45:34,571
Yeah?
是吗？

964
00:45:34,571 --> 00:45:37,460
STUDENT: Because otherwise it could be mistaken for a variable.
学生：因为否则它可能会被误认为是变量。

965
00:45:37,460 --> 00:45:38,335
DAVID MALAN: Exactly.
大卫·马兰：没错。

966
00:45:38,335 --> 00:45:41,180
Well, otherwise it would be mistaken for a variable, specifically
好吧，否则它会被误认为是变量，特别是

967
00:45:41,180 --> 00:45:42,990
assignment of a variable.
变量的赋值。

968
00:45:42,990 --> 00:45:47,270
So recall that in previous code, when we used the get_string function,
所以回想一下，在我们之前的代码中，当我们使用 get_string 函数时，

969
00:45:47,270 --> 00:45:52,465
we used an equals sign to assign, from right to left, the value of a variable.
我们使用等号从右到左给变量赋值。

970
00:45:52,465 --> 00:45:53,840
And that's a reasonable decision.
这是一个合理的决定。

971
00:45:53,840 --> 00:45:56,007
"Equal" kind of means that the two should ultimately
“等于”的意思是，这两个最终应该

972
00:45:56,007 --> 00:45:59,660
be equal even though you think about it from going right to left.
相等，即使你从右到左考虑它。

973
00:45:59,660 --> 00:46:03,180
Unfortunately, the authors of C kind of [? painted ?] themselves into a corner.
不幸的是，C 语言的作者把自己逼到一个角落里。

974
00:46:03,180 --> 00:46:05,900
And presumably, decades ago when they realized, oh, shoot,
而且可以推测，几十年前当他们意识到，糟糕，

975
00:46:05,900 --> 00:46:07,910
we've already used a single equal sign, how
我们已经使用过一个等号了，如何

976
00:46:07,910 --> 00:46:12,320
do we represent equality of two values, the answer they came up with was,
来表示两个值的相等呢？他们想出的答案是，

977
00:46:12,320 --> 00:46:14,450
all right, we'll just use two instead.
好吧，我们只需要用两个。

978
00:46:14,450 --> 00:46:16,058
And thus was born this decision.
就这样，这个决定诞生了。

979
00:46:16,058 --> 00:46:16,850
Is it the best one?
这是最好的吗？

980
00:46:16,850 --> 00:46:17,690
Who knows?
谁知道呢？

981
00:46:17,690 --> 00:46:20,450
Crazy enough, in other languages, like JavaScript,
更疯狂的是，在其他语言中，比如 JavaScript，

982
00:46:20,450 --> 00:46:23,810
you have not just one, but two, but also three equal signs
你不仅有一个，还有两个，甚至还有三个等号

983
00:46:23,810 --> 00:46:25,770
in a row to solve yet another problem.
排成一行，用来解决另一个问题。

984
00:46:25,770 --> 00:46:29,100
So reasonable people will disagree as to how good or bad these decisions are.
所以，理性的观点会对这些决定是好是坏有不同的看法。

985
00:46:29,100 --> 00:46:32,930
But in C, this is what you must do.
但在 C 语言中，你必须这样做。

986
00:46:32,930 --> 00:46:38,430
But there's a bad design decision here, too.
但这里也有一个糟糕的设计决策。

987
00:46:38,430 --> 00:46:40,560
It's still correct, the code, left and right.
代码仍然是正确的，左右两边。

988
00:46:40,560 --> 00:46:45,210
But I bet I could critique the quality of the design of both the Scratch code
但我敢打赌，我可以批评 Scratch 代码和 C 代码的设计质量，为什么？

989
00:46:45,210 --> 00:46:47,910
and the C code for reasons, what?
因为什么？

990
00:46:47,910 --> 00:46:51,788
STUDENT: Do we have to do else if x equals [INAUDIBLE]??
学生：我们必须做 else if x 等于 [听不清]？

991
00:46:51,788 --> 00:46:53,580
DAVID MALAN: OK, no, really good intuition.
大卫·马兰：好的，不，直觉很好。

992
00:46:53,580 --> 00:46:57,030
Do we have to ask this third question, "else if x equals y?"
我们必须问第三个问题吗，“else if x 等于 y”？

993
00:46:57,030 --> 00:46:59,610
So short answer, no, logically, right?
所以简而言之，不，从逻辑上来说，对吧？

994
00:46:59,610 --> 00:47:05,130
Just based on arithmetic, either x is less than y or x is greater than y
仅仅基于算术，要么 x 小于 y，要么 x 大于 y

995
00:47:05,130 --> 00:47:08,220
or, what's the only other possible answer?
或者，还有什么其他可能的答案？

996
00:47:08,220 --> 00:47:10,080
They must be equal, logically.
它们必须相等，从逻辑上来说。

997
00:47:10,080 --> 00:47:13,140
So technically, you're just kind of wasting the computer's time
所以从技术上来说，你只是在浪费电脑的时间

998
00:47:13,140 --> 00:47:15,270
by asking this question because it already knows,
因为你问了这个问题，而它已经知道了，

999
00:47:15,270 --> 00:47:16,353
at that point, the answer.
到那时，答案。

1000
00:47:16,353 --> 00:47:18,780
And you're wasting your time as the programmer bothering
而且你作为程序员，在浪费时间，去麻烦

1001
00:47:18,780 --> 00:47:20,700
to type out more code or more puzzle pieces
去写更多代码或更多拼图块。

1002
00:47:20,700 --> 00:47:24,010
than you need because logically one stems from the other.
比你需要的多，因为从逻辑上讲，两者是相互关联的。

1003
00:47:24,010 --> 00:47:28,080
So I can tighten this up, get rid of the "else, if," just use an "else."
所以我可以简化一下，去掉“else, if”，直接用“else”。

1004
00:47:28,080 --> 00:47:31,110
And I can do the same thing over here in C, thereby avoiding
在C语言中也可以做同样的事情，从而避免

1005
00:47:31,110 --> 00:47:33,870
the double equal sign altogether, but not because it's wrong
完全使用双等号，但不是因为它错误

1006
00:47:33,870 --> 00:47:38,340
but because you're wasting time, because now you're potentially asking only two
而是因为你在浪费时间，因为现在你可能只问了两个

1007
00:47:38,340 --> 00:47:43,050
questions, two Boolean expressions, instead of 50% more by asking
问题，两个布尔表达式，而不是通过询问增加 50%

1008
00:47:43,050 --> 00:47:46,200
a total of three questions at most.
最多三个问题。

1009
00:47:46,200 --> 00:47:52,900
Other questions then on this kind of code, logically or otherwise?
还有其他关于这种代码的问题吗，无论是逻辑上的还是其他方面的？

1010
00:47:52,900 --> 00:47:53,400
No?
没有？

1011
00:47:53,400 --> 00:47:58,450
All right, so if we have these puzzle pieces, so to speak, at our disposal,
好的，如果我们拥有这些拼图，我们可以使用它们，

1012
00:47:58,450 --> 00:48:00,753
how can we go about actually using these?
我们该如何使用它们？

1013
00:48:00,753 --> 00:48:03,420
Well, suppose that we actually want to do something with values.
假设我们真的想对值做点什么。

1014
00:48:03,420 --> 00:48:06,190
Let's introduce variables in C, as well.
让我们在C语言中也引入变量。

1015
00:48:06,190 --> 00:48:08,197
We saw an example using a string a moment ago.
我们之前看到了一个使用字符串的例子。

1016
00:48:08,197 --> 00:48:10,030
But what about with something like integers?
但整数呢？

1017
00:48:10,030 --> 00:48:11,947
Well, you might not have used this in Scratch.
你可能没有在Scratch中使用过它。

1018
00:48:11,947 --> 00:48:13,830
But here's the orange puzzle piece in Scratch
但在Scratch中，橙色的拼图块

1019
00:48:13,830 --> 00:48:17,100
via which you can create a variable called counter to count things.
可以让你创建一个名为“counter”的变量来计数。

1020
00:48:17,100 --> 00:48:19,638
And you can set it equal to some value like 0.
你可以把它设置为某个值，例如 0。

1021
00:48:19,638 --> 00:48:21,930
Now, you can perhaps guess where we're going with this.
现在，你可能猜到我们下一步要做什么了。

1022
00:48:21,930 --> 00:48:27,540
If I want in C a variable called counter and I want to set it equal to 0,
如果我在C语言中想要一个名为“counter”的变量，并且想要把它设置为 0，

1023
00:48:27,540 --> 00:48:30,210
I use a single equal sign because logically you
我使用单等号，因为从逻辑上讲，你

1024
00:48:30,210 --> 00:48:32,340
read it from right to left, or technically it's
从右到左读取它，或者从技术上讲，它是

1025
00:48:32,340 --> 00:48:34,050
executed from right to left.
从右到左执行的。

1026
00:48:34,050 --> 00:48:37,128
But that's not enough in C. What's missing from the screen?
但这在C语言中还不够。屏幕上缺少什么？

1027
00:48:37,128 --> 00:48:37,920
STUDENT: Data type.
学生：数据类型。

1028
00:48:37,920 --> 00:48:38,760
DAVID MALAN: I need a what?
戴维·马兰：我需要什么？

1029
00:48:38,760 --> 00:48:39,570
STUDENT: You need a data type.
学生：你需要数据类型。

1030
00:48:39,570 --> 00:48:40,860
DAVID MALAN: So we need a data type.
戴维·马兰：所以我们需要数据类型。

1031
00:48:40,860 --> 00:48:43,110
And if it's going to be an integer, indeed I'm going to use int.
如果它要成为一个整数，我确实要使用“int”。

1032
00:48:43,110 --> 00:48:44,943
And now the other mistake I keep making is--
现在我一直在犯的另一个错误是——

1033
00:48:44,943 --> 00:48:45,735
STUDENT: Semicolon.
学生：分号。

1034
00:48:45,735 --> 00:48:48,070
DAVID MALAN: So a semicolon at the end of the line.
戴维·马兰：所以行末需要一个分号。

1035
00:48:48,070 --> 00:48:50,153
So it's a little more verbose than some languages.
所以它比一些语言更啰嗦。

1036
00:48:50,153 --> 00:48:52,180
But if you read it left to right, this is
但如果你从左到右阅读，这就是

1037
00:48:52,180 --> 00:48:56,600
how you tell C to give you a variable called counter of type int
你告诉C语言给你一个名为“counter”的变量，类型为“int”

1038
00:48:56,600 --> 00:49:00,010
and initialize it to a value of 0.
并将它初始化为 0。

1039
00:49:00,010 --> 00:49:00,850
That's all.
就这些了。

1040
00:49:00,850 --> 00:49:04,750
All right, how about, in Scratch, if you want to change that variable by 1,
好的，在Scratch中，如果你想将这个变量改变 1，

1041
00:49:04,750 --> 00:49:05,860
by adding 1 to it?
给它加上 1？

1042
00:49:05,860 --> 00:49:07,280
In Scratch, it's super simple.
在Scratch中，这非常简单。

1043
00:49:07,280 --> 00:49:09,430
You just change it by 1 or even negative 1
你只需将它更改为 1 甚至负 1

1044
00:49:09,430 --> 00:49:11,830
if you want to go up or down respectively.
如果你想分别向上或向下。

1045
00:49:11,830 --> 00:49:14,590
In C, it turns out you have a few different ways to do this.
在C语言中，你实际上有几种不同的方法可以做到这一点。

1046
00:49:14,590 --> 00:49:18,140
And this looks like it's not mathematically possible,
这看起来在数学上是不可能的，

1047
00:49:18,140 --> 00:49:21,820
but that's because equals is assignment, recall.
但那是因为等号是赋值，还记得吗？

1048
00:49:21,820 --> 00:49:27,130
So this line of code is not saying that counter equals counter plus 1,
所以这行代码不是说“counter 等于 counter 加 1”，

1049
00:49:27,130 --> 00:49:30,160
because that's just not possible using typical numbers.
因为使用普通数字这是不可能的。

1050
00:49:30,160 --> 00:49:33,290
But this means take counter's value, add 1 to it,
但这意味着取计数器的值，加 1，

1051
00:49:33,290 --> 00:49:36,080
and assign it back to the counter variable.
并将其重新赋值给计数器变量。

1052
00:49:36,080 --> 00:49:38,450
So it's like incrementing counter in this way.
所以这就像这样递增计数器。

1053
00:49:38,450 --> 00:49:41,380
But this is such a common thing in C and in programming
但在 C 语言和编程中，这是非常常见的

1054
00:49:41,380 --> 00:49:43,990
to increase or decrease the values of variables,
增加或减少变量的值，

1055
00:49:43,990 --> 00:49:46,090
there's a more succinct syntax.
有一个更简洁的语法。

1056
00:49:46,090 --> 00:49:48,460
This is identical.
这完全一样。

1057
00:49:48,460 --> 00:49:51,167
And it might take you a little practice to get used to it,
你可能需要练习一下才能习惯它，

1058
00:49:51,167 --> 00:49:52,750
but it just saves you some keystrokes.
但这节省了你一些按键。

1059
00:49:52,750 --> 00:49:56,050
But it similarly adds 1, or whatever number you use there.
但它同样加 1，或者你在那里使用的任何数字。

1060
00:49:56,050 --> 00:49:58,720
And this is such a common operation in C especially
这在 C 语言中尤其是一个很常见的操作

1061
00:49:58,720 --> 00:50:02,590
that there's an even tighter way of executing the same idea.
因此有一个更紧凑的方式来执行相同的想法。

1062
00:50:02,590 --> 00:50:08,240
And you can literally just say counter++ and then semicolon in this case.
在这种情况下，你可以直接说 counter++，然后分号。

1063
00:50:08,240 --> 00:50:09,760
All three are exactly the same.
这三种方式完全相同。

1064
00:50:09,760 --> 00:50:11,170
All three are perfectly correct.
这三种方式都是完全正确的。

1065
00:50:11,170 --> 00:50:13,545
But you'll learn over time that typing less on the screen
但你最终会明白，在屏幕上少打字

1066
00:50:13,545 --> 00:50:15,860
is probably going to save you some time.
可能可以节省你一些时间。

1067
00:50:15,860 --> 00:50:19,660
Meanwhile, if we wanted to do the opposite and do something like minus 1
同时，如果我们想要做相反的操作，比如减 1

1068
00:50:19,660 --> 00:50:24,610
in Scratch, we could similarly do minus minus in C. Or we could do--
在 Scratch 中，我们可以类似地在 C 语言中使用减减。或者我们可以做--

1069
00:50:24,610 --> 00:50:28,450
yeah, we could do minus minus in C here at right.
是的，我们可以在这里在 C 语言中使用减减。

1070
00:50:28,450 --> 00:50:31,480
All right, so just some additional building blocks, translating
好的，所以只是一些额外的构建块，将

1071
00:50:31,480 --> 00:50:36,790
from scratch to C. Why don't we go ahead and try using this perhaps
从 Scratch 翻译到 C 语言。为什么我们不尝试使用它呢？

1072
00:50:36,790 --> 00:50:38,260
in the following way?
用以下方式？

1073
00:50:38,260 --> 00:50:40,750
Let me go ahead and go back to VS Code.
让我回到 VS Code。

1074
00:50:40,750 --> 00:50:45,910
And let me propose that we do something like this.
我建议我们做这样的事情。

1075
00:50:45,910 --> 00:50:48,550
In VS Code, I'm going to go ahead and clear my terminal window.
在 VS Code 中，我将清除我的终端窗口。

1076
00:50:48,550 --> 00:50:50,650
I'm going to close "hello.c" by just clicking
我将通过点击来关闭 "hello.c"

1077
00:50:50,650 --> 00:50:54,220
the X. I'm going to go ahead and create a new file called "compare.c"
X。我将创建一个名为 "compare.c" 的新文件

1078
00:50:54,220 --> 00:50:56,410
because the purpose in life of this program
因为这个程序的生命意义

1079
00:50:56,410 --> 00:50:58,942
is going to be to compare integers on the screen.
将是在屏幕上比较整数。

1080
00:50:58,942 --> 00:51:00,400
This time I'm not going to mess up.
这一次我不会搞砸。

1081
00:51:00,400 --> 00:51:04,480
I'm going to preemptively include CS50.h.
我会预先包含 CS50.h。

1082
00:51:04,480 --> 00:51:07,630
I'm going to preemptively include stdio.h.
我将预先包含 stdio.h。

1083
00:51:07,630 --> 00:51:13,690
And here, too, is a very common mistake in learning C. It is not "studio.h."
这里也是学习 C 语言时的一个很常见的错误。它不是 "studio.h"。

1084
00:51:13,690 --> 00:51:16,690
So when you email us asking why "studio.h" is not working,
所以当你给我们发邮件问为什么 "studio.h" 不起作用时，

1085
00:51:16,690 --> 00:51:18,190
that's because that is not the word.
那是因为那个词不对。

1086
00:51:18,190 --> 00:51:22,420
It is "standard io.h," meaning standard input and output,
它是 "standard io.h"，意思是标准输入和输出，

1087
00:51:22,420 --> 00:51:24,370
stuff involving the screen and the keyboard.
涉及屏幕和键盘的东西。

1088
00:51:24,370 --> 00:51:27,370
Then I'm going to go ahead and, just as before, int main(void),
然后，就像之前一样，我将继续 int main(void)，

1089
00:51:27,370 --> 00:51:29,830
but we'll come back to that eventually as to what it means.
但我们最终会回到它的含义。

1090
00:51:29,830 --> 00:51:35,050
And now inside of "main," which is just where the main part of my program goes,
现在在 "main" 中，它只是我的程序的主要部分所在，

1091
00:51:35,050 --> 00:51:39,310
again you can think of this as being analogous to "when green flag clicked."
你可以把它想象成类似于 "当绿色旗帜被点击时"。

1092
00:51:39,310 --> 00:51:40,870
This just kicks everything off.
这只是启动一切。

1093
00:51:40,870 --> 00:51:42,680
I'm going to go ahead and do two things.
我将做两件事。

1094
00:51:42,680 --> 00:51:45,100
I'm going to go ahead and get an integer called x,
我将获得一个名为 x 的整数，

1095
00:51:45,100 --> 00:51:47,080
and I'm going to prompt the user for that int
并提示用户输入该整数。

1096
00:51:47,080 --> 00:51:50,770
and just say something like, "what's x?", space.
然后说类似“x是多少？”，后面加空格。

1097
00:51:50,770 --> 00:51:55,540
Then I'm going to do int y equals get_int, quote, unquote, "what's y?",
然后我要做 int y 等于 get_int，引号，引号，"y是多少？"，

1098
00:51:55,540 --> 00:51:56,410
space.
加空格。

1099
00:51:56,410 --> 00:52:00,830
And then let's just do something simple like, if x is less than y,
然后让我们做一些简单的，例如，如果x小于y，

1100
00:52:00,830 --> 00:52:03,520
then go ahead and print out, quote, unquote,
就打印，引号，引号，

1101
00:52:03,520 --> 00:52:08,740
"x is less than y backslash n," semicolon.
"x小于y，换行符"，分号。

1102
00:52:08,740 --> 00:52:10,610
So it's not a very deep program.
所以这不是一个非常复杂的程序。

1103
00:52:10,610 --> 00:52:13,610
It's just going to do what most any human brain could do pretty quickly.
它只是在做大多数人类的大脑可以很快完成的事情。

1104
00:52:13,610 --> 00:52:17,080
But it's at least demonstrating how we might use now
但这至少说明了我们现在如何使用

1105
00:52:17,080 --> 00:52:19,480
something like a conditional in code.
像代码中的条件语句这样的东西。

1106
00:52:19,480 --> 00:52:21,490
So let me go ahead and re--
所以让我继续 re--

1107
00:52:21,490 --> 00:52:25,750
let me compile this code for the first time, make compare, enter.
让我第一次编译这段代码，输入 make compare，回车。

1108
00:52:25,750 --> 00:52:31,150
Nothing bad happens, which is good. "./compare" is how I run the program.
没有出现错误，这很好。"./compare" 是我运行程序的方式。

1109
00:52:31,150 --> 00:52:33,820
And just to tease this apart, dot, as we'll soon see,
为了更清楚地解释，点，正如我们很快就会看到，

1110
00:52:33,820 --> 00:52:36,770
essentially means that the file is in your current folder.
本质上意味着该文件位于您的当前文件夹中。

1111
00:52:36,770 --> 00:52:38,620
So dot means in your current folder.
所以点代表当前文件夹。

1112
00:52:38,620 --> 00:52:41,440
And we'll eventually see that dot dot means your parent
我们最终会看到双点代表您的父级

1113
00:52:41,440 --> 00:52:43,780
folder, like the one that contains wherever
文件夹，就像包含我所在位置的那个

1114
00:52:43,780 --> 00:52:45,820
I am on my computer's hard drive.
在我的电脑硬盘上。

1115
00:52:45,820 --> 00:52:47,050
All right. ./compare.
好的。./compare。

1116
00:52:47,050 --> 00:52:48,264
What's x?
x是多少？

1117
00:52:48,264 --> 00:52:49,210
1.
1.

1118
00:52:49,210 --> 00:52:50,470
2 for y.
y是2.

1119
00:52:50,470 --> 00:52:54,217
And hopefully it should say that x is less than y.
希望它会显示x小于y。

1120
00:52:54,217 --> 00:52:55,300
So pretty straightforward.
所以非常简单明了。

1121
00:52:55,300 --> 00:52:56,290
Proof by example.
例子证明。

1122
00:52:56,290 --> 00:52:58,480
And hopefully this would work in other cases, too.
希望这在其他情况下也能奏效。

1123
00:52:58,480 --> 00:53:04,960
But if I flip that around and I rerun it, ./compare, and I do 2 and 1,
但是如果我反过来，重新运行，./compare，输入2和1，

1124
00:53:04,960 --> 00:53:06,432
nothing's going to happen.
什么也不会发生。

1125
00:53:06,432 --> 00:53:08,140
But you would expect that because there's
但你会期望是这样的，因为有

1126
00:53:08,140 --> 00:53:11,860
only one Boolean expression deciding whether or not
只有一个布尔表达式决定是否

1127
00:53:11,860 --> 00:53:13,880
I should actually type this out.
我应该实际把它输入出来。

1128
00:53:13,880 --> 00:53:15,160
So what's going on?
所以发生了什么？

1129
00:53:15,160 --> 00:53:17,140
Well, if this helps you, you might find it
好吧，如果这对你有所帮助，你可能会发现它

1130
00:53:17,140 --> 00:53:20,830
useful to think about the logic of any program, be it in Scratch or C,
对于理解任何程序的逻辑，无论是 Scratch 还是 C，都很有帮助。

1131
00:53:20,830 --> 00:53:22,600
as kind of a flowchart of sorts.
可以把它想象成一种流程图。

1132
00:53:22,600 --> 00:53:24,910
And we'll put up a few of these over time just in case
我们会不时地展示一些流程图，以防

1133
00:53:24,910 --> 00:53:26,690
you're a particularly visual thinker.
你是个特别善于视觉思考的人。

1134
00:53:26,690 --> 00:53:28,780
And this represents what it is I just did.
这代表了我刚刚做的操作。

1135
00:53:28,780 --> 00:53:32,470
So here in this picture is where the program starts conceptually.
所以在这张图片中，程序从概念上开始运行。

1136
00:53:32,470 --> 00:53:35,860
And any time you see a diamond, think of that as a Boolean expression,
当您看到菱形时，把它想象成一个布尔表达式，

1137
00:53:35,860 --> 00:53:37,330
a question that's being asked.
一个被问到的问题。

1138
00:53:37,330 --> 00:53:39,940
And the question being asked is, is x less than y?
而被问到的问题是，x是否小于y？

1139
00:53:39,940 --> 00:53:44,600
That has two possible answers, true or false, yes or no respectively.
这个问题有两个可能的答案，分别是真或假，即“是”或“否”。

1140
00:53:44,600 --> 00:53:48,400
So let me propose, per the arrow, that if the answer is true, then print out,
所以让我们假设，根据箭头，如果答案是真，则打印出来，

1141
00:53:48,400 --> 00:53:52,480
per this rectangle, "x is less than y," just quote, unquote, and then stop.
根据这个矩形，"x小于y"，引号，引号，然后结束。

1142
00:53:52,480 --> 00:53:53,680
That's it for the program.
这就是程序的全部内容。

1143
00:53:53,680 --> 00:53:56,800
But logically, if x is not less than y, that
但从逻辑上讲，如果x不小于y，那么

1144
00:53:56,800 --> 00:54:00,310
is that question's answer is false, we'll just skip right to the end
问题的答案是假，我们直接跳到末尾

1145
00:54:00,310 --> 00:54:01,210
and stop.
并结束。

1146
00:54:01,210 --> 00:54:03,493
So this is a control-flow diagram.
这是一个控制流程图。

1147
00:54:03,493 --> 00:54:05,410
It's just a pictorial way that you could write
它只是用图形的方式让你可以在

1148
00:54:05,410 --> 00:54:09,490
on a piece of paper that just represents what it is the program is doing.
纸上表示程序正在做的事情。

1149
00:54:09,490 --> 00:54:12,520
And this gets a little more interesting if now we
如果我们现在做点其他事情，它会更有趣。

1150
00:54:12,520 --> 00:54:14,260
do something else with the code.
对代码做点其他事情。

1151
00:54:14,260 --> 00:54:20,620
For instance, instead of just concluding that it's less than 1 or the other,
例如，与其只是得出小于1或其他结论，

1152
00:54:20,620 --> 00:54:22,330
let's go back to the code here.
我们回到这里的代码。

1153
00:54:22,330 --> 00:54:24,028
Let me clear my terminal window.
让我清除我的终端窗口。

1154
00:54:24,028 --> 00:54:25,070
And let me add an "else."
让我添加一个 "else"。

1155
00:54:25,070 --> 00:54:29,950
So else, go ahead and print out "x"--
所以 else，继续打印出 "x" --

1156
00:54:29,950 --> 00:54:34,240
I don't think I want to say this-- "greater than y."
我不认为我想说这个 -- "大于 y"。

1157
00:54:34,240 --> 00:54:35,480
It's not quite right.
不太对。

1158
00:54:35,480 --> 00:54:38,208
What would be reasonable to say here?
这里合乎逻辑的说法是什么？

1159
00:54:38,208 --> 00:54:39,500
STUDENT: "x is not less than y.
学生: "x 不小于 y。

1160
00:54:39,500 --> 00:54:43,850
DAVID MALAN: Yeah, subtle, but "x is not less than y" because it could be equal.
戴维·马兰: 是的，微妙，但 "x 不小于 y"，因为它可能等于 y。

1161
00:54:43,850 --> 00:54:48,990
We don't know if we're only checking two scenarios here.
我们不知道我们在这里是否只检查了两种情况。

1162
00:54:48,990 --> 00:54:53,030
So if I recompile this, make compare, ./compare.
所以如果我重新编译这个，make compare, ./compare。

1163
00:54:53,030 --> 00:54:55,970
Now if I do 1, comma 2, I still get the same answer.
现在如果我输入 1，逗号 2，我仍然得到相同的答案。

1164
00:54:55,970 --> 00:55:01,532
If I rerun ./compare 2, comma 1, I now get the opposite answer.
如果我重新运行 ./compare 2，逗号 1，我现在得到相反的答案。

1165
00:55:01,532 --> 00:55:02,990
It's not as good as might be ideal.
这并不像理想的那么好。

1166
00:55:02,990 --> 00:55:05,750
It'd be nice to know if it's equal to or greater than.
如果知道它等于或大于，会更好。

1167
00:55:05,750 --> 00:55:08,330
But at least that's all of the code that we have here.
但至少这是我们这里所有的代码。

1168
00:55:08,330 --> 00:55:10,430
And just to now paint a picture, if I go back
为了画一个图，如果我回到

1169
00:55:10,430 --> 00:55:13,340
to my control-flow diagram, my flow chart here,
我的控制流程图，我的流程图在这里，

1170
00:55:13,340 --> 00:55:15,800
this is what it looked like before logically.
从逻辑上来说，它以前是这样的。

1171
00:55:15,800 --> 00:55:21,600
Now that I've added in a second branch, so to speak,
现在，我已经添加了第二个分支，这么说吧，

1172
00:55:21,600 --> 00:55:26,420
now, if the answer is false, I first print out x is not less than y,
现在，如果答案是错误的，我首先打印出 x 不小于 y，

1173
00:55:26,420 --> 00:55:28,370
and then I stop the program.
然后我停止程序。

1174
00:55:28,370 --> 00:55:31,297
So same idea, but the decision tree, if you will,
所以，同样的想法，但是决策树，如果你愿意，

1175
00:55:31,297 --> 00:55:34,130
if you've taken a 10 or the like, is getting a little bit bigger now
如果你学过 10 或类似的课程，现在决策树会变得稍微大一些

1176
00:55:34,130 --> 00:55:34,672
conceptually.
在概念上。

1177
00:55:34,672 --> 00:55:36,755
All right, what if we do something more than this?
好吧，如果我们做更多的事情呢？

1178
00:55:36,755 --> 00:55:38,700
Let's actually have that third condition.
让我们实际实现第三种情况。

1179
00:55:38,700 --> 00:55:40,973
Let me go back into my code here.
让我回到这里的代码。

1180
00:55:40,973 --> 00:55:43,890
I'm going to hide the terminal window just to make room for more code.
我要隐藏终端窗口，以便为更多代码腾出空间。

1181
00:55:43,890 --> 00:55:47,730
And I'm going to say, "else if x is greater
我要说，“else if x 大于

1182
00:55:47,730 --> 00:55:51,720
than y," then go ahead and say not "x is not less than y,"
y，” 那么继续说，不是 "x 不小于 y"，

1183
00:55:51,720 --> 00:55:55,710
but rather "x is greater than y."
而是 "x 大于 y"。

1184
00:55:55,710 --> 00:55:59,950
And then down here, I'll do an "else if x equals equals y,"
然后在这里，我会添加一个 "else if x 等于等于 y"，

1185
00:55:59,950 --> 00:56:06,540
then I can go ahead and say printf, "x is equal to y backslash n,"
那么我就可以继续说 printf，"x 等于 y 反斜杠 n"，

1186
00:56:06,540 --> 00:56:07,990
close quote.
关闭引号。

1187
00:56:07,990 --> 00:56:11,160
All right, so now if I run it-- let me open my terminal window again.
好的，所以现在如果我运行它--让我重新打开我的终端窗口。

1188
00:56:11,160 --> 00:56:13,380
Let me rerun make compare.
让我重新运行 make compare。

1189
00:56:13,380 --> 00:56:15,570
Let me rerun ./compare.
让我重新运行 ./compare。

1190
00:56:15,570 --> 00:56:17,400
1 and 2 are the same.
1 和 2 是相同的。

1191
00:56:17,400 --> 00:56:18,600
Let me rerun it.
让我重新运行它。

1192
00:56:18,600 --> 00:56:20,730
2 and 1 are the same.
2 和 1 是相同的。

1193
00:56:20,730 --> 00:56:22,470
Let me rerun it a third time.
让我第三次重新运行它。

1194
00:56:22,470 --> 00:56:26,130
1 and 1 are now in fact equal.
1 和 1 现在实际上是相等的。

1195
00:56:26,130 --> 00:56:28,080
So this works correctly.
所以这是正确的。

1196
00:56:28,080 --> 00:56:31,920
But why did I make a point of using these "else if"s?
但是我为什么要特意使用这些“else if”呢？

1197
00:56:31,920 --> 00:56:36,660
Put another way, couldn't I just make my life a little simpler
换句话说，我不能让我的生活更简单一些吗？

1198
00:56:36,660 --> 00:56:39,180
and just say, if this, then that?
直接说，如果这样，那就那样？

1199
00:56:39,180 --> 00:56:40,200
If this, then that.
如果这样，那就那样。

1200
00:56:40,200 --> 00:56:41,640
If this, then that.
如果这样，那就那样。

1201
00:56:41,640 --> 00:56:43,290
Just ask all three questions.
只需问三个问题。

1202
00:56:43,290 --> 00:56:44,340
Keep the code simple.
保持代码简单。

1203
00:56:44,340 --> 00:56:47,010
Don't bother with these else's.
别管这些else。

1204
00:56:47,010 --> 00:56:48,715
Would this work for me?
这对我来说有用吗？

1205
00:56:48,715 --> 00:56:49,215
Yeah?
是吗？

1206
00:56:49,215 --> 00:56:52,312
STUDENT: It just seems like [INAUDIBLE] the program
学生：这看起来就像 [听不清] 程序

1207
00:56:52,312 --> 00:56:53,520
doesn't have to run the rest.
不必运行剩下的部分。

1208
00:56:53,520 --> 00:56:56,980
DAVID MALAN: Yeah, so it saves a little bit of time because in this case,
大卫·马兰：对，因此这节省了一点时间，因为在这种情况下，

1209
00:56:56,980 --> 00:57:00,840
just like in English, this is like asking three separate questions.
就像在英语中一样，这就像在问三个不同的问题。

1210
00:57:00,840 --> 00:57:05,190
And it's not harnessing any information from previous questions
而且它没有利用之前问题的任何信息

1211
00:57:05,190 --> 00:57:08,950
in order to decide whether you should bother asking that other question.
来决定是否需要问另一个问题。

1212
00:57:08,950 --> 00:57:11,610
In other words, if x is less than y-- and you already
换句话说，如果x小于y——而且你已经

1213
00:57:11,610 --> 00:57:14,460
figured that out because it's 1 and 2 respectively-- you're
弄清楚了，因为它们分别是1和2——你会

1214
00:57:14,460 --> 00:57:15,420
going to print this.
打印这个。

1215
00:57:15,420 --> 00:57:17,967
Why would you waste time asking this question when
为什么你要浪费时间问这个问题，当

1216
00:57:17,967 --> 00:57:19,050
it's not going to be true?
它不会是真的？

1217
00:57:19,050 --> 00:57:21,133
Why would you waste time asking this question when
为什么你要浪费时间问这个问题，当

1218
00:57:21,133 --> 00:57:22,240
it's not going to be true?
它不会是真的？

1219
00:57:22,240 --> 00:57:24,115
And so the point I wanted to make here, which
所以我想在这里强调的是，

1220
00:57:24,115 --> 00:57:27,300
is that if we visualize that particular design,
那就是如果我们可视化那个特定的设计，

1221
00:57:27,300 --> 00:57:30,000
what the flow chart looks like is actually this.
流程图的样子实际上是这样的。

1222
00:57:30,000 --> 00:57:31,320
And let me zoom in at the top.
让我放大顶部的图像。

1223
00:57:31,320 --> 00:57:34,500
If you ask the question "is x less than y," well,
如果你问“x是否小于y”，那么

1224
00:57:34,500 --> 00:57:37,502
you're going to go ahead and say, x less than y.
你就会继续说，x小于y。

1225
00:57:37,502 --> 00:57:39,210
Then if you go down to the next question,
然后如果你往下看下一个问题，

1226
00:57:39,210 --> 00:57:41,490
you're still going to ask is x greater than y.
你仍然会问x是否大于y。

1227
00:57:41,490 --> 00:57:45,060
And then below that, you're still going to ask is x equal equal to y?
然后在下面，你仍然会问x是否等于y？

1228
00:57:45,060 --> 00:57:50,730
So no matter what x and y are, you're asking one, two, three questions all
所以无论x和y是什么，你都会问一个、两个、三个问题，所有

1229
00:57:50,730 --> 00:57:51,580
of the time.
的时间。

1230
00:57:51,580 --> 00:57:54,840
But if we actually go in and do what we did the first time,
但如果我们真的进去，做我们第一次做的事，

1231
00:57:54,840 --> 00:57:59,700
where if I go back to my code and I undo this edit and add back the "else if"s--
如果我回到我的代码，撤销这个编辑，并添加回“else if”——

1232
00:57:59,700 --> 00:58:01,990
and now let me go back to the flow chart,
现在让我回到流程图，

1233
00:58:01,990 --> 00:58:05,440
which I claim is bad because it's one, two, three questions, one
我声称它很糟糕，因为它是一个、两个、三个问题，一个

1234
00:58:05,440 --> 00:58:09,630
or two of which might not be necessary-- now if I visualize what I just did,
或者两个可能是不必要的——现在如果我可视化我刚才做的事情，

1235
00:58:09,630 --> 00:58:12,480
the flow chart gets a little more complicated looking,
流程图看起来稍微复杂了一些，

1236
00:58:12,480 --> 00:58:15,430
but it's going to be better designed, more efficient.
但它将设计得更好，更有效率。

1237
00:58:15,430 --> 00:58:15,930
Why?
为什么？

1238
00:58:15,930 --> 00:58:19,320
Well, because if I start at the top here, I ask one question,
嗯，因为如果我从这里开始，我问一个问题，

1239
00:58:19,320 --> 00:58:20,460
is x less than y.
x是否小于y。

1240
00:58:20,460 --> 00:58:22,050
If the answer is true, OK.
如果答案是正确的，好的。

1241
00:58:22,050 --> 00:58:23,220
I say x less than y.
我说x小于y。

1242
00:58:23,220 --> 00:58:25,680
And then, boom, I sort of cheat and go all the way
然后，砰，我有点作弊，直接走到

1243
00:58:25,680 --> 00:58:29,400
to the end of the program and stop, having asked only one question.
程序的末尾并停止，只问了一个问题。

1244
00:58:29,400 --> 00:58:33,600
If, though, x is not less than y, OK, fine, I'll ask you a second question.
但是，如果x不小于y，好的，没问题，我会问你第二个问题。

1245
00:58:33,600 --> 00:58:37,680
But if the answer is true, boom, I print out x is greater than y,
但如果答案是正确的，我就会输出 x 大于 y，

1246
00:58:37,680 --> 00:58:38,730
and then I stop.
然后就停止。

1247
00:58:38,730 --> 00:58:42,000
And only in a perverse case where x actually
只有在一种极端情况下，x 实际上

1248
00:58:42,000 --> 00:58:46,410
equals y, which I'm going to claim is very unlikely or infrequent,
等于 y，我声称这不太可能或不常发生，

1249
00:58:46,410 --> 00:58:51,420
only then am I going to ask one, two, three questions to figure out whether
只有在那时，我才会问一、二、三个问题来确定是否

1250
00:58:51,420 --> 00:58:53,950
or not to print something at all.
是否要输出任何内容。

1251
00:58:53,950 --> 00:58:56,557
So this is what we mean by distinguishing between correctness
这就是我们所说的区分代码的正确性，

1252
00:58:56,557 --> 00:58:58,140
of code-- because it's still correct--
因为它仍然是正确的，

1253
00:58:58,140 --> 00:59:01,050
but this version is better designed because hopefully you're
但这个版本设计得更好，因为希望你会

1254
00:59:01,050 --> 00:59:04,980
going to go down this branch or this branch rather than the longest one
走这条分支或这条分支，而不是最长的那条分支

1255
00:59:04,980 --> 00:59:06,390
frequently.
经常。

1256
00:59:06,390 --> 00:59:13,660
Any questions now about this code or this visualization thereof?
现在关于这段代码或它的可视化有任何问题吗？

1257
00:59:13,660 --> 00:59:14,230
Yeah?
是吗？

1258
00:59:14,230 --> 00:59:17,597
STUDENT: I don't know if [INAUDIBLE]
学生：我不知道是否[听不清]

1259
00:59:19,332 --> 00:59:20,540
DAVID MALAN: A perfect segue.
戴维·马兰：完美的过渡。

1260
00:59:20,540 --> 00:59:23,153
Why did I bother, though, even asking this question?
不过，我为什么要费心问这个问题呢？

1261
00:59:23,153 --> 00:59:25,070
Don't need to because when I hit this button--
不需要，因为当我按下这个按钮时，

1262
00:59:25,070 --> 00:59:27,440
hopefully I have the right slide in place--
希望我的幻灯片放对了位置，

1263
00:59:27,440 --> 00:59:30,287
this would be even better than that design.
这将比那个设计更好。

1264
00:59:30,287 --> 00:59:31,620
So thank you for teeing that up.
感谢你提出这个问题。

1265
00:59:31,620 --> 00:59:32,662
This is the same picture.
这是同一张图片。

1266
00:59:32,662 --> 00:59:35,630
It sort of got bigger because there's fewer nodes,
它变大了，因为节点更少了，

1267
00:59:35,630 --> 00:59:37,100
fewer shapes in the picture.
图片中的形状更少了。

1268
00:59:37,100 --> 00:59:40,400
Notice that if x less than y, boom, we say as much, and we stop.
请注意，如果 x 小于 y，我们会这么说，然后停止。

1269
00:59:40,400 --> 00:59:43,910
If x is not less than y but it's greater than y, boom, we stop.
如果 x 不小于 y，但它大于 y，我们会停止。

1270
00:59:43,910 --> 00:59:46,820
Or if it's not greater than, we immediately
或者，如果它不大于，我们会立即

1271
00:59:46,820 --> 00:59:49,580
conclude x indeed is equal to y.
得出结论 x 确实等于 y。

1272
00:59:49,580 --> 00:59:50,900
And again, we stop.
我们再次停止。

1273
00:59:50,900 --> 00:59:54,680
So this picture is about as efficient and as
所以，这张图的效率和

1274
00:59:54,680 --> 00:59:57,200
well designed as we can make our logic.
设计得都尽可能好。

1275
00:59:57,200 --> 00:59:59,640
That's about as good as we can solve this problem.
这就是我们能解决这个问题的最佳方法。

1276
00:59:59,640 --> 01:00:02,690
So if I go back to my code now to make my C code
所以，如果我现在回到我的代码中，让我的 C 代码

1277
01:00:02,690 --> 01:00:06,830
match that, the only thing I need to do is stop wasting the computer's time.
与之匹配，我唯一需要做的是停止浪费计算机的时间。

1278
01:00:06,830 --> 01:00:08,540
Don't ask that third question.
不要问第三个问题。

1279
01:00:08,540 --> 01:00:12,290
Just logically, mathematically conclude that of course it's
从逻辑上和数学上得出结论，它当然会

1280
01:00:12,290 --> 01:00:16,455
going to be equal at that point in the story.
在故事中的那个时刻相等。

1281
01:00:16,455 --> 01:00:18,080
All right, any other questions on this?
好的，关于这个还有其他问题吗？

1282
01:00:18,080 --> 01:00:21,340
STUDENT: [INAUDIBLE]
学生： [听不清]

1283
01:00:21,340 --> 01:00:23,906
DAVID MALAN: Sorry, a little louder?
戴维·马兰：抱歉，能大声一点吗？

1284
01:00:23,906 --> 01:00:26,702
STUDENT: [INAUDIBLE]
学生： [听不清]

1285
01:00:28,353 --> 01:00:29,770
DAVID MALAN: Really good question.
戴维·马兰：真是个好问题。

1286
01:00:29,770 --> 01:00:31,728
What if I put in something that's not a number?
如果我输入了非数字的内容呢？

1287
01:00:31,728 --> 01:00:35,910
So here, too, is where the CS50 library and the implementation of get_int
所以，这也是 CS50 库和 get_int 实现发挥作用的地方

1288
01:00:35,910 --> 01:00:36,990
will be your friend.
将成为你的好帮手。

1289
01:00:36,990 --> 01:00:41,400
So for instance, if I run ./compare and I want to compare cats and dogs,
例如，如果我运行 ./compare，我想比较猫和狗，

1290
01:00:41,400 --> 01:00:43,905
I could type in "cats," Enter.
我可以输入 "cats"，然后回车。

1291
01:00:43,905 --> 01:00:45,780
It's just going to prompt me again and again.
它会一直提示我输入。

1292
01:00:45,780 --> 01:00:47,738
It's not going to let me type in "dogs" either.
它也不会让我输入 "dogs"。

1293
01:00:47,738 --> 01:00:49,740
It's going to force me to give it an integer.
它会强制我输入一个整数。

1294
01:00:49,740 --> 01:00:51,880
C does not do that by default.
C 语言默认不会这样做。

1295
01:00:51,880 --> 01:00:55,110
And in fact, as we'll soon see over the course of CS50,
事实上，正如我们将在CS50课程中很快看到，

1296
01:00:55,110 --> 01:00:57,660
C is actually a very dangerous language at the end of the day
C实际上是一种非常危险的语言

1297
01:00:57,660 --> 01:01:00,660
because it just trusts that the human is doing what it wants.
因为它只是相信人类正在做它想做的事。

1298
01:01:00,660 --> 01:01:04,890
And as such, a lot of today's software that is hacked in some ways,
因此，当今许多以某种方式被黑客攻击的软件，

1299
01:01:04,890 --> 01:01:07,800
if it's using C or another language called C++,
如果它使用C或另一种叫做C++的语言，

1300
01:01:07,800 --> 01:01:11,190
are actually very vulnerable to certain types of hacking,
实际上非常容易受到某些类型的黑客攻击，

1301
01:01:11,190 --> 01:01:14,880
whereas other languages that we'll get to in the class are less so for reasons
而我们将在课堂上学习的其他语言则不会，原因是

1302
01:01:14,880 --> 01:01:17,170
like this.
像这样。

1303
01:01:17,170 --> 01:01:21,440
All right, so besides this, let's consider just one other data type.
好的，除了这个之外，让我们再考虑一种数据类型。

1304
01:01:21,440 --> 01:01:21,940
how about.
怎么样？

1305
01:01:21,940 --> 01:01:26,710
So besides strings, besides chars, there's some others on this list here.
除了字符串，除了字符，这里还有其他一些东西。

1306
01:01:26,710 --> 01:01:29,110
Sorry, besides strings, besides integers,
抱歉，除了字符串，除了整数，

1307
01:01:29,110 --> 01:01:33,410
there's this other data type here in C known as a char for a single character.
在C中，这里还有另一种数据类型被称为char，用于表示单个字符。

1308
01:01:33,410 --> 01:01:35,050
So here, let me just tease this apart.
所以，让我把这些分开。

1309
01:01:35,050 --> 01:01:37,690
A string is indeed a string of text.
字符串确实是一串文本。

1310
01:01:37,690 --> 01:01:40,540
It is zero or more characters together.
它是由零个或多个字符组成的。

1311
01:01:40,540 --> 01:01:45,130
A char is always precisely one character.
char始终是一个字符。

1312
01:01:45,130 --> 01:01:48,520
Not all languages bother distinguishing between a single character
并非所有语言都关心区分单个字符

1313
01:01:48,520 --> 01:01:49,660
and a string of characters.
和字符串。

1314
01:01:49,660 --> 01:01:53,140
But in C, a string is typically multiple characters,
但在C中，字符串通常由多个字符组成，

1315
01:01:53,140 --> 01:01:54,640
but technically can be zero.
但从技术上讲可以是零。

1316
01:01:54,640 --> 01:01:56,350
Coincidentally, it could be one.
巧合的是，它可以是一个。

1317
01:01:56,350 --> 01:01:58,210
But it's capable of being more.
但它可以包含更多字符。

1318
01:01:58,210 --> 01:02:02,290
But a char is literally, as the word implies, a single character.
但是，char字面意思是，正如这个词所暗示的，一个字符。

1319
01:02:02,290 --> 01:02:05,050
All right, given that, notice that in the CS50 library,
好的，考虑到这一点，请注意，在CS50库中，

1320
01:02:05,050 --> 01:02:08,388
besides get_string, besides get_int, we also have get_char,
除了get_string，除了get_int，我们还有get_char，

1321
01:02:08,388 --> 01:02:10,930
so another handy function for just getting a single character
所以，另一个用于获取单个字符的便捷函数

1322
01:02:10,930 --> 01:02:11,770
from the user.
来自用户。

1323
01:02:11,770 --> 01:02:14,603
Now, why would it be useful to get a single character from the user?
现在，为什么从用户那里获取单个字符有用呢？

1324
01:02:14,603 --> 01:02:16,312
Well, what if you're just doing something
好吧，如果你只是在做一些事情

1325
01:02:16,312 --> 01:02:19,310
that you and I do pretty frequently when you install new software
你和我在安装新软件时经常做的事情

1326
01:02:19,310 --> 01:02:20,750
or fill out some form?
或者填写一些表格？

1327
01:02:20,750 --> 01:02:23,370
You agree to some form of terms and conditions.
你同意某种形式的条款和条件。

1328
01:02:23,370 --> 01:02:25,650
So in fact, let me go back over to VS Code here.
实际上，让我回到VS Code这里。

1329
01:02:25,650 --> 01:02:29,540
And let me propose that I create a new program called agree.c,
让我提议创建一个名为agree.c的新程序，

1330
01:02:29,540 --> 01:02:32,420
so something akin to asking for the user's agreement.
所以，类似于询问用户的同意。

1331
01:02:32,420 --> 01:02:35,698
So in VS Code, I'm going to type "code agree.c."
所以，在VS Code中，我要输入"code agree.c"。

1332
01:02:35,698 --> 01:02:37,490
And I'm going to do some quick boilerplate.
我将进行一些快速操作。

1333
01:02:37,490 --> 01:02:43,280
So include CS50.h, include stdio.h, int main(void).
所以，包含CS50.h，包含stdio.h，int main(void)。

1334
01:02:43,280 --> 01:02:46,820
And then inside of main, which is like the "green flag clicked,"
然后在main内部，就像"绿色旗帜被点击"，

1335
01:02:46,820 --> 01:02:47,960
I'm going to do this.
我要做这个。

1336
01:02:47,960 --> 01:02:51,290
Go ahead and get a character from the user,
继续从用户那里获取一个字符，

1337
01:02:51,290 --> 01:02:54,500
and ask them something simple like, "Do you agree?,"
并询问他们一些简单的问题，比如："你同意吗？"，

1338
01:02:54,500 --> 01:02:56,490
expecting a yes/no response.
期待一个是/否的回应。

1339
01:02:56,490 --> 01:03:00,778
But at the beginning of this line, I need to put the return value somewhere.
但是，在这行的开头，我需要把返回值放到某个地方。

1340
01:03:00,778 --> 01:03:02,570
So I'm going to put it in a variable called
所以，我把它放在一个叫做

1341
01:03:02,570 --> 01:03:06,200
C. And in programming, if you're just getting a single value,
C的变量中。在编程中，如果你只是获取一个值，

1342
01:03:06,200 --> 01:03:11,645
it's OK sometimes to use X and Y or C when you're using--
在某些情况下，使用 X 和 Y 或 C 时是可以的，当你使用--

1343
01:03:11,645 --> 01:03:15,470
in larger programs, you'll benefit from using actual words like "answer,"
在更大的程序中，使用像“答案”这样的实际单词会更有益，

1344
01:03:15,470 --> 01:03:16,820
like we did from the get go.
就像我们从一开始就做的那样。

1345
01:03:16,820 --> 01:03:18,870
But C has to be a specific type.
但 C 必须是特定的类型。

1346
01:03:18,870 --> 01:03:21,020
So I'm going to literally say "char," and then
所以我将直接说“char”，然后

1347
01:03:21,020 --> 01:03:23,180
I'm going to finish my thought with a semicolon.
我会用分号结束我的想法。

1348
01:03:23,180 --> 01:03:26,030
And here's now how I could check if the user agrees or not.
现在，我可以检查用户是否同意。

1349
01:03:26,030 --> 01:03:27,480
I could do something like this.
我可以做这样的事情。

1350
01:03:27,480 --> 01:03:31,580
If the value of C equals equals, quote, unquote,
如果 C 的值等于等于，引号，引号，

1351
01:03:31,580 --> 01:03:38,240
lowercase 'y,' then go ahead and print out "Agreed backslash n."
小写“y”，然后继续打印“同意反斜杠 n”。

1352
01:03:38,240 --> 01:03:44,420
Else if the variable C has a value equal to lowercase 'n', let's go ahead
否则，如果变量 C 的值等于小写“n”，让我们继续

1353
01:03:44,420 --> 01:03:48,440
and print out, say, "Not agreed," as though I'm agreeing or not to some
并打印出，比如，“不同意”，就好像我同意或不同意某些

1354
01:03:48,440 --> 01:03:49,670
terms and conditions.
条款和条件。

1355
01:03:49,670 --> 01:03:51,590
But notice these are not typos.
但请注意，这些不是打字错误。

1356
01:03:51,590 --> 01:03:56,400
What did I do ever so subtly different from last time I used text?
我做了什么与上次使用文本时略有不同的事情？

1357
01:03:56,400 --> 01:03:56,900
Yeah?
对吧？

1358
01:03:56,900 --> 01:03:58,983
STUDENT: Single quotes instead of double quotes.
学生：单引号而不是双引号。

1359
01:03:58,983 --> 01:04:01,150
DAVID MALAN: Single quotes instead of double quotes.
大卫·马兰：单引号而不是双引号。

1360
01:04:01,150 --> 01:04:02,150
So here's the heuristic.
所以这是启发式方法。

1361
01:04:02,150 --> 01:04:04,860
When using strings, which are generally multiple characters,
当使用字符串时，字符串通常是多个字符，

1362
01:04:04,860 --> 01:04:06,240
have to use double quotes.
必须使用双引号。

1363
01:04:06,240 --> 01:04:09,900
When using a single character, you should use single quotes
当使用单个字符时，应该使用单引号

1364
01:04:09,900 --> 01:04:11,320
around the single character.
围绕单个字符。

1365
01:04:11,320 --> 01:04:13,770
So let me go ahead now and, make agree.
所以我现在就去做，让它同意。

1366
01:04:13,770 --> 01:04:16,890
Nothing went wrong, which is good. ./agree, Enter,
一切顺利，这很好。 ./同意，回车，

1367
01:04:16,890 --> 01:04:19,080
and let me go ahead and type in y for yes.
然后我继续输入 y 代表是。

1368
01:04:19,080 --> 01:04:20,350
It seems to work.
它似乎有效。

1369
01:04:20,350 --> 01:04:24,480
Let me run it again. ./agree. n for no, and it seems to work.
我再运行一次。 ./同意。n 代表否，它似乎有效。

1370
01:04:24,480 --> 01:04:27,600
And just if I type in something random like question mark, I don't know,
如果我输入一些随机的东西，比如问号，我不知道，

1371
01:04:27,600 --> 01:04:28,590
it doesn't crash.
它没有崩溃。

1372
01:04:28,590 --> 01:04:32,830
It just ignores me because I only had two Boolean expressions there.
它只是忽略了我，因为我只在那里写了两个布尔表达式。

1373
01:04:32,830 --> 01:04:35,610
But notice that it's actually a little buggy arguably.
但请注意，它实际上可能有点错误。

1374
01:04:35,610 --> 01:04:38,550
Let me run it again. ./agree, Enter.
我再运行一次。 ./同意，回车。

1375
01:04:38,550 --> 01:04:41,760
How about capital Y because, like, my Caps Lock is down.
大写 Y 怎么样，因为我的大小写锁定键被按下了。

1376
01:04:41,760 --> 01:04:43,050
OK, it just ignores me.
好的，它只是忽略了我。

1377
01:04:43,050 --> 01:04:46,020
Let me do it again. ./agree, capital N because my-- oops--
我再做一次。 ./同意，大写 N 因为我的-- 哎呀--

1378
01:04:46,020 --> 01:04:48,540
because my Caps Lock is down.
因为我的大小写锁定键被按下了。

1379
01:04:48,540 --> 01:04:49,590
OK, it just ignores me.
好的，它只是忽略了我。

1380
01:04:49,590 --> 01:04:52,590
But this should make sense because I'm literally checking for lowercase.
但这应该是合理的，因为我实际上是在检查小写字母。

1381
01:04:52,590 --> 01:04:55,990
So how could I fix this?
那么我该如何解决这个问题？

1382
01:04:55,990 --> 01:05:00,347
How could I fix this without just changing lowercase to uppercase,
我该如何解决这个问题，而不仅仅是将小写字母改为大写字母，

1383
01:05:00,347 --> 01:05:02,680
because that would then break it in the other direction?
因为那样做会破坏另一个方向的代码？

1384
01:05:02,680 --> 01:05:03,220
Yeah?
对吧？

1385
01:05:03,220 --> 01:05:06,510
STUDENT: [INAUDIBLE]
学生： [听不清]

1386
01:05:09,698 --> 01:05:12,490
DAVID MALAN: Yeah, let's just add another branch here, so to speak.
大卫·马兰：是的，我们可以在这里添加另一个分支，可以这么说。

1387
01:05:12,490 --> 01:05:18,090
So if variable C equals equals capital Y, then I can go ahead here
所以如果变量 C 等于等于大写 Y，那么我可以在此处继续

1388
01:05:18,090 --> 01:05:20,280
and say printf agreed.
并说 printf 同意。

1389
01:05:20,280 --> 01:05:23,160
And then let me close my terminal to make more room.
然后我关闭我的终端以腾出更多空间。

1390
01:05:23,160 --> 01:05:27,690
Otherwise, down here, else if C equals equals capital N,
否则，在下面，else if C 等于等于大写 N，

1391
01:05:27,690 --> 01:05:31,050
let's go ahead and again say printf not agreed.
让我们继续说 printf 不同意。

1392
01:05:31,050 --> 01:05:33,600
And I claim that this would actually now work.
我声称这实际上现在可以工作了。

1393
01:05:33,600 --> 01:05:36,180
It's a four-way fork in the road, but I'm at least
这是一条四岔路口，但至少

1394
01:05:36,180 --> 01:05:40,500
checking for lowercase, uppercase, lowercase, uppercase for y and n
我正在检查 y 和 n 的小写、大写、小写、大写。

1395
01:05:40,500 --> 01:05:41,580
respectively.
分别。

1396
01:05:41,580 --> 01:05:44,910
I claim that this is correct, but this too,
我声称这是正确的，但这也

1397
01:05:44,910 --> 01:05:47,490
even if you've never programmed before, should start today
即使你以前从未编程过，也应该从今天开始

1398
01:05:47,490 --> 01:05:49,290
to rub you the wrong way.
让你不爽。

1399
01:05:49,290 --> 01:05:51,420
Like, we can do better.
就像，我们可以做得更好。

1400
01:05:51,420 --> 01:05:53,790
This isn't the best design.
这不是最好的设计。

1401
01:05:53,790 --> 01:05:54,570
Why might that be?
为什么呢？

1402
01:05:54,570 --> 01:05:55,490
Yeah?
是吗？

1403
01:05:55,490 --> 01:06:00,735
STUDENT: Could you change the character c to be uppercase, like before you even
学生：你可以将字符 c 更改为大写，就像在您甚至

1404
01:06:00,735 --> 01:06:01,235
[INAUDIBLE]?
[听不清]？

1405
01:06:01,235 --> 01:06:02,420
DAVID MALAN: Ah, clever.
大卫·马兰：啊，聪明。

1406
01:06:02,420 --> 01:06:07,790
So could we change the variable c to just be forced to uppercase
所以我们能否将变量 c 强制转换为大写

1407
01:06:07,790 --> 01:06:09,320
or maybe forced to lowercase?
或者强制转换为小写？

1408
01:06:09,320 --> 01:06:12,650
No matter what the human types, we just do that ourselves so that way
无论人类输入什么，我们自己就那样做，这样

1409
01:06:12,650 --> 01:06:15,380
we can just simplify this again to two possible scenarios.
我们就可以再次将它简化为两种可能的情况。

1410
01:06:15,380 --> 01:06:17,930
I love that, but we haven't seen any functions yet
我喜欢那样，但我们还没有看到任何函数

1411
01:06:17,930 --> 01:06:20,570
in C that would let me change things to uppercase or lowercase.
在 C 中，可以让我将事物更改为大写或小写。

1412
01:06:20,570 --> 01:06:22,795
So we'll get there, but a good instinct and correct.
所以我们会做到这一点，但这是一个很好的直觉，而且是正确的。

1413
01:06:22,795 --> 01:06:23,420
Other thoughts?
还有其他想法吗？

1414
01:06:23,420 --> 01:06:24,620
STUDENT: Use "or."
学生：使用“或”。

1415
01:06:24,620 --> 01:06:28,550
DAVID MALAN: So we could use "or" in some sense, like a logical "or."
大卫·马兰：所以我们可以某种意义上使用“或”，就像逻辑上的“或”。

1416
01:06:28,550 --> 01:06:32,760
What I don't like about this, to be clear, is that it's repeating itself.
让我说明一下，我不喜欢它的一点是，它在重复自己。

1417
01:06:32,760 --> 01:06:35,510
And there's this principle in programming, and in life in general,
并且编程中，以及生活中一般都遵循这样一个原则：

1418
01:06:35,510 --> 01:06:37,940
like, don't repeat yourself unnecessarily.
不要不必要地重复自己。

1419
01:06:37,940 --> 01:06:41,930
And by that I mean I literally have the same line 10 as 14.
我的意思是，我的第 10 行和第 14 行完全一样。

1420
01:06:41,930 --> 01:06:44,760
I have the same line 18 as 22.
我的第 18 行和第 22 行完全一样。

1421
01:06:44,760 --> 01:06:48,920
And if anything, one, I literally wasted twice as much time as I needed to.
而且，如果有什么的话，我实际上浪费了我所需时间两倍的时间。

1422
01:06:48,920 --> 01:06:51,200
Put another way, per our discussion of Scratch,
换句话说，根据我们对 Scratch 的讨论，

1423
01:06:51,200 --> 01:06:53,510
what if I go in and just change something like,
如果我进去只更改某些东西，比如

1424
01:06:53,510 --> 01:06:55,610
I want to be more excited, like "Agreed!"?
我想更兴奋一些，比如“同意！”？

1425
01:06:55,610 --> 01:06:57,818
Well, I might forget to change it in the other place.
好吧，我可能会忘记更改另一个地方。

1426
01:06:57,818 --> 01:07:00,527
And let's just claim for today's purposes that that looks stupid,
并且就今天而言，我们假定这看起来很蠢，

1427
01:07:00,527 --> 01:07:02,580
it's a bug, because I want them to be consistent.
这是一个错误，因为我希望它们保持一致。

1428
01:07:02,580 --> 01:07:06,090
So don't invite situations where you might change something
所以不要制造你可能在一个地方更改某些东西，

1429
01:07:06,090 --> 01:07:07,650
in one place but not another.
而另一个地方不更改的情况。

1430
01:07:07,650 --> 01:07:10,030
Just only write it in one place total.
总共只写在一个地方。

1431
01:07:10,030 --> 01:07:12,280
So I like this idea of "or"-ing things together.
所以我喜欢将事物“或”在一起的这个想法。

1432
01:07:12,280 --> 01:07:14,580
So let me go ahead and delete what I just did.
所以让我继续删除我刚刚做的东西。

1433
01:07:14,580 --> 01:07:18,240
And just to be clear, too, while this is on the screen, when you highlight code
并且为了说明一下，当你在屏幕上高亮代码时，

1434
01:07:18,240 --> 01:07:21,630
in VS Code based on how we've configured it, these dots just show you
在 VS Code 中，根据我们的配置，这些点只显示了

1435
01:07:21,630 --> 01:07:25,230
how much I've indented because in C, stylistically, the convention
我缩进了多少，因为在 C 中，风格上，惯例

1436
01:07:25,230 --> 01:07:29,710
is generally to indent four spaces and maybe four more spaces.
通常是缩进四个空格，可能还会再缩进四个空格。

1437
01:07:29,710 --> 01:07:32,100
So those dots just help you count without having
所以这些点只是帮助你计数，而无需

1438
01:07:32,100 --> 01:07:34,560
to manually eyeball things yourself.
手动估算。

1439
01:07:34,560 --> 01:07:36,180
But let me delete those lines.
但是让我删除这些行。

1440
01:07:36,180 --> 01:07:38,250
Let me delete these lines.
让我删除这些行。

1441
01:07:38,250 --> 01:07:40,090
And this is going to look a little weird,
这看起来会有点奇怪，

1442
01:07:40,090 --> 01:07:43,590
but the way you can "or" two thoughts together, so to
但你可以将两个想法“或”在一起，

1443
01:07:43,590 --> 01:07:46,950
speak, like "or" them together, is you don't say "or,"
也就是说，将它们“或”在一起，你不用说“或”，

1444
01:07:46,950 --> 01:07:50,610
but you use two vertical bars, which syntactically
而是使用两个竖线，在语法上

1445
01:07:50,610 --> 01:07:53,070
means the English word "or."
意味着英文单词“或”。

1446
01:07:53,070 --> 01:07:55,650
And you can just ask the other question, if C equals,
然后你可以问另一个问题，如果C等于，

1447
01:07:55,650 --> 01:07:57,330
quote, unquote, capital 'Y.'
引号，引号，大写“Y”。

1448
01:07:57,330 --> 01:08:02,340
And then down here, I can say or C equals equals capital 'N.'
然后在这里，我可以说或者C等于等于大写“N”。

1449
01:08:02,340 --> 01:08:05,170
So it adds a little more code to each of those lines,
所以它在每一行都添加了一些额外的代码，

1450
01:08:05,170 --> 01:08:09,450
but it doesn't add redundancy, because I've not duplicated my printf.
但它没有添加冗余，因为我没有复制我的printf。

1451
01:08:09,450 --> 01:08:12,570
I've not added more curly braces unnecessarily.
我没有不必要地添加更多花括号。

1452
01:08:12,570 --> 01:08:17,040
Now as an aside, there's the opposite of "or", logically is the word "and."
顺便说一下，"或"的反义词，在逻辑上是“和”。

1453
01:08:17,040 --> 01:08:19,740
Just so you've seen it, I could do this.
为了让你看到它，我可以这样做。

1454
01:08:19,740 --> 01:08:24,430
"&&" in C is how you express that the thing on the left must be true
在 C 语言中，"&&" 表示左侧的东西必须为真

1455
01:08:24,430 --> 01:08:26,319
and the thing on the right must be true.
右侧的东西也必须为真。

1456
01:08:26,319 --> 01:08:30,045
But why would this make no sense in this context of line 8?
但这在第 8 行的语境中为什么没有意义呢？

1457
01:08:30,045 --> 01:08:31,920
STUDENT: It can't be uppercase and lowercase.
学生：它不能同时是大写和小写。

1458
01:08:31,920 --> 01:08:33,753
DAVID MALAN: Yeah, at least to my knowledge,
大卫·马兰：是的，至少据我所知，

1459
01:08:33,753 --> 01:08:36,300
a character can't be both lowercase and uppercase.
一个字符不能同时是小写和大写。

1460
01:08:36,300 --> 01:08:37,720
That just makes no logical sense.
这在逻辑上没有意义。

1461
01:08:37,720 --> 01:08:41,250
So indeed "or" is what we want in this case.
所以，在这种情况下，我们确实想要“或”。

1462
01:08:41,250 --> 01:08:43,286
Other questions?
还有其他问题吗？

1463
01:08:43,286 --> 01:08:49,245
STUDENT: In CS50.h, is there a way to directly compare strings [INAUDIBLE]??
学生：在 CS50.h 中，有没有办法直接比较字符串 [听不清]？

1464
01:08:49,245 --> 01:08:50,370
DAVID MALAN: Good question.
大卫·马兰：好问题。

1465
01:08:50,370 --> 01:08:53,310
Via CS50.h, is there a way to compare strings.
通过 CS50.h，有没有办法比较字符串。

1466
01:08:53,310 --> 01:08:54,270
Short answer, no.
简短的回答，没有。

1467
01:08:54,270 --> 01:08:56,100
But C is going to give us that capability.
但 C 会给我们这种能力。

1468
01:08:56,100 --> 01:08:59,439
And in fact, next week, among the things we'll do is actually compare strings.
事实上，下周，我们会做的事情之一就是比较字符串。

1469
01:08:59,439 --> 01:09:01,439
And if you've programmed before, you'll see in C
如果你之前做过编程，你会在 C 语言中看到

1470
01:09:01,439 --> 01:09:04,533
that it actually doesn't work the way that you might expect.
它实际上并不像你预期的那样工作。

1471
01:09:04,533 --> 01:09:06,450
But that's a problem, too, that we will solve.
但这也是一个我们会解决的问题。

1472
01:09:06,450 --> 01:09:08,040
But that transcends CS50.
但这超出了 CS50 的范围。

1473
01:09:08,040 --> 01:09:15,370
That's a question for C. Other questions on this kind of logic?
这是一个关于 C 语言的问题。关于这种逻辑还有其他问题吗？

1474
01:09:15,370 --> 01:09:18,790
Just to make this real then, anytime you click one of those EULAs
为了使这变得真实，当你点击任何一个 EULA

1475
01:09:18,790 --> 01:09:22,000
or terms and conditions on a form in a piece of software,
或者软件中表单上的条款和条件时，

1476
01:09:22,000 --> 01:09:24,850
odds are there is code as simple as this underneath the hood.
很可能在幕后有像这样的简单代码。

1477
01:09:24,850 --> 01:09:25,760
Maybe it's graphical.
也许它是图形化的。

1478
01:09:25,760 --> 01:09:27,760
Maybe it's checking for you clicking this button
也许它检查你是否点击了这个按钮

1479
01:09:27,760 --> 01:09:29,052
or maybe hitting the Enter key.
或者也许是按了回车键。

1480
01:09:29,052 --> 01:09:31,479
But underneath the hood is presumably some kind
但在幕后，可能有一些

1481
01:09:31,479 --> 01:09:35,740
of conditional checking for those kinds of outputs.
条件检查，用于这些类型的输出。

1482
01:09:35,740 --> 01:09:37,600
All right, how about another building block
好的，再来一个构建块

1483
01:09:37,600 --> 01:09:39,558
from last time, which we'll now translate to C,
来自上次，现在我们将它翻译成 C 语言，

1484
01:09:39,558 --> 01:09:41,720
namely loops, things that happen again and again?
即循环，一遍又一遍重复的事情？

1485
01:09:41,720 --> 01:09:43,640
And these, too, are everywhere in code.
这些代码在代码中无处不在。

1486
01:09:43,640 --> 01:09:47,710
So in Scratch, here's how we might meow three times, super simple.
所以在 Scratch 中，我们可以这样发出三次喵喵声，超级简单。

1487
01:09:47,710 --> 01:09:49,430
In C, it's going to look a little weird.
在C语言中，这看起来有点奇怪。

1488
01:09:49,430 --> 01:09:52,810
But you will get used to this over time if you've never programmed before.
但如果你以前从未编程过，随着时间的推移，你会习惯的。

1489
01:09:52,810 --> 01:09:55,540
It looks like a mouthful, OK.
看起来很长，好吧。

1490
01:09:55,540 --> 01:09:57,940
But let's tease it apart line by line.
但让我们逐行地分析它。

1491
01:09:57,940 --> 01:10:01,360
And you'll see that you won't have that reaction frequently because it's all
你会发现你不会经常有这种反应，因为这一切

1492
01:10:01,360 --> 01:10:03,500
going to start to look very similar to itself.
将开始看起来非常相似。

1493
01:10:03,500 --> 01:10:04,900
But what are we doing here?
但我们在这里做什么呢？

1494
01:10:04,900 --> 01:10:09,400
In C, you don't have the luxury of these cute and fun puzzle pieces
在C语言中，你没有这些可爱有趣的拼图块的奢侈

1495
01:10:09,400 --> 01:10:12,430
that just do the work for you, repeat three times.
它们只是为你完成工作，重复三次。

1496
01:10:12,430 --> 01:10:16,250
In fact, in C and programming in general, sometimes
事实上，在C语言和一般编程中，有时

1497
01:10:16,250 --> 01:10:18,870
the work is on us to actually figure out, OK,
工作需要我们自己弄清楚，好吧，

1498
01:10:18,870 --> 01:10:21,830
how can I use functions, variables, conditionals, and loops
我如何使用函数、变量、条件语句和循环

1499
01:10:21,830 --> 01:10:25,580
and implement some idea like repetition, like looping?
来实现一些像重复、循环这样的想法？

1500
01:10:25,580 --> 01:10:27,680
And in C, here's how this might work.
在C语言中，这可能就是这样工作的。

1501
01:10:27,680 --> 01:10:31,850
How can I go about doing something like printing "meow" three times?
我如何才能做到像打印三次"喵"这样的事情？

1502
01:10:31,850 --> 01:10:33,620
Well, I know about variables now.
好吧，我现在了解变量了。

1503
01:10:33,620 --> 01:10:35,270
We're about to see loops.
我们马上就要看到循环了。

1504
01:10:35,270 --> 01:10:39,110
And I've seen how I can update variables by plussing or minusing
而且我看到了如何通过加或减来更新变量

1505
01:10:39,110 --> 01:10:40,280
some value to them.
它们的值。

1506
01:10:40,280 --> 01:10:41,850
Let's combine those ideas.
让我们把这些想法结合起来。

1507
01:10:41,850 --> 01:10:46,375
So first, I'm doing what with this highlighted line in English?
那么首先，用英语来说，我对这行高亮显示的代码做了什么？

1508
01:10:46,375 --> 01:10:49,250
If a friend cared to ask you, like, 'what is this line of code doing'
如果一个朋友想问你，比如，“这行代码在做什么”

1509
01:10:49,250 --> 01:10:51,012
later today, what would you say?
今天晚些时候，你会怎么说？

1510
01:10:51,012 --> 01:10:54,250
STUDENT: It's creating a variable called "counter" and setting it equal to 3.
学生：它创建了一个名为“计数器”的变量，并将其设置为 3。

1511
01:10:54,250 --> 01:10:56,750
DAVID MALAN: Good, it's creating a variable called "counter"
大卫·马兰：很好，它创建了一个名为“计数器”的变量

1512
01:10:56,750 --> 01:10:58,400
and setting it equal to 3.
并将其设置为 3。

1513
01:10:58,400 --> 01:11:01,040
I'll use slightly new jargon.
我将使用稍微不同的术语。

1514
01:11:01,040 --> 01:11:04,157
I'm defining a variable, would be the term of our "called counter"
我正在定义一个变量，用我们的术语来说就是“叫做计数器”

1515
01:11:04,157 --> 01:11:05,240
and setting it equal to 3.
并将其设置为 3。

1516
01:11:05,240 --> 01:11:07,152
So I'll use my hand to represent the counter.
所以我将用我的手来代表计数器。

1517
01:11:07,152 --> 01:11:08,360
And that's all a variable is.
这就是变量的全部。

1518
01:11:08,360 --> 01:11:11,870
It's like storage in some case that I'm representing information, using
在某种情况下，它就像存储，我正在使用它来表示信息，

1519
01:11:11,870 --> 01:11:14,480
my hand in this case or the computer's memory here.
在这种情况下，我的手或这里计算机的内存。

1520
01:11:14,480 --> 01:11:17,575
Now what happens when using a loop in C?
现在，在C语言中使用循环时会发生什么？

1521
01:11:17,575 --> 01:11:20,700
There's different types of loops, one of which is called a for loop-- oop--
有不同类型的循环，其中一种叫做for循环-- oop--

1522
01:11:20,700 --> 01:11:22,790
one of which is called a while loop-- spoiler.
其中一种叫做while循环--剧透。

1523
01:11:22,790 --> 01:11:24,770
A while loop works like this.
while循环的工作原理如下。

1524
01:11:24,770 --> 01:11:28,910
Inside of parentheses is a Boolean expression just like inside
在括号内是一个布尔表达式，就像在

1525
01:11:28,910 --> 01:11:30,770
of a conditional that asks a question.
条件语句中那样，它会问一个问题。

1526
01:11:30,770 --> 01:11:33,330
But this time the question is going to determine,
但这一次，这个问题将决定，

1527
01:11:33,330 --> 01:11:37,080
do you keep going through the loop again and again and again?
你是否要一遍又一遍地循环下去？

1528
01:11:37,080 --> 01:11:38,810
So it's not a one-time thing potentially.
所以它可能不是一次性的事情。

1529
01:11:38,810 --> 01:11:41,210
It is checked again and again and again to decide
它会一遍又一遍地检查，以决定

1530
01:11:41,210 --> 01:11:44,810
when it is time to stop looping, to stop cycling.
何时停止循环，停止循环。

1531
01:11:44,810 --> 01:11:46,970
All right, so it's asking this question first.
好的，所以它首先问这个问题。

1532
01:11:46,970 --> 01:11:49,713
Is counter greater than 0?
计数器是否大于 0？

1533
01:11:49,713 --> 01:11:52,880
OK, obviously the answer is true because I'm still holding up three fingers.
好吧，很明显答案是正确的，因为我仍然举着三个手指。

1534
01:11:52,880 --> 01:11:54,140
So what happens?
那么会发生什么呢？

1535
01:11:54,140 --> 01:11:58,070
C goes inside of the curly braces per the indentation
C 按照缩进规则进入花括号内

1536
01:11:58,070 --> 01:12:02,340
and executes printf of "meow," which prints out a "meow" on the screen.
并执行 `printf` 打印 "meow"，这将在屏幕上显示一个 "meow"。

1537
01:12:02,340 --> 01:12:04,640
The next line of code executes, which, recall,
接下来执行代码行，请记住，

1538
01:12:04,640 --> 01:12:07,250
is the same as just subtracting 1 from counter.
它等同于从计数器中减去 1。

1539
01:12:07,250 --> 01:12:10,790
So I think I take down one finger, so I'm left with two.
所以我想我应该放下一个手指，只剩下两个手指了。

1540
01:12:10,790 --> 01:12:12,035
And what happens next?
接下来会发生什么？

1541
01:12:12,035 --> 01:12:13,910
Well, this you just kind of have to memorize.
这个你只能记住它了。

1542
01:12:13,910 --> 01:12:16,580
Once you get to the end of the inside of a loop,
当你到达循环内部的结尾时，

1543
01:12:16,580 --> 01:12:19,460
you go back to the beginning of a loop here
你会回到这里循环的开头

1544
01:12:19,460 --> 01:12:22,770
and ask the same question, the same Boolean expression.
并问相同的问题，相同的布尔表达式。

1545
01:12:22,770 --> 01:12:24,680
So is 2 greater than 0?
那么 2 是否大于 0？

1546
01:12:24,680 --> 01:12:25,700
OK, obviously so.
好的，显然是的。

1547
01:12:25,700 --> 01:12:27,890
So you go into it, you print a "meow."
所以你进入它，打印一个 "meow"。

1548
01:12:27,890 --> 01:12:31,400
You go into it and decrement counter further by one.
你进入它并将计数器再减 1。

1549
01:12:31,400 --> 01:12:33,470
So now my hand is holding up one.
现在我的手举起了一根手指。

1550
01:12:33,470 --> 01:12:35,900
Now we wrap back around to the Boolean expression.
现在我们回到布尔表达式。

1551
01:12:35,900 --> 01:12:37,790
Is 1 greater than 0?
1 是否大于 0？

1552
01:12:37,790 --> 01:12:38,480
Obviously.
显然。

1553
01:12:38,480 --> 01:12:40,340
We print out a third "meow."
我们打印了第三个 "meow"。

1554
01:12:40,340 --> 01:12:43,850
We then decrement counter again, and my hand goes to zero.
然后我们再次减去计数器，我的手变为零。

1555
01:12:43,850 --> 01:12:45,680
We go back around once more.
我们再次回到开头。

1556
01:12:45,680 --> 01:12:47,600
Is 0 greater than 0?
0 是否大于 0？

1557
01:12:47,600 --> 01:12:48,350
No.
不。

1558
01:12:48,350 --> 01:12:49,970
And now the program just terminates.
现在程序就终止了。

1559
01:12:49,970 --> 01:12:51,980
Or if there were more code here, it would just
或者如果有更多代码，它将

1560
01:12:51,980 --> 01:12:56,240
jump outside of the curly braces and keep going lower on the screen.
跳出花括号，继续向下执行。

1561
01:12:56,240 --> 01:12:57,810
So that's all that's happening.
这就是发生的所有事情。

1562
01:12:57,810 --> 01:13:00,740
And so this is what MIT has the luxury of doing with pictures.
因此，MIT 有条件用图片来进行演示。

1563
01:13:00,740 --> 01:13:03,440
But at MIT, someone probably essentially wrote
但 MIT 的某人可能编写了

1564
01:13:03,440 --> 01:13:09,030
code that looks like this to give us the illusion, the abstraction of this.
看起来像这样的代码来给我们这种错觉，这种抽象。

1565
01:13:09,030 --> 01:13:12,710
So what we're learning today is how they invented these puzzle pieces
所以我们今天学到的是他们是如何用这些低级管道来发明这些拼图的，

1566
01:13:12,710 --> 01:13:17,370
by just using lower-level plumbing, if you will, like this here.
如果你愿意，就如同这里一样。

1567
01:13:17,370 --> 01:13:17,870
Yeah?
对吧？

1568
01:13:17,870 --> 01:13:21,900
STUDENT: What would happen if you created the variable "counter"
学生：如果你在花括号内创建了变量 "counter"

1569
01:13:21,900 --> 01:13:23,330
inside of the curly braces?
会发生什么？

1570
01:13:23,330 --> 01:13:24,830
DAVID MALAN: A really good question.
大卫·马兰：一个很好的问题。

1571
01:13:24,830 --> 01:13:28,430
What would happen if you created the variable inside of the curly braces?
如果你在花括号内创建变量会发生什么？

1572
01:13:28,430 --> 01:13:30,650
Short answer, it just wouldn't work in C,
简而言之，它在 C 语言中无法工作，

1573
01:13:30,650 --> 01:13:33,560
because if I were to try with my slide here,
因为如果我用我的幻灯片在这里尝试，

1574
01:13:33,560 --> 01:13:39,650
for instance, to move this line of code here down inside of this, for instance,
例如，将这行代码移到下面，

1575
01:13:39,650 --> 01:13:44,700
now the very top line is trying to use counter before it even exists.
现在最上面的代码行试图使用 counter 变量，但它甚至还没有存在。

1576
01:13:44,700 --> 01:13:46,160
So C is very literal it.
所以 C 语言非常严格。

1577
01:13:46,160 --> 01:13:48,000
Reads top to bottom, left to right.
从上到下，从左到右读取。

1578
01:13:48,000 --> 01:13:50,870
And if it hasn't seen you define or create a variable yet,
如果它还没有看到你定义或创建变量，

1579
01:13:50,870 --> 01:13:55,550
you're going to get some scary error message on the screen instead.
你将得到一个吓人的错误信息。

1580
01:13:55,550 --> 01:13:59,010
All right, other questions on this here code?
好的，还有什么关于这段代码的问题吗？

1581
01:13:59,010 --> 01:13:59,510
No?
没有？

1582
01:13:59,510 --> 01:14:03,110
All right, so if we want to then maybe tighten this up a bit,
好的，如果我们想要稍微精简一下，

1583
01:14:03,110 --> 01:14:05,130
let me propose that we could do this instead.
我建议我们可以这样做。

1584
01:14:05,130 --> 01:14:07,850
So besides this version of the code, let me just
除了这个版本的代码，我只要

1585
01:14:07,850 --> 01:14:10,070
do something more canonical, more conventional.
做一些更规范，更常规的事情。

1586
01:14:10,070 --> 01:14:13,280
So you're totally fine with using a variable like counter.
所以你完全可以接受使用像 counter 这样的变量。

1587
01:14:13,280 --> 01:14:15,500
It's what Scratch uses by default. It's very verbose.
这是 Scratch 默认使用的。它非常冗长。

1588
01:14:15,500 --> 01:14:16,520
It does what it says.
它按字面意思执行。

1589
01:14:16,520 --> 01:14:18,410
Frankly, once you get comfy with programming,
坦白地说，一旦你习惯了编程，

1590
01:14:18,410 --> 01:14:20,480
like most typical programmers, whenever they
就像大多数典型的程序员一样，当他们

1591
01:14:20,480 --> 01:14:24,210
have a single integer in a program whose sole purpose in life is to count,
在一个程序中有一个唯一的整数，它的唯一作用就是计数，

1592
01:14:24,210 --> 01:14:27,810
they'll just use "i" for integer just like I used "c" for character.
他们会像我用 "c" 表示字符一样，用 "i" 表示整数。

1593
01:14:27,810 --> 01:14:29,820
When you have larger programs, you don't want
当你的程序更大时，你不想

1594
01:14:29,820 --> 01:14:35,070
to start using A and B and C and D and E and F and so forth for your variables
开始使用 A 和 B 和 C 和 D 和 E 和 F 等等作为你的变量

1595
01:14:35,070 --> 01:14:36,880
because nothing's going to make any sense.
因为什么都讲不通。

1596
01:14:36,880 --> 01:14:40,980
But when you're doing something super simple like counting with an integer,
但是当你做一些非常简单的事情，比如用整数计数时，

1597
01:14:40,980 --> 01:14:44,670
using a short-named variable is totally stylistically reasonable.
使用一个简短的变量名在风格上是完全合理的。

1598
01:14:44,670 --> 01:14:48,195
But I can tighten this up further, not just renaming counter to i.
但我可以进一步简化，不仅仅是将 counter 重命名为 i。

1599
01:14:48,195 --> 01:14:50,580
What else can I do, if you recall?
你还记得我可以做什么吗？

1600
01:14:50,580 --> 01:14:51,300
Over here?
这里？

1601
01:14:51,300 --> 01:14:52,800
STUDENT: [INAUDIBLE]
学生：[听不清]

1602
01:14:52,800 --> 01:14:53,550
DAVID MALAN: Sure.
大卫·马兰：当然。

1603
01:14:53,550 --> 01:14:55,150
STUDENT: A for loop?
学生：一个 for 循环？

1604
01:14:55,150 --> 01:14:56,400
DAVID MALAN: Oh, OK, for loop.
大卫·马兰：哦，好的，for 循环。

1605
01:14:56,400 --> 01:14:57,442
Yes, that was my spoiler.
是的，那是我的剧透。

1606
01:14:57,442 --> 01:15:00,300
But while in a while loop, I can tighten this up slightly more.
但在 while 循环中，我可以稍微简化一下。

1607
01:15:00,300 --> 01:15:01,460
Over here?
这里？

1608
01:15:01,460 --> 01:15:03,660
STUDENT: Instead of i equals i minus 1.
学生：不是 i 等于 i 减 1。

1609
01:15:03,660 --> 01:15:06,420
DAVID MALAN: Yeah, instead of i equals i minus 1,
大卫·马兰：是的，不是 i 等于 i 减 1，

1610
01:15:06,420 --> 01:15:08,310
I can actually tighten this up this way.
我可以这样进一步简化。

1611
01:15:08,310 --> 01:15:10,143
And we didn't see the minus before, but it's
之前我们没有看到减号，但是

1612
01:15:10,143 --> 01:15:15,120
the same idea-- i minus equals 1, or even more succinctly, i minus minus.
是同一个意思——i 减等于 1，或者更简洁地说，i 减减。

1613
01:15:15,120 --> 01:15:18,210
So when you get comfortable with programming, any of these approaches
所以当你习惯了编程，这些方法中的任何一个

1614
01:15:18,210 --> 01:15:19,230
are correct.
都是正确的。

1615
01:15:19,230 --> 01:15:21,875
This would be more conventional at this point.
在这一点上，这将更加传统。

1616
01:15:21,875 --> 01:15:24,000
So if you want to write code like most other people
所以如果你想像大多数人一样写代码

1617
01:15:24,000 --> 01:15:28,410
write code, adopt ultimately these kinds of conventions.
写代码，最终采用这些约定。

1618
01:15:28,410 --> 01:15:31,170
All right, so that just does the exact same thing, though.
好的，虽然它只是做完全相同的事情。

1619
01:15:31,170 --> 01:15:33,780
But let's now put this into practice.
但现在让我们把它付诸实践。

1620
01:15:33,780 --> 01:15:36,460
Let me go back to VS Code here.
让我回到这里的 VS Code。

1621
01:15:36,460 --> 01:15:40,590
Let me go ahead and clear my terminal and close agree.c from before.
让我先清除我的终端并关闭之前的 agree.c。

1622
01:15:40,590 --> 01:15:43,200
And let me go ahead and create a file called "meow."
让我创建一个名为 "meow" 的文件。

1623
01:15:43,200 --> 01:15:45,540
So code meow.c.
所以代码是 meow.c。

1624
01:15:45,540 --> 01:15:47,530
And let me do this the sort of wrong way.
让我用一种错误的方式来做。

1625
01:15:47,530 --> 01:15:49,320
Let me include stdio.h.
让我包含 stdio.h。

1626
01:15:49,320 --> 01:15:52,860
at the top, int main(void) thereafter.
在顶部，int main(void) 之后。

1627
01:15:52,860 --> 01:15:56,282
Inside of there, let me do printf "meow."
在里面，让我执行 printf "meow"。

1628
01:15:56,282 --> 01:15:57,240
And then you know what?
然后你知道吗？

1629
01:15:57,240 --> 01:15:58,020
I don't want to keep typing that.
我不想一直打这个。

1630
01:15:58,020 --> 01:16:00,460
Let me just go ahead and copy/paste two more times.
让我继续复制粘贴两次。

1631
01:16:00,460 --> 01:16:04,140
So I claim this is correct, make meow.
所以我声称这是正确的，make meow。

1632
01:16:04,140 --> 01:16:05,520
./meow, done.
./meow，完成。

1633
01:16:05,520 --> 01:16:07,980
I've got code that prints "meow" three times.
我有代码打印了三次 "meow"。

1634
01:16:07,980 --> 01:16:11,790
But this, again, should already rub you the wrong way.
但是这，再次强调，应该已经让你感觉不舒服了。

1635
01:16:11,790 --> 01:16:13,290
Why?
为什么？

1636
01:16:13,290 --> 01:16:14,040
Yeah?
是吗？

1637
01:16:14,040 --> 01:16:15,267
STUDENT: There's duplication.
学生：这里有重复。

1638
01:16:15,267 --> 01:16:16,350
DAVID MALAN: Because what?
大卫·马兰：因为什么？

1639
01:16:16,350 --> 01:16:17,030
STUDENT: There's duplication.
学生：这里有重复。

1640
01:16:17,030 --> 01:16:18,690
DAVID MALAN: Because I have duplication.
大卫·马兰：因为我这里有重复。

1641
01:16:18,690 --> 01:16:20,250
I mean, I literally copied and pasted it.
我是说，我实际上是复制粘贴的。

1642
01:16:20,250 --> 01:16:21,510
And that's kind of a good rule of thumb.
这算是个经验法则。

1643
01:16:21,510 --> 01:16:24,690
If you, in the future, start finding yourself copying and pasting code
如果你在将来发现自己开始复制粘贴代码

1644
01:16:24,690 --> 01:16:27,570
within the same program, you're probably doing something wrong.
在同一个程序里，你可能做错了什么。

1645
01:16:27,570 --> 01:16:30,100
There's a better way to design it even if it's correct.
即使它正确，也存在更好的设计方法。

1646
01:16:30,100 --> 01:16:32,513
So this is clearly a candidate for a loop.
所以这显然适合使用循环。

1647
01:16:32,513 --> 01:16:34,180
So let me go ahead and actually do that.
所以让我来实际做一下。

1648
01:16:34,180 --> 01:16:37,380
Let me just go ahead and remove all of this duplication.
让我把所有的重复部分去掉。

1649
01:16:37,380 --> 01:16:42,630
Let me give myself a variable called i, set it equal to 3.
我给自己一个名为 i 的变量，将其设置为 3。

1650
01:16:42,630 --> 01:16:44,580
Let me go ahead and give myself a while loop
我创建一个 while 循环

1651
01:16:44,580 --> 01:16:47,550
and check that i is greater than 0.
并检查 i 是否大于 0。

1652
01:16:47,550 --> 01:16:50,640
Inside of this loop, let me print out just "meow" once.
在这个循环内，我打印一次“meow”。

1653
01:16:50,640 --> 01:16:54,060
But I'll reuse that code again and again because here I'm
但我会重复使用这段代码，因为这里我

1654
01:16:54,060 --> 01:16:56,100
going to do i minus minus.
将执行 i 自减。

1655
01:16:56,100 --> 01:16:59,820
So that's the exact same code, the tight version of it that we saw a moment ago.
所以这是与之前看到的紧凑版本完全相同的代码。

1656
01:16:59,820 --> 01:17:04,900
Let me go ahead and "make meow" again, ./meow, and it still works.
让我再次运行“make meow”，./meow，它仍然有效。

1657
01:17:04,900 --> 01:17:06,270
Why is this version better?
为什么这个版本更好？

1658
01:17:06,270 --> 01:17:10,320
Because if you want the cat to meow five times, you change it in one place.
因为如果你想让猫叫五次，你只需要在一个地方修改。

1659
01:17:10,320 --> 01:17:15,630
If you want to make the cat a dog, you change the meow to a woof in one place,
如果你想把猫变成狗，你只需要在一个地方把“meow”改成“woof”，

1660
01:17:15,630 --> 01:17:18,210
albeit changing the file name eventually, but changing it
尽管最终要修改文件名，但修改

1661
01:17:18,210 --> 01:17:22,950
in one place, not worrying about changing it again and again and again.
只需要在一个地方修改，而不必担心要反复修改。

1662
01:17:22,950 --> 01:17:25,810
But there are other ways to do this.
但还有其他的方法可以实现。

1663
01:17:25,810 --> 01:17:30,300
For instance, let me propose that.
例如，我建议这样做。

1664
01:17:30,300 --> 01:17:34,540
And actually, let's see, let me propose that instead of just doing it this way,
实际上，让我们看看，我建议，不要只是以这种方式来做，

1665
01:17:34,540 --> 01:17:36,870
just to be clear--
为了更清晰——

1666
01:17:36,870 --> 01:17:39,660
yeah, let's go ahead and propose that instead of doing this,
是的，让我们建议，不要这样做，

1667
01:17:39,660 --> 01:17:41,670
we can actually count in different directions.
我们可以从不同的方向进行计数。

1668
01:17:41,670 --> 01:17:44,820
I'm kind of forcing this idea of starting at 3, going down to 0.
我有点强迫这种从 3 开始，一直减到 0 的想法。

1669
01:17:44,820 --> 01:17:47,610
But when normal humans in this room, if you ever count something,
但当房间里的人，如果你们曾经数过东西，

1670
01:17:47,610 --> 01:17:49,530
you probably do 1, 2, 3, and done.
你们可能就会 1、2、3，然后就完成了。

1671
01:17:49,530 --> 01:17:51,640
Like, that's how we would count in the real world.
就像，这就是我们在现实世界中计数的方式。

1672
01:17:51,640 --> 01:17:54,480
Well, we can do that, too, here code-wise.
嗯，我们也可以在代码里这样做。

1673
01:17:54,480 --> 01:17:56,670
We could initialize i to 1.
我们可以将 i 初始化为 1。

1674
01:17:56,670 --> 01:18:00,870
We could check that i is less than or equal to 3.
我们可以检查 i 是否小于或等于 3。

1675
01:18:00,870 --> 01:18:03,000
And we've not seen this syntax before, but there's
我们之前还没有见过这种语法，但是这里

1676
01:18:03,000 --> 01:18:06,060
no easy way on a typical keyboard to type a less than or equal sign
没有简单的方法可以在标准键盘上输入小于或等于符号

1677
01:18:06,060 --> 01:18:07,020
like in a math book.
就像数学书中的那样。

1678
01:18:07,020 --> 01:18:11,100
So we use two characters, a less-than sign and then an equal sign
所以我们使用两个字符，一个小于号，然后是一个等于号

1679
01:18:11,100 --> 01:18:11,940
back to back.
并排在一起。

1680
01:18:11,940 --> 01:18:13,620
And that means less than or equal to.
这意味着小于或等于。

1681
01:18:13,620 --> 01:18:18,030
And this is the same idea so long as I plus plus i inside of it
只要我在循环中将 i 加加，这个想法就一样

1682
01:18:18,030 --> 01:18:22,080
because that'll start at 1, then 2, but it won't stop then.
因为这会从 1 开始，然后是 2，但不会在 2 处停止。

1683
01:18:22,080 --> 01:18:25,440
It will go up to until i is equal to 3.
它会一直循环直到 i 等于 3。

1684
01:18:25,440 --> 01:18:29,500
Once i becomes 4, then that Boolean expression isn't going to be true.
一旦 i 变成 4，那么那个布尔表达式将不再为真。

1685
01:18:29,500 --> 01:18:32,430
So it stops after three "meow"s total.
所以它会在总共三次 "喵" 之后停止。

1686
01:18:32,430 --> 01:18:34,710
But there's another way, too, and this is probably
但是还有另一种方法，这可能是

1687
01:18:34,710 --> 01:18:37,560
the most conventional and the way you should do it
最传统的，也是你应该使用的方法

1688
01:18:37,560 --> 01:18:39,360
even though it's just as correct.
即使它同样正确。

1689
01:18:39,360 --> 01:18:43,030
In CS, if you've seen already last week, we almost always start counting from 0.
在 CS 中，如果你上周已经见过，我们几乎总是从 0 开始计数。

1690
01:18:43,030 --> 01:18:43,530
Why?
为什么？

1691
01:18:43,530 --> 01:18:46,380
Just because, so we're not wasting a pattern of bits.
仅仅因为这样，所以我们不会浪费一组比特位。

1692
01:18:46,380 --> 01:18:49,480
So generally when you start writing code that counts,
所以一般来说，当你开始编写计数代码时，

1693
01:18:49,480 --> 01:18:52,770
you should, quote, unquote, "almost always" start at 0,
你应该，引用一下，"几乎总是"从 0 开始，

1694
01:18:52,770 --> 01:18:56,070
count up to but not through the total you
计数到但不包括你所关注的总计，

1695
01:18:56,070 --> 01:18:59,200
care about so you don't get one extra by accident.
这样你就不会意外地多加一个。

1696
01:18:59,200 --> 01:19:01,710
And so this would be the most conventional way
所以这将是我们刚刚描述的最传统的方式

1697
01:19:01,710 --> 01:19:04,090
of doing what we just described.
去做我们刚刚描述的事情。

1698
01:19:04,090 --> 01:19:05,130
But they're all correct.
但它们都是正确的。

1699
01:19:05,130 --> 01:19:07,620
You can make an argument that all of them are equally good.
你可以争辩说，它们都同样好。

1700
01:19:07,620 --> 01:19:10,740
This is what most people, quote, unquote, "would do."
这是大多数人，引用一下，"会做的事情"。

1701
01:19:10,740 --> 01:19:15,255
OK, other questions on this here syntax or logic?
好的，关于这个语法或逻辑还有其他问题吗？

1702
01:19:18,440 --> 01:19:19,220
No?
没有？

1703
01:19:19,220 --> 01:19:21,530
All right, how about--
好的，那我们呢--

1704
01:19:21,530 --> 01:19:23,120
we got some cookies on the horizon.
我们已经有一些饼干在路上了。

1705
01:19:23,120 --> 01:19:26,240
But before we get there, let's meow a few more times, if we may.
但我们还没到那里之前，我们再喵几声，如果可以的话。

1706
01:19:26,240 --> 01:19:31,373
So how about doing a little bit differently versus the while loop.
那么，我们来尝试一下与 while 循环略微不同的方式。

1707
01:19:31,373 --> 01:19:32,790
And I think we heard it over here.
我想我们从这里听到了。

1708
01:19:32,790 --> 01:19:35,850
Turns out there's another type of loop altogether.
事实证明，还有另一种类型的循环。

1709
01:19:35,850 --> 01:19:37,850
So this one here.
所以，这个循环。

1710
01:19:37,850 --> 01:19:40,940
And this one, if you can believe it, is probably even more conventional
而这个，如果你能相信的话，可能比另一个方法更传统

1711
01:19:40,940 --> 01:19:41,940
than the other way.
。

1712
01:19:41,940 --> 01:19:43,940
And this is going to be thematic in programming.
这在编程中将是主题性的。

1713
01:19:43,940 --> 01:19:46,463
There's rarely one way, one right way to do things.
很少有一条正确的方式去做事情。

1714
01:19:46,463 --> 01:19:49,130
You're going to have bunches of different tools in your toolkit.
你的工具箱里会有很多不同的工具。

1715
01:19:49,130 --> 01:19:52,213
And your code might look different from someone else's because each of you
你的代码可能与其他人的代码看起来不同，因为你们每个人

1716
01:19:52,213 --> 01:19:54,470
tends to reach for a different tool in that toolkit.
倾向于从那个工具箱中选择不同的工具。

1717
01:19:54,470 --> 01:19:55,650
And here's another tool--
还有一个工具--

1718
01:19:55,650 --> 01:19:57,350
and as you proposed earlier--
就像你之前提议的那样--

1719
01:19:57,350 --> 01:19:58,370
a for loop.
一个 for 循环。

1720
01:19:58,370 --> 01:20:02,960
A for loop is just another way of achieving the exact same idea
一个 for 循环只是另一种实现完全相同想法的方式

1721
01:20:02,960 --> 01:20:04,800
using slightly different syntax.
使用稍微不同的语法。

1722
01:20:04,800 --> 01:20:08,360
And it's appealing, frankly in general, because it's a little more succinct.
坦率地说，它在一般情况下更吸引人，因为它更简洁。

1723
01:20:08,360 --> 01:20:11,540
It just saves some keystrokes even though you have to memorize
它只是节省了一些按键，即使你必须记住

1724
01:20:11,540 --> 01:20:12,980
the order in which it works.
它的工作顺序。

1725
01:20:12,980 --> 01:20:18,628
This code is identical to this code here functionally.
这段代码在功能上与这边的代码相同。

1726
01:20:18,628 --> 01:20:20,670
But aesthetically, of course, it looks different.
但在美学上，当然，它看起来不同。

1727
01:20:20,670 --> 01:20:21,630
How does it work?
它是如何工作的？

1728
01:20:21,630 --> 01:20:24,330
In a for loop, notice that in the parentheses
在一个 for 循环中，注意在括号中

1729
01:20:24,330 --> 01:20:26,790
is not a single simple Boolean expression.
不是一个简单的布尔表达式。

1730
01:20:26,790 --> 01:20:28,480
There are three things.
有三个部分。

1731
01:20:28,480 --> 01:20:33,060
One, before a semicolon, is a place to initialize a variable
第一部分，在分号之前，是初始化变量的地方

1732
01:20:33,060 --> 01:20:34,710
to do your counting typically.
通常用于计数。

1733
01:20:34,710 --> 01:20:36,617
Second is the Boolean expression.
第二个是布尔表达式。

1734
01:20:36,617 --> 01:20:37,450
So it's still there.
所以它还在那里。

1735
01:20:37,450 --> 01:20:40,242
It's just surrounded on the left and the right by two other things.
它只是被左右两边的其他两件事包围着。

1736
01:20:40,242 --> 01:20:41,610
Lastly is the update.
最后是更新。

1737
01:20:41,610 --> 01:20:45,917
What do you want to do at the end of every loop through this block of code?
在每次循环遍历这段代码块的最后，你想做什么？

1738
01:20:45,917 --> 01:20:48,250
So you can probably imagine where we're going with this.
所以你可能已经想到我们要往哪里走了。

1739
01:20:48,250 --> 01:20:49,300
How does this work?
这是如何工作的？

1740
01:20:49,300 --> 01:20:51,570
The first thing that happens is that a variable
首先发生的事情是，一个变量

1741
01:20:51,570 --> 01:20:54,360
called i is defined and initialized to the value of 0.
名为i被定义并初始化为0的值。

1742
01:20:54,360 --> 01:20:56,400
That happens once and only once.
这只会发生一次。

1743
01:20:56,400 --> 01:20:58,020
Then we check the condition.
然后我们检查条件。

1744
01:20:58,020 --> 01:21:00,570
Is 0 less than 3?
0是否小于3？

1745
01:21:00,570 --> 01:21:01,470
Obviously yes.
显然是的。

1746
01:21:01,470 --> 01:21:03,690
So now we don't do the plus plus yet.
所以现在我们还没有做加加操作。

1747
01:21:03,690 --> 01:21:04,810
We go into the loop.
我们进入循环。

1748
01:21:04,810 --> 01:21:07,352
And this is where the for loop's a little confusing at first.
这就是for循环一开始让人感到有点困惑的地方。

1749
01:21:07,352 --> 01:21:08,460
We print out "meow."
我们打印出"喵"。

1750
01:21:08,460 --> 01:21:09,540
Then what happens?
然后发生了什么？

1751
01:21:09,540 --> 01:21:10,480
There's no more lines.
没有更多行。

1752
01:21:10,480 --> 01:21:14,740
So we go back to the for loop, and we increment i at that point.
所以我们回到for循环，并在那一刻递增i。

1753
01:21:14,740 --> 01:21:16,200
So now i is 1.
所以现在i是1。

1754
01:21:16,200 --> 01:21:19,290
Then we check the condition. i is less than 3?
然后我们检查条件。i是否小于3？

1755
01:21:19,290 --> 01:21:20,640
Yes, because 1 is less than 3.
是的，因为1小于3。

1756
01:21:20,640 --> 01:21:23,040
We go back into the loop and print "meow."
我们回到循环并打印"喵"。

1757
01:21:23,040 --> 01:21:26,250
Now we go back to the plus plus, so i is now 2.
现在我们回到加加操作，所以i现在是2。

1758
01:21:26,250 --> 01:21:27,390
We check the condition.
我们检查条件。

1759
01:21:27,390 --> 01:21:28,890
2 is less than 3 obviously.
2显然小于3。

1760
01:21:28,890 --> 01:21:31,200
So we go back into the loop and print "meow."
所以我们回到循环并打印"喵"。

1761
01:21:31,200 --> 01:21:34,590
Then we do the increment. i is now 3.
然后我们进行递增。i现在是3。

1762
01:21:34,590 --> 01:21:37,380
Is 3 less than 3?
3是否小于3？

1763
01:21:37,380 --> 01:21:41,070
No, so we exit the loop, and we're done, or we keep
不，所以我们退出循环，我们完成了，或者我们继续

1764
01:21:41,070 --> 01:21:42,960
going down here if there's more code.
向下走，如果有更多代码。

1765
01:21:42,960 --> 01:21:45,240
But how many times did I say "meow?"
但我说了多少次"喵"？

1766
01:21:45,240 --> 01:21:52,280
1, 2, 3 total, when my hand was 0, 1, and 2.
一共1, 2, 3次，当我的手是0, 1, 2的时候。

1767
01:21:52,280 --> 01:21:54,410
Questions on this alternative syntax?
关于这种替代语法，有什么问题吗？

1768
01:21:54,410 --> 01:21:56,540
It takes some getting used to, but most people
它需要一些时间去习惯，但大多数人

1769
01:21:56,540 --> 01:21:58,910
would write loops using a for loop, I would say.
会使用for循环编写循环，我会说。

1770
01:21:58,910 --> 01:22:02,150
STUDENT: Could you now in the curly braces, use just one line of code?
学生：现在你能在花括号中只用一行代码吗？

1771
01:22:02,150 --> 01:22:02,870
DAVID MALAN: Yes.
大卫·马兰：是的。

1772
01:22:02,870 --> 01:22:05,540
If you really want to be cool and save syntax,
如果你真的想酷一点，节省语法，

1773
01:22:05,540 --> 01:22:11,390
yes, it is correct and common to eliminate the curly braces if you only
是的，如果你只有一行代码，去掉花括号是正确且常见的。

1774
01:22:11,390 --> 01:22:13,400
have one line of code therein.
其中有一行代码。

1775
01:22:13,400 --> 01:22:16,150
We in class will always put the curly braces there
我们在课堂上会始终在那里放置花括号

1776
01:22:16,150 --> 01:22:19,400
because this is the kind of thing where, if you get forgetful, you go in later
因为这是那种，如果你健忘，之后再进去

1777
01:22:19,400 --> 01:22:20,360
and add a second line.
添加第二行。

1778
01:22:20,360 --> 01:22:22,360
Like, darn it, like you forgot the curly braces,
就像，该死，就像你忘记了花括号，

1779
01:22:22,360 --> 01:22:24,150
things will not work as expected.
事情将不会按预期进行。

1780
01:22:24,150 --> 01:22:27,950
So in general, use the curly braces, but you do not have to strictly.
所以一般来说，使用花括号，但你并不一定要严格使用。

1781
01:22:27,950 --> 01:22:30,000
Other questions on 6?
关于6还有什么其他问题吗？

1782
01:22:30,000 --> 01:22:30,500
Yes?
是的？

1783
01:22:30,500 --> 01:22:33,665
STUDENT: [INAUDIBLE]
学生：[听不清]

1784
01:22:33,665 --> 01:22:35,290
DAVID MALAN: Can be used without, what?
大卫·马兰：可以不用什么？

1785
01:22:35,290 --> 01:22:37,168
STUDENT: [INAUDIBLE]
学生：[听不清]

1786
01:22:37,168 --> 01:22:39,460
DAVID MALAN: Oh, could you do it without the condition?
大卫·马兰：哦，你可以不用条件吗？

1787
01:22:39,460 --> 01:22:43,570
Yes, there are very fancy things you can do that we won't focus on today.
是的，你可以做很多很花哨的事情，但我们今天不会重点关注。

1788
01:22:43,570 --> 01:22:48,160
But yes, if you want to get rid of the condition, you could get rid of this
但是，是的，如果你想摆脱条件，你可以摆脱这个

1789
01:22:48,160 --> 01:22:48,820
here.
这里。

1790
01:22:48,820 --> 01:22:51,370
And that would actually make the loop go forever,
这实际上会导致循环永远运行，

1791
01:22:51,370 --> 01:22:53,290
which may be a good thing if it's like a clock
如果它像一个时钟一样，这可能是一件好事，

1792
01:22:53,290 --> 01:22:57,010
that you want to tick forever, but often not a good thing in code.
你希望它永远滴答作响，但通常在代码中不是一件好事。

1793
01:22:57,010 --> 01:22:58,600
Good question, though.
不过，好问题。

1794
01:22:58,600 --> 01:23:03,023
All right, so beyond that, let's just go ahead and put this into context.
好吧，除此之外，让我们继续把它放在上下文中。

1795
01:23:03,023 --> 01:23:04,940
Just in case it helps you to think about this,
以防它有助于你思考这个问题，

1796
01:23:04,940 --> 01:23:07,360
this is just another flow chart, if you're
这只是另一个流程图，如果你

1797
01:23:07,360 --> 01:23:09,520
more of a visual thinker, that represents
更喜欢视觉思考，它代表着

1798
01:23:09,520 --> 01:23:11,590
what it is this loop is now doing.
这个循环现在正在做什么。

1799
01:23:11,590 --> 01:23:14,630
Previously, all of our arrows went from top to bottom and stopped.
之前，我们所有的箭头都是从上到下，然后停止。

1800
01:23:14,630 --> 01:23:16,960
But now there's an arrow going back, up, and around
但现在有一个箭头向后、向上、环绕

1801
01:23:16,960 --> 01:23:18,740
because of this loop, this cycle.
因为这个循环，这个周期。

1802
01:23:18,740 --> 01:23:21,550
So when we start this program, we set i equal to 0.
所以当我们启动这个程序时，我们将 i 设置为 0。

1803
01:23:21,550 --> 01:23:23,920
We then check, is i less than 3?
然后我们检查，i 是否小于 3？

1804
01:23:23,920 --> 01:23:25,990
Obviously it is, so we print "meow."
显然是的，所以我们打印 "meow"。

1805
01:23:25,990 --> 01:23:29,860
We increment i, and then we go back to that same condition.
我们增加 i，然后返回到相同的条件。

1806
01:23:29,860 --> 01:23:31,930
We check the condition.
我们检查条件。

1807
01:23:31,930 --> 01:23:33,040
We print "meow."
我们打印 "meow"。

1808
01:23:33,040 --> 01:23:36,190
i plus plus, go back, go back.
i 加加，返回，返回。

1809
01:23:36,190 --> 01:23:40,440
Now, if i equals 3, 3 is not less than 3, so the answer is false.
现在，如果 i 等于 3，3 不小于 3，所以答案是 false。

1810
01:23:40,440 --> 01:23:41,248
And we stop.
然后我们停止。

1811
01:23:41,248 --> 01:23:43,040
So again, it's just another way of thinking
所以，再次强调，这只是另一种思考方式

1812
01:23:43,040 --> 01:23:46,460
about how the code in Scratch, how the code in C
关于 Scratch 中的代码，C 中的代码

1813
01:23:46,460 --> 01:23:50,660
might alternatively work in each of these contexts.
可能会在这两种情况下交替使用。

1814
01:23:50,660 --> 01:23:53,750
But there's this one other puzzle piece in Scratch,
但是 Scratch 中还有另一个拼图块，

1815
01:23:53,750 --> 01:23:55,700
recall, that's not the repeat block, which
回想一下，那不是 repeat 块，它

1816
01:23:55,700 --> 01:23:59,210
is for finite numbers of repetitions, but forever.
用于有限次数的重复，但永远是。

1817
01:23:59,210 --> 01:24:02,240
And in C, there is a way to do this, but it's a little weird looking.
在 C 中，有一种方法可以做到这一点，但这看起来有点奇怪。

1818
01:24:02,240 --> 01:24:03,860
There's no forever keyword.
没有 forever 关键字。

1819
01:24:03,860 --> 01:24:08,300
But you can use the while loop or, as you inferred,
但是，你可以使用 while 循环，或者像你推断的那样，

1820
01:24:08,300 --> 01:24:12,000
you can actually use the for loop without a condition in the middle.
你实际上可以使用 for 循环，中间没有条件。

1821
01:24:12,000 --> 01:24:14,720
So here, I can actually say this.
所以这里，我可以这样说。

1822
01:24:14,720 --> 01:24:17,690
If I want to do something forever, I want
如果我想永远做某事，我想

1823
01:24:17,690 --> 01:24:20,600
to make sure that the answer to my question, the Boolean expression,
确保我的问题的答案，布尔表达式，

1824
01:24:20,600 --> 01:24:23,570
is always true, always true, always true,
始终为真，始终为真，始终为真，

1825
01:24:23,570 --> 01:24:27,680
the easiest way to achieve that goal is just literally write "true" there
实现这个目标最简单的方法就是直接在那里写 "true"

1826
01:24:27,680 --> 01:24:29,670
because true is true no matter what.
因为 true 无论如何都是真的。

1827
01:24:29,670 --> 01:24:31,970
And it's a trick for making the loop forever
这是一个让循环永远运行的小技巧，

1828
01:24:31,970 --> 01:24:33,740
go around and around, as you might if you
一遍又一遍地循环，就像你可能想要做的那样，

1829
01:24:33,740 --> 01:24:36,740
want the cat to live forever and meow incessantly
让猫永远活着，不停地喵喵叫，

1830
01:24:36,740 --> 01:24:39,690
or if it is a clock that you want to tick forever or the like.
或者如果你想要一个永远滴答作响的时钟之类的。

1831
01:24:39,690 --> 01:24:44,720
So here, for instance, is how we might have a cat meow endlessly,
例如，这里是如何让猫不停地喵喵叫，

1832
01:24:44,720 --> 01:24:47,420
using this so-called for loop instead.
而是使用这种所谓的for循环。

1833
01:24:47,420 --> 01:24:50,330
But recall that in Scratch, we also had this ability
但回想一下，在Scratch中，我们也有这种能力

1834
01:24:50,330 --> 01:24:52,700
to create some of our own puzzle pieces.
创建我们自己的积木块。

1835
01:24:52,700 --> 01:24:55,700
And this, too, is something that we're going to be able to do here in C.
这也是我们将在C语言中可以做到的事情。

1836
01:24:55,700 --> 01:24:59,570
And let me propose that we do exactly that
我建议我们正是这样做

1837
01:24:59,570 --> 01:25:03,090
by introducing the C analog of this.
通过引入C语言的类似物。

1838
01:25:03,090 --> 01:25:08,023
So here, for instance, is, in Scratch, our definition
例如，这里是在Scratch中，我们的定义

1839
01:25:08,023 --> 01:25:10,190
of a function called meow whose sole purpose in life
一个名为“喵”的函数，它的唯一生命目标

1840
01:25:10,190 --> 01:25:12,740
was to just play the sound "meow" until it's done.
就是播放“喵”的声音，直到完成。

1841
01:25:12,740 --> 01:25:15,000
This is going to look a little weird at first.
乍一看，这会有点奇怪。

1842
01:25:15,000 --> 01:25:17,540
But you'll notice some similarities with main.
但你会注意到它与main函数有一些相似之处。

1843
01:25:17,540 --> 01:25:21,230
So recall this thing I keep typing with main, int main(void), int main(void).
所以回想一下我一直用main键入的这个东西，int main(void)，int main(void)。

1844
01:25:21,230 --> 01:25:25,080
That's just the "when green flag clicked" equivalent for today.
这只是今天“当绿旗点击时”的等效项。

1845
01:25:25,080 --> 01:25:28,940
But if you want to create your own puzzle piece or your own function in C,
但是如果你想在C语言中创建自己的积木块或自己的函数，

1846
01:25:28,940 --> 01:25:31,190
you, for now, literally do this.
现在，你就照着做就行了。

1847
01:25:31,190 --> 01:25:34,760
You say, void, the name of the function you want to create, and then
你说，void，你要创建的函数名，然后

1848
01:25:34,760 --> 01:25:35,870
void in parentheses.
括号里的void。

1849
01:25:35,870 --> 01:25:39,920
And technically what this means is that this function has no return value.
从技术上讲，这意味着这个函数没有返回值。

1850
01:25:39,920 --> 01:25:42,800
It doesn't hand you anything back like get_string or get_int.
它不会像get_string或get_int那样给你返回任何东西。

1851
01:25:42,800 --> 01:25:45,500
And the "void" in parentheses means it takes no inputs.
括号里的“void”表示它不接受任何输入。

1852
01:25:45,500 --> 01:25:46,437
It only meows.
它只会喵。

1853
01:25:46,437 --> 01:25:48,020
You don't have to tell it how to meow.
你不需要告诉它如何喵。

1854
01:25:48,020 --> 01:25:49,220
It's just going to meow.
它只会喵。

1855
01:25:49,220 --> 01:25:51,740
So no arguments, so to speak.
所以说，没有参数。

1856
01:25:51,740 --> 01:25:53,990
This literally just prints out "meow."
它实际上只是打印出“喵”。

1857
01:25:53,990 --> 01:25:56,990
But what this does for me is it abstracts away the idea of meowing.
但它对我来说，抽象掉了喵的思想。

1858
01:25:56,990 --> 01:25:59,360
I don't need to know how to use printf or that you're
我不需要知道如何使用printf，或者说你是否正在

1859
01:25:59,360 --> 01:26:01,370
using printf to make the cat meow.
使用printf让猫叫。

1860
01:26:01,370 --> 01:26:05,300
I now have a function in life called meow because in Scratch, recall,
我现在在生活中有一个名为“喵”的函数，因为回想一下，在Scratch中，

1861
01:26:05,300 --> 01:26:06,470
I used it like this.
我是这样使用的。

1862
01:26:06,470 --> 01:26:10,640
When the green flag is clicked, I could repeat three times this new custom
当绿旗被点击时，我可以重复三次这个新的自定义

1863
01:26:10,640 --> 01:26:11,450
puzzle piece.
积木块。

1864
01:26:11,450 --> 01:26:13,940
But in C, I could now do this.
但在C语言中，我现在可以这样做。

1865
01:26:13,940 --> 01:26:18,920
In my main program, I can use a for loop just like we saw a moment ago,
在我的主程序中，我可以使用一个for循环，就像我们刚才看到的那样，

1866
01:26:18,920 --> 01:26:20,480
copy/pasted from earlier.
从之前复制粘贴过来的。

1867
01:26:20,480 --> 01:26:25,310
But now I can call my own C function called meow.
但现在我可以调用我自己的C语言函数，名为“喵”。

1868
01:26:25,310 --> 01:26:28,040
And let me go ahead now and do this.
现在，让我继续这样做。

1869
01:26:28,040 --> 01:26:33,560
If I go over to my C code here, back in VS Code, let me go ahead
如果我回到这里的C代码，回到VS Code，让我继续

1870
01:26:33,560 --> 01:26:35,480
and delete everything inside main.
删除main函数内部的所有内容。

1871
01:26:35,480 --> 01:26:42,260
Let me go ahead and do for int i equals 0, i is less than 3, i++.
让我继续这样做，对于int i等于0，i小于3，i++。

1872
01:26:42,260 --> 01:26:45,980
Inside of my curly braces, let me go ahead and say "meow."
在我的花括号内，让我继续说“喵”。

1873
01:26:45,980 --> 01:26:49,460
But I now need this meow function to exist because if I
但我现在需要这个“喵”函数存在，因为如果我

1874
01:26:49,460 --> 01:26:52,280
do "make meow" again, notice error.
再次执行“make meow”，注意错误。

1875
01:26:52,280 --> 01:26:56,660
"Implicit declaration of function meow is invalid in C99"--
“函数“喵”的隐式声明在C99中无效”--

1876
01:26:56,660 --> 01:26:59,970
the 1999 version of C. What does that mean?
C语言的1999版本。这是什么意思？

1877
01:26:59,970 --> 01:27:02,510
Well, it doesn't know what the meow function is.
好吧，它不知道“喵”函数是什么。

1878
01:27:02,510 --> 01:27:04,820
And the meow function is not in CS50.h.
“喵”函数不在CS50.h中。

1879
01:27:04,820 --> 01:27:06,710
It's not in stdio.h.
它也不在stdio.h中。

1880
01:27:06,710 --> 01:27:08,070
I have to create it.
我必须创建它。

1881
01:27:08,070 --> 01:27:12,020
So let me type out or really copy/paste what I had on the screen a moment ago--
所以，让我打出来，或者直接复制粘贴我之前在屏幕上显示的内容。

1882
01:27:12,020 --> 01:27:13,370
"void meow meow"--
“空喵喵”

1883
01:27:13,370 --> 01:27:20,210
[CHUCKLES] "void meow(void)" printf, quote, unquote, "meow," close quote,
[笑声] “空喵（空）”  printf，引号，引号， “喵，”  引号，

1884
01:27:20,210 --> 01:27:21,440
semicolon.
分号。

1885
01:27:21,440 --> 01:27:24,350
But here, too, let me scooch this down a bit
但是这里，我也要稍微向下移动一下

1886
01:27:24,350 --> 01:27:26,010
so you can see all the code at once.
这样你就可以一次性看到所有的代码了。

1887
01:27:26,010 --> 01:27:27,620
Let me now do make meow.
现在让我来做 make 喵。

1888
01:27:27,620 --> 01:27:30,860
And unfortunately, I still have an error.
不幸的是，我仍然有一个错误。

1889
01:27:30,860 --> 01:27:36,680
If I scroll up, still on line 7 of meow.c,
如果我向上滚动，仍然在 meow.c 的第 7 行，

1890
01:27:36,680 --> 01:27:42,300
my compiler thinks that meow is invalid, that it does not exist.
我的编译器认为 meow 是无效的，它不存在。

1891
01:27:42,300 --> 01:27:44,150
This too is a common mistake.
这也是一个常见的错误。

1892
01:27:44,150 --> 01:27:50,240
And as simple as this code might be in spirit, where did I screw up?
尽管这段代码在精神上可能很简单，但我究竟错在哪里了？

1893
01:27:50,240 --> 01:27:51,655
Yeah, in the middle.
没错，在中间。

1894
01:27:51,655 --> 01:27:54,530
STUDENT: You need to define the function like above where you use it.
学生：你需要像上面那样在使用函数的地方定义它。

1895
01:27:54,530 --> 01:27:57,238
DAVID MALAN: Yeah, I need to define the function before I use it.
大卫·马兰：没错，我需要在使用函数之前定义它。

1896
01:27:57,238 --> 01:27:59,120
So again, C is going to take you literally.
所以，再一次，C 会严格地按照你的字面意思来执行。

1897
01:27:59,120 --> 01:28:03,230
If you try to call meow on line 7, you better not define it on line 11.
如果你尝试在第 7 行调用 meow，你最好不要在第 11 行定义它。

1898
01:28:03,230 --> 01:28:05,120
You better define it higher up.
你最好在上面定义它。

1899
01:28:05,120 --> 01:28:09,290
So the simplest fix is going to be just to do this.
所以最简单的解决方法就是这样做。

1900
01:28:09,290 --> 01:28:10,610
Let me clear my terminal.
让我清除我的终端。

1901
01:28:10,610 --> 01:28:13,970
Let me highlight and just delete the meow function.
让我突出显示并删除 meow 函数。

1902
01:28:13,970 --> 01:28:15,770
And let me just paste it up here.
然后我把它粘贴到这里。

1903
01:28:15,770 --> 01:28:18,000
And this will actually solve the problem.
这样就能解决问题了。

1904
01:28:18,000 --> 01:28:19,950
Make meow now works.
现在 make 喵可以运行了。

1905
01:28:19,950 --> 01:28:22,550
And if I do ./meow, that, too, works.
如果我运行 ./meow，它也能运行。

1906
01:28:22,550 --> 01:28:26,090
But this isn't really the best solution because if your solution is constantly,
但这不是最好的解决方案，因为如果你的解决方案总是

1907
01:28:26,090 --> 01:28:28,798
oh, well, just put it up there, put it up there, put it up there,
哦，好吧，把它放在那里，把它放在那里，把它放在那里，

1908
01:28:28,798 --> 01:28:30,530
I bet we could contrive a situation where
我敢肯定我们可以设计一种情况，

1909
01:28:30,530 --> 01:28:32,450
one function needs to be above the other,
一个函数需要在另一个函数之上，

1910
01:28:32,450 --> 01:28:33,620
but it needs to be above the other.
但它必须在另一个函数之上。

1911
01:28:33,620 --> 01:28:35,495
And that's just not going to work in general.
通常情况下，这是行不通的。

1912
01:28:35,495 --> 01:28:40,110
And more importantly, it just pushes main lower and lower and lower
更重要的是，它会不断地将 main 向下移动

1913
01:28:40,110 --> 01:28:40,712
in your file.
在你的文件中。

1914
01:28:40,712 --> 01:28:42,420
But the whole point of your main function
但是你的 main 函数的重点是

1915
01:28:42,420 --> 01:28:43,890
is like, that's the entry point.
它就像一个入口点。

1916
01:28:43,890 --> 01:28:46,540
That is what happens when the green flag is clicked.
它就像绿色的旗帜被点击时发生的事情。

1917
01:28:46,540 --> 01:28:50,340
And so just in terms of user conventions, it's just useful for main
所以，从用户的角度来看，让 main 始终位于文件的顶部非常有用，因为这样你就能快速找到它。

1918
01:28:50,340 --> 01:28:53,400
to always be at the top of a file because then you can find it fast.
你的朋友，你的 TA 可以快速找到它，如果它位于文件的顶部。

1919
01:28:53,400 --> 01:28:56,910
Your friends can, your TFs can find it quickly if it's at the top.
你的朋友，你的 TA 可以快速找到它，如果它位于文件的顶部。

1920
01:28:56,910 --> 01:29:01,290
So the other solution here would be to leave meow at the bottom
所以另一个解决方法是将 meow 放在底部

1921
01:29:01,290 --> 01:29:02,880
and leave main at the top.
并将 main 放在顶部。

1922
01:29:02,880 --> 01:29:07,080
But this is the only time, if I may, that copy/paste is OK.
但是，如果可以的话，这将是唯一一次可以使用复制粘贴的地方。

1923
01:29:07,080 --> 01:29:11,560
What I've highlighted here in line 11 is what's called the function's prototype.
我在第 11 行突出显示的内容被称为函数原型。

1924
01:29:11,560 --> 01:29:16,860
It is enough information to give you the return type, the name of the function,
它包含了足够的信息，可以告诉你函数的返回类型、函数名称

1925
01:29:16,860 --> 01:29:18,630
and the return value--
以及返回值

1926
01:29:18,630 --> 01:29:20,820
and any arguments.
以及任何参数。

1927
01:29:20,820 --> 01:29:25,590
And so if you just copy/paste that one line and end it with a semicolon
所以，如果你只复制粘贴这一行并以分号结尾

1928
01:29:25,590 --> 01:29:29,850
up there, that's enough of a hint to the compiler
就在上面，这对编译器来说已经足够提示了

1929
01:29:29,850 --> 01:29:32,370
that, OK, it doesn't exist yet, but it will.
好的，它现在还不存在，但它会存在的。

1930
01:29:32,370 --> 01:29:34,650
And it will look like that.
它看起来会是这样的。

1931
01:29:34,650 --> 01:29:37,110
That's the only time it's OK to copy/paste
这是唯一一次可以进行复制粘贴的时候

1932
01:29:37,110 --> 01:29:39,630
the very first line of a function you've written
你写过的函数的第一行

1933
01:29:39,630 --> 01:29:42,000
to the top of the file with a semicolon so
到文件的顶部，并在后面添加一个分号，这样

1934
01:29:42,000 --> 01:29:45,270
that you can make the compiler happy.
就可以让编译器开心了。

1935
01:29:45,270 --> 01:29:51,390
So if I do make meow now, still no errors. ./meow, and it now works.
所以如果我现在做 make meow，仍然没有错误。./meow，现在它就可以工作了。

1936
01:29:51,390 --> 01:29:55,800
But let me add one final feature, coming back to Scratch here.
但让我在这里回到 Scratch，添加最后一个功能。

1937
01:29:55,800 --> 01:29:57,480
And then it's time for a snack.
然后该吃点心了。

1938
01:29:57,480 --> 01:30:01,920
So here, recall, was sort of the last fancy thing we did in Scratch, where
所以，你还记得吗？这是我们在 Scratch 中做的最后一个比较复杂的事情，就是

1939
01:30:01,920 --> 01:30:04,380
we created not only our own custom puzzle piece,
我们不仅创建了自己的自定义拼图块，

1940
01:30:04,380 --> 01:30:08,370
but it took an input so that we didn't need to keep using the loop ourself.
而且它还可以接收输入，这样我们就不用一直使用循环了。

1941
01:30:08,370 --> 01:30:11,250
We could just let the meow function be told how many times
我们只需要告诉 meow 函数，

1942
01:30:11,250 --> 01:30:12,570
do you want the cat to meow.
你想让猫叫几声。

1943
01:30:12,570 --> 01:30:16,980
So in C, we don't have to make that many changes except this.
所以在 C 语言中，除了这里以外，我们不需要做太多更改。

1944
01:30:16,980 --> 01:30:21,670
We change the prototype to take an argument inside of parentheses.
我们将原型更改为在括号中接收一个参数。

1945
01:30:21,670 --> 01:30:23,190
And this is the syntax for that.
这就是它的语法。

1946
01:30:23,190 --> 01:30:26,850
If you want your own function in C to take one or more arguments,
如果你想让你的 C 语言函数接收一个或多个参数，

1947
01:30:26,850 --> 01:30:30,330
you give the arguments a name, n, or whatever you want to call it.
你需要给参数起一个名字，比如 n，或者你想要叫什么都行。

1948
01:30:30,330 --> 01:30:33,060
But you have to tell C what the type of that input is.
但是你必须告诉 C，这个输入的类型是什么。

1949
01:30:33,060 --> 01:30:34,650
So it's an int n.
所以它是一个 int 类型的 n。

1950
01:30:34,650 --> 01:30:36,240
So it knows it's a number.
这样它就知道这是一个数字。

1951
01:30:36,240 --> 01:30:38,290
And then you can just use n in your program.
然后你就可以在你的程序中使用 n 了。

1952
01:30:38,290 --> 01:30:41,460
So instead of hard coding, typing manually the number 3,
所以，与其硬编码，手动输入数字 3，

1953
01:30:41,460 --> 01:30:43,090
I'm just using n here.
我在这里使用的是 n。

1954
01:30:43,090 --> 01:30:46,590
So this is equivalent to what I did with Scratch, by just dragging and dropping
所以这相当于我在 Scratch 中，通过拖放

1955
01:30:46,590 --> 01:30:48,720
the n variable there.
n 变量来实现的。

1956
01:30:48,720 --> 01:30:51,240
And then "meow" will get printed that many times.
然后 "meow" 会被打印那么多次。

1957
01:30:51,240 --> 01:30:54,780
If I want to then use this-- notice, this is the last version of the cat
如果我想使用它，注意，这是我们上周做的猫的最后一个版本，

1958
01:30:54,780 --> 01:30:58,330
that we did last week-- you just say "meow" this many times.
你只需要说 "meow" 那么多遍。

1959
01:30:58,330 --> 01:31:03,060
So in C, this is where now the code gets very succinct
所以在 C 语言中，这里就是代码变得非常简洁的地方

1960
01:31:03,060 --> 01:31:06,653
because all the main part of the program does is meow three times.
因为程序的主要部分就是让猫叫三声。

1961
01:31:06,653 --> 01:31:08,070
So this, again, is an abstraction.
所以这又是一个抽象。

1962
01:31:08,070 --> 01:31:11,730
I don't need to know, care, or remember how meow is implemented.
我不需要知道、关心或记住 meow 是如何实现的。

1963
01:31:11,730 --> 01:31:16,230
I just need to know what its return value, its name, and any arguments
我只需要知道它的返回值、它的名字，以及它的任何参数

1964
01:31:16,230 --> 01:31:17,560
thereto are.
是什么。

1965
01:31:17,560 --> 01:31:21,600
So if I make this change, I think we can get the cat
所以如果我做这个更改，我认为我们可以让猫

1966
01:31:21,600 --> 01:31:23,490
to meow any number of times.
叫任意多次。

1967
01:31:23,490 --> 01:31:25,920
Let me go back over to my C code here.
让我回到我的 C 代码这里。

1968
01:31:25,920 --> 01:31:31,710
Let me go back into the file and change "void" here to be int n,
让我回到文件，将这里的 "void" 更改为 int n，

1969
01:31:31,710 --> 01:31:33,390
where n just means number.
其中 n 代表数字。

1970
01:31:33,390 --> 01:31:36,960
I could use i, but n tends to be a quantity instead of a counter.
我也可以使用 i，但 n 往往表示一个数量，而不是一个计数器。

1971
01:31:36,960 --> 01:31:40,320
I then, inside of this function, am going to do a for loop--
然后，在这个函数内部，我将执行一个 for 循环，

1972
01:31:40,320 --> 01:31:43,620
for int i get 0; i less than n--
for int i 为 0；i 小于 n，

1973
01:31:43,620 --> 01:31:46,110
instead of 3-- i++.
而不是 3，i++。

1974
01:31:46,110 --> 01:31:49,050
And then inside of here, I'll paste that "meow" again.
然后在这里，我将再次粘贴 "meow"。

1975
01:31:49,050 --> 01:31:52,950
I need to change my prototype to be identical, so another copy/paste,
我需要将我的原型更改为相同的，所以再复制粘贴一次，

1976
01:31:52,950 --> 01:31:54,240
or just manually edit it.
或者手动编辑它。

1977
01:31:54,240 --> 01:31:56,940
But now notice what's cool about main, is
但现在注意一下main的妙处在于

1978
01:31:56,940 --> 01:32:00,090
that now I can meow maybe three times.
现在我可以喵叫三次。

1979
01:32:00,090 --> 01:32:04,260
Make meow, Enter, ./meow.
输入 meow，回车， ./meow。

1980
01:32:04,260 --> 01:32:09,870
OK, or if I really want to be cool, I can change this to 30,000 times.
好吧，如果我真想酷炫一下，可以把这改成30000次。

1981
01:32:09,870 --> 01:32:11,940
Go back here, make meow.
回到这里，输入 meow。

1982
01:32:11,940 --> 01:32:16,500
Increase the size of my terminal window for a dramatic pre-break flourish.
为了一个戏剧性的暂停效果，扩大一下我的终端窗口。

1983
01:32:16,500 --> 01:32:18,390
And there are 30-- that was a fast cat.
然后就有30——那只猫真快。

1984
01:32:18,390 --> 01:32:19,950
There are 30,000 meows.
这里有30000声喵叫。

1985
01:32:19,950 --> 01:32:22,990
I think now let's go ahead and take-- that's a lot-- a 10-minute break.
我觉得现在可以休息一下——这太长了——休息十分钟。

1986
01:32:22,990 --> 01:32:23,940
We'll see you in 10.
十分钟后再见。

1987
01:32:23,940 --> 01:32:26,400
Cookies are now served outside.
现在外面有饼干。

1988
01:32:26,400 --> 01:32:29,490
All right, so we are back.
好了，我们回来了。

1989
01:32:29,490 --> 01:32:31,920
And I realize this has been a lot so far, right?
我意识到到目前为止已经讲了很多东西了，对吧？

1990
01:32:31,920 --> 01:32:33,630
So there's a lot of new syntax.
所以有很多新的语法。

1991
01:32:33,630 --> 01:32:36,100
There's a lot of translation of Scratch over to C.
有很多从Scratch到C语言的转换。

1992
01:32:36,100 --> 01:32:39,790
But among the goals of having spent last week in Scratch
但是我们上周花时间学习Scratch的目标之一

1993
01:32:39,790 --> 01:32:44,830
and having spent problems at 0 in Scratch is that none of today's ideas
以及在Scratch中花费大量时间解决问题，就是为了让今天的这些想法

1994
01:32:44,830 --> 01:32:46,430
are really all that new.
并不真正算得上是新的东西。

1995
01:32:46,430 --> 01:32:49,780
It's just a lot of syntax that will get more comfortable and more
只是有很多语法，随着时间的推移，你就会越来越熟悉，越来越

1996
01:32:49,780 --> 01:32:52,480
in your muscle memory as time passes.
刻在你的肌肉记忆里。

1997
01:32:52,480 --> 01:32:56,170
Up until now, though, we've focused largely on these side effects,
不过，到目前为止，我们主要关注的是这些副作用，

1998
01:32:56,170 --> 01:32:58,100
like things happening on the screen.
比如屏幕上发生的事情。

1999
01:32:58,100 --> 01:33:01,450
And that was akin to the speech bubble appearing in the world of Scratch.
这就像在Scratch的世界里，出现了一个对话框。

2000
01:33:01,450 --> 01:33:05,170
But let's focus for just a bit-- before we then explore things
但我们先集中精力——在我们探索一些

2001
01:33:05,170 --> 01:33:07,930
we can't do very well in code-- on return
在代码中无法很好地完成的事情——关于返回值

2002
01:33:07,930 --> 01:33:10,870
values instead in C. We've seen them already.
在C语言中。我们已经见过它们了。

2003
01:33:10,870 --> 01:33:12,880
Like, get_string returns a value.
比如，get_string 函数会返回一个值。

2004
01:33:12,880 --> 01:33:16,400
Get_int returns a value, a string and an int respectively.
Get_int 函数会返回一个值，分别是字符串和整数。

2005
01:33:16,400 --> 01:33:19,000
But what if we want to make our own functions that don't just
但如果我们想创建自己的函数，它们不仅仅

2006
01:33:19,000 --> 01:33:21,910
meow and visually have this side effect of meowing on the screen
喵叫，并在视觉上产生在屏幕上喵叫的副作用

2007
01:33:21,910 --> 01:33:24,310
but actually hand us back some value?
而是真正地给我们返回一些值呢？

2008
01:33:24,310 --> 01:33:26,950
Well, I bet we can do this in C, as well.
嗯，我敢肯定我们也能在C语言中做到这一点。

2009
01:33:26,950 --> 01:33:30,488
Well, let me propose that to go that route--
嗯，我建议我们走这条路——

2010
01:33:30,488 --> 01:33:31,780
let me go back to VS Code here.
让我回到这里的VS Code。

2011
01:33:31,780 --> 01:33:33,940
And let's make our very simple calculator
让我们制作一个非常简单的计算器

2012
01:33:33,940 --> 01:33:35,668
that just adds some numbers together.
它只把一些数字加起来。

2013
01:33:35,668 --> 01:33:37,460
But the same calculator, we'll soon see, is
但我们很快就会发现，同样的计算器

2014
01:33:37,460 --> 01:33:40,790
going to get us into trouble if you don't understand what the computer is
如果不懂得计算机在

2015
01:33:40,790 --> 01:33:42,770
doing underneath the hood.
幕后做的事情，就会让我们陷入困境。

2016
01:33:42,770 --> 01:33:47,690
Let me go ahead and run code of, say, calculator.c.
让我运行一下代码，比如calculator.c。

2017
01:33:47,690 --> 01:33:49,910
And in here, let me go ahead and give myself
这里，让我给自己

2018
01:33:49,910 --> 01:33:56,660
access to the CS50 library with CS50.h, the stdio.h library with stdio.h,
访问 CS50 库，使用 CS50.h，访问 stdio.h 库，使用 stdio.h，

2019
01:33:56,660 --> 01:34:01,370
int main(void), which, again, we'll just take for granted today that we have
int main(void)，再次强调，我们今天就假设我们拥有它

2020
01:34:01,370 --> 01:34:03,290
to include atop any of these programs.
来包含在这些程序的顶部。

2021
01:34:03,290 --> 01:34:06,420
And let's just add two numbers together-- super simple calculator.
然后，我们把两个数字加起来——超级简单的计算器。

2022
01:34:06,420 --> 01:34:08,420
So it gives me a variable called x.
所以它给我一个叫做 x 的变量。

2023
01:34:08,420 --> 01:34:10,640
Assign it the return value of get_int.
给它赋值为 get_int 函数的返回值。

2024
01:34:10,640 --> 01:34:13,520
And I'll ask the user to give us x.
然后我让用户输入 x。

2025
01:34:13,520 --> 01:34:15,530
Give me another variable called y.
给我一个叫做 y 的变量。

2026
01:34:15,530 --> 01:34:18,470
Assign it the return value of get_int again.
再次为它赋值为 get_int 函数的返回值。

2027
01:34:18,470 --> 01:34:20,900
But this time, ask the user for y.
但这次，要向用户询问 y 的值。

2028
01:34:20,900 --> 01:34:26,600
And then, lastly, let's just go ahead and print out the value of x plus y.
最后，让我们直接打印出 x 加 y 的值。

2029
01:34:26,600 --> 01:34:29,540
But I don't think I can get away with something
但我认为我不能就这样做

2030
01:34:29,540 --> 01:34:33,230
like this, x plus y semicolon, because if I
像这样，x 加 y，分号，因为如果我

2031
01:34:33,230 --> 01:34:36,080
do this, based on what we've seen before,
这样做，根据我们之前看到的，

2032
01:34:36,080 --> 01:34:37,790
what's actually going to get printed out?
实际上会打印出什么？

2033
01:34:37,790 --> 01:34:38,390
STUDENT: x plus y.
学生：x 加 y。

2034
01:34:38,390 --> 01:34:40,250
DAVID MALAN: Right, literally like x plus y.
大卫·马兰：没错，就是字面意思 x 加 y。

2035
01:34:40,250 --> 01:34:43,700
So I think this is where I need the F in "printf" for formatting.
所以，我认为这就是我需要在 “printf” 中使用 F 进行格式化的原因。

2036
01:34:43,700 --> 01:34:48,470
What I think I really want to do is print out the value of some placeholder
我认为我真正想做的是打印一些占位符的值

2037
01:34:48,470 --> 01:34:51,140
because, what do I want to substitute for percent i
因为，我想用百分号 i 代替什么

2038
01:34:51,140 --> 01:34:55,280
maybe as a second argument to printf intuitively?
也许作为 printf 的第二个参数更直观？

2039
01:34:55,280 --> 01:34:56,990
Maybe just x plus y.
也许就是 x 加 y。

2040
01:34:56,990 --> 01:34:59,630
So indeed, I can get away with this because it turns out in C,
因此，我确实可以这样做，因为事实证明在 C 语言中，

2041
01:34:59,630 --> 01:35:03,290
there's a bunch of arithmetic operators, all of the ones that you might expect,
有很多算术运算符，所有你可能期望的运算符，

2042
01:35:03,290 --> 01:35:07,010
including addition, subtraction, multiplication, division,
包括加法、减法、乘法、除法，

2043
01:35:07,010 --> 01:35:09,570
and even this one, the so-called modulo operator,
甚至还有这个，所谓的模运算符，

2044
01:35:09,570 --> 01:35:12,470
which generally gives us the ability to calculate a remainder when
它通常使我们能够计算出当

2045
01:35:12,470 --> 01:35:13,977
you divide one number by another.
你用一个数除另一个数时得到的余数。

2046
01:35:13,977 --> 01:35:15,560
But I'll keep it simple with addition.
但我会用加法来保持简单。

2047
01:35:15,560 --> 01:35:20,480
And indeed, with printf, if I want to print out the value of x plus y,
实际上，如果我想使用 printf 打印出 x 加 y 的值，

2048
01:35:20,480 --> 01:35:21,480
I can do that.
我可以做到。

2049
01:35:21,480 --> 01:35:25,940
But I have to tell printf what kind of value to expect, an integer,
但我必须告诉 printf 预期得到什么样的值，一个整数，

2050
01:35:25,940 --> 01:35:29,010
thus the percent i instead of %s for string.
因此，使用百分号 i 而不是字符串的百分号 s。

2051
01:35:29,010 --> 01:35:30,630
And I think this should do the job.
我认为这应该可以完成工作。

2052
01:35:30,630 --> 01:35:32,090
So let me go back to my terminal.
所以，让我回到我的终端。

2053
01:35:32,090 --> 01:35:34,370
Make calculator, Enter.
创建 calculator，回车。

2054
01:35:34,370 --> 01:35:37,430
All is well so far. ./calculator, and let's keep it simple--
目前一切顺利。 ./calculator，让我们保持简单--

2055
01:35:37,430 --> 01:35:39,230
1 for x, 2 for y.
x 为 1，y 为 2。

2056
01:35:39,230 --> 01:35:42,140
And indeed, I get 3 as the output.
实际上，我得到了 3 作为输出。

2057
01:35:42,140 --> 01:35:43,170
It's not very dynamic.
它不是很有动态性。

2058
01:35:43,170 --> 01:35:46,170
It can't do a subtraction or multiplication or much more.
它不能做减法、乘法或更多。

2059
01:35:46,170 --> 01:35:49,370
But it does at least do those kinds of calculations.
但它至少可以进行这些类型的计算。

2060
01:35:49,370 --> 01:35:54,085
But let me propose now that we maybe make a reusable addition
但现在我建议我们也许可以创建一个可重复使用的加法

2061
01:35:54,085 --> 01:35:56,960
function, right, because addition is something I'm going to do a lot.
函数，对吧，因为加法是我要经常做的事情。

2062
01:35:56,960 --> 01:35:59,750
And maybe it should be abstracted away with a function
也许应该使用一个函数将它抽象出来

2063
01:35:59,750 --> 01:36:02,310
just like meowing was abstracted away a moment ago.
就像刚才将喵喵叫抽象出来一样。

2064
01:36:02,310 --> 01:36:05,060
So let me go ahead and instead of doing this,
所以，让我继续，而不是这样做，

2065
01:36:05,060 --> 01:36:08,360
let me go ahead and give myself a function called add,
让我继续给自己一个叫做 add 的函数，

2066
01:36:08,360 --> 01:36:11,870
but instead of last time where I had a meow function,
但与上次我有一个 meow 函数不同，

2067
01:36:11,870 --> 01:36:14,420
I'm obviously going to call this "add" instead.
我显然会把它叫做 "add"。

2068
01:36:14,420 --> 01:36:19,040
And instead of last time, taking in no arguments,
并且与上次不同，这次不接受任何参数，

2069
01:36:19,040 --> 01:36:21,600
I think I want add to work a little differently.
我认为我想让 add 有点不同。

2070
01:36:21,600 --> 01:36:24,920
I don't want add necessarily to take an argument yet,
我现在并不想让 add 接受任何参数，

2071
01:36:24,920 --> 01:36:27,320
but I do want add to return some type of value.
但我想让 add 返回某种类型的值。

2072
01:36:27,320 --> 01:36:31,347
And just intuitively, what type of value should an addition function return?
直觉上，加法函数应该返回什么类型的值？

2073
01:36:31,347 --> 01:36:32,180
STUDENT: An integer.
学生：一个整数。

2074
01:36:32,180 --> 01:36:33,680
DAVID MALAN: An integer, so an int.
大卫·马兰：一个整数，所以是 int 类型。

2075
01:36:33,680 --> 01:36:37,250
So I'm going to change void, which means the absence of a return value--
所以我将要改变 void，它意味着没有返回值 -

2076
01:36:37,250 --> 01:36:39,860
nothing's coming back-- to literally "int."
什么都没有返回 - 变成“int”类型。

2077
01:36:39,860 --> 01:36:43,250
But I'm not going to change the thing inside parentheses yet.
但现在我不会改变括号里面的内容。

2078
01:36:43,250 --> 01:36:47,090
I'm going to go ahead and copy my prototype up here.
我将把我的原型复制到这里。

2079
01:36:47,090 --> 01:36:51,590
And I'm going to make this change, return x plus y.
然后我会进行这个修改，返回 x 加 y。

2080
01:36:51,590 --> 01:36:57,438
And then here, instead of printing out x plus y, let's go ahead and do this.
然后在这里，而不是打印出 x 加 y，我们来做这个。

2081
01:36:57,438 --> 01:36:59,480
Let me give myself a third variable just for now.
让我现在给自己一个第三个变量。

2082
01:36:59,480 --> 01:37:02,540
z equals the return value of this brand-new
z 等于这个全新的

2083
01:37:02,540 --> 01:37:05,660
add function that's going to add x plus y for me.
add 函数的返回值，它会帮我计算 x 加 y。

2084
01:37:05,660 --> 01:37:07,520
And then let me print out the value of z.
然后让我打印出 z 的值。

2085
01:37:07,520 --> 01:37:10,860
Instead of x plus y, I'm outsourcing now to this add function
现在我将 x 加 y 的计算外包给这个 add 函数

2086
01:37:10,860 --> 01:37:14,690
so it will do the addition of x plus y.
这样它就可以完成 x 加 y 的运算。

2087
01:37:14,690 --> 01:37:19,160
So similar in spirit to meowing, but the return values, I claim,
所以和喵喵叫类似，但我认为返回值

2088
01:37:19,160 --> 01:37:20,400
are about to create an issue.
即将导致问题。

2089
01:37:20,400 --> 01:37:22,640
So let me make calculator again.
所以让我重新构建计算器。

2090
01:37:22,640 --> 01:37:24,270
And there's definitely some errors.
并且肯定存在一些错误。

2091
01:37:24,270 --> 01:37:28,580
So here we have, "use of undeclared identifier x."
所以这里我们看到，“使用未声明的标识符 x”。

2092
01:37:28,580 --> 01:37:30,390
And that's on line 17.
它在第 17 行。

2093
01:37:30,390 --> 01:37:32,300
So that's pretty far down in the file.
所以这在文件中的位置比较靠下。

2094
01:37:32,300 --> 01:37:37,350
So specifically, my compiler does not like my use of x on line 17.
具体来说，我的编译器不喜欢我在第 17 行使用 x。

2095
01:37:37,350 --> 01:37:42,510
But wait a minute, x is clearly defined on line 8.
等等，x 在第 8 行明显被定义了。

2096
01:37:42,510 --> 01:37:46,555
What intuitively might explain this issue
即使你以前从未编程过，什么直觉可以解释这个问题

2097
01:37:46,555 --> 01:37:48,180
even if you've never programmed before?
呢？

2098
01:37:48,180 --> 01:37:48,750
Yeah?
是吗？

2099
01:37:48,750 --> 01:37:52,245
STUDENT: Well, because x and y are defined in the main function, not
学生：嗯，因为 x 和 y 定义在 main 函数中，而不是

2100
01:37:52,245 --> 01:37:53,277
the add function.
add 函数中。

2101
01:37:53,277 --> 01:37:56,110
DAVID MALAN: Yeah, because x and y are defined in the main function,
大卫·马兰：没错，因为 x 和 y 定义在 main 函数中，

2102
01:37:56,110 --> 01:37:57,412
not in the add function.
而不是 add 函数中。

2103
01:37:57,412 --> 01:37:59,620
So the term of art here that we're about to introduce
所以我们即将介绍的技术术语

2104
01:37:59,620 --> 01:38:00,820
is something called "scope."
叫做“作用域”。

2105
01:38:00,820 --> 01:38:05,920
So "scope" just refers to the context in which variables exist--
所以“作用域”指的是变量存在的上下文 -

2106
01:38:05,920 --> 01:38:08,030
the context in which variables exist.
变量存在的上下文。

2107
01:38:08,030 --> 01:38:09,580
So by that, I mean this.
我的意思是，

2108
01:38:09,580 --> 01:38:11,200
On line 8, I've declared x.
在第 8 行，我声明了 x。

2109
01:38:11,200 --> 01:38:12,595
On line y, I've declared--
在第 y 行，我声明了 -

2110
01:38:12,595 --> 01:38:14,830
[CHUCKLES] on line 9, I've declared y.
[笑声] 在第 9 行，我声明了 y。

2111
01:38:14,830 --> 01:38:18,100
But the catch is-- and here's where the curly braces are helpful--
但是关键是 - 这里花括号就很重要 -

2112
01:38:18,100 --> 01:38:25,000
those variables only exist in the context of the outer curly braces
这些变量只存在于最靠近它们的外部花括号的上下文中

2113
01:38:25,000 --> 01:38:26,950
that are nearest to them, like this.
就像这样。

2114
01:38:26,950 --> 01:38:31,690
So I can use x and y on lines 10, 11, 12, and even up to 13,
所以我在第 10 行、第 11 行、第 12 行，甚至第 13 行都可以使用 x 和 y，

2115
01:38:31,690 --> 01:38:33,170
but not thereafter.
但之后就不行了。

2116
01:38:33,170 --> 01:38:35,920
So I certainly can't use x down here on line 7.
所以，我肯定不能在第 7 行使用 x。

2117
01:38:35,920 --> 01:38:39,400
But this is a problem, because if add's purpose in life is to add x and y
但这是个问题，因为如果 add 函数存在的意义是计算 x 加 y

2118
01:38:39,400 --> 01:38:43,540
but add can't access x plus y, well, we have an issue of scope.
但 add 函数无法访问 x 加 y，那么我们就有作用域的问题。

2119
01:38:43,540 --> 01:38:46,840
Like, x and y are not in scope for this add function.
也就是说，x 和 y 不在 add 函数的作用域内。

2120
01:38:46,840 --> 01:38:50,650
But that's OK because remember that every function we've seen thus far
但这没关系，因为我们记得，到目前为止，我们看到的所有函数

2121
01:38:50,650 --> 01:38:53,790
can have maybe a return value or a side effect,
都可以有一个返回值或者副作用，

2122
01:38:53,790 --> 01:38:59,220
but it can also take 0 or one or two or more inputs, known as arguments.
但它也可以接受 0 个、1 个、2 个或更多个输入，称为参数。

2123
01:38:59,220 --> 01:39:00,740
So what if I instead do this?
那如果我改为这样做呢？

2124
01:39:00,740 --> 01:39:02,460
Let me clear my terminal window.
让我清理一下我的终端窗口。

2125
01:39:02,460 --> 01:39:05,630
And let me update add to not take nothing
让我更新 add 函数，不要接收任何东西

2126
01:39:05,630 --> 01:39:07,550
as input but maybe two integers.
作为输入，而是接受两个整数。

2127
01:39:07,550 --> 01:39:10,130
And I'll call them arbitrarily a and b.
我会随意地将它们命名为 a 和 b。

2128
01:39:10,130 --> 01:39:12,920
But I have to tell the compiler what type of arguments
但我必须告诉编译器这些参数是什么类型

2129
01:39:12,920 --> 01:39:16,040
they are-- two integers, one after the other.
它们是什么——两个整数，一个接一个。

2130
01:39:16,040 --> 01:39:18,720
And now what I can do is this.
现在我可以这样做。

2131
01:39:18,720 --> 01:39:21,380
Let me change this up here, too-- int a, int b--
让我在这里也修改一下——int a, int b——

2132
01:39:21,380 --> 01:39:23,840
just so that the prototype is exactly the same.
这样原型就完全一样了。

2133
01:39:23,840 --> 01:39:27,800
And the only purpose of this prototype is just to avoid the previous error,
这个原型的唯一目的是为了避免先前的错误，

2134
01:39:27,800 --> 01:39:30,440
where the compiler didn't realize add was going to exist
编译器没有意识到 add 函数会存在

2135
01:39:30,440 --> 01:39:32,790
because it came later in the file.
因为它在文件中出现的比较晚。

2136
01:39:32,790 --> 01:39:37,580
So here on line 11 now, if I want to add two values, x and y,
现在，在第 11 行，如果我想添加两个值，x 和 y，

2137
01:39:37,580 --> 01:39:39,650
this is now the syntax.
这就是语法了。

2138
01:39:39,650 --> 01:39:42,530
We saw syntax in Scratch for passing in inputs
我们在 Scratch 中看到了传递输入的语法

2139
01:39:42,530 --> 01:39:44,360
to tell it how many times to meow.
来告诉它要喵多少次。

2140
01:39:44,360 --> 01:39:50,160
So this is just telling add what two numbers to add together.
所以这只是在告诉 add 函数要将哪两个数字加在一起。

2141
01:39:50,160 --> 01:39:54,787
So now I have to change this to a plus b, for reasons we'll soon see.
所以现在我必须将它改为 a 加 b，原因我们很快就会看到。

2142
01:39:54,787 --> 01:39:56,120
And let me see if this is right.
让我看看这是否正确。

2143
01:39:56,120 --> 01:39:57,060
Make calculator.
生成 calculator。

2144
01:39:57,060 --> 01:39:59,000
So far so good. ./calculator.
目前为止一切顺利。./calculator。

2145
01:39:59,000 --> 01:40:02,120
Let's do 1 and 2 for x and y respectively.
我们分别将 1 和 2 赋给 x 和 y。

2146
01:40:02,120 --> 01:40:05,630
And hopefully we should, again, see 3.
我们希望再次看到结果为 3。

2147
01:40:05,630 --> 01:40:07,020
Now, what's going on?
现在，发生了什么？

2148
01:40:07,020 --> 01:40:11,990
So here, again, if I zoom in on my add function, this "int" here on the left,
这里，我再次放大 add 函数，这个左边的 "int"，

2149
01:40:11,990 --> 01:40:15,476
on line 15, means what about add?
在第 15 行，意味着关于 add 函数什么呢？

2150
01:40:15,476 --> 01:40:16,700
STUDENT: [INAUDIBLE]
学生：[听不见]

2151
01:40:16,700 --> 01:40:18,980
DAVID MALAN: This means that it has a return value, that it's an int.
大卫·马兰：这意味着它有一个返回值，它是一个整数。

2152
01:40:18,980 --> 01:40:21,563
So it's going to hand me back, metaphorically, a slip of paper
所以它会形象地说，将一张纸条传给我

2153
01:40:21,563 --> 01:40:24,080
with an answer on it that is of type integer.
上面写着答案，这个答案是整数类型。

2154
01:40:24,080 --> 01:40:25,400
It's not a word, like my name.
它不是一个单词，比如我的名字。

2155
01:40:25,400 --> 01:40:26,750
It's a number instead.
它是一个数字。

2156
01:40:26,750 --> 01:40:33,290
These mentions of int here and here are inside the parentheses, which means
这里提到的 int，这里和这里，都在括号里面，这意味着

2157
01:40:33,290 --> 01:40:36,390
this function, add, takes two inputs.
这个函数，add，接受两个输入。

2158
01:40:36,390 --> 01:40:37,460
The first is an int.
第一个是整数。

2159
01:40:37,460 --> 01:40:38,540
The second is an int.
第二个也是整数。

2160
01:40:38,540 --> 01:40:42,930
And just so we have something to call them, I call them a and b respectively.
为了方便我们称呼它们，我分别将它们命名为 a 和 b。

2161
01:40:42,930 --> 01:40:49,010
So what happens essentially when I call the add function now on line 11,
所以，实际上，当我在第 11 行调用 add 函数时，

2162
01:40:49,010 --> 01:40:51,050
I'm kind of passing in x.
我相当于传递了 x。

2163
01:40:51,050 --> 01:40:52,610
I'm passing in y.
我传递了 y。

2164
01:40:52,610 --> 01:40:56,210
But the add function is going to think of them as a and b respectively.
但是 add 函数会将它们分别视为 a 和 b。

2165
01:40:56,210 --> 01:40:57,770
It could call them anything I want.
我可以随意地称呼它们。

2166
01:40:57,770 --> 01:41:00,710
I could change this to the word "first" and "second."
我可以将它们改为 "first" 和 "second"。

2167
01:41:00,710 --> 01:41:03,500
And then I could literally change this to "first + second."
然后我可以将这里直接改为 "first + second"。

2168
01:41:03,500 --> 01:41:07,220
Those are perfectly acceptable as argument or variable names.
这些都是可以接受的参数名或变量名。

2169
01:41:07,220 --> 01:41:08,210
But who really cares?
但谁在乎呢？

2170
01:41:08,210 --> 01:41:12,500
Like, a and b for such a simple function is perfectly reasonable, too.
比如，对于这样一个简单的函数，用 a 和 b 来命名也是很合理的。

2171
01:41:12,500 --> 01:41:14,540
Technically, if your mind is going there,
技术上来说，如果你这么想，

2172
01:41:14,540 --> 01:41:18,365
I could even call them the exact same thing.
我甚至可以称它们为完全相同的东西。

2173
01:41:18,365 --> 01:41:21,240
But let me propose for today, certainly don't do that because it just
但让我今天提出，当然不要那样做，因为那样做只会

2174
01:41:21,240 --> 01:41:24,210
confuses things if you've got x's and y's here, x's and y's here,
让事情变得混乱，如果你这里有 x 和 y，这里也有 x 和 y，

2175
01:41:24,210 --> 01:41:25,470
but they're clearly different.
但它们显然是不同的。

2176
01:41:25,470 --> 01:41:26,310
Just don't do that.
就不要那样做。

2177
01:41:26,310 --> 01:41:29,640
Try to come up with different variables just to keep yourself sane.
尽量想出不同的变量，只是为了让自己保持理智。

2178
01:41:29,640 --> 01:41:33,930
But here, I have a function that takes now two integers, a and b respectively.
但是在这里，我有一个函数，它现在接受两个整数，分别是 a 和 b。

2179
01:41:33,930 --> 01:41:37,920
It just returns the sum of them so that I can now store the return
它只是返回它们的总和，这样我就可以存储返回

2180
01:41:37,920 --> 01:41:40,680
value of add in a variable called z.
add 的值到一个名为 z 的变量中。

2181
01:41:40,680 --> 01:41:45,180
And then, quite simply, print it out.
然后，很简单，打印出来。

2182
01:41:45,180 --> 01:41:47,520
But there's one other thing I can do here.
但这里我还有一件事可以做。

2183
01:41:47,520 --> 01:41:51,690
Now, if we think about design, even if you've never programmed before,
现在，如果我们考虑设计，即使你以前从未编程过，

2184
01:41:51,690 --> 01:41:55,350
do I really need the variable z?
我真的需要变量 z 吗？

2185
01:41:55,350 --> 01:41:58,890
Because I'm defining it on line 11, and then I'm quickly using it on line 12,
因为我在第 11 行定义了它，然后我在第 12 行很快地使用它，

2186
01:41:58,890 --> 01:41:59,672
and that's it?
就这样吗？

2187
01:41:59,672 --> 01:42:01,380
Like, sometimes you don't need variables.
就像，有时候你不需要变量。

2188
01:42:01,380 --> 01:42:03,213
And they might make your code more readable.
它们可能会让你的代码更易读。

2189
01:42:03,213 --> 01:42:06,840
But strictly speaking-- and this is just kind of like substitution in math--
但严格来说，这就像数学中的替换一样，

2190
01:42:06,840 --> 01:42:10,980
if z is the same thing as "add (x, y)," well, let me go ahead
如果 z 和 “add (x, y)” 是同一个东西，那么，让我继续

2191
01:42:10,980 --> 01:42:12,870
and just delete line 11 altogether.
并直接删除第 11 行。

2192
01:42:12,870 --> 01:42:14,520
Let me get rid of mention of z.
让我摆脱对 z 的提及。

2193
01:42:14,520 --> 01:42:16,800
You can actually get away with doing this.
你实际上可以做到这一点。

2194
01:42:16,800 --> 01:42:20,340
And much like the Join block in Scratch, where I kind of overlaid it
就像 Scratch 中的 Join 模块一样，我把它覆盖了

2195
01:42:20,340 --> 01:42:24,390
on the Say block, kind of stacking them, you can stack functions in C,
在 Say 模块上，将它们叠起来，你可以在 C 中叠加函数，

2196
01:42:24,390 --> 01:42:26,640
or nest them really, kind of mathematically.
或者说真的将它们嵌套起来，有点像数学上的嵌套。

2197
01:42:26,640 --> 01:42:28,530
Honestly, it makes it a little harder to read
说实话，这会让它有点难以阅读

2198
01:42:28,530 --> 01:42:31,320
because your mind has to dive in conceptually deeper and deeper
因为你的思维必须在概念上越来越深入

2199
01:42:31,320 --> 01:42:33,010
into this second argument.
到这个第二个参数中。

2200
01:42:33,010 --> 01:42:35,310
But it's perfectly acceptable, too.
但这也是完全可以接受的。

2201
01:42:35,310 --> 01:42:38,100
And just to connect the dots to maybe something from high school,
只是为了将这些点连接起来，可能与高中的一些东西有关，

2202
01:42:38,100 --> 01:42:40,890
this is kind of analogous to a function in math class
这有点类似于数学课上的函数

2203
01:42:40,890 --> 01:42:43,260
being like f of x, where f is some function name,
就像 f of x 一样，其中 f 是某个函数名，

2204
01:42:43,260 --> 01:42:45,700
x is some arbitrary input to that function.
x 是该函数的任意输入。

2205
01:42:45,700 --> 01:42:49,120
And when you start to put functions inside of functions
当你开始将函数放在函数内部时

2206
01:42:49,120 --> 01:42:51,570
so that the output of one becomes the input to the next,
这样，一个函数的输出就成为下一个函数的输入，

2207
01:42:51,570 --> 01:42:54,313
it's like using this syntax, f of g of x and so forth.
这就像使用这种语法，f of g of x 等等。

2208
01:42:54,313 --> 01:42:56,230
If you've never seen that before, don't worry.
如果你以前从未见过，别担心。

2209
01:42:56,230 --> 01:42:59,730
But if you have, it's a way to connect some of these dots.
但如果你有，这是一个连接一些这些点的方法。

2210
01:42:59,730 --> 01:43:02,880
Any questions, though, on just this idea of now
不过，关于现在这个想法，有什么问题吗？

2211
01:43:02,880 --> 01:43:05,580
having a function that doesn't just have a side effect
拥有一个不只是有副作用的函数

2212
01:43:05,580 --> 01:43:10,500
but instead has a return value?
而是具有返回值？

2213
01:43:10,500 --> 01:43:11,790
Yeah, in back?
好的，后面那位？

2214
01:43:11,790 --> 01:43:14,031
STUDENT: In our declaration of main, why did we
学生：在我们对 main 的声明中，为什么我们

2215
01:43:14,031 --> 01:43:16,622
show it as returning an integer instead of void?
把它显示为返回一个整数而不是 void？

2216
01:43:16,622 --> 01:43:19,080
DAVID MALAN: In our definition of main, why did I do, what?
大卫·马兰：在我们对 main 的定义中，我做了什么？

2217
01:43:19,080 --> 01:43:21,445
STUDENT: Why do we show it as returning an integer
学生：为什么我们把它显示为返回一个整数

2218
01:43:21,445 --> 01:43:22,870
instead of returning as void?
而不是返回 void？

2219
01:43:22,870 --> 01:43:24,820
DAVID MALAN: Oh, a really good question that I was trying
哦，这是一个很好的问题，我今天一直在试图

2220
01:43:24,820 --> 01:43:26,195
to sweep under the rug for today.
掩盖过去。

2221
01:43:26,195 --> 01:43:28,240
But in every one of our programs thus far,
但在我们迄今为止的每一个程序中，

2222
01:43:28,240 --> 01:43:31,330
I have indeed said "int main(void)."
我确实说过“int main(void)”。

2223
01:43:31,330 --> 01:43:34,940
Technically speaking, whenever you write a program and it finishes running,
从技术上讲，每当你编写一个程序并完成运行时，

2224
01:43:34,940 --> 01:43:37,750
it actually returns a value somewhat secretly.
它实际上会秘密地返回一个值。

2225
01:43:37,750 --> 01:43:41,200
It returns the number 0 by convention, which means all is well.
按照惯例，它返回数字 0，表示一切正常。

2226
01:43:41,200 --> 01:43:44,420
And it can return any other integer if something goes wrong.
如果出现问题，它可以返回任何其他整数。

2227
01:43:44,420 --> 01:43:46,960
In fact, on your Mac, PC, or even phone, if you've ever
事实上，在你的 Mac、PC 甚至手机上，如果你曾经

2228
01:43:46,960 --> 01:43:50,030
gotten like a weird message on the screen, like something went wrong
在屏幕上看到过奇怪的提示，比如出了点问题

2229
01:43:50,030 --> 01:43:53,710
and it's like a weird numeric code, like error negative 129, or something
并且它看起来像一个奇怪的数字代码，比如错误 -129，或者类似的东西

2230
01:43:53,710 --> 01:43:57,340
arbitrary like that, that tends to mean that some program running
任意之类的，这意味着运行的某个程序

2231
01:43:57,340 --> 01:44:01,660
on your Mac, PC, or phone had something go wrong with the main function.
在你的 Mac、PC 或者手机上，主函数出现了一些问题。

2232
01:44:01,660 --> 01:44:03,608
And that is the number that was returned.
这就是返回的数字。

2233
01:44:03,608 --> 01:44:05,650
But that's more than we want to talk about today.
但今天我们不想讨论太多。

2234
01:44:05,650 --> 01:44:07,060
But we'll come back to this.
但我们会再回来谈这个。

2235
01:44:07,060 --> 01:44:08,890
But main always returns a number.
但 main 总是返回一个数字。

2236
01:44:08,890 --> 01:44:10,930
By default, it is 0.
默认情况下，它是 0。

2237
01:44:10,930 --> 01:44:12,640
More on that soon.
很快就会谈到这一点。

2238
01:44:12,640 --> 01:44:15,790
All right, so with that said, let's actually tease
好了，话虽如此，让我们真正地揭示

2239
01:44:15,790 --> 01:44:18,100
apart what it is we've been using underneath the hood
我们在幕后使用的是什么

2240
01:44:18,100 --> 01:44:21,743
here a little bit by returning to VS Code's interface itself.
这里，通过返回 VS Code 的界面本身。

2241
01:44:21,743 --> 01:44:23,660
It turns out that all this time, even though I
事实证明，一直以来，尽管我

2242
01:44:23,660 --> 01:44:27,050
keep alluding to macOS and Windows, which like 99% of us
一直提到了 macOS 和 Windows，我们中 99% 的人

2243
01:44:27,050 --> 01:44:29,540
are probably running on our laptops or desktops,
可能正在我们的笔记本电脑或台式机上运行，

2244
01:44:29,540 --> 01:44:32,390
there's actually other very popular operating systems in the world,
实际上，世界上还有其他非常流行的操作系统，

2245
01:44:32,390 --> 01:44:33,620
among which is Linux.
其中之一就是 Linux。

2246
01:44:33,620 --> 01:44:36,960
So Linux is a very popular operating system,
所以 Linux 是一个非常流行的操作系统，

2247
01:44:36,960 --> 01:44:39,380
the thing that turns on-- the thing that boots up
当你在第一次开机时，它启动——它启动

2248
01:44:39,380 --> 01:44:40,880
when you first turn on a computer.
你的电脑。

2249
01:44:40,880 --> 01:44:44,690
And it's very commonly used for servers nowadays.
如今它广泛用于服务器。

2250
01:44:44,690 --> 01:44:48,860
All of CS50's own servers run some version of Linux.
CS50 自己的服务器都运行着某种版本的 Linux。

2251
01:44:48,860 --> 01:44:51,080
Those students more comfortable sometimes
那些有时更习惯使用 Linux 的学生

2252
01:44:51,080 --> 01:44:54,410
run Linux on their own Macs or PCs even.
甚至会在他们自己的 Mac 或 PC 上运行 Linux。

2253
01:44:54,410 --> 01:44:56,720
So Linux is a very popular operating system.
所以 Linux 是一个非常流行的操作系统。

2254
01:44:56,720 --> 01:45:00,110
And it's particularly characterized by its textual interface,
它最显著的特征是其文本界面，

2255
01:45:00,110 --> 01:45:03,770
its command-line interface, even though it also comes with graphical ones,
它的命令行界面，即使它也带了图形界面，

2256
01:45:03,770 --> 01:45:04,410
as well.
也是。

2257
01:45:04,410 --> 01:45:07,490
So again, this term we started today with, a graphical user interface
所以，我们今天开始提到的这个词，图形用户界面

2258
01:45:07,490 --> 01:45:09,230
is a thing with menus and buttons.
是一个带菜单和按钮的东西。

2259
01:45:09,230 --> 01:45:11,850
It's literally what you and I use every day on our devices,
它就是我们每天在设备上使用的东西，

2260
01:45:11,850 --> 01:45:13,220
otherwise known as a GUI.
也就是我们所说的 GUI。

2261
01:45:13,220 --> 01:45:15,440
But today onward, you'll get more comfortable
但从今天开始，你会更加熟悉

2262
01:45:15,440 --> 01:45:18,380
with and more practice with this terminal window
并更多地练习使用这个终端窗口

2263
01:45:18,380 --> 01:45:22,430
down here, which represents a command-line interface, or CLI.
这里，它代表命令行界面，或 CLI。

2264
01:45:22,430 --> 01:45:26,270
And just so you have a mental model of what's going on in the cloud here,
为了让你对这里云中发生的事情有一个心理模型，

2265
01:45:26,270 --> 01:45:31,460
when you access cs50.dev, you are accessing this version of VS Code
当你访问 cs50.dev 时，你就是在访问这个版本的 VS Code

2266
01:45:31,460 --> 01:45:34,290
in the cloud, a piece of software just running in a browser.
在云端，一段软件正在浏览器中运行。

2267
01:45:34,290 --> 01:45:36,680
But that piece of software is automatically
但这段软件会自动

2268
01:45:36,680 --> 01:45:41,600
connected to your very own personal server in the cloud, so to speak.
连接到你自己的个人云服务器，可以这么说。

2269
01:45:41,600 --> 01:45:43,860
Technically speaking, it's a "docker container."
从技术上讲，它是一个“Docker容器”。

2270
01:45:43,860 --> 01:45:47,930
But it means that you have essentially your own mini server in the cloud
但这意味着你基本上在云端拥有了自己的小型服务器

2271
01:45:47,930 --> 01:45:50,640
that only you have access to.
只有你可以访问。

2272
01:45:50,640 --> 01:45:55,460
And that server or container is running an operating system called Linux.
这个服务器或容器运行着一个名为Linux的操作系统。

2273
01:45:55,460 --> 01:45:58,370
And in fact, every time I've been running a command down here,
实际上，每次我在这里运行命令时，

2274
01:45:58,370 --> 01:46:02,750
whether it's code or make or ./hello or anything else,
无论是代码、make、./hello还是其他任何东西，

2275
01:46:02,750 --> 01:46:06,740
I've been running commands from here in Sanders Theatre on a server somewhere
我一直在桑德斯剧院的某个服务器上运行命令

2276
01:46:06,740 --> 01:46:10,280
in the cloud, my own Linux container or server.
在云端，我自己的Linux容器或服务器。

2277
01:46:10,280 --> 01:46:12,050
And you'll have the same yourself.
你也会拥有相同的。

2278
01:46:12,050 --> 01:46:14,270
This is the thing that we have pre-configured
这是我们预先配置好的

2279
01:46:14,270 --> 01:46:18,320
for you by installing the compiler in so many other pieces of software
为你安装编译器和其他许多软件

2280
01:46:18,320 --> 01:46:20,180
you'll soon see in the class.
你很快就会在课堂上看到。

2281
01:46:20,180 --> 01:46:24,920
But underneath the hood, then, of Linux is a soon-to-be familiar environment
但Linux的底层是一个即将熟悉的环境

2282
01:46:24,920 --> 01:46:27,530
that allows you to run different types of commands.
它允许你运行不同类型的命令。

2283
01:46:27,530 --> 01:46:29,542
And those commands include things like this.
这些命令包括以下内容。

2284
01:46:29,542 --> 01:46:32,250
And this is something you'll develop muscle memory for over time.
随着时间的推移，你会对此形成肌肉记忆。

2285
01:46:32,250 --> 01:46:36,710
But I wanted to give you a sense of some of the most popular textual commands
但我希望让你了解一些最流行的文本命令

2286
01:46:36,710 --> 01:46:38,690
because we're essentially about to take away
因为我们实际上要带走

2287
01:46:38,690 --> 01:46:42,740
muscle memory you have from a GUI world and have you type out words that
你在GUI世界中所拥有的肌肉记忆，让你输入代表的文字

2288
01:46:42,740 --> 01:46:46,280
represent double-clicking on things, dragging on other things,
双击某些东西，拖动其他东西，

2289
01:46:46,280 --> 01:46:48,680
and other such commands that you and I take for granted.
以及其他我们习以为常的命令。

2290
01:46:48,680 --> 01:46:51,830
It'll be a little painful at first in the first days or weeks,
最初的几天或几周会有点痛苦，

2291
01:46:51,830 --> 01:46:56,150
but it will make you far more productive long term so that even after CS50,
但从长远来看，它会让你更有效率，即使在CS50之后，

2292
01:46:56,150 --> 01:46:59,390
if you start using your programming skills in some other domain, class,
如果你开始在其他领域、课堂

2293
01:46:59,390 --> 01:47:02,660
or real-world job, you'll just be a lot faster at the keyboard
或现实世界的工作中使用你的编程技能，你会在键盘上更快

2294
01:47:02,660 --> 01:47:04,980
and able to do more work more quickly.
并且能够更快地完成更多工作。

2295
01:47:04,980 --> 01:47:08,660
So with that said, let me go back to VS Code over here.
也就是说，让我回到这里的VS Code。

2296
01:47:08,660 --> 01:47:11,360
I'm going to go ahead and open up my File Explorer over here.
我将打开我的文件资源管理器。

2297
01:47:11,360 --> 01:47:14,180
And you'll see at left all of the files that I've
在左侧，你会看到我创建的所有文件

2298
01:47:14,180 --> 01:47:17,210
created thus far in class and all of the programs
在课堂上创建的所有程序

2299
01:47:17,210 --> 01:47:19,250
that I've compiled thus far in class.
我在课堂上编译的所有程序。

2300
01:47:19,250 --> 01:47:21,620
I also have this source 1 directory, which
我还有这个source 1目录，它

2301
01:47:21,620 --> 01:47:25,070
you can download from the course's website, which has all of today's code
你可以从课程网站上下载，它包含了今天的所有代码

2302
01:47:25,070 --> 01:47:27,740
pre-written in advance, so you don't have to type everything
提前写好了，所以你不必输入所有内容

2303
01:47:27,740 --> 01:47:28,910
that I literally type.
我字面上输入的内容。

2304
01:47:28,910 --> 01:47:31,560
But all of these files are things that I've created.
但所有这些文件都是我创建的。

2305
01:47:31,560 --> 01:47:34,070
And you'll see that in white are the C files.
你会看到用白色显示的是C文件。

2306
01:47:34,070 --> 01:47:38,180
And grayed out are actually the binary files, the machine code
用灰色显示的是二进制文件，也就是我创建并运行的机器代码。

2307
01:47:38,180 --> 01:47:40,160
that I created that I was running.
我创建并运行的机器代码。

2308
01:47:40,160 --> 01:47:45,080
So you can click on any of these files in VS Code to open them.
因此，你可以在VS Code中点击任何这些文件来打开它们。

2309
01:47:45,080 --> 01:47:47,330
For instance, here is hello.c.
例如，这是hello.c。

2310
01:47:47,330 --> 01:47:49,860
And voila, it opens in the text editor.
瞧，它在文本编辑器中打开了。

2311
01:47:49,860 --> 01:47:52,520
But if I try to open "hello," that's not going to work,
但是如果我尝试打开“hello”，它就无法正常工作，

2312
01:47:52,520 --> 01:47:53,870
because that's zeros and ones.
因为那是 0 和 1。

2313
01:47:53,870 --> 01:47:57,098
And frankly, the computer could show me all those zeros and ones,
坦白说，电脑可以向我展示所有这些 0 和 1，

2314
01:47:57,098 --> 01:47:58,640
but it's just not going to be useful.
但这毫无用处。

2315
01:47:58,640 --> 01:48:01,800
And honestly, it's too easy to make one mistake and break the whole thing.
老实说，犯一个错误就很容易破坏整个程序。

2316
01:48:01,800 --> 01:48:05,690
So instead, VS Code says that it can't display the text, because it's binary
因此，VS Code 表示它无法显示文本，因为它为二进制

2317
01:48:05,690 --> 01:48:07,860
or maybe unsupported more generally.
或更普遍地说是不受支持的。

2318
01:48:07,860 --> 01:48:12,470
So know that you want to only click on the .c files when writing C code.
所以记住，在编写 C 代码时，你只想点击 .c 文件。

2319
01:48:12,470 --> 01:48:14,240
But let me go ahead and do something else.
但让我继续做其他事情。

2320
01:48:14,240 --> 01:48:18,650
Suppose that I decide that, wait a minute, we're nearing the end of class.
假设我决定，等等，我们快下课了。

2321
01:48:18,650 --> 01:48:23,180
And we're not done yet, but what if I want to change hello.c to goodbye.c
我们还没结束，但如果我想把 hello.c 改成 goodbye.c

2322
01:48:23,180 --> 01:48:26,990
or if I want to change meow.c to woof.c and turn it into a dog?
或者如果我想把 meow.c 改成 woof.c，把它变成一条狗？

2323
01:48:26,990 --> 01:48:28,310
Well, let's actually do that.
好吧，让我们实际操作一下。

2324
01:48:28,310 --> 01:48:32,450
I could go over here and right click or Control click on the file,
我可以到这里，右键单击或 Control 点击该文件，

2325
01:48:32,450 --> 01:48:33,650
just like on a Mac or PC.
就像在 Mac 或 PC 上一样。

2326
01:48:33,650 --> 01:48:35,520
I can find the Rename option.
我可以找到重命名选项。

2327
01:48:35,520 --> 01:48:37,460
And I can do it all via the GUI.
我可以用 GUI 完成所有操作。

2328
01:48:37,460 --> 01:48:41,120
But you should get more comfortable using commands like these here.
但是你应该习惯使用像这样的命令。

2329
01:48:41,120 --> 01:48:45,410
And among the commands on this list are "mv" for move, a.k.a.
该列表中的命令包括“mv”表示移动，也称为

2330
01:48:45,410 --> 01:48:46,430
rename.
重命名。

2331
01:48:46,430 --> 01:48:52,430
So for instance, if I want to change meow.c to be woof.c instead,
例如，如果我想把 meow.c 改成 woof.c，

2332
01:48:52,430 --> 01:48:56,960
I literally type "mv" space, the original file name, space,
我只需要输入“mv”空格，原始文件名，空格，

2333
01:48:56,960 --> 01:48:58,140
and the new file name.
和新文件名。

2334
01:48:58,140 --> 01:49:00,050
So this is very similar to what I've already
所以这非常类似于我已经

2335
01:49:00,050 --> 01:49:03,260
been doing with the code program or the make program.
用 code 程序或 make 程序做的。

2336
01:49:03,260 --> 01:49:06,200
I not only type the name of the command but also the thing
我不仅输入命令的名称，还输入

2337
01:49:06,200 --> 01:49:08,690
that I want to code or the thing that I want to make.
我想要编写的代码或想要制作的东西。

2338
01:49:08,690 --> 01:49:12,140
In this case, I type the thing that I want to move from old to new.
在这种情况下，我输入我要从旧位置移动到新位置的东西。

2339
01:49:12,140 --> 01:49:15,230
Now, if I hit Enter in a moment, watch on the left-hand side,
现在，如果我马上按下 Enter，注意左侧，

2340
01:49:15,230 --> 01:49:18,200
meow.c in the GUI should automatically change
GUI 中的 meow.c 应该自动更改

2341
01:49:18,200 --> 01:49:23,800
even though I'm doing this all via the command-line keyboard interface.
即使我是在通过命令行键盘界面完成这一切。

2342
01:49:23,800 --> 01:49:25,282
And now it becomes woof.c.
现在它就变成了 woof.c。

2343
01:49:25,282 --> 01:49:26,740
I mean, it's not all that exciting.
我的意思是，这并不令人兴奋。

2344
01:49:26,740 --> 01:49:29,380
But this is just to say that they are one and the same.
但这只是为了说明它们是一回事。

2345
01:49:29,380 --> 01:49:33,260
One is a GUI, one is a CLI, but it's the same exact thing.
一个是 GUI，一个是 CLI，但它们完全相同。

2346
01:49:33,260 --> 01:49:35,530
Moreover, let me go ahead and close now the GUI
此外，让我继续关闭左侧的 GUI

2347
01:49:35,530 --> 01:49:37,510
at left, the so-called explorer.
也就是所谓的资源管理器。

2348
01:49:37,510 --> 01:49:41,327
And in my terminal window alone, now I'm kind of out of my element,
现在我只有终端窗口，有点不知所措，

2349
01:49:41,327 --> 01:49:43,660
like wait a minute, what was the file I created earlier?
就像等等，我之前创建的文件是什么？

2350
01:49:43,660 --> 01:49:45,550
Well, there's other commands as well.
好吧，还有其他命令。

2351
01:49:45,550 --> 01:49:50,500
On this list is, coincidentally, "ls," which lists
这个列表中，巧合的是，有“ls”，它列出

2352
01:49:50,500 --> 01:49:52,940
the file in your current folder.
当前文件夹中的文件。

2353
01:49:52,940 --> 01:49:56,770
And as you might have gleaned here, "mv" for move, "ls" for list,
你可能已经知道，这里“mv”表示移动，“ls”表示列出，

2354
01:49:56,770 --> 01:49:59,560
CS people like to be succinct, terse, and type
计算机科学专业的人喜欢简洁、简明，并输入

2355
01:49:59,560 --> 01:50:01,150
the minimal number of keystrokes.
最少的键击次数。

2356
01:50:01,150 --> 01:50:04,180
That's why these are all abbreviated commands instead of full words.
这就是为什么这些都是缩写命令而不是完整的单词。

2357
01:50:04,180 --> 01:50:07,480
But if I go back to my terminal window and type "ls," voila,
但如果我回到我的终端窗口并键入“ls”，瞧，

2358
01:50:07,480 --> 01:50:13,540
there is exactly the same contents of my server but displayed textually.
我的服务器的相同内容都在这里，但以文本形式显示。

2359
01:50:13,540 --> 01:50:14,920
And there's some heuristics here.
这里有一些启发式方法。

2360
01:50:14,920 --> 01:50:18,040
In green with an asterisk is all of the programs
用绿色和星号标记的是所有程序

2361
01:50:18,040 --> 01:50:21,110
that I made with make that are executable.
我用 make 制作的可执行程序。

2362
01:50:21,110 --> 01:50:24,150
So the asterisks just means this is executable with dot-slash.
所以星号只是意味着这是可以用点斜杠执行的。

2363
01:50:24,150 --> 01:50:27,860
Meanwhile, the source 1 directory, which only I have because I downloaded it
同时，source 1 目录，只有我拥有，因为我提前下载了它

2364
01:50:27,860 --> 01:50:31,520
in advance, has a slash to indicate that it's a folder instead of a file.
事先，它有一个斜杠来表示它是一个文件夹，而不是一个文件。

2365
01:50:31,520 --> 01:50:36,570
But all of these white files ending in .c we created together here today.
但所有这些以 .c 结尾的白色文件都是我们今天一起创建的。

2366
01:50:36,570 --> 01:50:42,020
Now, what if I really am embarrassed by my very first program, hello.c?
现在，如果我真的对我的第一个程序 hello.c 感到很尴尬呢？

2367
01:50:42,020 --> 01:50:48,020
Well, I can very destructively go and use the rm command for remove.
好吧，我可以非常具有破坏性地去使用 rm 命令来删除。

2368
01:50:48,020 --> 01:50:52,370
And rm hello.c is going to prompt me, a little cryptically,
而 rm hello.c 会提示我，有点神秘，

2369
01:50:52,370 --> 01:50:54,740
"remove regular file 'hello.c'?"
“删除普通文件‘hello.c’吗？”

2370
01:50:54,740 --> 01:51:01,580
And amazingly, this rm program has code just like we wrote earlier for agree.c,
令人惊讶的是，这个 rm 程序有代码，就像我们之前为 agree.c 编写的代码一样，

2371
01:51:01,580 --> 01:51:03,560
where I can type 'y' to delete it.
在那里我可以键入“y”来删除它。

2372
01:51:03,560 --> 01:51:05,060
I can type 'n' not to delete it.
我可以键入“n”来不删除它。

2373
01:51:05,060 --> 01:51:06,180
But let's delete it.
但让我们删除它。

2374
01:51:06,180 --> 01:51:08,210
Let's go ahead and hit y, enter.
让我们继续按下 y，然后回车。

2375
01:51:08,210 --> 01:51:09,840
Nothing seems to happen.
似乎什么也没发生。

2376
01:51:09,840 --> 01:51:11,370
But in general, that's a good thing.
但总的来说，这是一件好事。

2377
01:51:11,370 --> 01:51:14,170
But if I type "ls" again, notice what is now missing?
但如果我再次键入“ls”，请注意现在缺少什么？

2378
01:51:14,170 --> 01:51:15,920
And in fact, the list is a little shorter.
事实上，列表短了一些。

2379
01:51:15,920 --> 01:51:18,110
So it's one line instead of two.
所以是一行，而不是两行。

2380
01:51:18,110 --> 01:51:20,370
"hello.c" is now gone.
“hello.c”现在不见了。

2381
01:51:20,370 --> 01:51:24,300
Now, if you do that, there are not easy ways to get the file back.
现在，如果你那样做，没有简单的方法可以找回文件。

2382
01:51:24,300 --> 01:51:26,750
So don't do that unless you really want to.
所以不要那样做，除非你真的想要。

2383
01:51:26,750 --> 01:51:29,910
But there are backups maintained of these files, as well.
但这些文件也都有备份。

2384
01:51:29,910 --> 01:51:31,160
Well, what else is there, too?
好吧，还有其他什么？

2385
01:51:31,160 --> 01:51:32,510
Well, there's all of these other commands.
好吧，还有所有这些其他命令。

2386
01:51:32,510 --> 01:51:34,052
And you'll experience them over time.
你将随着时间的推移体验到它们。

2387
01:51:34,052 --> 01:51:35,540
Like, "cp" is copy.
比如，“cp”是复制。

2388
01:51:35,540 --> 01:51:40,190
"mkdir" is make directory. "rmdir" is remove directory.
“mkdir”是创建目录。“rmdir”是删除目录。

2389
01:51:40,190 --> 01:51:43,070
And for instance, let me just show you one folder.
例如，让我只展示一个文件夹。

2390
01:51:43,070 --> 01:51:45,770
If I type "ls," there's that source 1 folder
如果我键入“ls”，那里是那个 source 1 文件夹

2391
01:51:45,770 --> 01:51:47,510
that I claimed I downloaded in advance.
我声称我提前下载了它。

2392
01:51:47,510 --> 01:51:50,120
If you want to see what's there, you can type "cd"
如果你想看看里面有什么，你可以键入“cd”

2393
01:51:50,120 --> 01:51:53,810
for change directory, source 1, enter.
用于更改目录，source 1，回车。

2394
01:51:53,810 --> 01:51:56,970
And voila, notice that your prompt has now changed.
瞧，请注意你的提示现在已经改变了。

2395
01:51:56,970 --> 01:51:58,310
And let me clear the screen.
让我清理一下屏幕。

2396
01:51:58,310 --> 01:52:03,320
Just as a visual reminder of where you are, you can see before the dollar sign
为了让你直观地了解你在哪里，你可以在美元符号之前看到

2397
01:52:03,320 --> 01:52:05,370
now the name of the folder that you're inside of.
你现在所处的文件夹的名称。

2398
01:52:05,370 --> 01:52:08,090
So in Mac or Windows, you'd see obviously a graphical folder.
所以在 Mac 或 Windows 中，你显然会看到一个图形文件夹。

2399
01:52:08,090 --> 01:52:11,360
Here, you just see a little textual reminder of where you now are.
在这里，你只会看到一个小的文本提醒，表明你现在在哪里。

2400
01:52:11,360 --> 01:52:14,840
And if I type "ls," you'll see that I wrote a crazy number of files
如果我键入“ls”，你会看到我写了很多文件

2401
01:52:14,840 --> 01:52:15,770
before class.
课前。

2402
01:52:15,770 --> 01:52:18,380
And each of these represents different versions of the files
每一个都代表了不同版本的程序

2403
01:52:18,380 --> 01:52:20,540
that we've been coding here in real time that I usually
我们一直在实时编写，我通常

2404
01:52:20,540 --> 01:52:22,748
have printouts of just to go through things in series
只需打印出来以便按顺序查看

2405
01:52:22,748 --> 01:52:25,135
so you have copies online, as well.
您也可以在线获取副本。

2406
01:52:25,135 --> 01:52:28,010
So in short, all of these commands, if you've never used them before,
简而言之，如果您以前从未使用过这些命令，

2407
01:52:28,010 --> 01:52:29,780
they will soon become like muscle memory.
它们很快就会变成肌肉记忆。

2408
01:52:29,780 --> 01:52:31,760
And they do the most basic of operations.
它们执行最基本的操作。

2409
01:52:31,760 --> 01:52:33,927
But there will be other commands that we'll see over
但随着时间的推移，我们将看到其他执行更多功能的命令。

2410
01:52:33,927 --> 01:52:36,470
time that do even much more than that.
它们的功能远不止这些。

2411
01:52:36,470 --> 01:52:39,050
But let's go ahead now and solve some actual problems.
但现在让我们继续解决一些实际问题。

2412
01:52:39,050 --> 01:52:41,990
And it's no coincidence that we keep showing or alluding
我们不断展示或影射超级马里奥兄弟并非偶然，

2413
01:52:41,990 --> 01:52:44,300
to Super Mario Brothers in some form, an older game
这是一款来自任天堂娱乐系统的较老游戏，

2414
01:52:44,300 --> 01:52:47,660
from the Nintendo Entertainment System, that allows you ultimately
它最终允许您

2415
01:52:47,660 --> 01:52:50,720
to have this two-dimensional world, where Mario moves up and down
拥有这个二维世界，马里奥可以在其中上下移动

2416
01:52:50,720 --> 01:52:52,730
and side scrolls from left to right.
并从左到右滚动。

2417
01:52:52,730 --> 01:52:55,940
But you'll see we can distill even some aspects of "Mario"
但您会发现，我们甚至可以将“马里奥”的某些方面

2418
01:52:55,940 --> 01:53:00,260
into some fairly representative programming problems.
提炼成一些相当有代表性的编程问题。

2419
01:53:00,260 --> 01:53:02,835
And in fact, let me propose that we consider this screen
实际上，我建议我们考虑一下这个屏幕

2420
01:53:02,835 --> 01:53:04,460
from the original Super Mario Brothers.
来自原始的超级马里奥兄弟。

2421
01:53:04,460 --> 01:53:09,810
So there's these four blocks in the sky, each with a question mark.
天空中有四个方块，每个方块上都有一个问号。

2422
01:53:09,810 --> 01:53:12,800
And if you click on one of these-- or if Mario jumps up
如果你点击其中一个，或者马里奥跳到

2423
01:53:12,800 --> 01:53:15,800
underneath each of these question marks, he
每个问号的下方，他

2424
01:53:15,800 --> 01:53:18,140
gets like a coin or something else that pops out.
会获得一枚硬币或其他弹出的东西。

2425
01:53:18,140 --> 01:53:22,550
Let's distill this, though, into its essence and consider in C, how can
让我们将其提炼到本质，并考虑在 C 语言中，我们如何

2426
01:53:22,550 --> 01:53:26,310
we make, not a blue sky yet, not a green grassy hill, and so forth,
创建，不是蓝色的天空，也不是绿色的草地等等，

2427
01:53:26,310 --> 01:53:28,910
but how can we just make four question marks in a row,
而是如何仅仅在一行中创建四个问号，

2428
01:53:28,910 --> 01:53:32,790
because I dare say that we do have the building blocks via which to do this.
因为我敢说我们确实有用于实现此目的的构建块。

2429
01:53:32,790 --> 01:53:38,180
Well, the simplest way might be to go over here and run code of mario.c.
好吧，最简单的方法可能是到这里运行 mario.c 的代码。

2430
01:53:38,180 --> 01:53:42,560
And then in mario.c, let's include some stdio.h so we have printf.
然后在 mario.c 中，让我们包含一些 stdio.h，以便我们拥有 printf。

2431
01:53:42,560 --> 01:53:45,200
Let's do int main(void), as we keep doing.
让我们像往常一样做 int main(void)。

2432
01:53:45,200 --> 01:53:47,960
And inside of main, let's keep it super simple--
在 main 内部，让我们保持超级简单——

2433
01:53:47,960 --> 01:53:51,360
1, 2, 3, 4, backslash n.
1，2，3，4，反斜杠 n。

2434
01:53:51,360 --> 01:53:52,880
Doesn't get much simpler than that.
没有比这更简单的了。

2435
01:53:52,880 --> 01:53:54,838
This is not going to be the prettiest of games.
这将不会是最漂亮的游戏。

2436
01:53:54,838 --> 01:54:00,947
But if I make Mario now, ./mario, I get my four question marks in the sky.
但如果我现在创建马里奥，./mario，我将在天空中得到我的四个问号。

2437
01:54:00,947 --> 01:54:02,780
All right, so it's not all that interesting.
好吧，所以这并不那么有趣。

2438
01:54:02,780 --> 01:54:07,287
But this is clearly a candidate for what type of programming feature.
但这显然是哪种编程功能的候选者？

2439
01:54:07,287 --> 01:54:08,565
STUDENT: Scratch.
学生：Scratch。

2440
01:54:08,565 --> 01:54:11,690
DAVID MALAN: Not to Scratch, though Scratch would make it more interesting.
戴维·马兰：不是 Scratch，虽然 Scratch 会让它更有趣。

2441
01:54:11,690 --> 01:54:12,005
yeah?
是吗？

2442
01:54:12,005 --> 01:54:12,320
STUDENT: A loop.
学生：循环。

2443
01:54:12,320 --> 01:54:14,028
DAVID MALAN: So some kind of loop, right?
戴维·马兰：所以某种循环，对吧？

2444
01:54:14,028 --> 01:54:15,980
So print the thing out iteratively instead.
所以用迭代的方式打印出来。

2445
01:54:15,980 --> 01:54:16,730
So let me do that.
所以让我来做。

2446
01:54:16,730 --> 01:54:19,620
Instead of just printing this out all at once,
与其一次性打印所有内容，

2447
01:54:19,620 --> 01:54:25,106
let me go ahead and remove this and do for int i gets zero; i less than 4;
让我继续删除这个，然后做 for int i gets zero; i less than 4;

2448
01:54:25,106 --> 01:54:26,280
i++.
i++。

2449
01:54:26,280 --> 01:54:29,390
And then in here, let me go ahead and print out just one question mark
然后在这里，让我继续打印出一个问号

2450
01:54:29,390 --> 01:54:30,420
instead.
而不是所有。

2451
01:54:30,420 --> 01:54:31,800
And now let's run this.
现在让我们运行一下。

2452
01:54:31,800 --> 01:54:35,210
So "make mario" to recompile it, ./mario.
所以要重新编译它，就输入“make mario”，然后 ./mario。

2453
01:54:35,210 --> 01:54:37,910
And does anyone not want me to hit Enter yet?
还有谁不想让我按回车？

2454
01:54:37,910 --> 01:54:38,855
Why?
为什么？

2455
01:54:38,855 --> 01:54:40,730
STUDENT: Because it's gonna print a new line.
学生：因为这样会打印一个新行。

2456
01:54:40,730 --> 01:54:43,860
DAVID MALAN: Yeah, it's going to print out a new line every time.
戴维·马兰：是的，它每次都会打印一个新行。

2457
01:54:43,860 --> 01:54:48,205
So notice it's four question marks, but there each on its own line.
所以请注意，这里有四个问号，但它们分别占一行。

2458
01:54:48,205 --> 01:54:49,580
All right, well, let me fix this.
好的，让我来解决一下。

2459
01:54:49,580 --> 01:54:51,590
It's obviously because of the backslash n.
很明显，这是因为反斜杠 n。

2460
01:54:51,590 --> 01:54:52,940
So let me remove that.
所以让我把它去掉。

2461
01:54:52,940 --> 01:54:55,850
Let me rerun make mario, ./mario.
让我重新运行 make mario， ./mario。

2462
01:54:55,850 --> 01:54:59,960
And it's better in one way but worse in another.
这样在一个方面有所改进，但在另一方面却更糟糕。

2463
01:54:59,960 --> 01:55:01,910
So wait, but now the dollar sign is doing
等等，但现在美元符号正在

2464
01:55:01,910 --> 01:55:03,785
that thing where it's on the same line, which
做那件事，它在同一行，这

2465
01:55:03,785 --> 01:55:05,550
just looks stupid if nothing else.
至少看起来很蠢。

2466
01:55:05,550 --> 01:55:07,830
So how can I fix that?
那么我怎样才能解决这个问题？

2467
01:55:07,830 --> 01:55:08,400
Yeah?
是吗？

2468
01:55:08,400 --> 01:55:11,070
STUDENT: [INAUDIBLE]
学生：[听不清]

2469
01:55:11,070 --> 01:55:14,070
DAVID MALAN: Yeah, so logically, we don't have that many building blocks
戴维·马兰：是的，所以从逻辑上讲，我们没有那么多的构建块

2470
01:55:14,070 --> 01:55:14,570
today.
今天。

2471
01:55:14,570 --> 01:55:17,200
It's a lot of new syntax, but it's not that many new ideas.
有很多新的语法，但新的想法却不多。

2472
01:55:17,200 --> 01:55:21,330
Let's just use printf to print out literally one and only
让我们只使用 printf 来打印一个，也只有一个

2473
01:55:21,330 --> 01:55:24,690
one of these backslash n's, but outside of the loop so
反斜杠 n，但要在循环之外，这样

2474
01:55:24,690 --> 01:55:27,750
it happens after all four of those have been printed.
它将在这四个被打印之后发生。

2475
01:55:27,750 --> 01:55:30,510
All right, let me do make mario again, ./mario.
好的，让我再次运行 make mario， ./mario。

2476
01:55:30,510 --> 01:55:32,680
And OK, now we're back in business.
好的，我们现在回来了。

2477
01:55:32,680 --> 01:55:35,760
So sort of silly syntactical details, but if you
所以，这是一些愚蠢的语法细节，但如果你

2478
01:55:35,760 --> 01:55:39,750
reduce the problem to its essence, it should hopefully, logically,
将问题简化为其本质，它应该，希望，逻辑上，

2479
01:55:39,750 --> 01:55:41,225
become clear over time.
随着时间的推移会变得清晰。

2480
01:55:41,225 --> 01:55:44,100
All right, well, how about not just something like that but vertical?
好的，怎么样，不仅仅是像这样，而是垂直的？

2481
01:55:44,100 --> 01:55:45,720
Well, we've done something vertical already.
嗯，我们已经做过垂直的事情了。

2482
01:55:45,720 --> 01:55:47,720
And so I can imagine we could change the program
所以我可以想象，我们可以改变程序

2483
01:55:47,720 --> 01:55:51,540
to very simply print out three bricks instead of four question marks.
简单地打印出三个砖块，而不是四个问号。

2484
01:55:51,540 --> 01:55:53,890
But what if we consider a two-dimensional world?
但是如果我们考虑二维世界呢？

2485
01:55:53,890 --> 01:55:55,890
And later on in this game if you go underground,
在游戏的后半部分，如果你进入地下，

2486
01:55:55,890 --> 01:55:57,720
everything looks like this with lots of bricks.
所有东西看起来都像这样，有很多砖块。

2487
01:55:57,720 --> 01:55:59,678
And let me propose, for the sake of discussion,
让我提议，为了讨论起见，

2488
01:55:59,678 --> 01:56:03,947
that this big wall here is like a 3-by-3 grid of bricks.
这堵大墙就像一个 3x3 的砖块网格。

2489
01:56:03,947 --> 01:56:05,280
So it's not just a single brick.
所以它不仅仅是一块砖块。

2490
01:56:05,280 --> 01:56:07,530
It's like three by three, or nine total.
它就像 3x3，或者总共 9 个。

2491
01:56:07,530 --> 01:56:09,450
Now things get interesting.
现在事情变得有趣了。

2492
01:56:09,450 --> 01:56:11,820
And let me go back to mario.c.
让我回到 mario.c。

2493
01:56:11,820 --> 01:56:15,150
I could take the easy road out and just say, all right, well,
我可以走捷径，直接说，好吧，

2494
01:56:15,150 --> 01:56:21,270
let's printf, how about 1, 2, 3, backslash n, close quote.
让我们 printf，怎么样，1、2、3、反斜杠 n、关闭引号。

2495
01:56:21,270 --> 01:56:23,490
And then, OK, let me just copy/paste.
然后，好的，让我复制粘贴。

2496
01:56:23,490 --> 01:56:26,520
And I'm using hashes instead of the actual bricks.
而我使用的是井号而不是真正的砖块。

2497
01:56:26,520 --> 01:56:28,860
But aesthetically, it's pretty close.
但从美学角度来看，它非常接近。

2498
01:56:28,860 --> 01:56:33,073
Let me now go ahead and "make mario" again, ./mario.
现在让我再次运行“make mario”， ./mario。

2499
01:56:33,073 --> 01:56:34,740
And it doesn't quite look like a square.
它看起来不像一个正方形。

2500
01:56:34,740 --> 01:56:37,823
But that's just because the hashes are a little taller than they are wide.
但这仅仅是因为井号比它们宽略高一些。

2501
01:56:37,823 --> 01:56:40,140
But it is correct, but not well designed.
但它是正确的，但设计得不好。

2502
01:56:40,140 --> 01:56:44,430
So here, too, what would be better designed than just hardcoding, typing
所以在这里，除了硬编码和输入之外，还有什么更好的设计方法呢？

2503
01:56:44,430 --> 01:56:48,280
literally all of these hashes?
这些哈希值呢？

2504
01:56:48,280 --> 01:56:49,876
Yeah?
是吗？

2505
01:56:49,876 --> 01:56:51,540
STUDENT: We could use maybe two loops.
学生：也许我们可以使用两个循环。

2506
01:56:51,540 --> 01:56:53,040
DAVID MALAN: Interesting, two loops.
大卫·马兰：有趣，两个循环。

2507
01:56:53,040 --> 01:56:56,080
And why two loops instead of one?
为什么要用两个循环而不是一个循环呢？

2508
01:56:56,080 --> 01:56:57,580
STUDENT: Oh, wait, nevermind.
学生：哦，等等，算了。

2509
01:56:57,580 --> 01:57:00,545
Well, I was going to say you could do it one for vertical and one
嗯，我本来想说你可以用一个循环来表示垂直方向，另一个循环来表示水平方向。

2510
01:57:00,545 --> 01:57:01,170
for horizontal.
表示水平方向。

2511
01:57:01,170 --> 01:57:02,280
DAVID MALAN: OK, it's the right instinct.
大卫·马兰：好的，这是正确的直觉。

2512
01:57:02,280 --> 01:57:04,170
So one for vertical, one for horizontal.
所以一个循环表示垂直方向，另一个循环表示水平方向。

2513
01:57:04,170 --> 01:57:06,060
And even though these predate most of us,
即使这些东西比我们大多数人出现的时间都要早，

2514
01:57:06,060 --> 01:57:08,220
old-school typewriters you might know or might
你可能知道或记得老式打字机，

2515
01:57:08,220 --> 01:57:12,180
recall that if you feed a piece of paper into it, you can print like line,
如果你把一张纸放进去，你可以像这样打印一行，

2516
01:57:12,180 --> 01:57:16,180
then it scrolls, line, then it scrolls, line, then it scrolls.
然后它滚动，一行，然后它滚动，一行，然后它滚动。

2517
01:57:16,180 --> 01:57:18,390
This is kind of how the terminal window works, too.
终端窗口也是这样工作的。

2518
01:57:18,390 --> 01:57:20,970
You can print rows and columns, but you have
你可以打印行和列，但是你必须

2519
01:57:20,970 --> 01:57:24,540
to print one row at a time, one row at a time, one row at a time.
一次打印一行，一次打印一行，一次打印一行。

2520
01:57:24,540 --> 01:57:28,810
It's not easy, but it is possible to go backwards and go up and down.
这并不容易，但可以向后走，上下走。

2521
01:57:28,810 --> 01:57:31,960
But just going row by row by row is more typical.
但是一行一行地走是更常见的。

2522
01:57:31,960 --> 01:57:33,010
So how can I do this?
那么我该怎么做呢？

2523
01:57:33,010 --> 01:57:36,370
Well, I could use at least one and maybe even indeed two loops.
好吧，我至少可以使用一个循环，甚至可以使用两个循环。

2524
01:57:36,370 --> 01:57:39,270
And this is where we're just now composing different ideas
而这正是我们现在将不同的想法组合在一起的地方

2525
01:57:39,270 --> 01:57:40,990
from today and even last week.
来自今天，甚至上周。

2526
01:57:40,990 --> 01:57:45,900
So let me go ahead and say, for int i gets 0; i less than 3--
所以让我说，对于int i获取0；i小于3--

2527
01:57:45,900 --> 01:57:47,370
for a 3-by-3 grid--
对于3x3的网格--

2528
01:57:47,370 --> 01:57:48,810
i++.
i++。

2529
01:57:48,810 --> 01:57:51,180
And now let me cheat slightly.
现在让我稍微作弊一下。

2530
01:57:51,180 --> 01:57:55,790
Let me print out just three of these here, and that's it.
让我在这里打印出这三个，就这些。

2531
01:57:55,790 --> 01:57:56,790
So I'm kind of cheating.
所以我在某种程度上作弊了。

2532
01:57:56,790 --> 01:58:01,360
I'm printing out rows dynamically, but I'm still printing three columns all
我动态地打印行，但我仍然在一次打印三列。

2533
01:58:01,360 --> 01:58:02,170
in one breath.
一口气打印。

2534
01:58:02,170 --> 01:58:03,430
But let's see what happens.
但让我们看看会发生什么。

2535
01:58:03,430 --> 01:58:07,840
Make mario, ./mario, and it does work.
创建马里奥，./马里奥，它确实有效。

2536
01:58:07,840 --> 01:58:12,610
But what if you said, no, I want 4 by 4 or 5 by 5 or 6 by 6?
但是如果你说，不，我想要4x4或者5x5或者6x6呢？

2537
01:58:12,610 --> 01:58:17,590
Now I have to change the 3 to a 6, and I have to add another three hashes here.
现在我必须把3改为6，并且我必须在这里添加另外三个哈希值。

2538
01:58:17,590 --> 01:58:20,180
Things get messy if we don't do this mathematically.
如果我们不以数学的方式这样做，事情就会变得很乱。

2539
01:58:20,180 --> 01:58:22,120
So let me now do this instead.
所以现在让我这样做。

2540
01:58:22,120 --> 01:58:26,440
Why don't I go ahead and print out every row at a time.
为什么我不一次打印一行呢？

2541
01:58:26,440 --> 01:58:30,340
But for each row, let me use another loop to decide, like, rat-a-tat-tat,
但是对于每一行，让我使用另一个循环来决定，比如，哒哒哒，

2542
01:58:30,340 --> 01:58:33,010
from left to right, how many do I want to print.
从左到右，我想打印多少个。

2543
01:58:33,010 --> 01:58:35,890
So to do this, I could do another for loop.
所以为了做到这一点，我可以使用另一个for循环。

2544
01:58:35,890 --> 01:58:39,050
I could call this variable something different. j is pretty common.
我可以给这个变量起一个不同的名字。j很常见。

2545
01:58:39,050 --> 01:58:40,480
We start at i, we go to j.
我们从i开始，我们到j。

2546
01:58:40,480 --> 01:58:43,720
If you go past k, maybe l, you're probably doing something wrong.
如果你超过k，也许是l，你可能做错了什么。

2547
01:58:43,720 --> 01:58:46,990
You don't want nested, nested, nested loops, but two is OK.
你不想使用嵌套、嵌套、嵌套的循环，但两个循环是可以的。

2548
01:58:46,990 --> 01:58:52,480
j equals 0; j is less than 3; j++.
j等于0；j小于3；j++。

2549
01:58:52,480 --> 01:58:57,178
And then here, I can print out a single one of these and no new line.
然后在这里，我可以打印出一个，并且没有换行符。

2550
01:58:57,178 --> 01:58:58,970
I don't want to screw up like I did before.
我不想像以前那样搞砸了。

2551
01:58:58,970 --> 01:59:00,340
So I'll just do one.
所以我就做一次。

2552
01:59:00,340 --> 01:59:03,970
Let me go ahead and do make mario now, ./mario.
让我现在来做 make mario，./mario。

2553
01:59:03,970 --> 01:59:06,482
But when I hit Enter, this is not correct yet.
但是当我按下回车键时，这还不正确。

2554
01:59:06,482 --> 01:59:07,690
What's it going to look like?
它会是什么样子？

2555
01:59:07,690 --> 01:59:09,130
STUDENT: A single line?
学生：一条线？

2556
01:59:09,130 --> 01:59:12,040
DAVID MALAN: A single line of nine hashes, I think,
大卫·马兰：我想是一条有九个井号的线，

2557
01:59:12,040 --> 01:59:14,980
because I never used a single backslash n.
因为我从未使用过一个反斜杠 n。

2558
01:59:14,980 --> 01:59:16,220
So that looks wrong.
所以看起来不对。

2559
01:59:16,220 --> 01:59:23,620
So between what line number should I insert a printf of backslash n?
那么我应该在哪个行号之间插入一个打印反斜杠 n 的语句？

2560
01:59:23,620 --> 01:59:25,660
Let me look a little farther back if I can.
如果可以，让我再往回看看。

2561
01:59:25,660 --> 01:59:26,920
How about over here?
这里怎么样？

2562
01:59:26,920 --> 01:59:27,520
Yeah?
是吗？

2563
01:59:27,520 --> 01:59:28,720
STUDENT: 10 and 11.
学生：10 和 11 之间。

2564
01:59:28,720 --> 01:59:30,280
DAVID MALAN: Between 10 and 11.
大卫·马兰：在 10 和 11 之间。

2565
01:59:30,280 --> 01:59:31,580
So I'm going to go in here.
所以我要到这里。

2566
01:59:31,580 --> 01:59:34,930
I'm going to add printf, quote, unquote, "backslash n" semicolon.
我要添加 printf，引号，引号，“反斜杠 n” 分号。

2567
01:59:34,930 --> 01:59:37,380
Let me go back and recompile mario--
让我回去重新编译 mario--

2568
01:59:37,380 --> 01:59:38,290
./mario.
./mario。

2569
01:59:38,290 --> 01:59:41,320
And crossing fingers-- voila, perfect.
然后祈祷-- 瞧，完美。

2570
01:59:41,320 --> 01:59:43,210
I printed out now a 3-by-3.
我现在打印了一个 3x3 的。

2571
01:59:43,210 --> 01:59:44,440
Now, it's correct.
现在，它是正确的。

2572
01:59:44,440 --> 01:59:48,130
It's not, if we want to be really nitpicky, maybe still not
如果我们真的要挑剔的话，它可能仍然不是

2573
01:59:48,130 --> 01:59:49,240
the best design.
最好的设计。

2574
01:59:49,240 --> 01:59:51,310
Where am I perhaps repeating myself?
我可能在哪里重复了自己？

2575
01:59:53,840 --> 01:59:54,627
Yeah?
是吗？

2576
01:59:54,627 --> 01:59:55,770
STUDENT: [INAUDIBLE]
学生：[听不清]

2577
01:59:55,770 --> 01:59:57,770
DAVID MALAN: Yeah, I mean, it's not a huge deal.
大卫·马兰：是的，我的意思是，这没什么大不了的。

2578
01:59:57,770 --> 02:00:00,247
But now I have two, people would call these magic numbers.
但是现在我有两个，人们会称之为魔数。

2579
02:00:00,247 --> 02:00:02,330
"Magic" in the sense of, where did that come from?
“魔数”的意思是，它从哪里来的？

2580
02:00:02,330 --> 02:00:05,100
You just randomly put it in the middle of your code.
你只是随机把它放在代码的中间。

2581
02:00:05,100 --> 02:00:06,878
And you also put the same thing here.
你也把相同的东西放在这里。

2582
02:00:06,878 --> 02:00:10,170
Now I have to make sure I don't screw up and make one change but not the other.
现在我必须确保我不会搞砸，做了一个改变，但另一个没有改变。

2583
02:00:10,170 --> 02:00:11,837
So it turns out we can factor these out.
所以事实证明我们可以把它们分解出来。

2584
02:00:11,837 --> 02:00:15,050
I can actually do something like this, int n equals 3.
我实际上可以这样做，int n 等于 3。

2585
02:00:15,050 --> 02:00:17,690
And then I can just change this to n and this
然后我可以把这个改成 n，把这个

2586
02:00:17,690 --> 02:00:19,730
to n, which is marginally better because now
改成 n，这稍微好一点，因为现在

2587
02:00:19,730 --> 02:00:22,160
I only have to change n in one place if I want
如果我想改变这个东西的大小，我只需要在一个地方改变 n。

2588
02:00:22,160 --> 02:00:24,113
to make this thing bigger or smaller.
让它变大或变小。

2589
02:00:24,113 --> 02:00:25,530
It's still going to work the same.
它仍然会以同样的方式工作。

2590
02:00:25,530 --> 02:00:27,830
So make mario, ./mario.
所以 make mario，./mario。

2591
02:00:27,830 --> 02:00:28,880
There's our 3-by-3.
这是我们的 3x3。

2592
02:00:28,880 --> 02:00:35,120
But if I want to make a 5-by-5, let me change the n to 5, rerun make mario,
但是如果我想做一个 5x5 的，让我把 n 改成 5，重新运行 make mario，

2593
02:00:35,120 --> 02:00:35,900
./mario.
./mario。

2594
02:00:35,900 --> 02:00:38,480
And now it's a bigger grid, 5-by-5.
现在它是一个更大的网格，5x5。

2595
02:00:38,480 --> 02:00:40,162
But this is a little fragile.
但这有点脆弱。

2596
02:00:40,162 --> 02:00:42,620
And it turns out there's another trick we should introduce.
事实证明，我们应该引入另一个技巧。

2597
02:00:42,620 --> 02:00:45,590
It turns out that C supports what are called constants,
事实证明，C 语言支持所谓的常量，

2598
02:00:45,590 --> 02:00:48,920
whereby if you have a variable that you want to exist because it's useful
也就是说，如果你有一个变量，你希望它存在，因为它很有用

2599
02:00:48,920 --> 02:00:50,857
but you don't want to accidentally change it,
但是你又不想意外地改变它，

2600
02:00:50,857 --> 02:00:53,690
or if you're working with a partner in class or a colleague at work,
或者如果你在课堂上与搭档合作或在工作中与同事合作，

2601
02:00:53,690 --> 02:00:57,140
you don't want your partner or colleague to accidentally change
你不想你的搭档或同事意外更改

2602
02:00:57,140 --> 02:01:01,250
that value with their own code, you can go into your code and tell C,
该值使用他们自己的代码，你可以进入你的代码并告诉 C，

2603
02:01:01,250 --> 02:01:05,790
this is actually a constant integer, a const, so to speak.
这实际上是一个常数整数，一个 const，可以这么说。

2604
02:01:05,790 --> 02:01:07,790
And this will just prevent you or someone else
这将阻止你或其他人

2605
02:01:07,790 --> 02:01:11,430
from doing something stupid by accidentally changing it elsewhere.
意外地将它更改在其他地方而做一些愚蠢的事情。

2606
02:01:11,430 --> 02:01:14,510
The code is still going to work the same, ./mario,
代码仍然会以相同的方式工作，./mario，

2607
02:01:14,510 --> 02:01:18,690
but you won't be accidentally able to change it very easily to something
但你不会很容易地意外地将它更改为某物

2608
02:01:18,690 --> 02:01:19,190
else.
别的。

2609
02:01:19,190 --> 02:01:22,160
And honestly, what we've now done, too, is set ourselves
坦率地说，我们现在也做的事情，是让自己

2610
02:01:22,160 --> 02:01:23,420
up to make this more dynamic.
能够让它更具动态性。

2611
02:01:23,420 --> 02:01:27,920
Let me go up here, and let me add the CS50 library so that we have access
让我到这里，让我添加 CS50 库，以便我们可以访问

2612
02:01:27,920 --> 02:01:30,050
to get_int because now we could do something
get_int，因为现在我们可以做一些事情

2613
02:01:30,050 --> 02:01:36,920
fancy like ask the get_int function for the size of this brick wall.
有趣的事情，比如向 get_int 函数询问这堵砖墙的大小。

2614
02:01:36,920 --> 02:01:39,150
And then we can use n dynamically.
然后我们可以动态地使用 n。

2615
02:01:39,150 --> 02:01:42,300
So for instance, let me increase the size of my terminal, make mario,
例如，让我增加终端的大小，创建 mario，

2616
02:01:42,300 --> 02:01:45,140
./mario, size 3.
./mario，大小为 3。

2617
02:01:45,140 --> 02:01:47,150
Gives me a 3-by-3.
给我一个 3x3 的。

2618
02:01:47,150 --> 02:01:50,000
./mario size 5 gives me a 5-by-5.
./mario 大小为 5 给我一个 5x5 的。

2619
02:01:50,000 --> 02:01:54,600
./mario, how about 50, gives me a crazy big one, but it's all dynamic.
./mario，50 怎么样，给我一个超大的，但它都是动态的。

2620
02:01:54,600 --> 02:01:56,760
And now I don't have to even change the code.
现在我甚至不需要更改代码。

2621
02:01:56,760 --> 02:01:58,980
It just now works.
它现在就可以工作了。

2622
02:01:58,980 --> 02:02:01,500
As an aside, if you're wondering how I type so darn fast,
顺便说一句，如果你想知道我为什么打字这么快，

2623
02:02:01,500 --> 02:02:03,900
sometimes it's just because I'm hitting the up arrow.
有时只是因为我在按向上箭头。

2624
02:02:03,900 --> 02:02:06,600
It turns out that Linux will remember, if you
事实证明，如果你配置 Linux，它会记住

2625
02:02:06,600 --> 02:02:08,860
configure it this way, all of your previous commands.
以这种方式，你之前的所有命令。

2626
02:02:08,860 --> 02:02:12,480
So if you hit up, up, up, I can go through the past couple of hours
所以如果你按向上，向上，向上，我可以查看过去几个小时

2627
02:02:12,480 --> 02:02:14,820
of commands that I've typed, which is useful sometimes--
我输入的命令，这有时很有用——

2628
02:02:14,820 --> 02:02:16,950
not for hours of commands but the past few--
不是几个小时的命令，而是过去几个——

2629
02:02:16,950 --> 02:02:18,810
just to save yourself some keystrokes.
只是为了节省一些按键。

2630
02:02:18,810 --> 02:02:22,110
And another trick in a terminal window is to do this.
在终端窗口中，还有一个技巧。

2631
02:02:22,110 --> 02:02:28,050
If I do ./ma and I get bored and I don't want to type out "rio,"
如果我输入 ./ma，我厌倦了，不想再打出 “rio”，

2632
02:02:28,050 --> 02:02:31,800
I can also just hit Tab, and it will autocomplete based on the characters
我也可以直接按 Tab 键，它会根据匹配的字符自动补全。

2633
02:02:31,800 --> 02:02:32,470
that do match.
匹配的字符。

2634
02:02:32,470 --> 02:02:36,990
So those kinds of tricks, too, will save you time over time.
所以，这些技巧也能随着时间的推移节省你的时间。

2635
02:02:36,990 --> 02:02:38,070
But let's do this.
但让我们试试这个。

2636
02:02:38,070 --> 02:02:41,880
It's kind of broken, arguably, if I do this.
如果我这样做，可以说它有点问题。

2637
02:02:41,880 --> 02:02:44,400
How about "cat?"
“cat” 怎么样？

2638
02:02:44,400 --> 02:02:45,900
All right, well, that works.
好的，它确实可以。

2639
02:02:45,900 --> 02:02:48,480
That prevents me from doing something stupid
这阻止了我做一些愚蠢的事情

2640
02:02:48,480 --> 02:02:51,120
because get_int only accepts integers.
因为 get_int 只接受整数。

2641
02:02:51,120 --> 02:02:54,000
But it will accept 0, which does nothing.
但它会接受 0，它什么也不做。

2642
02:02:54,000 --> 02:02:56,370
It will accept negative 1, which does nothing.
它会接受负 1，它什么也不做。

2643
02:02:56,370 --> 02:02:57,600
And that's not bad.
这不是坏事。

2644
02:02:57,600 --> 02:02:59,040
It's not doing something weird.
它没有做一些奇怪的事情。

2645
02:02:59,040 --> 02:03:01,890
But it would be nice to catch that and force the user
但如果能捕获到这一点，并强制用户

2646
02:03:01,890 --> 02:03:04,410
to give us a positive integer instead so we at least
给我们一个正整数，这样我们至少

2647
02:03:04,410 --> 02:03:05,732
see something on the screen.
在屏幕上看到一些东西。

2648
02:03:05,732 --> 02:03:08,190
So let me go back into my code, and let me propose that now
所以让我回到我的代码，并且我现在建议

2649
02:03:08,190 --> 02:03:12,018
that we have the CS50 library, why don't we do something like this?
既然我们有了 CS50 库，为什么不尝试一下呢？

2650
02:03:12,018 --> 02:03:13,060
I'm going to change this.
我要更改一下。

2651
02:03:13,060 --> 02:03:14,640
I'm going to get rid of the constant just in case
为了以防万一，我要去掉这个常数

2652
02:03:14,640 --> 02:03:16,080
the user needs to type it again.
用户需要重新输入。

2653
02:03:16,080 --> 02:03:17,250
And what if I do this?
如果我这样做呢？

2654
02:03:17,250 --> 02:03:20,070
While n is less than 1--
当 n 小于 1 时...

2655
02:03:20,070 --> 02:03:23,610
so if it's 0, negative 1, negative 2, or whatever, let's go ahead
所以如果是 0、负 1、负 2 或其他，让我们继续

2656
02:03:23,610 --> 02:03:28,860
and again ask the user for an int, and ask them for the size again.
并再次询问用户一个整型值，并再次询问他们大小。

2657
02:03:28,860 --> 02:03:33,780
And therefore, only once n is not less than 1 will
因此，只有当 n 不小于 1 时，

2658
02:03:33,780 --> 02:03:36,670
this loop break out and will proceed with the rest of the code.
这个循环才会跳出并继续执行代码的其余部分。

2659
02:03:36,670 --> 02:03:37,770
So now let me try this.
现在让我试试。

2660
02:03:37,770 --> 02:03:42,120
Make mario, ./mario 0--
创建 mario，./mario 0...

2661
02:03:42,120 --> 02:03:42,960
didn't like that.
不喜欢这样。

2662
02:03:42,960 --> 02:03:44,370
Negative 1-- didn't like that.
负 1...不喜欢这样。

2663
02:03:44,370 --> 02:03:45,810
Negative 2-- didn't like that.
负 2...不喜欢这样。

2664
02:03:45,810 --> 02:03:48,640
3-- it did like that.
3...它喜欢这样。

2665
02:03:48,640 --> 02:03:52,950
So using a loop now, I can ensure that the human is providing me
现在使用循环，我可以确保用户提供给我

2666
02:03:52,950 --> 02:03:55,810
with input that I actually want.
我真正想要的输入。

2667
02:03:55,810 --> 02:03:57,180
So this is correct.
所以这是正确的。

2668
02:03:57,180 --> 02:04:01,140
But I dare say 6 through 10 could be done better.
但我敢说 6 到 10 可以做得更好。

2669
02:04:01,140 --> 02:04:06,580
Why is this poorly designed instinctively?
为什么这直觉上设计得很糟糕？

2670
02:04:06,580 --> 02:04:07,080
Yeah?
是吧？

2671
02:04:07,080 --> 02:04:07,930
STUDENT: There's repetition.
学生：存在重复。

2672
02:04:07,930 --> 02:04:10,600
DAVID MALAN: What's the repetition, to be clear, what lines?
大卫·马兰：重复的是什么，说清楚点，是哪几行？

2673
02:04:10,600 --> 02:04:12,145
STUDENT: Lines 6 and 9.
学生：第 6 行和第 9 行。

2674
02:04:12,145 --> 02:04:13,240
DAVID MALAN: 6 and 9.
大卫·马兰：第 6 行和第 9 行。

2675
02:04:13,240 --> 02:04:16,400
OK, so they're literally the same, and that's generally not a good thing.
好的，它们完全一样，这通常不是一件好事。

2676
02:04:16,400 --> 02:04:19,390
And maybe I could change this one to remind the user like, hey,
也许我可以修改这行代码，提醒用户，嘿，

2677
02:04:19,390 --> 02:04:20,688
that's not a positive number.
这不是一个正数。

2678
02:04:20,688 --> 02:04:22,480
So you might want to customize the message.
所以你可能想要自定义消息。

2679
02:04:22,480 --> 02:04:26,390
But just having copy/paste here for the most part is not a good thing.
但仅仅在这里进行复制粘贴，在很大程度上不是一件好事。

2680
02:04:26,390 --> 02:04:29,770
So it turns out-- and there's just one feature of C we wanted to introduce you
事实证明——我们今天想向你介绍 C 语言的一个特性——事实证明，还有一个方法可以帮助我们

2681
02:04:29,770 --> 02:04:33,400
to today-- it turns out there's one other way that would actually help us
消除使用 get_int 两次，尤其是询问

2682
02:04:33,400 --> 02:04:37,450
eliminate this redundancy of using get_int twice and particularly asking
完全相同的问题——大小——

2683
02:04:37,450 --> 02:04:39,670
literally the same question-- size--
两次重复。

2684
02:04:39,670 --> 02:04:40,990
twice in duplicate.
两次重复。

2685
02:04:40,990 --> 02:04:42,937
So I'm actually going to go into my code here,
所以我要进入我的代码，

2686
02:04:42,937 --> 02:04:45,520
and I'm going to delete the loop as we've written it thus far.
并且我要删除我们目前为止编写的循环。

2687
02:04:45,520 --> 02:04:47,750
And instead of using a while loop, I'm going
而不是使用 while 循环，我将

2688
02:04:47,750 --> 02:04:49,750
to introduce instead something that we typically
引入一个我们通常

2689
02:04:49,750 --> 02:04:52,960
call a do while loop, which is a little bit different.
称为 do while 循环，它略有不同。

2690
02:04:52,960 --> 02:04:55,360
Indeed, we begin with the keyword "do," and then
事实上，我们从关键字“do”开始，然后

2691
02:04:55,360 --> 02:04:57,850
inside of the curly braces, what I'm going to do here
在花括号内，我要在这里做的事情

2692
02:04:57,850 --> 02:05:02,690
is that thing I might want to do once and more times thereafter.
是我可能想做一次，然后再次做的事情。

2693
02:05:02,690 --> 02:05:08,690
So for instance, I'm going to say n equals get_int quote, unquote, "size."
例如，我要说 n 等于 get_int，引号，引号，"size"。

2694
02:05:08,690 --> 02:05:12,110
And then at the bottom of this block of code, then
然后在这段代码块的底部，

2695
02:05:12,110 --> 02:05:15,380
I'm going to use the keyword "while," as well as parentheses as always
我要使用关键字“while”，以及始终使用的括号

2696
02:05:15,380 --> 02:05:16,740
for a Boolean expression.
用于布尔表达式。

2697
02:05:16,740 --> 02:05:17,280
And here.
以及这里。

2698
02:05:17,280 --> 02:05:21,500
I'm going to ask the question, do this while n is less than 1.
我要问一个问题，当 n 小于 1 时，执行这段代码。

2699
02:05:21,500 --> 02:05:25,250
But there's one fix I still need to do here because notice on the current line
但是，这里还有一处需要修复的地方，因为请注意当前行

2700
02:05:25,250 --> 02:05:28,280
8, I actually haven't given n a type.
8，实际上我还没有给 n 指定类型。

2701
02:05:28,280 --> 02:05:29,990
I haven't declared n yet.
我还没有声明 n。

2702
02:05:29,990 --> 02:05:37,100
But it would not be correct to declare n here, inside of that do block.
但是在这里，在这个 do 代码块中声明 n 是不正确的。

2703
02:05:37,100 --> 02:05:39,060
But why might that be?
但是为什么呢？

2704
02:05:39,060 --> 02:05:44,780
Why would it not be a good thing to declare n inside of these curly braces?
为什么在这些花括号内声明 n 不是一个好主意呢？

2705
02:05:44,780 --> 02:05:47,240
Yeah, so recall that this is an issue of scope.
是的，请记住，这是一个作用域问题。

2706
02:05:47,240 --> 02:05:49,820
Recall that the scope of a variable is generally
请记住，变量的作用域通常

2707
02:05:49,820 --> 02:05:53,690
confined to the most recently opened curly braces in which that variable is
被限定在最近打开的花括号中，其中该变量是

2708
02:05:53,690 --> 02:05:54,230
declared.
声明的。

2709
02:05:54,230 --> 02:05:56,690
And so if I declare this variable on line 8,
所以如果我在第 8 行声明这个变量，

2710
02:05:56,690 --> 02:05:58,845
I'm not going to be able to use it on line 10.
我将无法在第 10 行使用它。

2711
02:05:58,845 --> 02:06:01,470
But there is a fix, even though it might look a little strange.
但是，即使它看起来有点奇怪，也有一种解决办法。

2712
02:06:01,470 --> 02:06:04,020
I'm going to go above my do block here.
我要到我的 do 代码块上面去。

2713
02:06:04,020 --> 02:06:06,290
And before I go into this loop, I'm actually
在进入这个循环之前，我实际上

2714
02:06:06,290 --> 02:06:10,183
going to declare n to be an integer, but semicolon, end of thought.
要声明 n 是一个整数，但分号，思想结束。

2715
02:06:10,183 --> 02:06:12,350
I'm not going to bother giving it a value, because I
我不会费心给它赋值，因为我知道

2716
02:06:12,350 --> 02:06:17,000
know logically I'm going to end up giving it a value anyway now on line 9.
从逻辑上讲，我现在最终会在第 9 行给它赋值。

2717
02:06:17,000 --> 02:06:19,400
And so what's different about this version of the code
所以，这个版本的代码有什么不同

2718
02:06:19,400 --> 02:06:24,200
is that the do while loop ensures that we prompt the user for input at least
是 do while 循环确保我们至少提示用户输入一次

2719
02:06:24,200 --> 02:06:24,740
once.
。

2720
02:06:24,740 --> 02:06:30,140
And then while that input is not what we expect, for instance less than 1, then
然后，当输入不符合我们的预期时，例如小于 1，那么

2721
02:06:30,140 --> 02:06:32,583
it's going to execute again, again, again.
它会再次执行，再次执行，再次执行。

2722
02:06:32,583 --> 02:06:34,250
And indeed, the semantics are just that.
实际上，语义就是这样。

2723
02:06:34,250 --> 02:06:38,460
Do the following while this Boolean expression is true.
当这个布尔表达式为真时，执行以下操作。

2724
02:06:38,460 --> 02:06:44,180
So if I go ahead now and rerun make mario, compiles OK-- ./mario.
所以，如果我现在继续运行 make mario，编译成功-- ./mario。

2725
02:06:44,180 --> 02:06:48,140
And now I'll go ahead and input something that's not correct, like 0.
现在，我将输入一些不正确的东西，比如 0。

2726
02:06:48,140 --> 02:06:49,340
But I'm prompted again.
但是我又被提示了。

2727
02:06:49,340 --> 02:06:52,250
I'll input something like negative 1, and I'm prompted again.
我将输入类似负 1 的东西，然后我又被提示了。

2728
02:06:52,250 --> 02:06:54,920
But if I go ahead and input, for instance, 10,
但是如果我继续输入，例如，10，

2729
02:06:54,920 --> 02:07:02,060
now, because that's a positive integer, I indeed get a 10-by-10 grid of bricks.
现在，因为这是一个正整数，我确实得到一个 10x10 的砖块网格。

2730
02:07:02,060 --> 02:07:05,110
And there's one other thing we should introduce here, too, in C, too.
在 C 中，我们也应该在这里介绍另一件事。

2731
02:07:05,110 --> 02:07:06,022
C supports comments.
C 支持注释。

2732
02:07:06,022 --> 02:07:07,730
And a couple of you have asked about this
你们中的一些人问过这个问题

2733
02:07:07,730 --> 02:07:09,740
if you come from other programming languages.
如果你来自其他编程语言。

2734
02:07:09,740 --> 02:07:13,070
Suppose I want to remember what it is I just did with this program.
假设我想记住我刚刚用这个程序做了什么。

2735
02:07:13,070 --> 02:07:20,120
Let me go in between lines 5 and 6 here and do "// prompt user for positive
让我在这里在第 5 行和第 6 行之间加上 "// prompt user for positive

2736
02:07:20,120 --> 02:07:20,713
integer."
integer."

2737
02:07:20,713 --> 02:07:22,130
This is what's known as a comment.
这就是所谓的注释。

2738
02:07:22,130 --> 02:07:25,378
And it's grayed out only in the sense that the compiler is not
它只是在灰色的意义上，编译器不会

2739
02:07:25,378 --> 02:07:26,420
going to care about this.
关心这件事。

2740
02:07:26,420 --> 02:07:28,295
The computer is not going to care about this.
计算机不会关心这件事。

2741
02:07:28,295 --> 02:07:31,430
This is a note to self, like a sticky note in the context of Scratch.
这就像在 Scratch 中的一个便签，是自己给自己留的便签。

2742
02:07:31,430 --> 02:07:35,000
And it starts with "//," which essentially tells the compiler ignore
它以 "//" 开头，这实质上告诉编译器忽略

2743
02:07:35,000 --> 02:07:37,490
this, this is for the human, not for the computer.
这个，这个是给人看的，不是给计算机看的。

2744
02:07:37,490 --> 02:07:41,270
But this comment, so to speak, is a way of just reminding yourself, reminding
但是，这个注释，可以这么说，是一种提醒自己、提醒自己的方式，

2745
02:07:41,270 --> 02:07:43,520
your colleague, reminding your TF what it
你的同事，提醒你的 TF 是什么

2746
02:07:43,520 --> 02:07:46,460
is a few lines of code are meant to do.
几行代码应该做什么。

2747
02:07:46,460 --> 02:07:53,930
And now this comment might be print, and how about n-by-n grid of bricks?
现在这个注释可能是打印的，那么n*n的砖块网格呢？

2748
02:07:53,930 --> 02:07:57,890
And what's nice about comments is that theoretically you can get away with,
注释的好处是，理论上你可以摆脱，

2749
02:07:57,890 --> 02:08:00,440
or someone else can get away with, just reading this comment
或者其他人可以摆脱，只读这个注释

2750
02:08:00,440 --> 02:08:02,787
and then not even have to look at the rest of the code.
然后甚至不必看代码的其余部分。

2751
02:08:02,787 --> 02:08:05,870
They can look at this comment and not have to look at the rest of the code
他们可以查看此注释，而不必查看代码的其余部分

2752
02:08:05,870 --> 02:08:09,195
because you've described for them what it's meant to do.
因为你已经为他们描述了它应该做什么。

2753
02:08:09,195 --> 02:08:09,695
Yeah?
是吗？

2754
02:08:09,695 --> 02:08:13,020
STUDENT: I just had a question about the hashtag [INAUDIBLE]
学生：我有一个关于井号 [听不清] 的问题

2755
02:08:13,020 --> 02:08:14,790
DAVID MALAN: Sure.
大卫·马兰：当然。

2756
02:08:14,790 --> 02:08:16,440
STUDENT: That's for [INAUDIBLE]
学生：那是 [听不清] 的

2757
02:08:16,440 --> 02:08:19,080
DAVID MALAN: Correct, the hash sign in Python is a comment,
大卫·马兰：正确，在 Python 中，井号是注释，

2758
02:08:19,080 --> 02:08:24,360
is not the same thing in C. In C, hash include means to include the library's
在 C 中则不是这样。在 C 中，hash include 表示包含库的

2759
02:08:24,360 --> 02:08:26,320
header files in that way.
头文件。

2760
02:08:26,320 --> 02:08:28,290
Other questions on these here tricks?
还有其他关于这些技巧的问题吗？

2761
02:08:31,060 --> 02:08:31,600
No?
没有？

2762
02:08:31,600 --> 02:08:37,810
All right, so as promised, what is maybe C not actually good at?
好吧，正如承诺的那样，C 可能不擅长什么？

2763
02:08:37,810 --> 02:08:40,840
Well, let me propose that we consider what's
好吧，我想建议我们考虑一下什么是

2764
02:08:40,840 --> 02:08:42,280
actually inside of your computer.
实际上在你电脑里。

2765
02:08:42,280 --> 02:08:45,340
At the end of the day, whether it's a Mac, PC, iPhone, Android, phone,
归根结底，无论是 Mac、PC、iPhone、Android 手机，

2766
02:08:45,340 --> 02:08:48,257
or some other computer device, there's something that looks like this.
还是其他任何电脑设备，都有一些东西看起来像这样。

2767
02:08:48,257 --> 02:08:51,423
And this is memory, otherwise known as RAM, or random access memory,
这就是内存，也称为 RAM，即随机存取内存，

2768
02:08:51,423 --> 02:08:53,090
for reasons we'll get to in a few weeks.
原因我们将在几周后讲到。

2769
02:08:53,090 --> 02:08:54,770
But this is where data is stored.
但数据就存储在这里。

2770
02:08:54,770 --> 02:08:56,570
This is where "hello, world" is stored.
“hello, world” 就存储在这里。

2771
02:08:56,570 --> 02:08:59,200
This is where 1 and 2 and all of those numbers are stored.
1 和 2 以及所有这些数字都存储在这里。

2772
02:08:59,200 --> 02:09:03,590
Any data in your program is stored ultimately in the computer's memory.
程序中的任何数据最终都存储在计算机的内存中。

2773
02:09:03,590 --> 02:09:06,460
And the most important takeaway for today is that all of us
今天最重要的收获是，我们所有人

2774
02:09:06,460 --> 02:09:10,090
only have a finite amount of memory in our devices.
在我们的设备中只有有限的内存。

2775
02:09:10,090 --> 02:09:12,970
You might have a high-end device which has a lot of memory,
你可能有一个高端设备，它有很大的内存，

2776
02:09:12,970 --> 02:09:15,970
but it's still finite, which means you can only
但它仍然是有限的，这意味着你只能

2777
02:09:15,970 --> 02:09:17,650
count so high with that device.
用那个设备数到那么高。

2778
02:09:17,650 --> 02:09:20,150
You can only store so many files with that device.
你只能用那个设备存储那么多文件。

2779
02:09:20,150 --> 02:09:24,730
There are fundamental physical limitations even though mathematically,
即使在数学上，也存在基本的物理限制，

2780
02:09:24,730 --> 02:09:27,617
theoretically, we should be able to count toward infinity.
理论上，我们应该能够数到无穷大。

2781
02:09:27,617 --> 02:09:29,200
So what are the implications for this?
那么，这对我们有什么影响呢？

2782
02:09:29,200 --> 02:09:30,530
Well, consider this.
好吧，想想看。

2783
02:09:30,530 --> 02:09:34,677
In the world of numbers, as per week 0, if you're only using three digits--
在数字世界中，按照第 0 周，如果你只使用三位数——

2784
02:09:34,677 --> 02:09:37,760
and I've grayed out the fourth one just to make the point-- if you're only
我把第四位数涂成灰色，只是为了说明这一点——如果你只

2785
02:09:37,760 --> 02:09:43,750
using three digits, we can count from 0 to 1 in decimal, to 2, to3, to 4,
使用三位数，我们可以从 0 数到 1（十进制），到 2，到 3，到 4，

2786
02:09:43,750 --> 02:09:47,030
to 5, to 6, to 7.
到 5，到 6，到 7。

2787
02:09:47,030 --> 02:09:50,180
And as soon as you count to 8, you technically, per last week,
一旦你数到 8，你就需要，根据上周的内容，

2788
02:09:50,180 --> 02:09:51,600
need a fourth bit.
需要第四位。

2789
02:09:51,600 --> 02:09:55,970
But if you don't have it, the number 7 might seem
但如果你没有，数字 7 可能会看起来

2790
02:09:55,970 --> 02:09:58,770
to be followed by what number instead?
紧跟着什么数字？

2791
02:09:58,770 --> 02:09:59,450
STUDENT: 0.
学生：0。

2792
02:09:59,450 --> 02:10:00,380
DAVID MALAN: 0.
大卫·马兰：0。

2793
02:10:00,380 --> 02:10:03,260
The number overflows, so to speak, right?
这个数字就溢出了，可以这么说，对吧？

2794
02:10:03,260 --> 02:10:04,155
You carry the 1.
你进位了1。

2795
02:10:04,155 --> 02:10:07,280
But if there's no place to put the 1, because there's no fourth light bulb,
但如果没地方放这个1，因为没有第四个灯泡，

2796
02:10:07,280 --> 02:10:09,740
if there's no fourth transistor, if there's no fourth bit,
如果第四个晶体管不存在，如果第四个位不存在，

2797
02:10:09,740 --> 02:10:14,180
the lower bits, the zeros, are going to be mistaken for the number you
那些较低的位，那些0，会被误认为是你

2798
02:10:14,180 --> 02:10:15,080
and I know is 0.
以及我知道的数字0。

2799
02:10:15,080 --> 02:10:18,410
So integer overflow is a thing in computers
所以整数溢出是计算机中的一件事

2800
02:10:18,410 --> 02:10:21,560
whereby if you don't have enough memory, if you count high enough,
如果内存不足，如果你计数足够高，

2801
02:10:21,560 --> 02:10:23,690
the number will wrap around back to 0.
这个数字就会回绕到0。

2802
02:10:23,690 --> 02:10:26,210
Or sometimes it will wrap around to a negative number,
或者有时它会回绕到一个负数，

2803
02:10:26,210 --> 02:10:30,350
depending on whether the code supports negative and positive numbers and 0
取决于代码是否支持负数、正数和0

2804
02:10:30,350 --> 02:10:30,950
alike.
等等。

2805
02:10:30,950 --> 02:10:33,080
So that has some very real world implications
所以这在现实世界中有一些非常实际的影响

2806
02:10:33,080 --> 02:10:36,590
in integer overflow that's sort of a fundamental limitation of how
在整数溢出中，这是一种关于如何处理数字的基本限制。

2807
02:10:36,590 --> 02:10:37,850
numbers are typically stored.
数字通常是如何存储的。

2808
02:10:37,850 --> 02:10:39,980
Now, thankfully, we typically don't store things
现在，谢天谢地，我们通常不存储东西

2809
02:10:39,980 --> 02:10:42,590
based on number of digits but number of bits.
是基于位数而是基于位数。

2810
02:10:42,590 --> 02:10:44,270
And a bit is just a 0 or 1.
一个位仅仅是0或1。

2811
02:10:44,270 --> 02:10:46,820
And recall from last week that a common unit of measure
还记得上周我们提到的一个常见计量单位

2812
02:10:46,820 --> 02:10:51,080
is minimally eight bits, or a byte, but even more commonly is 32.
是至少8位，也就是一个字节，但更常见的是32位。

2813
02:10:51,080 --> 02:10:54,263
So for instance, here are 32 bits, all zeros.
例如，这里有32位，全是0。

2814
02:10:54,263 --> 02:10:56,180
And if you do out the math, this is the number
如果你算一下，这个数字

2815
02:10:56,180 --> 02:10:58,760
you and I know in decimal is of course 0.
你我用十进制都知道当然就是0。

2816
02:10:58,760 --> 02:11:03,410
But if I change all 32 zeros to ones, this is a really big number now.
但如果我把所有32个0都改为1，现在就变成了一个很大的数字。

2817
02:11:03,410 --> 02:11:05,810
If we're only using positive numbers, not negatives,
如果我们只使用正数，不使用负数，

2818
02:11:05,810 --> 02:11:10,680
what number roughly is this, 32 ones?
这个数字大致是多少，32个1？

2819
02:11:10,680 --> 02:11:15,520
It's roughly 4 billion in total-- roughly 4 billion in total.
总共大约是40亿——总共大约是40亿。

2820
02:11:15,520 --> 02:11:16,020
Why?
为什么？

2821
02:11:16,020 --> 02:11:19,770
Well, if you've got 32 bits, each can be two possible values, 0 or 1, that's
嗯，如果你有32位，每个位都有两种可能的值，0或1，那就是

2822
02:11:19,770 --> 02:11:22,260
2 to the 32nd power, which is roughly--
2的32次方，大约是——

2823
02:11:22,260 --> 02:11:26,490
I'll stipulate-- roughly 4 billion total.
我承认——总共大约是40亿。

2824
02:11:26,490 --> 02:11:29,883
The problem is, what if you want to count to 4,000,000,001?
问题是，如果你想数到4,000,000,001怎么办？

2825
02:11:29,883 --> 02:11:31,050
That's a bit of a white lie.
那有点说谎了。

2826
02:11:31,050 --> 02:11:32,290
It's not precisely that.
并不完全是那样。

2827
02:11:32,290 --> 02:11:34,457
But what if you want to count just higher than that?
但如果你想数到比那还高怎么办？

2828
02:11:34,457 --> 02:11:36,780
You'd need a 33rd bit because all of the others
你需要一个第33位，因为其他所有位

2829
02:11:36,780 --> 02:11:40,860
are going to go to 0 at that point, and you might count from 1 to 2
在那一点会变成0，你可能会从1数到2

2830
02:11:40,860 --> 02:11:45,690
to 3 to 4 billion back to 0, or worse if you're dealing with negative numbers,
到3到40亿再回到0，或者更糟的是，如果你在处理负数，

2831
02:11:45,690 --> 02:11:46,300
too.
也是一样。

2832
02:11:46,300 --> 02:11:51,540
So the fact that there are finitely many bits used in computers is a problem.
所以计算机中使用的位数是有限的，这是一个问题。

2833
02:11:51,540 --> 02:11:55,050
And negative numbers do add a complexity because this is specifically
而负数确实增加了复杂性，因为这个数字具体来说是

2834
02:11:55,050 --> 02:11:56,460
the 4 billion in question--
我们要讨论的40亿——

2835
02:11:56,460 --> 02:12:00,300
4,294,968,295.
4,294,968,295。

2836
02:12:00,300 --> 02:12:03,480
That is as high as you can count with 32 bits
用32位你能数到的最大数字

2837
02:12:03,480 --> 02:12:05,033
if you don't bother with negatives.
如果你不考虑负数的话。

2838
02:12:05,033 --> 02:12:07,200
But if you want negative numbers, you've got to half
但如果你想要负数，你必须把它们减半

2839
02:12:07,200 --> 02:12:10,350
that because you've got to save half of them for negative, half of them
因为你必须留出其中的一半用于负数，另一半用于正数，或多或少。

2840
02:12:10,350 --> 02:12:11,770
for positive, give or take.
或多或少。

2841
02:12:11,770 --> 02:12:14,640
And so if you're supporting negative numbers, as you probably
所以如果你支持负数，就像你可能

2842
02:12:14,640 --> 02:12:17,850
should for a calculator, for Microsoft Excel, Google Spreadsheets,
应该为计算器、微软 Excel、Google 表格做的那样，

2843
02:12:17,850 --> 02:12:21,060
you can only count as high up as 2 billion roughly,
你只能数到大约 20 亿，

2844
02:12:21,060 --> 02:12:24,640
or negative 2 billion roughly instead.
或者大约负 20 亿。

2845
02:12:24,640 --> 02:12:29,340
So it turns out that when you are using data types in C,
所以事实证明，当你使用 C 语言中的数据类型时，

2846
02:12:29,340 --> 02:12:32,760
you have some control over how many bits are actually used.
你可以控制实际使用的位数。

2847
02:12:32,760 --> 02:12:34,980
And this list is longer than we've covered today,
这个列表比我们今天讨论的要长，

2848
02:12:34,980 --> 02:12:37,800
but we did talk about integers for a while.
但我们确实讨论了一段时间的整数。

2849
02:12:37,800 --> 02:12:40,680
Those are, by convention nowadays, 32 bits.
如今，按照惯例，它们是 32 位。

2850
02:12:40,680 --> 02:12:44,760
If that's not enough, you can upgrade your variables to longs, which
如果这还不够，你可以将变量升级为 longs，它们

2851
02:12:44,760 --> 02:12:49,290
tend to be 64 bits instead, which isn't just twice as big as an integer,
通常是 64 位，这不仅仅是整数的两倍大，

2852
02:12:49,290 --> 02:12:52,500
it's actually 64 bits, which is exponentially more.
它实际上是 64 位，指数级地更大。

2853
02:12:52,500 --> 02:12:54,510
It's an unpronounceable number, at least for me.
至少对我来说，这是一个无法发音的数字。

2854
02:12:54,510 --> 02:12:58,240
That's a crazy big number, but it's available to you.
这是一个非常大的数字，但你可以使用它。

2855
02:12:58,240 --> 02:13:02,700
Moreover, we can see this if we actually are a little reckless with how
此外，如果我们在使用代码的方式上稍微鲁莽一些，我们就能看到这一点。

2856
02:13:02,700 --> 02:13:03,428
we're using code.
我们使用代码。

2857
02:13:03,428 --> 02:13:05,220
And just so you know too, though, there are
另外，你也要知道，有

2858
02:13:05,220 --> 02:13:07,140
functions even in CS50's library that let
即使在 CS50 的库中也有函数，可以让

2859
02:13:07,140 --> 02:13:10,930
you use these larger values, get long of course, will get you a long.
你使用这些更大的值，当然，获取 long 会给你一个 long。

2860
02:13:10,930 --> 02:13:16,240
And this one's a little non-obvious, but "%li" is the format code for printf,
这有点不明显，但是 “%li” 是 printf 的格式代码，

2861
02:13:16,240 --> 02:13:20,720
just so you know, for printing a long integer and not just an integer.
你只要知道，用于打印长整数，而不仅仅是整数。

2862
02:13:20,720 --> 02:13:22,330
So it's two characters instead of one.
所以它是两个字符，而不是一个字符。

2863
02:13:22,330 --> 02:13:26,860
Suppose, though, we actually want to use code involving some large numbers.
但是，假设我们实际上想要使用涉及一些大数字的代码。

2864
02:13:26,860 --> 02:13:29,208
It turns out that certain bad things can happen.
事实证明，某些不好的事情可能会发生。

2865
02:13:29,208 --> 02:13:30,500
So let me go ahead and do this.
所以让我继续做这个。

2866
02:13:30,500 --> 02:13:32,200
I'm going to go back over to VS Code here,
我将回到这里的 VS Code，

2867
02:13:32,200 --> 02:13:35,408
and I'm going to modify my calculator to do something that, at glance, should
我会修改我的计算器，做一些看起来很合理的事情，

2868
02:13:35,408 --> 02:13:36,880
be perfectly reasonable.
应该是完全合理的。

2869
02:13:36,880 --> 02:13:40,030
Let me go ahead and open up calculator.c, as before.
让我继续打开 calculator.c，像以前一样。

2870
02:13:40,030 --> 02:13:42,220
And where we left off, we had this add function.
我们在停下的地方，我们有这个 add 函数。

2871
02:13:42,220 --> 02:13:42,970
And you know what?
你知道吗？

2872
02:13:42,970 --> 02:13:45,502
I'm going to simplify it back to its very original version.
我将把它简化回它最初的版本。

2873
02:13:45,502 --> 02:13:47,710
I'm going to go ahead and get rid of the add function
我将继续删除 add 函数

2874
02:13:47,710 --> 02:13:50,845
and just distill it to its essence, which is not to add any more.
并将其简化为其本质，即不再添加任何东西。

2875
02:13:50,845 --> 02:13:51,970
But let's just do division.
但我们只做除法。

2876
02:13:51,970 --> 02:13:55,120
I want to print out this time maybe x divided by y.
这次我想打印出 x 除以 y。

2877
02:13:55,120 --> 02:13:59,770
So here we go. x divided by y is a nice simple program in my calculator.
所以，我们开始吧。x 除以 y 是我计算器中一个简单的程序。

2878
02:13:59,770 --> 02:14:03,250
Let me do make calculator again, ./calculator.
让我再次执行 make calculator，然后 ./calculator。

2879
02:14:03,250 --> 02:14:07,170
And let's divide something like 1 divided by 3, which should--
让我们除一些东西，比如 1 除以 3，这应该——

2880
02:14:07,170 --> 02:14:08,860
hm, OK, weird.
嗯，好吧，奇怪。

2881
02:14:08,860 --> 02:14:13,360
It gave me 0 instead of probably 0.3333333,
它给了我 0，而不是可能出现的 0.3333333，

2882
02:14:13,360 --> 02:14:16,540
as you might have expected for 1/3.
正如你可能预期 1/3 应该给出的结果。

2883
02:14:16,540 --> 02:14:19,990
So what might the takeaway there be?
所以，你从中能得到什么结论呢？

2884
02:14:19,990 --> 02:14:22,090
Why am I seeing zero perhaps?
为什么我看到了零？

2885
02:14:22,090 --> 02:14:22,600
Yeah?
是吗？

2886
02:14:22,600 --> 02:14:27,060
STUDENT: If 0's the integer [INAUDIBLE],, then if you want decimals [INAUDIBLE]..
学生：如果 0 是整数 [不可识别]，那么如果你想要小数 [不可识别]…

2887
02:14:27,060 --> 02:14:29,178
DAVID MALAN: Yeah, so 0 is an integer.
大卫·马兰：是的，所以 0 是一个整数。

2888
02:14:29,178 --> 02:14:31,470
And indeed, that's what I'm telling the thing to print.
实际上，这就是我告诉程序要打印的内容。

2889
02:14:31,470 --> 02:14:34,980
And in fact, if we go over to my little cheat sheet here of format codes,
事实上，如果我们看一下我的格式代码备忘单，

2890
02:14:34,980 --> 02:14:36,525
I'm currently using %i.
我目前使用的是 %i。

2891
02:14:36,525 --> 02:14:41,460
I should actually, when I do division of numbers that might have floating point
实际上，当我进行可能包含浮点数的数字除法时，

2892
02:14:41,460 --> 02:14:43,560
values, a decimal point that floats left to right,
也就是小数点在左右浮动的值，

2893
02:14:43,560 --> 02:14:47,698
otherwise known as a real number, I want to use %f for float instead.
也称为实数，我想要使用 %f 来表示浮点数。

2894
02:14:47,698 --> 02:14:49,740
So I'm actually going to go back to my code here.
所以我打算回到我的代码。

2895
02:14:49,740 --> 02:14:52,920
And let's try this-- %f instead of %i.
我们试试这个，使用 %f 代替 %i。

2896
02:14:52,920 --> 02:14:55,560
And let me go ahead and "make calculator."
我直接执行 “make calculator”。

2897
02:14:55,560 --> 02:14:56,370
Huh, all right.
嗯，好吧。

2898
02:14:56,370 --> 02:14:57,930
Well, this didn't work then.
看来这个方法行不通。

2899
02:14:57,930 --> 02:15:01,830
"Format specifies type 'double,' but the argument has type 'int.'
“格式指定类型为 'double'，但参数类型为 'int'。”

2900
02:15:01,830 --> 02:15:05,260
All right, so that, too, is not quite working.
好吧，这个也不太奏效。

2901
02:15:05,260 --> 02:15:09,150
So I think I actually need to make a change here further.
我想我需要在这里做进一步的改变。

2902
02:15:09,150 --> 02:15:10,870
Let me actually go ahead and do this.
我直接执行一下。

2903
02:15:10,870 --> 02:15:13,230
It turns out that besides integers, there
事实证明，除了整数之外，还有

2904
02:15:13,230 --> 02:15:15,750
are these things called floats, and also doubles.
称为浮点数和双精度数的东西。

2905
02:15:15,750 --> 02:15:19,082
A float uses 32 bits, and a double uses 64 bits.
浮点数使用 32 位，双精度数使用 64 位。

2906
02:15:19,082 --> 02:15:20,790
And that doesn't necessarily mean you can
这并不一定意味着你可以

2907
02:15:20,790 --> 02:15:22,860
count higher as much as it means you can have
计数更多，而是指你可以拥有

2908
02:15:22,860 --> 02:15:24,820
more numbers after the decimal point.
更多的小数位数。

2909
02:15:24,820 --> 02:15:27,610
So if you want a more precise value, you throw memory at it
所以，如果你想要一个更精确的值，你可以用更多的内存来存储它

2910
02:15:27,610 --> 02:15:30,363
by using a double and 64 bits instead of a float.
通过使用双精度数和 64 位而不是浮点数。

2911
02:15:30,363 --> 02:15:32,780
But we'll keep it simple, and let me go ahead and do this.
但我们还是先简单一点，我直接执行一下。

2912
02:15:32,780 --> 02:15:37,250
Let me just do the math using the type of variable that I should be here.
我直接用这里应该使用的变量类型进行计算。

2913
02:15:37,250 --> 02:15:43,240
Let me do not int, but float z equals x divided by y.
我直接使用 float z 等于 x 除以 y，而不是 int。

2914
02:15:43,240 --> 02:15:45,730
And now let me go ahead and print out the value of z.
现在我打印 z 的值。

2915
02:15:45,730 --> 02:15:47,605
Strictly speaking, I don't need the variable.
严格地说，我不需要这个变量。

2916
02:15:47,605 --> 02:15:50,830
But I'm trying to be pedantic and actually use a float explicitly
但我想严格一点，显式地使用一个浮点数

2917
02:15:50,830 --> 02:15:52,900
this time so we see a real number.
这次，这样我们就能看到一个实数。

2918
02:15:52,900 --> 02:15:57,760
All right, let me go ahead and do make calculator, ./calculator.
好的，我直接执行 make calculator，./calculator。

2919
02:15:57,760 --> 02:16:00,610
1 divided by 3 equals--
1 除以 3 等于——

2920
02:16:00,610 --> 02:16:04,420
damn, now it's just showing me more zeros, which clearly isn't the case.
糟糕，现在只是显示了更多零，这显然不正确。

2921
02:16:04,420 --> 02:16:08,750
Well, this is because of an issue that we'll generally call truncation.
好吧，这是因为一个问题，我们通常称之为截断。

2922
02:16:08,750 --> 02:16:12,320
So truncation is just a term of art that means if you take an integer
所以，截断只是一个专业术语，意思是如果你取一个整数

2923
02:16:12,320 --> 02:16:15,760
and you divide it by an integer, even if you get a fractional value,
并将其除以一个整数，即使你得到一个分数，

2924
02:16:15,760 --> 02:16:18,880
the fraction just gets thrown away because you're only
这个分数就被扔掉了，因为你只是在

2925
02:16:18,880 --> 02:16:21,062
doing integer-based math.
进行基于整数的运算。

2926
02:16:21,062 --> 02:16:23,020
So if there's anything after the decimal point,
所以，如果小数点之后有任何内容，

2927
02:16:23,020 --> 02:16:25,280
it just gets truncated, literally discarded.
就会被截断，也就是说被丢弃。

2928
02:16:25,280 --> 02:16:27,460
So what should 1 divided by 3 be?
那么 1 除以 3 应该等于多少呢？

2929
02:16:27,460 --> 02:16:31,810
Obviously, 0.33333333-- ad nauseum.
显然，0.33333333——无穷无尽。

2930
02:16:31,810 --> 02:16:34,670
Fortunately, you throw away everything after the decimal point,
幸运的是，你扔掉了小数点之后的所有内容，

2931
02:16:34,670 --> 02:16:37,000
which leaves you still with just 0.
剩下的是 0。

2932
02:16:37,000 --> 02:16:40,510
And even though I'm seeing more zeros, that's because we threw away all
虽然我看到了更多的零，但那是因为我们扔掉了所有的

2933
02:16:40,510 --> 02:16:41,049
of the 3's.
3。

2934
02:16:41,049 --> 02:16:44,200
That is just what happens when you use integers and do
这就是使用整数进行运算时发生的事情。

2935
02:16:44,200 --> 02:16:46,090
any kind of division like that.
像这样的任何一种除法。

2936
02:16:46,090 --> 02:16:47,959
But there is a solution.
但是有一个解决方法。

2937
02:16:47,959 --> 02:16:53,320
We can actually convert, or cast, integers to floating point values.
我们实际上可以将整数转换为浮点数。

2938
02:16:53,320 --> 02:16:56,230
So we can tell C, I know this is an integer now.
所以我们可以告诉C，我知道这现在是一个整数。

2939
02:16:56,230 --> 02:16:59,290
But go ahead and treat it as though it has a decimal point, even
但是继续把它当作有小数点一样对待，即使

2940
02:16:59,290 --> 02:17:01,690
if it's .0 At the end of the number.
如果它在数字的末尾是 .0。

2941
02:17:01,690 --> 02:17:06,100
So I can go into this, and I can use parentheses and literally write
所以我可以进入这里，我可以使用括号，并逐字写下

2942
02:17:06,100 --> 02:17:07,750
"float" in parentheses.
括号中的“float”。

2943
02:17:07,750 --> 02:17:12,700
And over here for y, I can literally use parentheses and convert y to a float.
而在这里对于y，我也可以使用括号，并将y转换为浮点数。

2944
02:17:12,700 --> 02:17:15,129
The term of art here is type casting.
这里专业的术语是类型转换。

2945
02:17:15,129 --> 02:17:19,330
You're converting one type to another effectively, or technically treating
你实际上将一种类型转换为另一种类型，或者从技术上讲是将

2946
02:17:19,330 --> 02:17:23,080
one type as though it's another even if it doesn't necessarily
一种类型当作另一种类型对待，即使它不一定

2947
02:17:23,080 --> 02:17:24,430
have a mathematical impact.
有数学上的影响。

2948
02:17:24,430 --> 02:17:28,959
But what it means now is that z will be defined
但现在这意味着z将被定义

2949
02:17:28,959 --> 02:17:31,219
by dividing one float by another.
通过将一个浮点数除以另一个浮点数。

2950
02:17:31,219 --> 02:17:33,700
So truncation will not now happen.
所以现在不会发生截断。

2951
02:17:33,700 --> 02:17:36,580
So let me do make calculator, ./calculator.
所以让我来制作计算器，./calculator。

2952
02:17:36,580 --> 02:17:39,100
And now 1 divided by 3, there it is.
现在1除以3，就在那里。

2953
02:17:39,100 --> 02:17:41,480
Now the math is actually correct.
现在数学实际上是正确的。

2954
02:17:41,480 --> 02:17:45,770
But my God, we had to jump through hoops just to get this to work.
但我的天哪，我们不得不跳过障碍才能让它工作。

2955
02:17:45,770 --> 02:17:48,610
So to be clear, the two issues we-- well, the issue we encountered
所以要明确地说，我们遇到的两个问题，或者说我们遇到的问题是

2956
02:17:48,610 --> 02:17:49,480
was truncation.
截断。

2957
02:17:49,480 --> 02:17:52,389
If you divide an int by an int, you will get an int no matter
如果你将一个整数除以一个整数，无论如何你都会得到一个整数

2958
02:17:52,389 --> 02:17:54,070
what it should be mathematically.
它在数学上应该是什么。

2959
02:17:54,070 --> 02:17:59,020
But if you instead type cast the values, the variables to a floating point
但如果你改为将值，将变量类型转换为浮点数

2960
02:17:59,020 --> 02:18:03,610
value, or a double for that matter, then a float divided by a float will give
值，或者说一个双精度数，那么一个浮点数除以一个浮点数将得到

2961
02:18:03,610 --> 02:18:06,520
you a float and preserve all of those 3's.
一个浮点数，并保留所有这些3。

2962
02:18:06,520 --> 02:18:10,870
But here's another catch, or at least a limitation potentially with computers.
但这里还有另一个问题，或者说至少是计算机潜在的限制。

2963
02:18:10,870 --> 02:18:14,379
What if I go ahead here and do--
如果我在这里继续做--

2964
02:18:14,379 --> 02:18:15,559
let me do this.
让我做这个。

2965
02:18:15,559 --> 02:18:18,820
Let me show you one trick here, even though the syntax is a bit weird.
让我在这里给你展示一个技巧，即使语法有点奇怪。

2966
02:18:18,820 --> 02:18:25,750
Instead of printing out %f alone, let me print out % dot,
而不是只打印 %f，让我打印 % 点，

2967
02:18:25,750 --> 02:18:30,080
maybe 5f So this is weird syntax.
也许是5f。所以这个语法很奇怪。

2968
02:18:30,080 --> 02:18:32,350
And it's only specific to printf.
它只适用于 printf。

2969
02:18:32,350 --> 02:18:36,770
"%.5f" means 'show me five decimal places specifically.'
“%.5f”表示“具体地显示我五个小数位”。

2970
02:18:36,770 --> 02:18:40,480
So if I do make calculator, ./calculator, 1, 3, voila,
所以如果我做 make calculator，./calculator，1，3，瞧，

2971
02:18:40,480 --> 02:18:43,010
I get five decimal places.
我得到了五个小数位。

2972
02:18:43,010 --> 02:18:44,469
If I want six, let's do this.
如果我想要六个，让我们这样做。

2973
02:18:44,469 --> 02:18:45,969
I'll change the code to 6.
我会将代码改为 6。

2974
02:18:45,969 --> 02:18:52,337
Make calculator, ./calculator, 1, 3, and now I get six 3's instead.
制作计算器，./calculator，1，3，现在我得到六个3而不是五个。

2975
02:18:52,337 --> 02:18:54,879
All right, well, wouldn't it be nice to be even more precise?
好吧，如果更精确一点会怎么样？

2976
02:18:54,879 --> 02:18:59,209
Let's give me 20 significant digits after the decimal point.
让我们在小数点后给我 20 位有效数字。

2977
02:18:59,209 --> 02:19:04,420
So make calculator, ./calculator, 1 divided by 3, and-- woo.
所以制作计算器，./calculator，1 除以 3，然后--哇。

2978
02:19:04,420 --> 02:19:09,481
So your middle school teacher seems to have lied to you at this point.
所以你的初中老师似乎在这个时候对你撒了谎。

2979
02:19:09,481 --> 02:19:14,620
1 divided by 3 is apparently not 0.33333 with a line over it,
1 除以 3 显然不是 0.33333，上面有一条线，

2980
02:19:14,620 --> 02:19:17,350
or just infinite number of 3's.
或者只是无限个3。

2981
02:19:17,350 --> 02:19:19,690
OK, that's not quite the right conclusion, though.
好的，但这并不是完全正确的结论。

2982
02:19:19,690 --> 02:19:20,230
Oops.
哎哟。

2983
02:19:20,230 --> 02:19:24,820
Why might I be seeing these weird numbers instead
为什么我看到的不是一堆3，而是这些奇怪的数字？

2984
02:19:24,820 --> 02:19:28,200
of just lots of 3's, intuitively?
从直觉上来说？

2985
02:19:31,340 --> 02:19:32,999
Why this rounding error?
为什么会出现这个舍入误差？

2986
02:19:32,999 --> 02:19:33,499
Yeah?
对吧？

2987
02:19:33,499 --> 02:19:36,307
STUDENT: The computer just has a [? limited ?] [? memory. ?] So
学生：电脑的内存是有限的。所以

2988
02:19:36,307 --> 02:19:37,665
there's [INAUDIBLE]
就会出现这种情况。

2989
02:19:37,665 --> 02:19:38,540
DAVID MALAN: Exactly.
大卫·马兰：没错。

2990
02:19:38,540 --> 02:19:41,270
The computer only has limited memory, finite memory.
电脑的内存是有限的，是有限的。

2991
02:19:41,270 --> 02:19:44,840
So it just can't represent every possible number in the universe
所以它无法表示宇宙中所有可能的数字

2992
02:19:44,840 --> 02:19:48,240
because we know from grade school there are infinitely many of those numbers.
因为我们从小学就知道，这些数字是无限的。

2993
02:19:48,240 --> 02:19:52,520
So what you're essentially seeing is the closest it can actually get.
所以你看到的实际上是最接近的值。

2994
02:19:52,520 --> 02:19:56,120
It's rounding to the nearest floating point value, if you will.
它将值舍入到最接近的浮点数，如果你愿意的话。

2995
02:19:56,120 --> 02:19:58,850
And it also relates to how the numbers themselves are represented
这还与这些数字在内存中的表示方式有关

2996
02:19:58,850 --> 02:20:00,145
in memory underneath the hood.
在引擎盖下的内存中。

2997
02:20:00,145 --> 02:20:01,520
I can do a little better, though.
不过，我还可以做得更好。

2998
02:20:01,520 --> 02:20:02,330
Let me zoom out.
让我缩小一下。

2999
02:20:02,330 --> 02:20:06,530
And let me upgrade, so to speak, from 32 bits to 64 bits and use
我们可以进行升级，从32位升级到64位，使用

3000
02:20:06,530 --> 02:20:07,400
doubles instead.
双精度浮点数。

3001
02:20:07,400 --> 02:20:09,410
I can still use %f.
我仍然可以使用%f。

3002
02:20:09,410 --> 02:20:11,030
You don't use %d for double.
双精度浮点数不用%d。

3003
02:20:11,030 --> 02:20:14,750
Let me do make calculator again, ./calculator, 1, 3.
我再运行一遍calculator，./calculator，1，3。

3004
02:20:14,750 --> 02:20:17,490
I get more 3's but still some rounding.
我得到了更多的3，但仍然存在一些舍入。

3005
02:20:17,490 --> 02:20:21,842
It's more precise, but it's not 100% accurate,
精度更高了，但不是100%准确，

3006
02:20:21,842 --> 02:20:24,050
because that's just not going to be possible in terms
因为这在计算机内存方面是不可能的

3007
02:20:24,050 --> 02:20:25,320
of the computer's memory.
。

3008
02:20:25,320 --> 02:20:29,450
So this is a whole other issue known as floating point imprecision, which
所以，这是一个全新的问题，称为浮点数精度问题，它

3009
02:20:29,450 --> 02:20:31,910
is another type of limitation.
是另一种类型的限制。

3010
02:20:31,910 --> 02:20:34,640
We saw integer overflow, if integers can only
我们看到了整数溢出，如果整数只能

3011
02:20:34,640 --> 02:20:37,860
count so high before you run out of bits and things wrap around.
计算到一定程度就会用完位，然后就会发生溢出。

3012
02:20:37,860 --> 02:20:40,350
Floating point imprecision means that you can't possibly
浮点数精度问题意味着你不可能

3013
02:20:40,350 --> 02:20:43,470
represent the infinite number of real numbers that exist in the universe
用有限的内存表示宇宙中无限多的实数

3014
02:20:43,470 --> 02:20:46,830
if you only have a finite amount of memory.
。

3015
02:20:46,830 --> 02:20:49,710
You would need an infinite number of bits, it would seem.
看来你需要无限多的位。

3016
02:20:49,710 --> 02:20:51,902
So these are two issues that actually fundamentally
所以，这两个问题实际上从根本上

3017
02:20:51,902 --> 02:20:53,610
can influence the correctness not only of
会影响你的代码以及现实世界中代码的正确性，不仅仅是

3018
02:20:53,610 --> 02:20:55,260
your code but code in the real world.
你的代码，还有现实世界中的代码。

3019
02:20:55,260 --> 02:20:56,820
And case in point, back in my day--
举个例子，在我那个年代--

3020
02:20:56,820 --> 02:20:59,310
I graduated in 1999-- and a lot of the world
我毕业于1999年，世界上很多人

3021
02:20:59,310 --> 02:21:01,350
thought the world was going to end around then
认为世界将在那时结束

3022
02:21:01,350 --> 02:21:06,180
because around the time the years rolled over from 1999 to 2000,
因为在年份从1999年翻到2000年的时候，

3023
02:21:06,180 --> 02:21:08,850
there was a lot of old software still running in the world.
世界上还有很多旧软件在运行。

3024
02:21:08,850 --> 02:21:12,450
And in fact, that old software, reasonably so,
事实上，这些旧软件，理所当然地，

3025
02:21:12,450 --> 02:21:14,740
only used two digits to represent years.
只用两位数来表示年份。

3026
02:21:14,740 --> 02:21:15,240
Why?
为什么？

3027
02:21:15,240 --> 02:21:17,200
Memory was very expensive early on.
早期内存非常昂贵。

3028
02:21:17,200 --> 02:21:20,910
And if you could use half as much memory to store a year, that was a win.
如果你可以用一半的内存来存储一年，那可是胜利。

3029
02:21:20,910 --> 02:21:21,870
That saved you money.
省钱。

3030
02:21:21,870 --> 02:21:23,310
That saved you memory.
省内存。

3031
02:21:23,310 --> 02:21:25,350
The problem though, of course, is that a lot
问题是，当然，有很多

3032
02:21:25,350 --> 02:21:29,970
of old software from the '70s and prior was still running in 1999.
很多上世纪70年代或更早期的旧软件还在1999年运行。

3033
02:21:29,970 --> 02:21:32,970
And unless companies or individuals updated that software,
除非公司或个人更新这些软件，

3034
02:21:32,970 --> 02:21:39,112
1999 might be mistaken for the year 1900 instead of 2000,
1999年可能会被误认为是1900年而不是2000年，

3035
02:21:39,112 --> 02:21:41,320
because all of the code just assumed that, of course,
因为所有的代码都假设，当然，

3036
02:21:41,320 --> 02:21:42,850
we're talking about the 1900s.
我们指的是20世纪。

3037
02:21:42,850 --> 02:21:45,120
This code is not going to be running 50 years later,
这些代码不可能在50年后继续运行，

3038
02:21:45,120 --> 02:21:46,762
but it was still in that case.
但事实上它仍在运行。

3039
02:21:46,762 --> 02:21:48,720
So people had to scramble, and they essentially
因此人们不得不手忙脚乱，他们实际上

3040
02:21:48,720 --> 02:21:53,310
had to solve this by using more digits, so upgrading from two to four.
不得不通过使用更多位数来解决这个问题，因此从两位数升级到四位数。

3041
02:21:53,310 --> 02:21:55,590
Nowadays, and really since the '70s too, we've
如今，实际上从70年代开始，我们已经

3042
02:21:55,590 --> 02:21:59,190
used 32-bit integers to keep track of time,
使用32位整数来跟踪时间，

3043
02:21:59,190 --> 02:22:03,120
specifically keeping track of the number of seconds
具体来说，跟踪的是从

3044
02:22:03,120 --> 02:22:08,400
using an integer from January 1, 1970, the so-called epoch whereby
1970年1月1日开始的秒数，这个日期被称为纪元，即

3045
02:22:08,400 --> 02:22:11,800
that's just an arbitrary date early on where we just started counting time.
一个早期的任意日期，我们从这个日期开始计算时间。

3046
02:22:11,800 --> 02:22:14,430
So all of the clocks in your Macs, PCs, and phones pretty much
所以你电脑的Mac、PC和手机里的所有时钟基本上

3047
02:22:14,430 --> 02:22:17,280
just have a single integer that gets updated every second,
只有一个整数，每秒更新一次，

3048
02:22:17,280 --> 02:22:20,080
but it's just keeping track not of absolute time per se,
但它只是跟踪的是并非绝对的时间，

3049
02:22:20,080 --> 02:22:23,460
but how many seconds have passed since January 1, 1970,
而是从1970年1月1日至今过去了多少秒，

3050
02:22:23,460 --> 02:22:25,710
just because that's the date humans chose.
仅仅是因为那是人类选择的日期。

3051
02:22:25,710 --> 02:22:28,650
The problem is you can only count as high as 4 billion,
问题是，使用32位整数，你最多只能计数到40亿，

3052
02:22:28,650 --> 02:22:31,950
give or take, with 32 bits and actually 2 billion, give or take,
大约如此，实际上是20亿，大约如此，

3053
02:22:31,950 --> 02:22:34,180
if you support negative numbers, as well.
如果你也支持负数的话。

3054
02:22:34,180 --> 02:22:37,500
And the problem with that is that we're about to trip over the same issue
而问题是，我们很快就会再次遇到同样的问题，

3055
02:22:37,500 --> 02:22:39,450
again in not too long from now.
在不久的将来。

3056
02:22:39,450 --> 02:22:45,760
This is the 2038 problem because in the year 2038, on that date, mark my words,
这就是2038年问题，因为在2038年，在那个日期，记住我的话，

3057
02:22:45,760 --> 02:22:46,830
things could break again.
事情可能会再次崩溃。

3058
02:22:46,830 --> 02:22:47,430
Why?
为什么？

3059
02:22:47,430 --> 02:22:50,820
Because that 32-bit value is going to accidentally wrap
因为那个32位的值会意外地回绕到

3060
02:22:50,820 --> 02:22:53,873
around back to a 0 or a negative value.
0或负值。

3061
02:22:53,873 --> 02:22:56,290
So we're going to go through the whole darn process again.
所以我们又要经历整个过程一遍。

3062
02:22:56,290 --> 02:22:59,190
Now, thankfully the solution, as you might expect, is kind of just
现在，幸运的是，正如你可能预料的那样，解决方法仅仅是

3063
02:22:59,190 --> 02:23:01,470
to kick the can even further down the road
把问题推迟到更远的将来，

3064
02:23:01,470 --> 02:23:07,050
and use 64 bits, which I think will get us another 290 million years of runway.
使用64位，我认为这将给我们再延长2.9亿年的时间。

3065
02:23:07,050 --> 02:23:08,290
It's more than twice.
这不止是两倍。

3066
02:23:08,290 --> 02:23:10,527
So it's not our problem anymore at that point.
所以到那时，这就不再是我们的问题了。

3067
02:23:10,527 --> 02:23:12,610
But that's fundamentally going to be the solution.
但从根本上来说，这将是解决方法。

3068
02:23:12,610 --> 02:23:15,160
But it will still be finite.
但它仍然是有限的。

3069
02:23:15,160 --> 02:23:18,240
So we're just deferring to our descendants
所以我们只是把问题推给我们的后代，

3070
02:23:18,240 --> 02:23:21,150
to actually deal with the issue some millions of years from now
让他们在数百万年后去解决这个问题，

3071
02:23:21,150 --> 02:23:22,930
if these things are still running.
如果这些东西还在运行的话。

3072
02:23:22,930 --> 02:23:26,010
So if that does happen, here's the specific date
所以如果真的发生了，以下是具体的日期，

3073
02:23:26,010 --> 02:23:28,290
that, in 2038, all of a sudden our clocks will still
在2038年，我们的时钟会突然

3074
02:23:28,290 --> 02:23:32,400
think because a negative number will get subtracted to the current epoch time.
认为时间是错误的，因为一个负数会被从当前的纪元时间中减去。

3075
02:23:32,400 --> 02:23:35,140
So it will think we're back in 1901.
所以它会认为我们回到了1901年。

3076
02:23:35,140 --> 02:23:38,170
So this has had some fun and very real world implications.
所以这带来了一些有趣且非常现实的影响。

3077
02:23:38,170 --> 02:23:41,250
So for instance, this is the game Pac-Man, which you might have played.
例如，这是你可能玩过的游戏《吃豆人》。

3078
02:23:41,250 --> 02:23:44,020
It kind of came out around my day, back in time.
这大概发生在我那个时代，在很早以前。

3079
02:23:44,020 --> 02:23:48,950
And if you get to the 256th level, this unfortunately
如果你达到了第256关，很不幸地，

3080
02:23:48,950 --> 02:23:50,700
is what happens because they didn't really
这就是会发生的事情，因为他们并没有真正地

3081
02:23:50,700 --> 02:23:54,280
expect that players would spend all this much time playing Pac-Man apparently.
预料到玩家会花这么多时间玩吃豆人。

3082
02:23:54,280 --> 02:23:56,370
And they didn't really have a condition saying,
而且他们并没有一个条件说，

3083
02:23:56,370 --> 02:23:59,832
you win if you get to the 255th or 266th level.
如果你达到第255关或第266关，你就赢了。

3084
02:23:59,832 --> 02:24:02,790
And so what happens here essentially is that the whole screen gets very
所以这里本质上发生的事情是整个屏幕变得非常

3085
02:24:02,790 --> 02:24:06,120
garbled because there's an integer in the original Pac-Man that
混乱不堪，因为在最初的吃豆人游戏中有一个整数，

3086
02:24:06,120 --> 02:24:11,100
counts to 256, but that's too big, so it wraps back around to 0.
它可以计数到256，但它太大了，所以它会回绕到0。

3087
02:24:11,100 --> 02:24:14,700
And it doesn't know when to stop printing fruits on the screen,
它不知道什么时候停止在屏幕上打印水果，

3088
02:24:14,700 --> 02:24:16,260
as in this case, to collect.
就像在这种情况下，去收集水果。

3089
02:24:16,260 --> 02:24:19,470
Another example of this is actually from the original Donkey Kong
另一个例子实际上来自最初的《大金刚》

3090
02:24:19,470 --> 02:24:24,420
game, which looks something like this in my day, too, whereby in Donkey Kong,
游戏，在我的时代它看起来像这样，在《大金刚》中，

3091
02:24:24,420 --> 02:24:26,880
there was this mathematical formula, whereby
有一个数学公式，通过它

3092
02:24:26,880 --> 02:24:31,740
the number of seconds you have to solve the game was a function of 10 times
你玩游戏所需的时间是当前关卡编号乘以10加上4的函数。

3093
02:24:31,740 --> 02:24:34,500
your current level number plus the number 4.
这就是决定你获得多少秒时间。

3094
02:24:34,500 --> 02:24:36,330
That dictated how many seconds you get.
当然，关卡越高，你获得的时间就越多

3095
02:24:36,330 --> 02:24:39,480
So of course, the higher the level, you get more and more time
随着关卡的提升。

3096
02:24:39,480 --> 02:24:41,130
as the level climbs.
不幸的是，一旦你达到了第22关，

3097
02:24:41,130 --> 02:24:47,580
Unfortunately, once you hit level 22, the math ends up being 10 times
计算结果就是22乘以10加上4，得到数字260。

3098
02:24:47,580 --> 02:24:51,690
22 plus 4, which gives you the number 260.
而且他们也使用了8位值，一个字节

3099
02:24:51,690 --> 02:24:55,290
And they, too, were using 8-bit values, a single byte
来表示数字，这意味着260大于256。

3100
02:24:55,290 --> 02:25:00,520
to represent numbers, which means 260 is bigger than 256.
而且这个数学计算的结果是，

3101
02:25:00,520 --> 02:25:02,520
And the way that math worked out was, well,
260减去256，如果它回绕，就会给玩家4秒钟时间来玩第

3102
02:25:02,520 --> 02:25:08,250
260 minus 256, if it wraps back around, gave people four seconds to solve level
22关，这几乎是不可能的。

3103
02:25:08,250 --> 02:25:10,440
22, which is just impossible.
就像，马里奥甚至都无法从他所在的位置向上爬几关。

3104
02:25:10,440 --> 02:25:12,480
Like, Mario can't even get up a couple of levels
所以这也算是一个众所周知的错误，

3105
02:25:12,480 --> 02:25:15,040
or so from where he actually was.
因为它确实存在。

3106
02:25:15,040 --> 02:25:17,400
So that, too, was sort of a well-known bug,
最后，这个错误就更加真实了，在2015年，

3107
02:25:17,400 --> 02:25:20,680
as well, since that works out to be there.
波音787被记录为出现了一个软件错误，而不是硬件错误

3108
02:25:20,680 --> 02:25:25,260
Lastly, and this one is all the more real, in 2015,
从以下意义上来说。

3109
02:25:25,260 --> 02:25:30,150
Boeing 787 was documented as having not a hardware bug but a software bug
“一架连续运行了248天的787型号飞机

3110
02:25:30,150 --> 02:25:31,560
in the following sense.
可能会因为控制单元同时进入安全模式而失去所有电源。

3111
02:25:31,560 --> 02:25:37,060
"A model 787 airplane that has been powered continuously for 248 days
这种情况是由一个软件计数器引起的，该计数器会在连续运行248天后溢出。

3112
02:25:37,060 --> 02:25:42,430
can lose all of its power due to the control unit simultaneously going
波音当时正在开发一个CPU软件升级，

3113
02:25:42,430 --> 02:25:43,690
into failsafe mode.
将解决不安全状况。”

3114
02:25:43,690 --> 02:25:48,100
This condition was caused by a software counter that will overflow
人们做了计算。

3115
02:25:48,100 --> 02:25:51,700
after 248 days of continuous power.
事实证明，波音可能使用了一个32位的整数。

3116
02:25:51,700 --> 02:25:55,720
Boeing at the time was in the process of developing a CPU software upgrade that
而且它们用来记录时间并不是以秒为单位，而是以百分之一秒为单位，

3117
02:25:55,720 --> 02:25:57,250
will remedy the unsafe condition."
因为如果你做一下计算，

3118
02:25:57,250 --> 02:25:58,310
And people did the math.
在一个32位的值达到40亿——

3119
02:25:58,310 --> 02:26:02,440
It turns out that Boeing was probably using an integer that was 32 bits.
或者20亿百分之一秒之后，

3120
02:26:02,440 --> 02:26:06,650
And they were keeping track of time not in seconds but hundredths of seconds,
这个数字会回绕到0，

3121
02:26:06,650 --> 02:26:12,830
because if you do out the math, after a 32-bit value has reached 4 billion--
它会将一个32位的整数回绕到0，

3122
02:26:12,830 --> 02:26:18,650
or 2 billion one hundredths of a second, the number wraps around back to 0,
这就是为什么如果你让你的计算机运行足够长的时间，

3123
02:26:18,650 --> 02:26:19,840
or negative 2 billion.
或者负20亿。

3124
02:26:19,840 --> 02:26:23,480
And the implications was literally the plane's power would stop.
而这意味着飞机的动力会停止。

3125
02:26:23,480 --> 02:26:26,770
And if you can believe it, if you grew up with Windows, macOS, or whatnot,
如果你相信，如果你在Windows、macOS或其他系统下长大，

3126
02:26:26,770 --> 02:26:29,080
anyone want to conjecture what the solution was
有人想知道解决方案是什么

3127
02:26:29,080 --> 02:26:33,550
until Boeing updated their software?
直到波音更新了他们的软件？

3128
02:26:33,550 --> 02:26:35,295
STUDENT: Turn it off, turn it back on.
学生：关机重启。

3129
02:26:35,295 --> 02:26:37,128
DAVID MALAN: Turn the plane off, and turn it
大卫·马兰：关掉飞机，然后打开

3130
02:26:37,128 --> 02:26:41,280
back on because that has the effect of resetting its memory and therefore
它，因为这会重置它的内存，因此

3131
02:26:41,280 --> 02:26:43,200
all of its variables back to 0.
它所有的变量都重置为0。

3132
02:26:43,200 --> 02:26:47,910
So this is ultimately to say as you dive into problem set 1, your first in C,
所以最终我们要说，当你开始做问题集1，你的第一个C语言问题集时，

3133
02:26:47,910 --> 02:26:51,360
you, too, will make quite a few mistakes when it comes to correctness.
你也会犯不少错误，尤其是在正确性方面。

3134
02:26:51,360 --> 02:26:54,840
You, too, will encounter opportunities for better design and better style.
你也会遇到改进设计和风格的机会。

3135
02:26:54,840 --> 02:26:57,272
In the real world, there are very much these issues.
在现实世界中，有很多这样的问题。

3136
02:26:57,272 --> 02:26:59,730
So even if you struggle, know that for better or for worse,
所以即使你遇到了困难，也要知道，无论好坏，

3137
02:26:59,730 --> 02:27:00,900
you're in very good company.
你并不孤单。

3138
02:27:00,900 --> 02:27:03,567
But some three months from now, you will be in much better shape
但是三个月后，你会好很多

3139
02:27:03,567 --> 02:27:06,210
because this was week 1, and this is CS50.
因为这是第一周，这里是CS50。

3140
02:27:06,210 --> 02:27:07,710
[APPLAUSE]
[掌声]

3141
02:27:11,310 --> 02:27:14,360
[INTRIGUING MUSIC]
[引人入胜的音乐]
