1
00:00:00,000 --> 00:00:03,472
[MUSIC PLAYING]
[音乐播放]

2
00:01:02,110 --> 00:01:05,319
DAVID J. MALAN: All right, this is CS50.
大卫·马兰：好的，这里是 CS50。

3
00:01:05,319 --> 00:01:07,720
And this is week 5.
这是第五周。

4
00:01:07,720 --> 00:01:11,890
And among our goals for today are to revisit some topics from past weeks
我们今天要做的其中一件事，是回顾一下之前几周的一些内容，

5
00:01:11,890 --> 00:01:16,120
but to focus all the more on design possibilities, particularly
但重点是设计可能性，尤其是

6
00:01:16,120 --> 00:01:17,420
by way of data structures.
通过数据结构。

7
00:01:17,420 --> 00:01:21,040
So data structures, again, is this way via which you can structure your data.
所以，数据结构，再一次地，它是指你可以用它来组织数据的方式。

8
00:01:21,040 --> 00:01:23,170
But more specifically in C, It's how you can
但更具体地说，在 C 语言中，它是指你可以

9
00:01:23,170 --> 00:01:27,160
use your computer's memory in interesting and, daresay, clever ways
以有趣且，我敢说，聪明的方式使用你的计算机内存

10
00:01:27,160 --> 00:01:29,067
to actually solve problems more effectively.
从而更有效地解决问题。

11
00:01:29,067 --> 00:01:31,150
But we're going to see today that there's actually
但今天我们将看到，实际上

12
00:01:31,150 --> 00:01:33,383
different types of data structures.
有不同类型的数据结构。

13
00:01:33,383 --> 00:01:35,550
And we'll make the distinction between abstractions,
我们将区分抽象

14
00:01:35,550 --> 00:01:38,170
like high-level descriptions of these structures
像这些结构的高级描述

15
00:01:38,170 --> 00:01:41,150
and the lower-level implementation details so to speak.
以及更低级的实现细节，姑且这么说吧。

16
00:01:41,150 --> 00:01:45,170
So in particular, we'll talk first today about what we call abstract data types.
因此，今天我们将首先谈论我们所说的抽象数据类型。

17
00:01:45,170 --> 00:01:48,190
So an abstract data type is like a data structure.
所以，抽象数据类型就像数据结构。

18
00:01:48,190 --> 00:01:51,250
But it offers certain properties, certain characteristics.
但是它提供了一些属性，一些特性。

19
00:01:51,250 --> 00:01:53,230
And it's actually up to the programmer how
而程序员实际上可以决定

20
00:01:53,230 --> 00:01:55,850
to implement the underlying implementation details.
如何实现底层的实现细节。

21
00:01:55,850 --> 00:01:58,960
So, for instance, there's actually this abstract data type that's
例如，实际上存在一种在计算中很常见的抽象数据类型，叫做

22
00:01:58,960 --> 00:02:00,880
common in computing known as a queue.
队列。

23
00:02:00,880 --> 00:02:04,490
And from the real world, most of us are presumably familiar with queues,
在现实生活中，我们大多数人可能都熟悉队列，

24
00:02:04,490 --> 00:02:07,770
otherwise known in the US typically as lines or forming lines.
在美国，通常被称为排队或排队。

25
00:02:07,770 --> 00:02:12,077
In fact, I have here three bags of cookies.
事实上，我这里有三大袋饼干。

26
00:02:12,077 --> 00:02:14,660
Could I get three volunteers to come up on stage and queue up?
三位志愿者可以上台排队吗？

27
00:02:14,660 --> 00:02:16,310
OK, I saw your hand first.
好的，我第一个看到你的手了。

28
00:02:16,310 --> 00:02:17,630
How about your hand second?
你的手第二个？

29
00:02:17,630 --> 00:02:20,000
And in the blue.
穿蓝色衣服的你。

30
00:02:20,000 --> 00:02:22,640
OK, come on down, just you three.
好的，请你们三位过来。

31
00:02:22,640 --> 00:02:23,570
Come on over.
过来。

32
00:02:23,570 --> 00:02:26,090
And if you want to queue up over here if you could.
如果可以的话，请你们在这里排队。

33
00:02:29,060 --> 00:02:30,060
Come on down.
过来。

34
00:02:30,060 --> 00:02:30,560
Thank you.
谢谢。

35
00:02:30,560 --> 00:02:32,870
As we begin, do you want to introduce yourselves first?
在我们开始之前，你们想先自我介绍吗？

36
00:02:32,870 --> 00:02:33,140
NAFTALI HOROWITZ: Hi.
纳夫塔利·霍洛维茨：你好。

37
00:02:33,140 --> 00:02:34,740
My name is Naftali Horowitz.
我叫纳夫塔利·霍洛维茨。

38
00:02:34,740 --> 00:02:37,850
I'm a first year studying computer science and economics.
我是一年级学生，学习计算机科学和经济学。

39
00:02:37,850 --> 00:02:41,567
And I sleep at Hurlbut Hall.
我住在赫尔巴特大厅。

40
00:02:41,567 --> 00:02:42,900
DAVID J. MALAN: All right, next.
大卫·马兰：好的，下一个。

41
00:02:42,900 --> 00:02:44,570
CATHERINE: Hi, everyone, my name is Catherine.
凯瑟琳：大家好，我叫凯瑟琳。

42
00:02:44,570 --> 00:02:46,260
I'm planning on studying engineering.
我计划学习工程学。

43
00:02:46,260 --> 00:02:49,010
I'm not sure mechanical or electrical yet but one of the two.
我不确定是机械还是电气，但会选择其中之一。

44
00:02:49,010 --> 00:02:50,218
And I'm currently in Kennedy.
我目前住在肯尼迪。

45
00:02:50,218 --> 00:02:51,093
DAVID J. MALAN: Nice.
大卫·马兰：不错。

46
00:02:51,093 --> 00:02:51,710
Nice to meet.
很高兴认识你。

47
00:02:51,710 --> 00:02:52,740
ISABELLA: Hi, everyone.
伊莎贝拉：大家好。

48
00:02:52,740 --> 00:02:53,570
I'm Isabella.
我叫伊莎贝拉。

49
00:02:53,570 --> 00:02:54,620
I'm in Strauss.
我住在斯特劳斯。

50
00:02:54,620 --> 00:02:56,412
And I plan on majoring in computer science.
我计划主修计算机科学。

51
00:02:56,412 --> 00:02:57,495
DAVID J. MALAN: Wonderful.
大卫·J·马兰：太棒了。

52
00:02:57,495 --> 00:02:58,950
Well, welcome to all three of you.
欢迎三位。

53
00:02:58,950 --> 00:03:00,630
And I think this will be pretty straightforward.
我认为这会很简单。

54
00:03:00,630 --> 00:03:02,420
I have here these three bags of cookies.
我这里有这三袋饼干。

55
00:03:02,420 --> 00:03:04,710
You formed nicely this line or this queue.
你们排成了一条漂亮的长队。

56
00:03:04,710 --> 00:03:07,610
So if you'd like to come up first and take your cookies, thank you.
所以，如果你想先上来拿你的饼干，谢谢。

57
00:03:07,610 --> 00:03:10,193
And right that way, that's all there is to this demonstration.
就这样，这就是这个演示的全部内容。

58
00:03:10,193 --> 00:03:11,390
Your cookies as well.
你们的饼干也一样。

59
00:03:11,390 --> 00:03:12,650
Right this way.
这边来。

60
00:03:12,650 --> 00:03:13,580
And your cookies.
还有你的饼干。

61
00:03:13,580 --> 00:03:14,300
Right this way.
这边来。

62
00:03:14,300 --> 00:03:15,650
Wonderfully well done.
干得真棒！

63
00:03:15,650 --> 00:03:17,340
Thank you to our volunteers.
感谢我们的志愿者。

64
00:03:17,340 --> 00:03:21,620
The point is actually sincere, though, simple as that demonstration was.
虽然这个演示很简单，但它确实说明了一个重要的道理。

65
00:03:21,620 --> 00:03:23,480
And as easy as it was to get those cookies,
虽然拿这些饼干很容易，

66
00:03:23,480 --> 00:03:26,660
queues actually manifest a property that actually
但排队实际上体现了一种性质，

67
00:03:26,660 --> 00:03:29,900
is germane to a lot of problem solving and computing and the real world.
这与很多问题解决、计算以及现实世界密切相关。

68
00:03:29,900 --> 00:03:34,780
Specifically, queues offer this characteristic, FIFO, first in first
具体来说，队列提供这种特性，FIFO，先进先出。

69
00:03:34,780 --> 00:03:35,280
out.
(FIFO)。

70
00:03:35,280 --> 00:03:37,280
And indeed as our volunteers just noticed,
事实上，正如我们的志愿者刚刚注意到的那样，

71
00:03:37,280 --> 00:03:41,327
as they queued up on stage, 1, 2, 3, that is the order in which I
当他们在台上排队时，1、2、3，这就是我

72
00:03:41,327 --> 00:03:42,410
handed them their cookies.
给他们饼干的顺序。

73
00:03:42,410 --> 00:03:44,240
And daresay it's a very equitable approach.
我敢说这是一个非常公平的方法。

74
00:03:44,240 --> 00:03:45,050
It's very fair.
非常公平。

75
00:03:45,050 --> 00:03:47,690
First come, first served might be a more casual way
先来先服务可能是一种更口语化的说法

76
00:03:47,690 --> 00:03:50,420
of describing FIFO, first in, first out.
来描述FIFO，先进先出。

77
00:03:50,420 --> 00:03:53,570
Now, structures like these actually offer specific operations
现在，像这样的结构实际上提供了特定的操作

78
00:03:53,570 --> 00:03:54,337
that make sense.
这些操作是有意义的。

79
00:03:54,337 --> 00:03:57,170
And in the context of queues, we generally describe these operations
在队列的背景下，我们通常将这些操作描述为

80
00:03:57,170 --> 00:03:58,850
as enqueueing and dequeueing
入队和出队。

81
00:03:58,850 --> 00:04:01,600
So when our first three volunteers came up, they enqueued.
所以，当我们的前三位志愿者上来时，他们就入队了。

82
00:04:01,600 --> 00:04:03,880
And as I handed them each a bag of cookies,
当我给他们每人发了一袋饼干时，

83
00:04:03,880 --> 00:04:06,550
they dequeued and exited in that same order.
他们就出队了，并按照相同的顺序离开。

84
00:04:06,550 --> 00:04:11,530
Now, how could you go about implementing a queue in code, specifically in C?
现在，如何在代码中实现一个队列，特别是在C语言中？

85
00:04:11,530 --> 00:04:14,210
Well, we can actually implement it in bunches of different ways.
我们可以用很多不同的方法来实现它。

86
00:04:14,210 --> 00:04:17,950
But perhaps the most obvious is to borrow our old friend, namely arrays.
但也许最明显的方法是借用我们老朋友，即数组。

87
00:04:17,950 --> 00:04:21,100
And we could use a data structure that looks a little something
我们可以使用一个看起来像这样的数据结构。

88
00:04:21,100 --> 00:04:26,150
like this, whereby we specify the total capacity of this data structure.
在这个结构中，我们指定了这个数据结构的总容量。

89
00:04:26,150 --> 00:04:30,140
For instance, we might store a total of 50 people or just 3 in this case.
例如，我们可以存储总共50个人，或者像这个例子中只有3个人。

90
00:04:30,140 --> 00:04:33,130
We might define our structure then as containing those people
然后，我们可以定义我们的结构，它包含这些人

91
00:04:33,130 --> 00:04:34,520
as simply an array.
作为一个简单的数组。

92
00:04:34,520 --> 00:04:37,750
And if a person is a data type that we've defined in week past,
如果一个人是我们在上周定义的数据类型，

93
00:04:37,750 --> 00:04:40,510
you could imagine each of our volunteers is indeed a person.
你可以想象，我们的每个志愿者都是一个人。

94
00:04:40,510 --> 00:04:44,440
And we've stored them one after the other contiguously in memory
我们已经将他们一个接一个地连续存储在内存中

95
00:04:44,440 --> 00:04:47,410
by way of this actual array.
通过这个真实的数组。

96
00:04:47,410 --> 00:04:51,637
But we do need to keep track inside of a queue using one other piece of data--
但我们确实需要使用另外一个数据来跟踪队列内部的信息，

97
00:04:51,637 --> 00:04:53,470
namely, we need to keep track of an integer,
也就是说，我们需要跟踪一个整数，

98
00:04:53,470 --> 00:04:57,610
like the size, like how many people are actually in the queue at this moment.
比如大小，比如现在队列中实际上有多少人。

99
00:04:57,610 --> 00:05:00,130
Because if we have a total capacity of 50,
因为如果我们的总容量是50，

100
00:05:00,130 --> 00:05:02,357
I'd like to if I only have three volunteers.
我希望只有三个志愿者。

101
00:05:02,357 --> 00:05:04,190
Then I can do some quick arithmetic and know
然后我可以快速算一下，就知道

102
00:05:04,190 --> 00:05:08,480
that I could have fit another 47 people in this same queue.
在这个队列中还可以容纳另外47个人。

103
00:05:08,480 --> 00:05:09,440
But it's finite.
但它是有限的。

104
00:05:09,440 --> 00:05:13,400
Of course, if we had 50 volunteers all wanting cookies, that's as many people
当然，如果我们有50个志愿者都想要饼干，那就和我们能处理的人数一样多。

105
00:05:13,400 --> 00:05:14,660
as we could actually handle.
就是我们实际能处理的人数。

106
00:05:14,660 --> 00:05:17,840
So there is this upper bound then on how many we could fit.
所以我们可以容纳的人数是有上限的。

107
00:05:17,840 --> 00:05:21,800
But there's yet other ways for storing data inside of a computer's memory.
但是，在计算机的内存中还有其他存储数据的方式。

108
00:05:21,800 --> 00:05:24,410
And there's this other abstract data type known as a stack.
还有另一种抽象数据类型叫做栈。

109
00:05:24,410 --> 00:05:26,600
And stacks are actually omnipresent as well
而且栈实际上无处不在

110
00:05:26,600 --> 00:05:29,340
even though it's not necessarily the system
尽管它不一定是

111
00:05:29,340 --> 00:05:31,640
you would want when you line up on stage.
你想要在舞台上排队的系统。

112
00:05:31,640 --> 00:05:34,070
For instance, could we get three more volunteers?
例如，我们可以再找到三个志愿者吗？

113
00:05:34,070 --> 00:05:37,190
OK, I saw a hand here, right here, and right here.
好的，我看到这里有一只手，这里还有一只手，这里还有一只手。

114
00:05:37,190 --> 00:05:38,150
Come on down.
请过来。

115
00:05:38,150 --> 00:05:40,610
We'll have the orchestra come up this time.
这次让乐队过来。

116
00:05:40,610 --> 00:05:43,580
All right, come on over.
好的，请过来。

117
00:05:43,580 --> 00:05:45,740
And if you wouldn't mind, come on over.
如果你不介意，请过来。

118
00:05:45,740 --> 00:05:47,620
We'll do introductions first.
我们先做一下自我介绍。

119
00:05:47,620 --> 00:05:50,870
This will be almost as easy as the last one if you want to introduce yourself.
如果你想做自我介绍，这将和上一个一样简单。

120
00:05:50,870 --> 00:05:52,890
And let me just stack you against the lectern this time.
这次我让你们在讲台上排成一列。

121
00:05:52,890 --> 00:05:54,090
So if you could go there.
所以请你们到那里去。

122
00:05:54,090 --> 00:05:55,560
And if you could come over here.
请你过来这边。

123
00:05:55,560 --> 00:05:58,220
And if you could come over here, we'll stack all three of you.
请你过来这边，我们把你们三个都排成一列。

124
00:05:58,220 --> 00:05:58,970
So you were first.
所以你第一个。

125
00:05:58,970 --> 00:06:00,260
So you're first in the stack.
所以你在栈里排第一个。

126
00:06:00,260 --> 00:06:00,530
SPEAKER: Hi.
嗨。

127
00:06:00,530 --> 00:06:01,130
I'm [INAUDIBLE].
我叫[听不清]。

128
00:06:01,130 --> 00:06:02,505
I have no idea what I'm studying.
我不知道我学什么。

129
00:06:02,505 --> 00:06:03,452
And I live in Strauss.
我住在斯特劳斯。

130
00:06:03,452 --> 00:06:04,535
DAVID J. MALAN: Wonderful.
太好了。

131
00:06:04,535 --> 00:06:05,035
And next?
下一个？

132
00:06:05,035 --> 00:06:05,535
SPEAKER: Hi.
嗨。

133
00:06:05,535 --> 00:06:07,370
I'm [? Tanai. ?] I'm studying econ and CS.
我叫[？Tanai？] 我学习经济学和计算机科学。

134
00:06:07,370 --> 00:06:09,270
And I live in Canada.
我住在加拿大。

135
00:06:09,270 --> 00:06:09,770
CLARA: Hi.
嗨。

136
00:06:09,770 --> 00:06:10,160
I'm Clara.
我叫克拉拉。

137
00:06:10,160 --> 00:06:11,240
I want to study applied math.
我想学习应用数学。

138
00:06:11,240 --> 00:06:12,320
And I'm in Wigglesworth.
我住在维格尔斯沃斯。

139
00:06:12,320 --> 00:06:12,860
DAVID J. MALAN: Wonderful.
太好了。

140
00:06:12,860 --> 00:06:14,068
Welcome, to all three of you.
欢迎你们三位。

141
00:06:14,068 --> 00:06:18,260
And if I may, let me just advance a bit more information about stacks.
如果可以，我想再谈一下关于栈的一些信息。

142
00:06:18,260 --> 00:06:21,050
The catch is that stacks actually support
关键是栈实际上支持

143
00:06:21,050 --> 00:06:24,470
what's known as LIFO, so last in, first out, which
一种叫做LIFO的东西，也就是后进先出，这

144
00:06:24,470 --> 00:06:26,850
is sort of the opposite really of a queue or a line.
实际上是队列或线的反义词。

145
00:06:26,850 --> 00:06:28,440
So in fact you were last in line.
所以实际上你在队列的最后。

146
00:06:28,440 --> 00:06:29,900
So here we have your cookies.
所以这是你的饼干。

147
00:06:29,900 --> 00:06:30,687
Thank you so much.
非常感谢。

148
00:06:30,687 --> 00:06:33,270
And if you'd like to exit that way, we have your cookies here.
如果你想从这边出去，你的饼干在这边。

149
00:06:33,270 --> 00:06:34,020
Thank you so much.
非常感谢。

150
00:06:34,020 --> 00:06:35,370
We'd you to exit this way.
请从这边离开。

151
00:06:35,370 --> 00:06:39,320
And even though you were first, LIFO doesn't really
即使你是第一个，后进先出法（LIFO）实际上并不会

152
00:06:39,320 --> 00:06:43,970
give you any cookies because you're first in, not last in.
给你任何饼干，因为你是第一个进来的，而不是最后一个进来的。

153
00:06:43,970 --> 00:06:45,920
So, yeah, OK, point's made.
所以，好吧，明白了。

154
00:06:45,920 --> 00:06:47,370
We'll give you the cookies.
我们会给你饼干的。

155
00:06:47,370 --> 00:06:50,030
All right, so thank you to all three of our volunteers.
好了，感谢三位志愿者。

156
00:06:50,030 --> 00:06:55,160
But LIFO, suffice to say, doesn't offer the same fairness
但后进先出法（LIFO）不足以说，它没有提供与队列或传统排队方式相同的公平性

157
00:06:55,160 --> 00:06:58,070
guarantees as a queue or a line more traditionally.
保证。

158
00:06:58,070 --> 00:07:01,680
And imagine just lining up in any store or the dining hall or the like.
想象一下在任何商店或食堂排队。

159
00:07:01,680 --> 00:07:06,540
Ideally, you want the people running the place to adhere to that queue,
理想情况下，你希望经营场所的人遵守队列，

160
00:07:06,540 --> 00:07:10,620
to that line so that FIFO is preserved if you indeed care about being first,
遵守排队顺序，以便如果你确实关心谁是第一个，那么先到先得法（FIFO）可以得到保留，

161
00:07:10,620 --> 00:07:15,130
whereas there are contexts in which LIFO does actually make sense.
而在一些情况下，后进先出法（LIFO）确实有意义。

162
00:07:15,130 --> 00:07:18,180
In fact, if you think about Gmail, your inbox, or Outlook,
事实上，如果你想想 Gmail、你的收件箱或 Outlook，

163
00:07:18,180 --> 00:07:21,083
typically you're viewing your inbox as a stack right.
通常你将你的收件箱视为一个堆栈，对吧？

164
00:07:21,083 --> 00:07:23,250
Because when you get new mail, where does it end up?
因为当你收到新邮件时，它会在哪里？

165
00:07:23,250 --> 00:07:26,080
It actually ends up in the top.
它实际上会出现在顶部。

166
00:07:26,080 --> 00:07:30,000
And if you're like me, odds are which emails do you tend to first?
如果你像我一样，你会倾向于先看哪封邮件？

167
00:07:30,000 --> 00:07:32,640
I mean, probably the ones on the top, the ones that
我的意思是，可能是那些在顶部的，那些

168
00:07:32,640 --> 00:07:36,300
came in last, most recently that is and that might actually
最后进来的，也就是最近的邮件，实际上可能

169
00:07:36,300 --> 00:07:39,578
be to the detriment of people who emailed you earlier today or yesterday.
对今天或昨天早些时候给你发邮件的人不利。

170
00:07:39,578 --> 00:07:42,120
Because once they sort of fall off the bottom of your screen,
因为一旦它们从你屏幕的底部掉下来，

171
00:07:42,120 --> 00:07:45,390
frankly, unless you click next, you may never see those emails again.
坦白地说，除非你点击“下一页”，否则你可能永远不会再看到那些邮件。

172
00:07:45,390 --> 00:07:48,000
But stacks are indeed one way of storing data.
但堆栈确实是一种存储数据的方式。

173
00:07:48,000 --> 00:07:50,520
And Google and Microsoft presumably made the judgment
谷歌和微软可能做出了判断，

174
00:07:50,520 --> 00:07:55,200
call that, in general, we users want to see the most recent data first.
认为，总的来说，我们用户希望首先看到最新数据。

175
00:07:55,200 --> 00:07:58,110
The last information might be the first we want out.
最新的信息可能是我们最想得到的。

176
00:07:58,110 --> 00:08:01,140
Now, just in terms of nomenclature, the two operations
现在，就术语而言，与入队和出队相似的两种操作

177
00:08:01,140 --> 00:08:03,990
that are analogous to enqueueing and dequeueing
分别是入栈和出栈。

178
00:08:03,990 --> 00:08:07,870
but with this property of LIFO are instead called push and pop.
它们具有后进先出法（LIFO）的特性，分别被称为入栈和出栈。

179
00:08:07,870 --> 00:08:10,350
So when our first volunteer came up on stage, so to speak,
所以当我们的第一个志愿者上台时，可以这么说，

180
00:08:10,350 --> 00:08:12,930
I pushed him onto the stack against the lectern there.
我把他推到讲台旁边的堆栈上。

181
00:08:12,930 --> 00:08:14,370
Second person was pushed.
第二个人被推进去。

182
00:08:14,370 --> 00:08:15,587
Third person was pushed.
第三个人被推进去。

183
00:08:15,587 --> 00:08:17,670
And then when it was time to hand out the cookies,
然后当发放饼干的时候，

184
00:08:17,670 --> 00:08:21,720
we popped them, so to speak, one after the other but preserving that LIFO
我们可以将它们“弹出”，一个接一个，但保留后进先出法（LIFO）

185
00:08:21,720 --> 00:08:22,285
property.
特性。

186
00:08:22,285 --> 00:08:24,660
But here's where things are a little interesting in terms
但这里在实现细节方面有点意思。

187
00:08:24,660 --> 00:08:26,220
of implementation details.
在实现细节方面。

188
00:08:26,220 --> 00:08:30,930
A stack could be implemented almost identically underneath the hood
堆栈可以在幕后几乎完全相同地实现

189
00:08:30,930 --> 00:08:33,039
to a queue because what do you need?
与队列相同，因为你需要什么？

190
00:08:33,039 --> 00:08:36,240
You need an array of people, which we could use our person data
你需要一个人的数组，我们可以使用我们在过去的课程中使用的人员数据

191
00:08:36,240 --> 00:08:38,304
type for past classes.
类型。

192
00:08:38,304 --> 00:08:40,679
We have to keep track of how many people are in the stack
我们必须跟踪堆栈中有多少人

193
00:08:40,679 --> 00:08:43,260
so that even if we have a capacity of like 50,
这样即使我们的容量是 50，

194
00:08:43,260 --> 00:08:48,330
we know at least that we can store 3 plus maybe 47 others.
我们至少知道我们可以存储 3 个人，再加上可能另外 47 个人。

195
00:08:48,330 --> 00:08:51,330
Now, there's still going to be a change in the underlying implementation
现在，底层实现仍然会有一些变化。

196
00:08:51,330 --> 00:08:55,830
details because not pictured here is the actual C code that actually pushes
细节是因为这里没有显示实际的 C 代码，它实际上是推入的

197
00:08:55,830 --> 00:08:57,900
and pops or enqueues and dequeues.
以及弹出或入队和出队。

198
00:08:57,900 --> 00:09:01,290
So whatever loops you're using, whatever code you're using,
所以无论你使用什么循环，无论你使用什么代码，

199
00:09:01,290 --> 00:09:04,110
odds are that's where those properties are going to be implemented.
这些属性很可能是在那里实现的。

200
00:09:04,110 --> 00:09:06,690
FIFO versus LIFO, you're going to implement maybe the loop
FIFO 与 LIFO，你可能会在循环中实现

201
00:09:06,690 --> 00:09:10,470
in this direction instead of this one or some such distinction.
在这个方向而不是那个方向，或者类似的区分。

202
00:09:10,470 --> 00:09:12,690
But at the end of the day, stacks and queues
但归根结底，栈和队列

203
00:09:12,690 --> 00:09:15,030
are just abstract data types in the sense
只是抽象数据类型，从某种意义上说

204
00:09:15,030 --> 00:09:17,700
that we can implement them in bunches of ways, two of them
我们可以用很多方法来实现它们，其中两种

205
00:09:17,700 --> 00:09:19,650
among them here thus far on the screen.
其中已经出现在屏幕上。

206
00:09:19,650 --> 00:09:21,870
But that array is going to come back to bite us.
但那个数组会回来咬我们。

207
00:09:21,870 --> 00:09:24,360
Because if you only have a capacity of 50,
因为如果你只有 50 个容量，

208
00:09:24,360 --> 00:09:27,450
what happens if 51 people want cookies next time?
如果下次有 51 个人想要饼干怎么办？

209
00:09:27,450 --> 00:09:30,300
You just don't have room for them even though, clearly, we have
你根本没有空间容纳他们，尽管很明显，我们有

210
00:09:30,300 --> 00:09:32,010
enough room for the people themselves.
足够的空间容纳这些人。

211
00:09:32,010 --> 00:09:33,240
We have enough memory.
我们有足够的内存。

212
00:09:33,240 --> 00:09:36,300
So it seems a little shortsighted to limit just how much data
所以，限制数据结构中可以容纳多少数据似乎有点目光短浅。

213
00:09:36,300 --> 00:09:38,170
can fit in our data structures.
可以容纳在我们数据结构中。

214
00:09:38,170 --> 00:09:41,580
So with that said, a friend of ours, Shannon Duvall at Elon University,
话虽如此，我们的一位朋友，艾伦大学的香农·杜瓦尔，

215
00:09:41,580 --> 00:09:45,390
kindly put together a visualization of the same.
好心地将同样的内容可视化。

216
00:09:45,390 --> 00:09:50,490
And allow me to introduce you to two fellows known as Jack and Lou.
现在让我向大家介绍两位名叫杰克和卢的家伙。

217
00:09:50,490 --> 00:09:52,485
If we could dim the lights for this video.
如果可以的话，请为这个视频调暗灯光。

218
00:09:52,485 --> 00:09:53,152
[VIDEO PLAYBACK]
[视频播放]

219
00:09:53,152 --> 00:09:56,138
[MUSIC PLAYING]
[音乐播放]

220
00:09:58,112 --> 00:10:00,940
- Once upon a time, there was a guy named Jack.
从前，有个名叫杰克的家伙。

221
00:10:00,940 --> 00:10:04,270
When it came to making friends, Jack did not have the knack.
说到交朋友，杰克没有天赋。

222
00:10:04,270 --> 00:10:07,300
So Jack went to talk to the most popular guy he knew.
于是杰克去和一个他认识的最受欢迎的人聊天。

223
00:10:07,300 --> 00:10:09,910
He went up to Lou and asked what do I do?
他走到卢身边问：“我该怎么办？”

224
00:10:09,910 --> 00:10:12,430
Lou saw that his friend was really distressed.
卢看到他的朋友真的很痛苦。

225
00:10:12,430 --> 00:10:15,070
Well, Lou began, just look how you're dressed.
“嗯，”卢开始说，“看看你穿的衣服。”

226
00:10:15,070 --> 00:10:17,620
Don't you have any clothes with a different look?
“你没有穿不同风格的衣服吗？”

227
00:10:17,620 --> 00:10:18,820
Yes, said Jack.
“有，”杰克说。

228
00:10:18,820 --> 00:10:20,000
I sure do.
“当然有。”

229
00:10:20,000 --> 00:10:22,340
Come to my house and I'll show them to you.
“来我家，我给你看看。”

230
00:10:22,340 --> 00:10:23,590
So they went off to Jack's.
于是他们去了杰克的家。

231
00:10:23,590 --> 00:10:26,620
And Jack showed Lou the box where he kept all his shirts
杰克给卢看一个箱子，里面放着他的所有衬衫

232
00:10:26,620 --> 00:10:28,270
and his pants and his socks.
还有他的裤子和袜子。

233
00:10:28,270 --> 00:10:31,330
Lou said, I see you have all your clothes in a pile.
卢说：“我看到你把所有的衣服都堆在一起。”

234
00:10:31,330 --> 00:10:33,820
Why don't you wear some others once in a while?
“为什么你不时地换着穿？”

235
00:10:33,820 --> 00:10:37,090
Jack said, well, when I remove clothes and socks,
杰克说：“嗯，当我脱掉衣服和袜子时，

236
00:10:37,090 --> 00:10:39,760
I wash them and put them away in the box.
我会洗掉它们，然后放回箱子里。”

237
00:10:39,760 --> 00:10:42,340
Then comes the next morning, and up I hop.
“然后第二天早上，我就跳起来。”

238
00:10:42,340 --> 00:10:45,400
I go to the box and get my clothes off the top.
“我走到箱子旁边，从上面拿衣服。”

239
00:10:45,400 --> 00:10:48,100
Lou quickly realized the problem with Jack.
卢很快就意识到杰克的问题所在。

240
00:10:48,100 --> 00:10:51,070
He kept clothes, CDs, and books in a stack.
他把衣服、CD 和书堆在一起。

241
00:10:51,070 --> 00:10:53,600
When he reached for something to read or to wear,
当他伸手去拿东西阅读或穿着时，

242
00:10:53,600 --> 00:10:55,960
he chose the top book or underwear.
他选择了最上面的书或内衣。

243
00:10:55,960 --> 00:10:58,580
Then when he was done, he would put it right back.
然后当他做完后，他会把它放回去。

244
00:10:58,580 --> 00:11:01,230
Back it would go on top of the stack.
它又回到了堆顶。

245
00:11:01,230 --> 00:11:03,560
I know the solution, said the triumphant Lou.
“我知道解决办法，”卢得意地说。

246
00:11:03,560 --> 00:11:06,140
You need to learn to start using a queue.
你需要学习如何开始使用队列。

247
00:11:06,140 --> 00:11:09,090
Lou took Jack's clothes and hung them in a closet.
Lou拿走了Jack的衣服，把它们挂在壁橱里。

248
00:11:09,090 --> 00:11:11,720
And when he had emptied the box, he just tossed it.
当他清空了盒子后，他就把它扔了。

249
00:11:11,720 --> 00:11:15,710
Then he said now, Jack, at the end of the day, put your clothes on the left
然后他说，Jack，在一天结束的时候，把你的衣服放在左边

250
00:11:15,710 --> 00:11:17,160
when you put them away.
当你收纳的时候。

251
00:11:17,160 --> 00:11:18,920
Then tomorrow morning when you see the sun
那么明天早上，当你看到太阳

252
00:11:18,920 --> 00:11:22,550
shine, get your clothes from the right from the end of the line.
照耀的时候，从队列的末端，从右边拿你的衣服。

253
00:11:22,550 --> 00:11:24,050
Don't you see, said Lou?
“你不明白吗，”Lou说。

254
00:11:24,050 --> 00:11:25,520
It will be so nice.
这会很棒。

255
00:11:25,520 --> 00:11:28,700
You'll wear everything once before you wear something twice.
在你第二次穿之前，你就会把所有东西都穿一遍。

256
00:11:28,700 --> 00:11:31,760
And with everything in queues in his closet and shelf,
而随着壁橱和架子上所有东西都排成队列，

257
00:11:31,760 --> 00:11:34,940
Jack started to feel quite sure of himself all thanks
Jack开始对自己非常有信心，这都要归功于

258
00:11:34,940 --> 00:11:36,920
to Lou and his wonderful queue.
Lou和他的神奇队列。

259
00:11:39,535 --> 00:11:40,430
[END PLAYBACK]
[播放结束]

260
00:11:40,930 --> 00:11:42,180
DAVID J. MALAN: So the same--
DAVID J. MALAN：所以是一样的——

261
00:11:42,180 --> 00:11:44,010
wonderful, thanks to Shannon--
很棒，感谢Shannon——

262
00:11:44,010 --> 00:11:46,440
so you might have noticed I wear black all the time
所以你可能已经注意到我总是穿黑色

263
00:11:46,440 --> 00:11:49,660
so we could make a similar gag about here's what my stack of clothes at home
所以我们可以做个类似的笑话，这就是我在家里的衣服堆的样子

264
00:11:49,660 --> 00:11:50,160
looks.
看起来。

265
00:11:50,160 --> 00:11:52,740
Even though I might own a blue and a red sweatshirt,
尽管我可能有一件蓝色和一件红色运动衫，

266
00:11:52,740 --> 00:11:55,980
it doesn't really work if you're popping everything from a stack every time,
如果你每次都从堆栈中弹出所有东西，这实际上是行不通的，

267
00:11:55,980 --> 00:11:59,130
cleaning it, replenishing the blacks sweaters before the red or the blue
清洁它，在红色或蓝色运动衫之前补充黑色运动衫

268
00:11:59,130 --> 00:12:00,720
even get popped themselves.
甚至自己也弹出。

269
00:12:00,720 --> 00:12:03,482
But we're going to focus today not just on stacks and queues
但今天我们将重点关注的不只是堆栈和队列

270
00:12:03,482 --> 00:12:05,190
which for us are really meant to motivate
这对我们来说真的旨在激励

271
00:12:05,190 --> 00:12:09,430
different ways of designing data even though the implementation details might
不同的数据设计方式，即使实现细节可能

272
00:12:09,430 --> 00:12:09,930
differ.
有所不同。

273
00:12:09,930 --> 00:12:12,000
But we're going to start focusing on solving some problems
但我们将开始专注于解决一些问题

274
00:12:12,000 --> 00:12:14,430
that invariably we'd be bumping up against anyway as we
不可避免地，我们会在开发过程中遇到这些问题

275
00:12:14,430 --> 00:12:17,070
develop more and more real world software, not just
开发越来越多的现实世界软件，而不仅仅是

276
00:12:17,070 --> 00:12:18,540
smaller programs as in class.
课堂上的小型程序。

277
00:12:18,540 --> 00:12:20,910
And arrays, recall, are what?
数组，还记得，是什么？

278
00:12:20,910 --> 00:12:22,830
What's the key characteristic or definition
数组的关键特征或定义是什么？

279
00:12:22,830 --> 00:12:25,448
of an array with respect to your computer's memory
数组与计算机内存相关的

280
00:12:25,448 --> 00:12:26,490
and storing things in it?
以及在其中存储事物？

281
00:12:26,490 --> 00:12:27,110
Yeah?
是吗？

282
00:12:27,110 --> 00:12:28,860
AUDIENCE: It stores the data contiguously.
观众：它连续存储数据。

283
00:12:28,860 --> 00:12:29,860
DAVID J. MALAN: Perfect.
DAVID J. MALAN：完美。

284
00:12:29,860 --> 00:12:32,610
So it stores the data contiguously back to back to back.
所以它连续存储数据，一个接一个。

285
00:12:32,610 --> 00:12:36,542
And as we've seen thus far, when you allocate space for an array,
正如我们迄今为止所看到的，当你为数组分配空间时，

286
00:12:36,542 --> 00:12:38,250
you typically do it with square brackets.
你通常用方括号来做。

287
00:12:38,250 --> 00:12:40,800
You specify a number in those brackets or maybe a constant,
你在方括号中指定一个数字，或者是一个常量，

288
00:12:40,800 --> 00:12:42,570
like capacity, like I just did.
比如容量，就像我刚才做的那样。

289
00:12:42,570 --> 00:12:45,780
And that fixates just how much data you can actually store in there.
这会固定你实际上可以存储多少数据。

290
00:12:45,780 --> 00:12:48,210
We did see last week, though, that we could
不过我们上周看到了，我们可以

291
00:12:48,210 --> 00:12:52,050
start to use malloc to allocate an equivalent number of bytes.
开始使用malloc来分配相同数量的字节。

292
00:12:52,050 --> 00:12:54,090
But even that, when you call it just once,
但即使这样，当你只调用它一次时，

293
00:12:54,090 --> 00:12:56,740
gives you back a specific finite number of bytes.
它会返回一个特定的有限数量的字节。

294
00:12:56,740 --> 00:12:59,280
So you're similarly deciding in advance how much memory you
因此，你同样要提前决定可以存储多少内存

295
00:12:59,280 --> 00:13:00,883
can store in an array.
在一个数组中。

296
00:13:00,883 --> 00:13:03,550
So let's consider what kinds of problems this could get us into.
那么让我们考虑一下这可能会导致什么问题。

297
00:13:03,550 --> 00:13:04,947
So here's an array of size three.
这是一个大小为 3 的数组。

298
00:13:04,947 --> 00:13:06,780
And suppose for the sake of discussion we've
为了便于讨论，假设我们已经

299
00:13:06,780 --> 00:13:10,290
already put three numbers into it 1, 2, and 3 literally.
将 1、2 和 3 这三个数字放入了其中。

300
00:13:10,290 --> 00:13:13,440
Suppose now we want to add a fourth number to that array.
现在假设我们想在这个数组中添加第四个数字。

301
00:13:13,440 --> 00:13:14,820
Well, where does it go?
那么它应该放在哪里呢？

302
00:13:14,820 --> 00:13:18,610
Intuitively and pictorially, you'd like to think it could go there.
从直觉和图像上来说，你可能想把它放在那里。

303
00:13:18,610 --> 00:13:21,390
But remember the context we introduced last week when
但请记住我们上周介绍的关于

304
00:13:21,390 --> 00:13:22,890
we talked about computers' memories.
计算机内存的内容。

305
00:13:22,890 --> 00:13:24,760
There's lots of stuff going on.
有很多事情正在发生。

306
00:13:24,760 --> 00:13:28,600
And if you only ask the computer, the operating system,
如果你只询问计算机，操作系统，

307
00:13:28,600 --> 00:13:32,795
room for three integers, who knows what's here and here and here,
只有三个整数的空间，谁知道这里，这里和这里是什么？

308
00:13:32,795 --> 00:13:34,670
not to mention everywhere else on the screen?
更不用说屏幕上的其他地方了？

309
00:13:34,670 --> 00:13:38,440
So if we zoom out for instance, we might like to put the number four there.
所以，如果我们放大来看，我们可能想把数字 4 放在那里。

310
00:13:38,440 --> 00:13:43,010
But we can't if in that greater context there's a lot more stuff going on.
但我们不能，因为在更大的环境中，还有更多的事情正在发生。

311
00:13:43,010 --> 00:13:46,550
So for instance, suppose that elsewhere in my same program or function
例如，假设在我的同一个程序或函数中的其他地方

312
00:13:46,550 --> 00:13:50,890
I've already created a string like H-E-L-L-O, comma, space, world,
我已经创建了一个字符串，例如 H-E-L-L-O, 逗号, 空格, world,

313
00:13:50,890 --> 00:13:52,120
backslash 0.
反斜杠 0。

314
00:13:52,120 --> 00:13:56,050
Just by bad luck, that could be allocated right next to my 1, 2, 3.
不幸的是，它可能被分配到我的 1、2、3 的旁边。

315
00:13:56,050 --> 00:13:56,620
Why?
为什么？

316
00:13:56,620 --> 00:13:59,860
Well, if I ask the operating system for space for three numbers,
好吧，如果我向操作系统请求三个数字的空间，

317
00:13:59,860 --> 00:14:02,710
then I ask the operating system for space for a string,
然后我向操作系统请求一个字符串的空间，

318
00:14:02,710 --> 00:14:06,580
it's pretty reasonable for the computer to put those things back to back,
计算机将这些东西放在一起是相当合理的，

319
00:14:06,580 --> 00:14:10,360
because it's not going to anticipate for us that, well, maybe they actually want
因为它不会为我们预先判断，嗯，也许他们实际上想要

320
00:14:10,360 --> 00:14:13,030
four numbers eventually or five numbers or more.
最终要四个数字，或者五个数字，或者更多。

321
00:14:13,030 --> 00:14:15,520
Now, as for all of these Oscars the Grouch,
现在，至于这些奥斯卡·葛鲁奇，

322
00:14:15,520 --> 00:14:17,920
that's just meant to represent pictorially
这仅仅是图像化地表示

323
00:14:17,920 --> 00:14:19,480
here the notion of garbage values.
这里垃圾值的概念。

324
00:14:19,480 --> 00:14:22,300
There's clearly other bytes there and available.
这里明显还有其他字节可用。

325
00:14:22,300 --> 00:14:23,680
I don't know what it is.
我不知道它是什么。

326
00:14:23,680 --> 00:14:24,910
And I don't care what it is.
我并不关心它是什么。

327
00:14:24,910 --> 00:14:29,020
But I do care that I can't just presume to put something right where
但我确实关心，我不能只是假定把东西放在

328
00:14:29,020 --> 00:14:33,350
I want in the computer's memory unless I preemptively ask it for more memory.
我希望在计算机内存中的位置，除非我提前请求更多内存。

329
00:14:33,350 --> 00:14:35,290
Now, if all of those are garbage values, which
现在，如果所有这些都是垃圾值，也就是

330
00:14:35,290 --> 00:14:38,410
is to say that who cares what they are-- it's just junk left over
也就是说，谁在乎它们是什么——这只是之前函数运行时剩下的垃圾——

331
00:14:38,410 --> 00:14:40,900
from previous runs of the function or the like--
来自之前函数运行的类似情况——

332
00:14:40,900 --> 00:14:44,140
there's clearly plenty of room for a fourth number.
明显还有很多空间可以放第四个数字。

333
00:14:44,140 --> 00:14:48,760
I could put the number four here or here or here or down here or here or here.
我可以把数字 4 放在这里，或者这里，或者这里，或者这里，或者这里，或者这里。

334
00:14:48,760 --> 00:14:51,670
But why would I not want to just plop the four wherever
但是，为什么我不想把 4 直接放在

335
00:14:51,670 --> 00:14:53,780
there is a garbage value currently?
现在有垃圾值的地方呢？

336
00:14:53,780 --> 00:14:54,280
Yeah?
是吗？

337
00:14:54,280 --> 00:14:57,580
AUDIENCE: Because you want it to be next to your array of 1, 2, 3.
观众：因为您希望它位于您的 1、2、3 数组旁边。

338
00:14:57,580 --> 00:15:00,205
DAVID J. MALAN: Exactly, I want it to be next to my array of 1,
大卫·马兰：没错，我希望它在我的 1 数组旁边，

339
00:15:00,205 --> 00:15:03,910
2, 3 because, again, arrays must be and must remain contiguous.
2、3 数组，因为，再次强调，数组必须是，并且必须保持连续。

340
00:15:03,910 --> 00:15:07,030
Now, that's not a deal breaker because where else could I
现在，这并不是一个决定性的问题，因为我还能把

341
00:15:07,030 --> 00:15:09,010
put maybe the entire array?
整个数组放在哪里呢？

342
00:15:09,010 --> 00:15:11,080
Well, there's room up here for four numbers.
嗯，这里有足够的空间放四个数字。

343
00:15:11,080 --> 00:15:12,980
There's room down here for four numbers.
这里还有空间可以放四个数字。

344
00:15:12,980 --> 00:15:13,720
So that's fine.
所以这很好。

345
00:15:13,720 --> 00:15:15,650
And that could be a solution to the problem.
这可以成为问题的解决方案。

346
00:15:15,650 --> 00:15:18,220
If you've run out of space in your fixed size array,
如果你在固定大小的数组中用完了空间，

347
00:15:18,220 --> 00:15:20,890
well maybe I just abstract everything else away,
也许我可以将其他所有内容抽象出来，

348
00:15:20,890 --> 00:15:25,270
and I just move my array to a different location that's a little bit bigger.
然后将我的数组移动到一个更大的位置。

349
00:15:25,270 --> 00:15:26,770
But there is going to be a downside.
但这样做也会有缺点。

350
00:15:26,770 --> 00:15:29,228
Even though this is a solution, even though I can certainly
即使这是一个解决方案，即使我肯定可以

351
00:15:29,228 --> 00:15:32,810
copy the 1, the 2, the 3-- and now I can plop the 4 there.
复制 1、2、3，现在我可以把 4 放到那里。

352
00:15:32,810 --> 00:15:36,010
And, heck, I can then let go of the old memory in some way
而且，我可以以某种方式释放旧内存

353
00:15:36,010 --> 00:15:38,920
and give it back to the operating system to be reused later.
并将其返还给操作系统以便稍后重用。

354
00:15:38,920 --> 00:15:40,720
This is successful.
这是成功的。

355
00:15:40,720 --> 00:15:44,350
But why intuitively might we not want this
但从直觉上讲，我们为什么不希望

356
00:15:44,350 --> 00:15:48,640
to be our solution of creating a new array that's a little bigger,
成为我们的解决方案，即创建一个更大的新数组，

357
00:15:48,640 --> 00:15:51,400
copying the old into the new, and getting rid of the old?
将旧的复制到新的中，并丢弃旧的？

358
00:15:55,310 --> 00:15:57,080
Good, yeah, I think I had one more step.
好的，是的，我认为我还有一个步骤。

359
00:15:57,080 --> 00:15:59,420
Suppose I want to add a fifth number, a sixth number.
假设我想添加第五个数字、第六个数字。

360
00:15:59,420 --> 00:16:00,740
That's a lot of work.
那可是很多工作。

361
00:16:00,740 --> 00:16:04,080
And, in fact, what's the expensive part or what's the slow part of that story?
实际上，那个故事中哪个部分最昂贵，哪个部分最慢？

362
00:16:04,080 --> 00:16:04,580
Yeah?
对吧？

363
00:16:04,580 --> 00:16:05,955
AUDIENCE: It takes a lot of time.
观众：这需要很多时间。

364
00:16:05,955 --> 00:16:07,580
DAVID J. MALAN: It takes a lot of time.
大卫·马兰：这需要很多时间。

365
00:16:07,580 --> 00:16:10,570
But specifically, what's taking time if we can put our finger on it?
具体来说，如果我们能指出的话，是什么在占用时间？

366
00:16:10,570 --> 00:16:11,860
Yeah, in the back?
对，在后面的人？

367
00:16:11,860 --> 00:16:14,260
AUDIENCE: You're using twice as much.
观众：你使用了双倍的内存。

368
00:16:14,260 --> 00:16:16,310
DAVID J. MALAN: OK, for a period of time,
大卫·马兰：好的，在一段时间内，

369
00:16:16,310 --> 00:16:19,120
I'm using twice as much memory, which certainly seems wasteful
我使用了双倍的内存，这看起来确实很浪费

370
00:16:19,120 --> 00:16:22,510
because even though I don't eventually need it, it is going to mushroom
因为即使我最终不需要它，它也会像蘑菇一样疯长

371
00:16:22,510 --> 00:16:26,150
and then shrink back down, which seems like an inefficient use of resources.
然后缩小，这似乎是一种低效的资源使用方式。

372
00:16:26,150 --> 00:16:28,930
But what specifically is slow about this process too?
但具体来说，这个过程的哪些方面也很慢呢？

373
00:16:28,930 --> 00:16:30,063
Yeah, in the middle.
对，中间的人。

374
00:16:30,063 --> 00:16:32,980
AUDIENCE: You're iterating through the original array to copy it over.
观众：你在遍历原始数组以将其复制过去。

375
00:16:32,980 --> 00:16:34,772
DAVID J. MALAN: Yeah, good choice of words.
大卫·马兰：是的，用词很好。

376
00:16:34,772 --> 00:16:38,390
You're iterating over the array to copy it over using a for loop, a while loop.
你正在使用 for 循环或 while 循环遍历数组以将其复制过去。

377
00:16:38,390 --> 00:16:41,020
So it's probably like big O of n steps just
所以这可能就像大 O 的 n 步

378
00:16:41,020 --> 00:16:44,260
to copy the array and technically big O of n plus 1 if we had one more.
来复制数组，从技术上讲，如果我们再多一个的话，就是大 O 的 n 加 1。

379
00:16:44,260 --> 00:16:45,520
But that's still big O of n.
但那仍然是大 O 的 n。

380
00:16:45,520 --> 00:16:48,580
So it's the copying, the moving of the data, so to speak,
所以说，它是复制，移动数据，

381
00:16:48,580 --> 00:16:50,120
that's certainly correct.
这当然没错。

382
00:16:50,120 --> 00:16:52,450
But maybe it's not the best design.
但也许这不是最好的设计。

383
00:16:52,450 --> 00:16:55,060
Wouldn't it be better if we could do something otherwise?
如果我们可以做些别的事，会不会更好？

384
00:16:55,060 --> 00:16:58,510
Well, let's consider what this might actually translate into in code
好吧，让我们考虑一下这实际上如何在代码中体现

385
00:16:58,510 --> 00:17:00,370
and what the implications then might be.
以及由此可能带来的影响。

386
00:17:00,370 --> 00:17:02,320
Let me switch over here to VS Code.
让我切换到 VS Code。

387
00:17:02,320 --> 00:17:07,700
Let me propose to open up a file called list.c brand new.
我建议打开一个名为 list.c 的全新文件。

388
00:17:07,700 --> 00:17:10,920
And let's create this list of numbers and then add to it over time
让我们创建一个数字列表，然后随着时间的推移不断添加内容

389
00:17:10,920 --> 00:17:13,770
and see when and where we actually bump up against these problems.
然后看看我们何时何地会遇到这些问题。

390
00:17:13,770 --> 00:17:17,450
So let me include standard io.h in order to simply
所以，让我包含 standard io.h，以便简单地

391
00:17:17,450 --> 00:17:21,290
be able to print things out ultimately, int main void, so no need
最终能够打印出内容，int main void，所以不需要

392
00:17:21,290 --> 00:17:22,880
for command line arguments here.
在这里使用命令行参数。

393
00:17:22,880 --> 00:17:27,950
Let me give myself an array called list just of size 3
让我给自己一个叫做list的数组，大小为3

394
00:17:27,950 --> 00:17:29,960
for consistency with the picture thus far.
为了与迄今为止的图片保持一致。

395
00:17:29,960 --> 00:17:31,970
And now let me go ahead and just manually
现在让我继续手动

396
00:17:31,970 --> 00:17:34,250
make it look like in memory what it did on the screen.
让它在内存中看起来像它在屏幕上所做的那样。

397
00:17:34,250 --> 00:17:37,520
So list bracket 0 is going to equal to number 1.
所以 list 中括号 0 将等于数字 1。

398
00:17:37,520 --> 00:17:40,790
List bracket 1 is going to equal the number 2.
List 中括号 1 将等于数字 2。

399
00:17:40,790 --> 00:17:42,920
And list bracket 2 equals number three.
而 list 中括号 2 等于数字 3。

400
00:17:42,920 --> 00:17:45,260
So even though the array is, of course, zero indexed,
所以即使数组是零索引的，当然，

401
00:17:45,260 --> 00:17:48,533
I'm using more familiar 1, 2, 3 as my digits here.
我在这里使用更熟悉的 1, 2, 3 作为我的数字。

402
00:17:48,533 --> 00:17:50,450
Now, suppose I want to print these things out.
现在，假设我想打印出这些东西。

403
00:17:50,450 --> 00:17:52,830
Let's just do something as a simple exercise.
让我们做一个简单的练习。

404
00:17:52,830 --> 00:17:58,520
So for int i equals 0, i is less than 3 i plus plus.
所以对于 int i 等于 0，i 小于 3 i 加加。

405
00:17:58,520 --> 00:18:01,220
Inside of this loop, I'm going to do something simple like print
在这个循环中，我将做一些简单的打印

406
00:18:01,220 --> 00:18:07,580
out iteratively, as you note, backslash n list bracket i.
迭代地输出，正如你所见，反斜杠 n list 中括号 i。

407
00:18:07,580 --> 00:18:09,000
So very simple program.
一个非常简单的程序。

408
00:18:09,000 --> 00:18:11,750
It's not the best design because I've got this magic number there.
这不是最好的设计，因为我在这里有一个神奇的数字。

409
00:18:11,750 --> 00:18:12,830
I'm hard coding the 3.
我硬编码了 3。

410
00:18:12,830 --> 00:18:15,080
But the point is just to go through the motions
但重点是只是走过这些动作

411
00:18:15,080 --> 00:18:19,250
of demonstrating how this code works.
来演示这段代码是如何工作的。

412
00:18:19,250 --> 00:18:21,805
Good, you got it in before I hit compile.
很好，你在我点击编译之前完成了。

413
00:18:21,805 --> 00:18:23,660
So wait.
所以等等。

414
00:18:23,660 --> 00:18:25,160
Thank you.
谢谢。

415
00:18:25,160 --> 00:18:26,630
All right.
好的。

416
00:18:26,630 --> 00:18:27,690
Maybe round of applause.
也许掌声。

417
00:18:27,690 --> 00:18:28,220
Thank you.
谢谢。

418
00:18:28,220 --> 00:18:30,170
[APPLAUSE]
[掌声]

419
00:18:30,170 --> 00:18:32,130
All right.
好的。

420
00:18:32,130 --> 00:18:34,880
All right, so this is going to get aggressive, though, eventually.
好的，所以这最终会变得咄咄逼人。

421
00:18:34,880 --> 00:18:36,740
So let me add the semicolon.
所以让我加上分号。

422
00:18:36,740 --> 00:18:39,960
Let me recompile this list.
让我重新编译这个列表。

423
00:18:39,960 --> 00:18:41,270
Seems to compile OK.
似乎编译正常。

424
00:18:41,270 --> 00:18:44,390
And if I do ./list, I should see, of course, 1, 2, 3.
如果我执行 ./list，我当然应该看到 1, 2, 3。

425
00:18:44,390 --> 00:18:45,380
So the code works.
所以代码有效。

426
00:18:45,380 --> 00:18:47,463
There's no memory constraints here because I'm not
这里没有内存限制，因为我没有

427
00:18:47,463 --> 00:18:48,980
trying to actually add some values.
试图实际添加一些值。

428
00:18:48,980 --> 00:18:54,200
But let me consider how I could go about implementing this idea of copying
但让我考虑如何实现这个复制的想法

429
00:18:54,200 --> 00:18:56,330
everything from the old array to the new array,
将所有内容从旧数组复制到新数组，

430
00:18:56,330 --> 00:18:59,960
frankly, just to see how annoying it is, how painful it is.
坦率地说，只是为了看看它有多烦人，有多痛苦。

431
00:18:59,960 --> 00:19:02,270
So you're about to see the code escalate quickly.
所以你将看到代码迅速升级。

432
00:19:02,270 --> 00:19:06,772
And it will be helpful to try to wrap your mind around each individual step
并且尝试理解每一个步骤将会有所帮助

433
00:19:06,772 --> 00:19:08,480
even though if you take a step back, it's
即使你退一步，它也是

434
00:19:08,480 --> 00:19:11,450
going to look like a crazy amount of code to solve a simple idea.
看起来像是为了解决一个简单的想法而写了大量的代码。

435
00:19:11,450 --> 00:19:12,330
But that's the point.
但这就是重点。

436
00:19:12,330 --> 00:19:14,660
We're going to get to a place, particularly in week 6
我们将到达一个地方，尤其是在第六周

437
00:19:14,660 --> 00:19:18,420
where all of what we're about to do reduces to one line of code.
我们即将要做的事情将简化为一行代码。

438
00:19:18,420 --> 00:19:19,998
So hang in there for now.
所以现在坚持住。

439
00:19:19,998 --> 00:19:21,290
So let me go ahead and do this.
所以让我继续做这件事。

440
00:19:21,290 --> 00:19:28,130
If I want to create a version of this code that can grow to fit more numbers,
如果我想创建一个可以扩展以容纳更多数字的代码版本，

441
00:19:28,130 --> 00:19:32,330
for instance, how can I go about doing this or at least demonstrate as much?
例如，我该怎么做呢？或者至少演示一下？

442
00:19:32,330 --> 00:19:37,070
Well, I cannot use an array in this traditional way of using square
好吧，我不能用这种传统的用方括号的方式来使用数组。

443
00:19:37,070 --> 00:19:42,140
brackets because that makes list, the variable, forever of size 3.
因为那样会使变量 list 永久地成为大小为 3 的列表。

444
00:19:42,140 --> 00:19:43,130
I can't free it.
我不能释放它。

445
00:19:43,130 --> 00:19:44,930
Remember free you can only use with malloc.
记住，free 只能与 malloc 一起使用。

446
00:19:44,930 --> 00:19:48,540
So you can't give it back and then recreate it using this syntax.
所以你不能将它归还，然后使用这种语法重新创建它。

447
00:19:48,540 --> 00:19:50,995
But I can use this trick from last time, whereby,
但我可以用上次的这个技巧，即

448
00:19:50,995 --> 00:19:53,870
if I know there is this function called malloc, whose purpose in life
如果我知道有一个叫做 malloc 的函数，它的作用是

449
00:19:53,870 --> 00:19:57,170
is to give me memory, I could, for instance re-declare
为我分配内存，我可以例如重新声明

450
00:19:57,170 --> 00:20:01,820
list to be a pointer so to speak that is the address of a chunk of memory.
list 为一个指针，它指向一块内存的地址。

451
00:20:01,820 --> 00:20:07,130
And I could ask malloc for a chunk of memory namely of size 3 but not 3
我可以向 malloc 请求一块内存，大小为 3，但不是 3

452
00:20:07,130 --> 00:20:09,770
per se, three integers for good measure.
本身，而是三个整数，以确保充足。

453
00:20:09,770 --> 00:20:14,180
So technically that's three times the size of whatever an int is.
因此，从技术上讲，这相当于 int 大小的三倍。

454
00:20:14,180 --> 00:20:17,690
Now, for our purposes today, that's technically 3 times 4 or 12.
现在，对于我们今天的目的，从技术上讲，这是 3 乘以 4 或 12。

455
00:20:17,690 --> 00:20:20,120
But I'm trying to do this very generally in case we use it
但我试图以一种非常普遍的方式来做这件事，以防我们使用它

456
00:20:20,120 --> 00:20:23,930
on an old computer or maybe a future computer, where the size of an int
在旧电脑上，或者可能是未来的电脑上，int 的大小

457
00:20:23,930 --> 00:20:25,230
might very well change.
可能会有很大变化。

458
00:20:25,230 --> 00:20:26,750
That's why I'm using size of int.
这就是我使用 sizeof(int) 的原因。

459
00:20:26,750 --> 00:20:29,660
It will tell me always the correct answer for my computer.
它将始终告诉我我的计算机的正确答案。

460
00:20:29,660 --> 00:20:31,760
So to use malloc--
所以要使用 malloc--

461
00:20:31,760 --> 00:20:36,637
not going to catch me on this one-- what header file do I need to add?
不会抓到我的--我需要添加什么头文件？

462
00:20:36,637 --> 00:20:37,137
Standard?
标准？

463
00:20:37,137 --> 00:20:38,051
AUDIENCE: Standard lib.h.
听众：stdlib.h。

464
00:20:38,051 --> 00:20:39,440
DAVID J. MALAN: Standard lib.h.
大卫·J·马兰：stdlib.h。

465
00:20:39,440 --> 00:20:42,500
So I'm going to go ahead and include standard lib.h, which
所以我会继续包含 stdlib.h，它

466
00:20:42,500 --> 00:20:43,977
gives me access to malloc.
让我可以访问 malloc。

467
00:20:43,977 --> 00:20:47,060
And what I'm going to additionally do is practice what I preach last week,
另外，我要练习上周我所讲的，

468
00:20:47,060 --> 00:20:51,500
whereby in extreme cases malloc can return not the address
即在极端情况下，malloc 可能返回的不是地址

469
00:20:51,500 --> 00:20:52,910
of an actual chunk of memory.
而是一块实际的内存。

470
00:20:52,910 --> 00:20:56,300
What else can malloc return in cases of error?
在出错的情况下，malloc 还可以返回什么？

471
00:20:56,300 --> 00:20:57,020
Yeah?
对吗？

472
00:20:57,020 --> 00:20:57,740
AUDIENCE: Null.
听众：NULL。

473
00:20:57,740 --> 00:21:00,420
DAVID J. MALAN: Null, N-U-L-L in all caps,
大卫·J·马兰：NULL，全部大写，

474
00:21:00,420 --> 00:21:02,188
which represents technically address 0.
它在技术上代表地址 0。

475
00:21:02,188 --> 00:21:03,980
But you're never supposed to use address 0.
但你永远不应该使用地址 0。

476
00:21:03,980 --> 00:21:07,160
So it's a special sentinel value that just means something went wrong.
所以它是一个特殊的哨兵值，表示出现错误。

477
00:21:07,160 --> 00:21:08,200
Do not proceed.
不要继续。

478
00:21:08,200 --> 00:21:09,950
So it's going to add some bulk to my code.
所以它会给我的代码增加一些负担。

479
00:21:09,950 --> 00:21:11,160
But it is good practice.
但这是个好习惯。

480
00:21:11,160 --> 00:21:14,738
So if list at this point actually equals equals null,
所以如果此时的 list 实际上等于 NULL，

481
00:21:14,738 --> 00:21:16,280
there's no more work to be done here.
这里就不用再做任何工作了。

482
00:21:16,280 --> 00:21:17,880
I've got to abort the demo altogether.
我必须完全中止演示。

483
00:21:17,880 --> 00:21:19,820
So I'm going to return 1 just arbitrarily
所以我会随意返回 1

484
00:21:19,820 --> 00:21:21,362
to say we're done with this exercise.
表示我们完成了这个练习。

485
00:21:21,362 --> 00:21:22,987
It's not going to be germane for class.
这对课堂来说并不重要。

486
00:21:22,987 --> 00:21:25,760
We can surely find room for three integers but best practice
我们肯定能找到容纳三个整数的空间，但最好的做法是

487
00:21:25,760 --> 00:21:27,830
whenever using malloc.
在使用 malloc 的时候。

488
00:21:27,830 --> 00:21:33,290
Now, this code here does not need to change because list is now still
现在，这里的代码不需要改变，因为 list 仍然是

489
00:21:33,290 --> 00:21:36,240
a chunk of memory of size 12, I can actually
一块大小为 12 的内存，我可以实际上

490
00:21:36,240 --> 00:21:38,520
get away with still using square bracket notation
仍然可以使用方括号表示法

491
00:21:38,520 --> 00:21:42,060
and treating this chunk of memory as though it's an array.
并将这块内存视为数组。

492
00:21:42,060 --> 00:21:43,230
And this is a bit subtle.
这有点微妙。

493
00:21:43,230 --> 00:21:47,040
But recall from last time, we talked briefly about pointer arithmetic,
但回想一下上次，我们简要讨论了指针运算，

494
00:21:47,040 --> 00:21:50,850
whereby the computer can do some arithmetic, some addition, subtraction
计算机可以在实际地址上进行一些运算，一些加法、减法

495
00:21:50,850 --> 00:21:54,088
on the actual addresses to get from one location to the other.
以从一个位置移动到另一个位置。

496
00:21:54,088 --> 00:21:56,130
And that's what the computer is going to do here.
这就是计算机在这里要做的。

497
00:21:56,130 --> 00:21:59,850
Because it says list bracket 0, that's essentially
因为它说列表方括号 0，这本质上

498
00:21:59,850 --> 00:22:03,960
just going to put the number 1 literally at the beginning
只是将数字 1 放在这块内存的开头

499
00:22:03,960 --> 00:22:05,030
of that chunk of memory.
。

500
00:22:05,030 --> 00:22:08,280
And because this is a modern computer, it's going to take four bytes in total.
而且因为这是一台现代计算机，它将总共占用 4 个字节。

501
00:22:08,280 --> 00:22:12,930
But I don't want to put the number 4 here to shift it over myself.
但我不想在这里放数字 4 来自己把它移过去。

502
00:22:12,930 --> 00:22:16,410
Because I'm using square brackets and because the computer
因为我使用方括号，并且因为计算机

503
00:22:16,410 --> 00:22:19,770
knows that this chunk of memory is being treated
知道这块内存被视为

504
00:22:19,770 --> 00:22:24,850
as a chunk of addresses of integers, pointer arithmetic magically kicks in.
一组整数的地址，指针运算就会神奇地启动。

505
00:22:24,850 --> 00:22:29,310
So what the computer is going to do for me is put this 1 at location 0.
所以计算机将为我做的就是把这个 1 放到位置 0。

506
00:22:29,310 --> 00:22:34,830
It's going to put this number 2 at location 1 times size of int, so 4.
它将把这个数字 2 放到位置 1 乘以 int 的大小，也就是 4。

507
00:22:34,830 --> 00:22:38,040
And it's going to put this number 3 at location 2 times
它将把这个数字 3 放到位置 2 乘以

508
00:22:38,040 --> 00:22:40,160
size of int, which gives me 8.
int 的大小，这给我 8。

509
00:22:40,160 --> 00:22:41,910
So in other words, you don't have to think
换句话说，你不需要考虑

510
00:22:41,910 --> 00:22:46,320
about how big that chunk of memory is if you already gave the compiler a clue as
这块内存有多大，如果你已经给编译器一个线索，

511
00:22:46,320 --> 00:22:46,997
to the size.
大小。

512
00:22:46,997 --> 00:22:49,330
For our purposes today, don't worry too much about that.
就我们今天而言，不必太担心。

513
00:22:49,330 --> 00:22:52,710
The bigger takeaway is that when you allocate space using malloc,
更大的收获是，当你使用 malloc 分配空间时，

514
00:22:52,710 --> 00:22:55,080
you can certainly treat it as though it's
你当然可以把它当作

515
00:22:55,080 --> 00:22:59,100
an array using week 2 notation, which is arguably simpler than using
使用第 2 周的符号表示的数组，这可以说比使用

516
00:22:59,100 --> 00:23:01,560
dots and stars and all of that.
点和星号以及所有这些更简单。

517
00:23:01,560 --> 00:23:03,480
But this isn't quite enough now because let
但这现在还不够，因为让

518
00:23:03,480 --> 00:23:05,730
me stipulate that for the sake of discussion,
我规定，为了讨论起见，

519
00:23:05,730 --> 00:23:10,320
at this point in time here on line 16, where the cursor is blinking,
此时，在第 16 行，光标正在闪烁，

520
00:23:10,320 --> 00:23:13,170
suppose I realize just for the sake of discussion,
假设我意识到，为了讨论起见，

521
00:23:13,170 --> 00:23:17,130
oh, I should have allocated space for four integers instead of three.
哦，我应该为四个整数分配空间，而不是三个。

522
00:23:17,130 --> 00:23:19,600
Now, obviously, if I were writing this for real,
现在，很明显，如果我是真的在写这个，

523
00:23:19,600 --> 00:23:22,498
I should just go fix the code now and recompile it altogether?
我应该现在就去修复代码并重新编译它？

524
00:23:22,498 --> 00:23:24,540
But let's just pretend for the sake of discussion
但让我们假设，为了讨论起见，

525
00:23:24,540 --> 00:23:28,770
that somewhere in your program you want to dynamically allocate more space
在你的程序中的某个地方，你想要动态地分配更多的空间

526
00:23:28,770 --> 00:23:32,490
and free up the old in order to implement this idea of copying
并释放旧的，以实现这个复制的想法

527
00:23:32,490 --> 00:23:34,270
from old to new memory.
从旧内存到新内存。

528
00:23:34,270 --> 00:23:35,710
So how could I do that?
那我该怎么做呢？

529
00:23:35,710 --> 00:23:39,570
Well, let me go ahead and temporarily give myself another chunk of memory.
好吧，让我先给自己再分配一块内存。

530
00:23:39,570 --> 00:23:41,770
And I'm going to literally call it tmp for short,
我将把它简称为 tmp，

531
00:23:41,770 --> 00:23:43,620
which is a common convention, tmp.
这是一个常见的约定，tmp。

532
00:23:43,620 --> 00:23:46,350
I'm going to set that equal to the amount of space
我将把它设置为我现在真正需要的空间大小。

533
00:23:46,350 --> 00:23:47,920
that I actually do now want.
。

534
00:23:47,920 --> 00:23:50,550
So I'm to say four times the size of an int.
所以我要说四倍于 int 的大小。

535
00:23:50,550 --> 00:23:54,510
So technically it'll give me 16 but space for four integers this time.
所以从技术上讲，它会给我 16，但这次是四个整数的空间。

536
00:23:54,510 --> 00:23:58,560
And what that's doing for me in code is essentially
在代码中，它基本上是

537
00:23:58,560 --> 00:24:02,858
trying to find me space for four integers elsewhere
尝试在其他地方为我找到四个整数的空间

538
00:24:02,858 --> 00:24:04,650
that might very well be garbage values now.
这些值现在很可能都是垃圾值。

539
00:24:04,650 --> 00:24:06,820
But I can, therefore, reuse them.
但因此我可以重用它们。

540
00:24:06,820 --> 00:24:09,690
So once I've done this, something could still go wrong.
所以，一旦我做完这件事，仍然可能出现问题。

541
00:24:09,690 --> 00:24:12,550
And I could check if temp equals equals null,
我可以检查 temp 是否等于 null，

542
00:24:12,550 --> 00:24:15,810
then actually I should exit altogether and finish up.
然后我应该完全退出并结束。

543
00:24:15,810 --> 00:24:17,848
But there's a subtlety here.
但这里有一个微妙之处。

544
00:24:17,848 --> 00:24:20,140
And you don't need to dwell too much on this for today.
今天你不必太关注这一点。

545
00:24:20,140 --> 00:24:22,350
But there is technically a bug right now.
但现在技术上确实存在一个 bug。

546
00:24:22,350 --> 00:24:28,500
Why based on week 4, last week, might it not be correct technically
为什么根据上周的第 4 周，技术上来说它可能不正确

547
00:24:28,500 --> 00:24:33,420
to immediately return 1 and abort the program altogether at this point?
立即返回 1 并完全中止程序？

548
00:24:33,420 --> 00:24:36,870
AUDIENCE: I think when you allocate memory sometimes it has garbage values.
观众：我认为当你分配内存时，有时它会包含垃圾值。

549
00:24:36,870 --> 00:24:38,870
DAVID J. MALAN: OK, so when you allocate memory,
大卫·马兰：好的，所以当你分配内存时，

550
00:24:38,870 --> 00:24:41,328
sometimes there might be garbage values there that is true.
有时那里可能会有垃圾值，这是真的。

551
00:24:41,328 --> 00:24:45,260
But that is to say that those 16 bytes might be garbage values,
但也就是说，这 16 个字节可能是垃圾值，

552
00:24:45,260 --> 00:24:47,360
have Oscar the grouch's all on the screen.
屏幕上全是奥斯卡·格鲁奇。

553
00:24:47,360 --> 00:24:51,290
But tmp itself will literally be the return value of malloc.
但 tmp 本身实际上将是 malloc 的返回值。

554
00:24:51,290 --> 00:24:55,310
And malloc will always return to you the address of a valid chunk of memory.
而 malloc 总是会返回一个有效内存块的地址给你。

555
00:24:55,310 --> 00:24:56,700
Or it will return null.
或者它会返回 null。

556
00:24:56,700 --> 00:24:59,090
So this line is actually OK.
所以这行代码实际上是 ok 的。

557
00:24:59,090 --> 00:25:02,170
What I don't love is that I'm returning 1 immediately.
我不喜欢的是我立即返回 1。

558
00:25:02,170 --> 00:25:05,360
AUDIENCE: I think [INAUDIBLE].
观众：[听不清]

559
00:25:05,360 --> 00:25:07,490
DAVID J. MALAN: Yes, so this is where it's subtle.
大卫·马兰：是的，所以这里很微妙。

560
00:25:07,490 --> 00:25:10,790
It's not quite right to just abort right now and return 1.
现在就中止并返回 1 并不完全正确。

561
00:25:10,790 --> 00:25:11,300
Why?
为什么？

562
00:25:11,300 --> 00:25:14,480
Because up here, remember, a few moments ago
因为在上面，请记住，几分钟前

563
00:25:14,480 --> 00:25:17,240
we used malloc presumably successfully.
我们使用了 malloc，推测成功了。

564
00:25:17,240 --> 00:25:21,080
Because if we got all the way down here, we did not abort on line 9.
因为如果我们一直走到这里，我们没有在第 9 行中止。

565
00:25:21,080 --> 00:25:22,190
So we kept going.
所以我们继续运行。

566
00:25:22,190 --> 00:25:26,780
But that means we've allocated three times size event, so 12 bytes earlier.
但这意味着我们已经分配了三倍大小的事件，所以之前分配了 12 个字节。

567
00:25:26,780 --> 00:25:30,140
So frankly, if you compile this code, run it, and then ask Valgrind,
所以坦率地说，如果你编译这段代码，运行它，然后询问 Valgrind，

568
00:25:30,140 --> 00:25:34,100
it's going to identify a memory leak of size 12 because, as you know,
它将识别出大小为 12 的内存泄漏，因为，如你所知，

569
00:25:34,100 --> 00:25:35,762
we did not free the original memory.
我们没有释放原始内存。

570
00:25:35,762 --> 00:25:38,720
So this is where frankly C does get a little annoying because you and I
所以，坦率地说，C 在这里有点烦人，因为你和我都

571
00:25:38,720 --> 00:25:41,490
as the programmers have to remember all of these details.
作为程序员必须记住所有这些细节。

572
00:25:41,490 --> 00:25:46,310
So what I really want to do here, before I return 1, to be best practice,
所以，为了最佳实践，在我返回 1 之前，我真正想做的是

573
00:25:46,310 --> 00:25:48,840
I want to free the original list.
我想释放原始列表。

574
00:25:48,840 --> 00:25:51,450
So I give back those bytes to the operating system.
所以我把那些字节还给操作系统。

575
00:25:51,450 --> 00:25:54,727
Now, as an aside, technically when any program quits, all of the memory
现在，顺便说一下，从技术上讲，当任何程序退出时，所有的内存

576
00:25:54,727 --> 00:25:56,810
is going to be given back to the operating system.
都将被归还给操作系统。

577
00:25:56,810 --> 00:26:00,710
But practicing what I'm preaching now will get you into better situations
但现在练习我正在宣扬的东西将让你处于更好的境地

578
00:26:00,710 --> 00:26:01,320
later.
以后。

579
00:26:01,320 --> 00:26:04,560
Because if you don't free up memory, you will have leaks.
因为如果你不释放内存，你就会有泄漏。

580
00:26:04,560 --> 00:26:06,690
And that's when our own Macs and PCs tend
而当我们的 Mac 和 PC 倾向于

581
00:26:06,690 --> 00:26:10,050
to start to slow down and use up more memory than they should.
开始变慢并使用比它们应该更多的内存。

582
00:26:10,050 --> 00:26:13,110
But let's avoid discussion of more error checking there.
但让我们避免在那里讨论更多错误检查。

583
00:26:13,110 --> 00:26:15,330
Let's just assume that now I'm on line 23
让我们假设我现在在程序的第 23 行

584
00:26:15,330 --> 00:26:19,230
of this program, whereby I have presumably successfully allocated
在这个程序中，我可能已经成功分配了

585
00:26:19,230 --> 00:26:20,110
enough space.
足够的内存空间。

586
00:26:20,110 --> 00:26:24,360
So the next step after allocating these four bytes is to, as you noted earlier,
所以，在分配完这四个字节之后，下一步是，就像你之前提到的，

587
00:26:24,360 --> 00:26:28,000
iteratively copy the old numbers into the new space.
迭代地将旧数字复制到新的内存空间中。

588
00:26:28,000 --> 00:26:30,043
So this is actually pretty straightforward.
其实这很简单。

589
00:26:30,043 --> 00:26:30,960
I'm going to go ahead.
我会继续进行。

590
00:26:30,960 --> 00:26:36,120
And for int i gets 0, i is less than 3 i plus plus just
然后对于 int i 等于 0，i 小于 3，i 加加，就像

591
00:26:36,120 --> 00:26:37,980
like I was printing last time.
我上次打印的那样。

592
00:26:37,980 --> 00:26:41,550
I'm going to go ahead and set the i-th location of temp
我会继续设置 temp 的第 i 个位置

593
00:26:41,550 --> 00:26:45,450
equal to the i-th location of list, semicolon.
等于 list 的第 i 个位置，分号。

594
00:26:45,450 --> 00:26:46,140
And that's it.
就这样。

595
00:26:46,140 --> 00:26:51,540
I'm just copying into the temporary array whatever was in the old array.
我只是将旧数组中的内容复制到临时数组中。

596
00:26:51,540 --> 00:26:55,230
But that still leaves me with this fourth byte, of course--
当然，这样一来我仍然会剩下这个第四个字节，

597
00:26:55,230 --> 00:26:58,290
or, sorry, this fourth location, where I want to put the number 4.
或者说，抱歉，这个第四个位置，我想在这里放置数字 4。

598
00:26:58,290 --> 00:27:00,540
But if I'm going to do that for the sake of discussion
但为了讨论起见，如果我要这样做

599
00:27:00,540 --> 00:27:03,540
even though this isn't really a compelling real world program,
即使这并不是一个真正令人信服的现实世界程序，

600
00:27:03,540 --> 00:27:08,820
I'm going to just manually go into the last location in tmp, a.k.a.
我将手动进入 tmp 中的最后一个位置，也就是

601
00:27:08,820 --> 00:27:12,810
tmp bracket 3 and set that equal to my fourth number.
tmp 中的方括号 3，并将其设置为我的第四个数字。

602
00:27:12,810 --> 00:27:13,920
So that's all.
就这样。

603
00:27:13,920 --> 00:27:18,780
The whole point here is to mimic in code what it was we wanted to do here.
这里的主要目的是在代码中模仿我们想要在这里做的事情。

604
00:27:18,780 --> 00:27:20,110
But now there's one more step.
但现在还有一步。

605
00:27:20,110 --> 00:27:23,880
What was the next step after copying the 1, the 2, the 3, and adding the 4?
在复制 1、2、3，并添加 4 之后，下一步是什么？

606
00:27:23,880 --> 00:27:25,650
What do I want to do?
我想做什么？

607
00:27:25,650 --> 00:27:27,810
Now, I can safely free the list.
现在，我可以安全地释放 list。

608
00:27:27,810 --> 00:27:30,240
Now I want to go ahead and get rid of the original memory
现在我想继续摆脱原来的内存

609
00:27:30,240 --> 00:27:32,530
or at least hand it back to the operating system.
或者至少将其还给操作系统。

610
00:27:32,530 --> 00:27:36,510
So here is where I can free the list, not in the case of an error
所以，在这里我可以释放 list，而不是在出现错误的情况下

611
00:27:36,510 --> 00:27:40,170
but actually deliberately free the original list because I
而是故意释放原来的 list，因为我

612
00:27:40,170 --> 00:27:42,420
don't need those 12 bytes anymore.
不再需要这 12 个字节了。

613
00:27:42,420 --> 00:27:46,440
But now if I want to really have quote, unquote list
但现在，如果我想真正拥有所谓的 list

614
00:27:46,440 --> 00:27:50,580
point at this new chunk of memory, well, then I could also do this,
指向这块新的内存，那么我也可以这样做，

615
00:27:50,580 --> 00:27:53,370
list equals temp.
list 等于 temp。

616
00:27:53,370 --> 00:27:54,630
So this is a little weird.
所以这有点奇怪。

617
00:27:54,630 --> 00:27:56,910
But recall that list has just now been freed.
但请记住，list 现在刚刚被释放了。

618
00:27:56,910 --> 00:28:00,000
So even though list technically contains the address of a chunk of memory,
因此，即使 list 技术上包含一块内存的地址，

619
00:28:00,000 --> 00:28:02,767
it's no longer valid because, again, it was freed.
它不再有效了，因为，再次强调，它已经被释放了。

620
00:28:02,767 --> 00:28:04,350
So, yes, it's still technically there.
所以，是的，它在技术上仍然存在。

621
00:28:04,350 --> 00:28:06,300
But it's effectively garbage values now.
但它实际上现在是垃圾值了。

622
00:28:06,300 --> 00:28:08,040
So I'm certainly free--
所以我当然可以自由地

623
00:28:08,040 --> 00:28:08,730
no pun intended.
没有双关语的意思。

624
00:28:08,730 --> 00:28:11,860
I'm certainly allowed to update the value of list.
我当然可以更新 list 的值。

625
00:28:11,860 --> 00:28:15,238
And I want list to now point to the new chunk of memory.
我想让 list 现在指向这块新的内存。

626
00:28:15,238 --> 00:28:17,280
So sort of metaphorically, if list was originally
所以，打个比方，如果 list 最初

627
00:28:17,280 --> 00:28:20,860
pointing at a chunk of memory there, maybe now I want it to point over here.
指向那里的某一块内存，也许现在我想让它指向这里。

628
00:28:20,860 --> 00:28:24,720
So I'm just updating the value of list ultimately.
所以，我最终只是更新了 list 的值。

629
00:28:24,720 --> 00:28:26,670
All right, now that I've got this all done,
好了，现在我完成了这一切，

630
00:28:26,670 --> 00:28:28,980
I think I can just use this same loop as before.
我想我可以继续使用之前相同的循环。

631
00:28:28,980 --> 00:28:32,220
I could change the 3 to a 4 because I now have four numbers.
我可以把 3 改成 4，因为我现在有四个数字了。

632
00:28:32,220 --> 00:28:35,100
At the very bottom of this program though, also subtle,
不过在这个程序的最底部，也比较微妙，

633
00:28:35,100 --> 00:28:38,430
I should probably now at the very end free this list.
我应该在最后释放这个列表。

634
00:28:38,430 --> 00:28:42,210
And for good measure, let me go ahead and return 0.
为了确保万无一失，我返回 0。

635
00:28:42,210 --> 00:28:44,820
But now I think I have a complete program that, again,
但我认为现在我已经编写了一个完整的程序，再次强调，

636
00:28:44,820 --> 00:28:47,850
to be clear is not how you would write this in the real world
这并不是你实际编程中写代码的方式

637
00:28:47,850 --> 00:28:52,140
because you would not allocate three integers then
因为你不会先分配三个整数，

638
00:28:52,140 --> 00:28:54,690
decide you want to allocate four then fix all of this.
然后决定要分配四个，再修复所有这些东西。

639
00:28:54,690 --> 00:28:56,550
But we could probably borrow, copy and paste
但我们可以借用、复制和粘贴

640
00:28:56,550 --> 00:28:59,850
some of this code into production code eventually, whereby this would
一些代码到生产代码中，这样一来，它将

641
00:28:59,850 --> 00:29:02,260
solve some actual problems dynamically.
动态地解决一些实际问题。

642
00:29:02,260 --> 00:29:04,320
So let me cross my fingers, make list.
所以，我祈祷一下，生成列表。

643
00:29:04,320 --> 00:29:06,030
So far so good, ./list.
目前看来还不错，./list。

644
00:29:06,030 --> 00:29:09,510
And I should see 1, 2, 3, 4.
我应该看到 1、2、3、4。

645
00:29:09,510 --> 00:29:14,100
So long story short, it's a lot of work just to get from the original array
简而言之，从原始数组到第二个数组，需要做很多工作

646
00:29:14,100 --> 00:29:15,000
to the second.
到第二个数组。

647
00:29:15,000 --> 00:29:18,900
So ideally, we would not do any of this in the first place.
理想情况下，我们一开始就不应该做任何这些事情。

648
00:29:18,900 --> 00:29:21,250
Ideally, what could we do instead?
理想情况下，我们应该怎么做呢？

649
00:29:21,250 --> 00:29:23,970
Well, maybe we should just allocate more memory
好吧，也许我们应该分配更多的内存

650
00:29:23,970 --> 00:29:27,422
from the get go in order to avoid this problem altogether.
从一开始就分配更多的内存，以完全避免这个问题。

651
00:29:27,422 --> 00:29:28,380
So how might I do that?
那么我该如何做到呢？

652
00:29:28,380 --> 00:29:33,480
Well, instead of having allocated an array of size 3, let alone an array
嗯，与其分配一个大小为 3 的数组，更不用说一个大小为 4 的数组了

653
00:29:33,480 --> 00:29:37,320
of size 4, why don't I just proactively from the beginning of my program
为什么我不能从程序一开始就主动分配一个大小为 30、甚至 300 或 3000 的数组呢？

654
00:29:37,320 --> 00:29:41,940
allocate an array of size 30 or heck 300 or 3,000
分配一个大小为 30 的数组，甚至 300 或 3000 的数组

655
00:29:41,940 --> 00:29:45,255
and then just keep track of how much of it I'm using?
然后跟踪使用了多少内存？

656
00:29:45,255 --> 00:29:46,810
That would be correct.
那是正确的。

657
00:29:46,810 --> 00:29:50,190
It would solve the problem of not painting yourself into a corner
它将解决你没有把自己逼入绝境的问题

658
00:29:50,190 --> 00:29:51,840
so quickly.
如此迅速地。

659
00:29:51,840 --> 00:29:53,215
But what remains as an issue?
但仍然存在一个问题？

660
00:29:53,215 --> 00:29:54,840
AUDIENCE: You're using a lot of memory.
观众：你正在使用大量的内存。

661
00:29:54,840 --> 00:29:56,800
DAVID J. MALAN: I'm using a bunch more memory.
大卫·J·马兰：我正在使用更多内存。

662
00:29:56,800 --> 00:29:59,675
Especially if this program's only going to ever manage a few numbers,
尤其如果这个程序只会管理几个数字，

663
00:29:59,675 --> 00:30:03,540
why are you wasting 100 times more memory than you might actually?
为什么浪费实际需要的 100 倍内存呢？

664
00:30:03,540 --> 00:30:06,140
And there's an another corner case that could still arise
还有一个极端情况仍然可能出现，

665
00:30:06,140 --> 00:30:08,120
even though this solves the problem.
即使这解决了问题。

666
00:30:08,120 --> 00:30:10,800
AUDIENCE: If you add another list, you'll run out of memory.
观众：如果你添加另一个列表，你就会内存不足。

667
00:30:10,800 --> 00:30:12,550
DAVID J. MALAN: Exactly, we can eventually
大卫·J·马兰：没错，最终我们仍然

668
00:30:12,550 --> 00:30:14,650
still run into the exact same problem because if I
会遇到同样的问题，因为如果我想

669
00:30:14,650 --> 00:30:17,813
want to put 301 numbers in the list or 3,001, well,
把 301 个数字或 3001 个数字放到列表中，那么，

670
00:30:17,813 --> 00:30:20,230
I'm still going to have to jump through all of these hoops
我仍然需要经历所有这些步骤

671
00:30:20,230 --> 00:30:22,000
and reallocate all of that space.
并重新分配所有那些空间。

672
00:30:22,000 --> 00:30:26,410
And, honestly, now per year concern about the looping, iterating 300 times
而且，说实话，现在每年的关注点是循环，300 次循环，

673
00:30:26,410 --> 00:30:29,260
3,000 times is certainly eventually going
3000 次循环，最终肯定

674
00:30:29,260 --> 00:30:33,020
to start to add up if we're doing it a lot in terms of speed and slowdown.
如果我们经常这样做，就会开始累积，从而导致速度下降。

675
00:30:33,020 --> 00:30:36,760
So maybe there's a better way altogether than doing this.
所以，也许有更好的方法，而不是这样做。

676
00:30:36,760 --> 00:30:41,050
And indeed there is if we start to treat our computer's memory as a canvas
实际上是有更好的方法，如果我们开始将计算机的内存视为一个画布

677
00:30:41,050 --> 00:30:44,890
that we can start to use to design data structures more generally.
我们可以开始使用它来更普遍地设计数据结构。

678
00:30:44,890 --> 00:30:46,630
Arrays are a data structure, arguably.
数组可以说是一种数据结构。

679
00:30:46,630 --> 00:30:47,540
They're super simple.
它们非常简单。

680
00:30:47,540 --> 00:30:49,060
They're contiguous chunks of memory.
它们是内存中的连续块。

681
00:30:49,060 --> 00:30:53,980
But we could use memory a little more cleverly, especially now per last week
但我们可以更巧妙地使用内存，尤其是在上周之后

682
00:30:53,980 --> 00:30:56,920
that we have pointers, which is painful as they might
我们有了指针，虽然它们可能会

683
00:30:56,920 --> 00:30:58,540
be to wrap your mind around sometimes.
让人难以理解。

684
00:30:58,540 --> 00:31:01,850
They really just let us point to different places in memory.
它们只是让我们指向内存中的不同位置。

685
00:31:01,850 --> 00:31:05,420
And so we can start to stitch things together in an interesting way.
所以我们可以开始以有趣的方式将事物拼接在一起。

686
00:31:05,420 --> 00:31:11,312
So the only syntax we'll really need to do that to stitch things together
所以我们真正需要的语法就是将事物拼接在一起

687
00:31:11,312 --> 00:31:13,270
in memory and build more interesting structures
在内存中并构建更有趣的数据结构

688
00:31:13,270 --> 00:31:17,290
are these things, struct, which allows us to represent structs already.
就是这些东西，struct，它让我们可以表示结构体。

689
00:31:17,290 --> 00:31:18,730
And we did this with persons.
我们用它来表示人。

690
00:31:18,730 --> 00:31:20,480
And we played with this last time as well.
我们上次也玩过这个。

691
00:31:20,480 --> 00:31:23,350
And we saw it already for queues and stacks.
我们已经看到过它用于队列和栈。

692
00:31:23,350 --> 00:31:25,990
The dot operator, we haven't used it that much.
点运算符，我们没有使用过太多。

693
00:31:25,990 --> 00:31:28,180
But recall that whenever you have a struct,
但请记住，每当您拥有一个结构体时，

694
00:31:28,180 --> 00:31:30,580
you can go inside of it using the dot operator.
您可以使用点运算符进入结构体内部。

695
00:31:30,580 --> 00:31:34,390
And we did that for a person, person.name and person.number
我们对人进行了这种操作，person.name 和 person.number

696
00:31:34,390 --> 00:31:36,790
when we were implementing a very simple address book.
当我们实现一个非常简单的地址簿时。

697
00:31:36,790 --> 00:31:38,578
The star was new last week.
星号是上周才出现的新符号。

698
00:31:38,578 --> 00:31:40,870
And it can mean different things in different contexts.
它在不同的上下文中可以有不同的含义。

699
00:31:40,870 --> 00:31:43,000
You use it when declaring a pointer.
您在声明指针时使用它。

700
00:31:43,000 --> 00:31:46,990
But you also use it when dereferencing a pointer, to go there.
但您还在解引用指针时使用它，以到达该位置。

701
00:31:46,990 --> 00:31:49,570
But just so you've seen it before, it actually
但为了您之前已经看到过，实际上

702
00:31:49,570 --> 00:31:53,900
tends to be a little annoying, a little confusing to use star and dot together.
将星号和点一起使用可能会有点令人讨厌，有点令人困惑。

703
00:31:53,900 --> 00:31:56,740
You might remember one example last week where in parentheses I
您可能还记得上周的一个例子，在括号中我

704
00:31:56,740 --> 00:31:57,940
put star something.
放入了星号加某个东西。

705
00:31:57,940 --> 00:32:02,200
And then I used a dot operator to go there and then go inside the structure.
然后我使用点运算符到达那里，然后进入结构体内部。

706
00:32:02,200 --> 00:32:04,330
Long story short, we'll see today that you
长话短说，我们今天会看到，您可以

707
00:32:04,330 --> 00:32:07,480
can combine simultaneous use of star and dot
同时使用星号和点

708
00:32:07,480 --> 00:32:10,390
into something that actually looks like an arrow, something
成为看起来像箭头的某种东西，某种东西

709
00:32:10,390 --> 00:32:14,510
that vaguely looks like a foam finger that might be pointing from one place
看起来有点像泡沫手指，它可能从一个地方

710
00:32:14,510 --> 00:32:15,570
to another.
指向另一个地方。

711
00:32:15,570 --> 00:32:17,990
So we'll see that actually in some code.
所以我们将在一些代码中看到这一点。

712
00:32:17,990 --> 00:32:20,960
So where can we take this?
那么我们可以将它用到哪里呢？

713
00:32:20,960 --> 00:32:24,470
Well, let's implement the first of these ideas, namely something that's
好吧，让我们实现这些想法中的第一个，即某种东西

714
00:32:24,470 --> 00:32:28,430
very canonical in computing known as a linked list.
在计算中非常典型，被称为链表。

715
00:32:28,430 --> 00:32:31,610
And let's see if we can maybe do this.
让我们看看我们是否可以做到这一点。

716
00:32:31,610 --> 00:32:35,720
How about Scully, could we get you to come on up and volunteer here?
斯库利，你可以上来做志愿者吗？

717
00:32:35,720 --> 00:32:37,418
So our friend Scully--
所以，我们的朋友斯库利--

718
00:32:37,418 --> 00:32:38,960
there's some cookies in this for you.
这里有些饼干给你。

719
00:32:38,960 --> 00:32:41,510
So Scully has come prepared with a whole bunch of balloons
斯库利准备了一堆气球

720
00:32:41,510 --> 00:32:44,900
to represent chunks of memory because we'd like to paint a picture here
来代表内存块，因为我们想在这里画一幅图

721
00:32:44,900 --> 00:32:48,620
of what's involved in actually allocating space that's not necessarily
描述实际分配空间的步骤，该空间不一定

722
00:32:48,620 --> 00:32:51,380
contiguous and might be over there or over here or over here
是连续的，可能在那边，或者这边，或者这边

723
00:32:51,380 --> 00:32:52,620
in the computer's memory.
在计算机内存中。

724
00:32:52,620 --> 00:32:56,120
So, for instance, if I want to start allocating space
所以，例如，如果我想开始分配空间

725
00:32:56,120 --> 00:32:58,850
one at a time for a list of numbers, Scully,
一次一个，给一个数字列表，Scully，

726
00:32:58,850 --> 00:33:01,190
could you go ahead and malloc one balloon for me?
你能帮我分配一个气球吗？

727
00:33:01,190 --> 00:33:04,910
And in this balloon I'll store for instance, the number one ultimately.
最终，我将在气球中存储数字 1。

728
00:33:04,910 --> 00:33:07,040
So we have a balloon here.
所以这里有一个气球。

729
00:33:07,040 --> 00:33:08,150
We rehearsed this before.
我们之前排练过。

730
00:33:08,150 --> 00:33:11,478
And these balloons are actually really hard to blow up and tie off quickly.
这些气球实际上很难快速吹起来并系好。

731
00:33:11,478 --> 00:33:12,020
So thank you.
谢谢。

732
00:33:12,020 --> 00:33:13,730
So here we have a chunk of memory.
所以这里有一块内存。

733
00:33:13,730 --> 00:33:19,190
And I could certainly for instance go in here and store if I might the--
我当然可以在这里存储，比如...

734
00:33:19,190 --> 00:33:19,950
here we go.
来了。

735
00:33:19,950 --> 00:33:22,670
I could certainly go ahead here and store in this balloon,
我当然可以在这里存储在这个气球中，

736
00:33:22,670 --> 00:33:24,620
for instance, the number one.
比如数字 1。

737
00:33:24,620 --> 00:33:27,867
But in the world of an array, it would just be back to back to back.
但在数组的世界里，它会紧挨着。

738
00:33:27,867 --> 00:33:30,200
And actually, frankly, why do we need the balloons even?
实际上，坦白说，我们为什么还需要气球呢？

739
00:33:30,200 --> 00:33:32,330
I could just use these numbers, 1, 2, 3.
我可以直接使用这些数字，1、2、3。

740
00:33:32,330 --> 00:33:34,670
But the problem doesn't indeed arise note,
但问题确实出现了，请注意，

741
00:33:34,670 --> 00:33:37,430
that when we want to put a fourth number, well where does it go?
当我们想要放一个第四个数字时，它会放在哪里？

742
00:33:37,430 --> 00:33:40,220
Well, again, just to paint a picture, ideally I
好吧，再次为了说明，理想情况下我

743
00:33:40,220 --> 00:33:42,770
might allocate space for four.
可能会为四个分配空间。

744
00:33:42,770 --> 00:33:46,190
But if this is my array of size 3 like where does it go?
但如果这是一个大小为 3 的数组，它会放在哪里？

745
00:33:46,190 --> 00:33:46,970
This is the point.
这就是重点。

746
00:33:46,970 --> 00:33:49,340
We can't just put it next to the 3.
我们不能直接把它放在 3 旁边。

747
00:33:49,340 --> 00:33:51,560
Maybe there's room for the 4 over here.
也许这里有空间放 4。

748
00:33:51,560 --> 00:33:54,930
But we have to somehow connect these from one to the other.
但我们必须以某种方式将它们从一个连接到另一个。

749
00:33:54,930 --> 00:33:56,430
So, in fact, let's act that out.
所以，实际上，让我们演绎一下。

750
00:33:56,430 --> 00:33:59,390
So if I instead use this balloon metaphor of just allocating space
如果我用这个气球的比喻，只是分配空间，

751
00:33:59,390 --> 00:34:01,473
from wherever it is, can you go ahead and allocate
无论在哪里，你能帮我分配

752
00:34:01,473 --> 00:34:03,350
like another chunk of memory for me?
一块内存吗？

753
00:34:03,350 --> 00:34:07,400
And here is where I'll now have a chunk of memory in which I can store
现在，这里有一块内存，我可以将数字存储在这里。

754
00:34:07,400 --> 00:34:11,909
the number computers a little slow.
计算机有点慢。

755
00:34:11,909 --> 00:34:15,910
So in here, the second balloon I'll have a separate chunk of memory.
所以在这里，在第二个气球里，我将拥有另一块独立的内存。

756
00:34:15,910 --> 00:34:18,113
AUDIENCE: Oh my gosh.
观众：我的天哪。

757
00:34:18,113 --> 00:34:19,280
DAVID J. MALAN: There we go.
大卫·J·马兰：好了。

758
00:34:19,280 --> 00:34:20,719
OK, good.
好的，很好。

759
00:34:20,719 --> 00:34:24,980
Second chunk of memory, thank you, Scully.
第二块内存，谢谢，Scully。

760
00:34:24,980 --> 00:34:28,739
Now, I can certainly--
现在，我当然可以...

761
00:34:28,739 --> 00:34:29,239
Thank you.
谢谢。

762
00:34:29,239 --> 00:34:33,300
I can certainly now store the number two in this chunk of memory.
现在我当然可以将数字 2 存储在这块内存中。

763
00:34:33,300 --> 00:34:34,940
But it's not necessarily contiguous.
但它不一定是连续的。

764
00:34:34,940 --> 00:34:37,833
This chunk came from over here as per Scully's position originally.
这块内存最初来自这里，根据 Scully 的位置。

765
00:34:37,833 --> 00:34:39,750
This chunk obviously is coming from over here.
这块内存显然来自这里。

766
00:34:39,750 --> 00:34:41,750
And if you don't mind holding that for a moment,
如果你不介意帮我拿一下，

767
00:34:41,750 --> 00:34:45,447
this is breaking the metaphor of an array, which was indeed contiguous.
这打破了数组的比喻，它确实是连续的。

768
00:34:45,447 --> 00:34:48,530
And even though I as the human can certainly go over and walk next to her,
即使我作为一个普通人可以走过去，走到她旁边，

769
00:34:48,530 --> 00:34:51,508
that's the equivalent of copying values from one place to another.
这等同于将值从一个地方复制到另一个地方。

770
00:34:51,508 --> 00:34:53,300
What if we're a little more clever, though?
但如果我们更聪明一些呢？

771
00:34:53,300 --> 00:34:55,940
And if Scully found space for this number one over here,
如果 Scully 在这里找到了数字 1 的空间，

772
00:34:55,940 --> 00:34:57,660
let's just leave this balloon here.
我们就把这个气球放在这里。

773
00:34:57,660 --> 00:34:59,785
And if she found space for the number 2 over there,
如果她在那里找到了数字 2 的空间，

774
00:34:59,785 --> 00:35:01,100
let's leave that balloon there.
我们就把那个气球放在那里。

775
00:35:01,100 --> 00:35:05,270
But we do somehow have to connect these numbers together.
但我们必须以某种方式将这些数字连接起来。

776
00:35:05,270 --> 00:35:06,650
And here is where to--
这就是我们应该……

777
00:35:06,650 --> 00:35:08,220
I'll try to do this on the fly.
我将尝试即兴发挥。

778
00:35:08,220 --> 00:35:10,060
Maybe I could do something like this.
也许我可以做这样的事情。

779
00:35:10,060 --> 00:35:11,570
I can take this balloon here.
我可以拿来这个气球。

780
00:35:11,570 --> 00:35:14,810
And I can actually tie a string to it so that if I
我实际上可以系一根绳子在它上面，这样如果我

781
00:35:14,810 --> 00:35:20,160
want to connect one to the other, we can link these, if you will, together.
想要将它们连接起来，我们可以将它们链接起来，如果可以的话。

782
00:35:20,160 --> 00:35:24,110
And so here now I have a linked list that is not necessarily contiguous.
因此，我现在拥有了一个并非连续的链接列表。

783
00:35:24,110 --> 00:35:27,200
There's a whole bunch of memory that may very well have real values,
有很多内存，它们可能包含真实值，

784
00:35:27,200 --> 00:35:28,880
may very well have garbage values.
也可能包含垃圾值。

785
00:35:28,880 --> 00:35:31,370
But I've somehow now linked these two together.
但我现在以某种方式将它们连接起来了。

786
00:35:31,370 --> 00:35:35,150
And maybe just as a final flourish, if we could blow up one more balloon
也许，作为最后的点缀，如果我们再吹一个气球

787
00:35:35,150 --> 00:35:37,730
to represent more space-- and now she's finding room
来代表更多的空间……现在她正在寻找那个气球的空间

788
00:35:37,730 --> 00:35:39,380
for that balloon over there.
在那里。

789
00:35:41,960 --> 00:35:42,560
Nice.
不错。

790
00:35:42,560 --> 00:35:45,060
This one is a Yale chunk of memory.
这个是一个耶鲁大学的内存块。

791
00:35:45,060 --> 00:35:51,930
So now I'll need one more link, if you will.
所以，如果可以的话，我需要再加一个链接。

792
00:35:51,930 --> 00:35:55,260
And if I actually connect these two in this way,
如果我以这种方式将它们连接起来，

793
00:35:55,260 --> 00:35:58,500
let me go ahead and tie this off here.
让我在这里把这个系上。

794
00:35:58,500 --> 00:36:01,970
Now I can go ahead and connect these two.
现在，我可以将它们连接起来了。

795
00:36:01,970 --> 00:36:05,000
If you never see this demonstration again in next year's videos,
如果你明年再也没看到这个演示，

796
00:36:05,000 --> 00:36:07,790
it's because this did not go very well.
那是因为这次演示不太成功。

797
00:36:07,790 --> 00:36:11,210
Here now we have the number one where we first malloced it,
这里，我们拥有了第一个数字，我们在第一次分配内存时得到了它，

798
00:36:11,210 --> 00:36:14,840
the number two roughly where we malloced it, and the number three--
第二个数字大约是在我们分配内存时得到的，第三个数字……

799
00:36:14,840 --> 00:36:17,360
OK, so maybe we'll fix this some other year.
好吧，也许我们明年会修复它。

800
00:36:17,360 --> 00:36:19,490
Now, we'll have the number 3 allocated there.
现在，我们拥有了第三个数字，它被分配在了那里。

801
00:36:19,490 --> 00:36:21,860
But the whole point of this silly exercise
但这个愚蠢的练习的重点是

802
00:36:21,860 --> 00:36:25,910
is that we can certainly use the computer's memory as more of a Canvas,
我们可以将计算机的内存更多地用作画布，

803
00:36:25,910 --> 00:36:31,040
put things wherever we want, wherever is available so long as we somehow
把东西放到我们想要放的地方，只要我们可以以某种方式

804
00:36:31,040 --> 00:36:35,510
connect the dots, so to speak and can make our way from one chunk of memory
将它们连接起来，比方说，从一块内存

805
00:36:35,510 --> 00:36:39,380
to the next to the next, thereby literally linking them together.
到下一块，再到下一块，从而将它们连接起来。

806
00:36:39,380 --> 00:36:41,732
But, of course, we're using balloons for this metaphor.
当然，我们用气球来做这个比喻。

807
00:36:41,732 --> 00:36:43,690
But at the end of the day, this is just memory.
但说到底，这只是内存。

808
00:36:43,690 --> 00:36:49,500
So how could we encode one chunk to another chunk to a third chunk
那么，我们如何将一块内存编码到另一块内存，再到第三块内存？

809
00:36:49,500 --> 00:36:50,310
might you think?
你可能会想？

810
00:36:50,310 --> 00:36:51,180
What's the trick?
诀窍是什么？

811
00:36:51,180 --> 00:36:51,435
Yeah?
是吗？

812
00:36:51,435 --> 00:36:52,227
AUDIENCE: Pointers.
观众：指针。

813
00:36:52,227 --> 00:36:53,520
DAVID J. MALAN: Using pointers.
大卫·马兰：使用指针。

814
00:36:53,520 --> 00:36:55,353
That's why we introduced pointers last week.
这就是我们上周介绍指针的原因。

815
00:36:55,353 --> 00:36:57,510
Because as simple as an idea as it is, as hard
因为这个想法虽然简单，但有时用代码写出来却很难，它

816
00:36:57,510 --> 00:36:59,640
as it is to write sometimes in code, it's
本质上就是一个指针，一根泡沫手指指向另一块内存。

817
00:36:59,640 --> 00:37:04,822
literally just a pointer, a foam finger pointing to another chunk of memory.
因此，这些指针实际上是用这些绳子来隐喻性地实现的。

818
00:37:04,822 --> 00:37:06,780
And so these pointers really are metaphorically
所以，我们必须稍后进行总结，并决定是否还要进行这个演示。

819
00:37:06,780 --> 00:37:09,370
being implemented now in with these pieces of string.
感谢斯库利参与。

820
00:37:09,370 --> 00:37:12,370
So we'll have to debrief later and decide if we ever do this demo again.
好的，我们还有很多……

821
00:37:12,370 --> 00:37:14,430
But thank you to Scully for participating.
好的，公平起见。

822
00:37:17,510 --> 00:37:19,760
OK, we have plenty of--
好的，公平起见。

823
00:37:19,760 --> 00:37:20,885
OK, fair's fair.
好的，公平起见。

824
00:37:23,360 --> 00:37:23,860
There we go.
好了。

825
00:37:23,860 --> 00:37:24,760
Thank you Scully.
谢谢 Scully。

826
00:37:24,760 --> 00:37:28,965
So let's now actually translate this to something a little more concrete
现在让我们把这转化成更具体的东西

827
00:37:28,965 --> 00:37:32,090
and then get to the point where we can actually solve this problem in code.
然后就能够在代码中解决这个问题。

828
00:37:32,090 --> 00:37:34,340
So here's that same canvas of memory.
这是我们之前相同的内存画布。

829
00:37:34,340 --> 00:37:36,910
And if in this canvas of memory now I actually
如果在这块内存画布上，我实际上要

830
00:37:36,910 --> 00:37:40,300
want to implement this idea of the number 1, the number 2, the number 3,
实现数字 1、数字 2、数字 3 的想法，

831
00:37:40,300 --> 00:37:43,870
let's stop tying our hands in terms of expecting our memory
让我们停止将内存绑到一起，期望内存

832
00:37:43,870 --> 00:37:47,780
to be contiguous back to back and start to move away from using arrays.
连续排列，并开始远离使用数组。

833
00:37:47,780 --> 00:37:50,920
So, for instance, suppose I want a malloc space for the number 1
例如，假设我想要一个存放数字 1 的 malloc 空间

834
00:37:50,920 --> 00:37:53,110
just as I first asked of Scully.
就像我最初请求 Scully 一样。

835
00:37:53,110 --> 00:37:55,050
Suppose it ends up over there on the board.
假设它最终出现在那块板上。

836
00:37:55,050 --> 00:37:56,800
The important thing for discussion here is
这里讨论的重点是

837
00:37:56,800 --> 00:38:01,750
that that number one, wherever it ends up, is surely located at some address.
无论数字 1 最终出现在哪里，它一定位于某个地址。

838
00:38:01,750 --> 00:38:03,880
And for the sake of discussion as in the past,
为了像过去一样进行讨论，

839
00:38:03,880 --> 00:38:07,510
suppose the number one just ends up at location 0x, 1, 2, 3.
假设数字 1 最终出现在 0x, 1, 2, 3 位置。

840
00:38:07,510 --> 00:38:11,050
So 0x, 1 2, 3 is where Scully was originally standing right here.
所以 0x, 1 2, 3 就是 Scully 最初站在这里的地方。

841
00:38:11,050 --> 00:38:13,870
Then we asked for malloc for another chunk of memory.
然后我们请求 malloc 分配另一块内存。

842
00:38:13,870 --> 00:38:17,980
Suppose that it ends up over here at address 0x, 4, 5, 6.
假设它最终出现在 0x, 4, 5, 6 地址。

843
00:38:17,980 --> 00:38:21,400
So that's maybe roughly here when Scully was standing in her second position.
所以，当 Scully 站在第二个位置时，大约在这里。

844
00:38:21,400 --> 00:38:23,630
Lastly, we allocate the number 3.
最后，我们分配数字 3。

845
00:38:23,630 --> 00:38:26,060
Maybe it ends up at location 0x, 7, 8, 9,
可能它最终出现在 0x, 7, 8, 9 位置，

846
00:38:26,060 --> 00:38:30,680
which was again per Scully's third malloc roughly over here on stage.
这再次对应于 Scully 的第三次 malloc，大约在舞台上的这里。

847
00:38:30,680 --> 00:38:34,040
Now, this picture alone doesn't seem to lend itself
现在，这张图本身似乎并不适合

848
00:38:34,040 --> 00:38:37,970
to an implementation of the string, metaphorically, to the pointers
用字符串的方式来实现，比喻地说，就是指针

849
00:38:37,970 --> 00:38:41,210
unless we allow ourselves a new luxury.
除非我们允许自己享受一种新的奢侈。

850
00:38:41,210 --> 00:38:47,000
Instead of just storing the number 1, 2, 3 in our usual squares,
而不是仅仅将数字 1、2、3 存储在我们通常的方框里，

851
00:38:47,000 --> 00:38:50,690
I think what I'm going to have to do is cheat and use more memory
我认为我将不得不作弊，使用更多内存

852
00:38:50,690 --> 00:38:51,740
to store what?
来存储什么？

853
00:38:51,740 --> 00:38:53,870
The pointers as you proposed.
正如你所提议的那样，是指针。

854
00:38:53,870 --> 00:38:56,090
So here's a trade off that I promised we would
所以，这里有一个我承诺过的权衡，

855
00:38:56,090 --> 00:39:01,070
start to see more and more if you want to improve your performance in terms
如果你想提高性能，你会发现它越来越多，具体说是在

856
00:39:01,070 --> 00:39:04,880
of time and avoid stupid copying of data from one place
时间方面，避免将数据从一个地方

857
00:39:04,880 --> 00:39:06,530
to another again and again and again.
反复复制到另一个地方。

858
00:39:06,530 --> 00:39:09,707
If you want to save time, you're going to have to give up some space.
如果你想节省时间，你将不得不牺牲一些空间。

859
00:39:09,707 --> 00:39:12,290
And there's going to be this trade off between time and space.
时间和空间之间将存在这种权衡。

860
00:39:12,290 --> 00:39:15,210
And it's up to you to decide ultimately which is more important.
最终由你决定哪个更重要。

861
00:39:15,210 --> 00:39:19,040
So if you allow yourself not enough memory for the numbers 1, 2 and 3
所以，如果你给自己分配的内存不足以容纳数字 1、2 和 3，

862
00:39:19,040 --> 00:39:23,690
but twice as much memory for the numbers 1, 2, and 3 and three pointers,
但数字 1、2 和 3 以及三个指针需要两倍的内存，

863
00:39:23,690 --> 00:39:26,670
one for each, what could we now do?
一个代表每个数字，我们现在能做什么？

864
00:39:26,670 --> 00:39:28,190
Well, if this node--
好吧，如果这个节点--

865
00:39:28,190 --> 00:39:29,840
and this is a computing term.
这是一个计算机术语。

866
00:39:29,840 --> 00:39:33,830
Node is just a generic term describing a box of memory, a chunk of memory
Node 是一个泛指，描述一盒内存，一块内存

867
00:39:33,830 --> 00:39:34,700
in this case.
在本例中。

868
00:39:34,700 --> 00:39:38,690
If I've given you this blank slate here, what value
如果你被赋予了这里这块空白，什么值

869
00:39:38,690 --> 00:39:44,040
would make sense to store here if it's associated with this number one?
如果它与这个数字 1 相关联，存储在这里会更有意义？

870
00:39:44,040 --> 00:39:44,540
Yeah?
嗯？

871
00:39:44,540 --> 00:39:46,550
AUDIENCE: Maybe the address of the next element.
也许是下一个元素的地址。

872
00:39:46,550 --> 00:39:49,050
DAVID J. MALAN: Good, maybe the address of the next element.
很好，也许是下一个元素的地址。

873
00:39:49,050 --> 00:39:52,010
So the next element technically is supposed to be the number 2.
所以下一个元素理论上应该是数字 2。

874
00:39:52,010 --> 00:39:56,300
So at this location, I'm going to store the value 0x, 4, 5, 6.
所以在这个位置，我要存储值 0x，4，5，6。

875
00:39:56,300 --> 00:39:59,900
What then logically should go here in the second box?
那么，第二个框里应该放什么？

876
00:39:59,900 --> 00:40:02,030
0x, 7, 8, 9.
0x，7，8，9。

877
00:40:02,030 --> 00:40:06,330
And then here's a little non-obvious-- it's the end of the list as of now.
然后这里有点不明显——就目前而言，这是列表的结尾。

878
00:40:06,330 --> 00:40:08,690
So we can't afford to let it be a garbage value
所以我们不能让它成为一个垃圾值

879
00:40:08,690 --> 00:40:10,410
because a garbage value is a value.
因为垃圾值也是一种值。

880
00:40:10,410 --> 00:40:14,030
And we don't want Oscar to effectively be pointing to some random location
我们不希望奥斯卡实际上指向一个随机的位置

881
00:40:14,030 --> 00:40:15,420
lest we go there.
以免我们去那里。

882
00:40:15,420 --> 00:40:19,490
So what would be a good special value to put here to terminate a list?
那么，这里有什么好的特殊值可以用来终止列表呢？

883
00:40:19,490 --> 00:40:24,630
So null, so not null, which we used for strings but same idea, N-U-L-L,
所以是 null，不是 null，我们之前在字符串中使用过它，但概念相同，N-U-L-L，

884
00:40:24,630 --> 00:40:28,950
which we keep using now for pointers, otherwise known as the 0 address,
现在我们继续将其用于指针，也称为 0 地址，

885
00:40:28,950 --> 00:40:32,730
which I could just write for shorthand as 0x0 in this case,
在这种情况下，我可以用 0x0 来简写，

886
00:40:32,730 --> 00:40:34,430
which is the same thing as null.
这与 null 相同。

887
00:40:34,430 --> 00:40:38,720
So here then, even though we've changed nothing about how a computer works--
所以，这里，即使我们没有改变计算机的工作方式——

888
00:40:38,720 --> 00:40:40,610
this is just my computer's memory--
这只是我的计算机的内存——

889
00:40:40,610 --> 00:40:45,320
I'm using more memory now to effectively link one chunk, to the next chunk,
我现在使用更多的内存来有效地将一块内存链接到下一块内存，

890
00:40:45,320 --> 00:40:46,130
to the next chunk.
到下一块内存。

891
00:40:46,130 --> 00:40:49,640
So easy, just to note that the downside is more space.
很简单，只是要注意缺点是占用更多空间。

892
00:40:49,640 --> 00:40:54,410
But now we don't have to worry about ever copying and moving this data
但现在我们不必担心复制和移动这些数据

893
00:40:54,410 --> 00:40:57,380
around, which maybe over time for really big programs
四处移动，对于非常大的程序来说，随着时间的推移，

894
00:40:57,380 --> 00:41:02,040
big data sets could very well be a net positive and a win for us.
大型数据集很有可能成为净收益，对我们来说是一件好事。

895
00:41:02,040 --> 00:41:09,560
So any questions first on this notion of what a linked list actually is?
关于链表到底是什么，有什么问题吗？

896
00:41:09,560 --> 00:41:11,810
No, all right, well, recall from last time
没有，好的，那么，回忆一下上一次

897
00:41:11,810 --> 00:41:15,140
too that rarely do we actually care what the specific addresses are.
我们很少关心具体的地址是什么。

898
00:41:15,140 --> 00:41:17,540
So this is one node, two node, and three nodes.
所以这是第一个节点、第二个节点和第三个节点。

899
00:41:17,540 --> 00:41:21,140
And inside of each of these nodes is two values, the actual number
每个节点内部有两个值，实际的数字

900
00:41:21,140 --> 00:41:23,692
we care about and then a pointer.
我们关心的数字，然后是一个指针。

901
00:41:23,692 --> 00:41:26,150
And now this is actually an opportunity to introduce a term
现在，这是一个引入一个术语的机会

902
00:41:26,150 --> 00:41:29,660
that you might see increasingly nowadays, data, so 1, 2, and 3,
你可能会越来越常看到，数据，所以是 1、2 和 3，

903
00:41:29,660 --> 00:41:31,567
which we obviously care about in this case.
在这种情况中，我们显然很关心它们。

904
00:41:31,567 --> 00:41:33,650
And then we could actually refer to these pointers
然后，我们可以更笼统地将这些指针称为

905
00:41:33,650 --> 00:41:36,200
more generally as metadata.
元数据。

906
00:41:36,200 --> 00:41:39,230
It's actual data because it's helping me solve a problem, get from one
它确实是数据，因为它帮助我解决问题，从一个地方

907
00:41:39,230 --> 00:41:40,100
place to another.
到另一个地方。

908
00:41:40,100 --> 00:41:43,370
But metadata is distinct from data in that I don't fundamentally
但元数据与数据的区别在于，我并不根本

909
00:41:43,370 --> 00:41:44,870
care about the metadata.
关心元数据。

910
00:41:44,870 --> 00:41:46,580
That's an implementation detail.
那是实现细节。

911
00:41:46,580 --> 00:41:49,740
But it does help me organize my actual data.
但它确实帮助我组织实际数据。

912
00:41:49,740 --> 00:41:51,530
So this is more of a high-level concept.
所以这是一个更高级的概念。

913
00:41:51,530 --> 00:41:53,300
So what, though, is a linked list?
那么，什么是链表呢？

914
00:41:53,300 --> 00:41:57,440
It turns out the store linked list will generally use just one more value.
事实证明，存储链表通常只需要一个额外的值。

915
00:41:57,440 --> 00:42:00,290
And I'm going to draw it only as a square, a single box,
我将它画成一个正方形，一个单一的框，

916
00:42:00,290 --> 00:42:03,320
because if I declare now in my code, as I soon will,
因为我很快就会在代码中声明它，

917
00:42:03,320 --> 00:42:08,660
a variable maybe called list that points to a node, this
一个变量，可能叫做list，它指向一个节点，这

918
00:42:08,660 --> 00:42:11,750
is effectively how I could implement a linked list.
实际上是我如何实现一个链表的方式。

919
00:42:11,750 --> 00:42:13,790
I use one node per value.
我使用每个值一个节点。

920
00:42:13,790 --> 00:42:18,800
And I use one extra pointer to find the first of those nodes.
我还使用一个额外的指针来找到第一个节点。

921
00:42:18,800 --> 00:42:22,010
And, in fact, here again is where I don't need to care fundamentally
实际上，这里我不用关心

922
00:42:22,010 --> 00:42:23,650
where any of these addresses are.
这些地址在哪里。

923
00:42:23,650 --> 00:42:27,170
It suffices to know that, yes, computers have memory addresses.
知道计算机有内存地址就足够了。

924
00:42:27,170 --> 00:42:29,050
So I could just abstract this away.
所以我只需要抽象掉这一点。

925
00:42:29,050 --> 00:42:31,630
And this is how I might pictorially represent
这就是我如何以图片形式来表示

926
00:42:31,630 --> 00:42:34,450
a linked list, a cleaner version of those three balloons,
一个链表，那些三个气球的更简洁版本，

927
00:42:34,450 --> 00:42:36,250
whereby I was here.
我就在这里。

928
00:42:36,250 --> 00:42:39,610
This was Scully's first balloon, second balloon, third balloon.
这是斯库里的第一个气球，第二个气球，第三个气球。

929
00:42:39,610 --> 00:42:43,720
These arrows now just represent pointers or strings with the balloons.
这些箭头现在只代表指向气球的指针或字符串。

930
00:42:43,720 --> 00:42:49,360
So with that said, how can we go about translating this to some actual code?
那么，我们如何将这个转换成实际代码呢？

931
00:42:49,360 --> 00:42:54,160
Well, here's where we can call into play some of that same syntax from last time
这里，我们可以使用上次的一些语法

932
00:42:54,160 --> 00:42:58,310
and even a couple of weeks ago when we introduced the notion of a structure.
甚至几周前我们引入结构的概念的时候。

933
00:42:58,310 --> 00:43:01,780
So here for instance is how we defined a couple classes ago the notion
例如，这是我们几节课前定义的一个概念

934
00:43:01,780 --> 00:43:02,480
of a person?
关于一个人？

935
00:43:02,480 --> 00:43:02,980
Why?
为什么？

936
00:43:02,980 --> 00:43:05,260
Well, C doesn't come with a person data type.
C 没有内置的“人”数据类型。

937
00:43:05,260 --> 00:43:08,650
But we concluded it was useful to be able to associate someone's name
但我们认为能够将某人的名字

938
00:43:08,650 --> 00:43:11,690
with their number and maybe even other fields as well.
和他们的号码，甚至其他字段联系起来非常有用。

939
00:43:11,690 --> 00:43:15,443
So we typedef'd a structure containing these two values.
因此我们用typedef定义了一个包含这两个值的结构体。

940
00:43:15,443 --> 00:43:17,860
We learned last week that string is technically char star.
我们上周学过，字符串在技术上是字符指针。

941
00:43:17,860 --> 00:43:20,170
But that doesn't change what the actual structure is.
但这并不改变实际的结构。

942
00:43:20,170 --> 00:43:22,270
And we call this struct a person.
我们称这个结构体为“人”。

943
00:43:22,270 --> 00:43:26,440
Well, here's what we revealed last time, again taking those training wheels off.
这是我们上次揭示的内容，再次去掉辅助轮。

944
00:43:26,440 --> 00:43:27,520
It's just a char star.
它仅仅是一个字符指针。

945
00:43:27,520 --> 00:43:29,620
Let's keep going in this direction, though.
让我们继续往这个方向走。

946
00:43:29,620 --> 00:43:32,530
If I want to define not a person but maybe more generically
如果我想定义的不是“人”，而是更泛化的

947
00:43:32,530 --> 00:43:35,350
something I'll call today a node, like a container
一个东西，我今天把它叫做节点，就像一个容器

948
00:43:35,350 --> 00:43:38,650
for my numbers and my pointers, well, I similarly
来存储我的数字和指针，那么，我同样

949
00:43:38,650 --> 00:43:40,690
just need two values, not a name and a number,
只需要两个值，不是名字和数字，

950
00:43:40,690 --> 00:43:44,800
which isn't relevant today but maybe the number as an actual int
今天并不重要，但可能是数字作为实际的整数

951
00:43:44,800 --> 00:43:48,410
so I can store the 1, the 2, the 3, the 4 and so forth.
这样我可以存储1，2，3，4等等。

952
00:43:48,410 --> 00:43:50,380
And this is a little less obvious.
这有点不明显。

953
00:43:50,380 --> 00:43:53,380
But conceptually, what should be the second value
但在概念上，第二个值应该是什么

954
00:43:53,380 --> 00:43:55,510
inside of any of these nodes?
在这些节点中的任何一个里面？

955
00:43:55,510 --> 00:43:56,320
Yeah?
对吧？

956
00:43:56,320 --> 00:43:57,880
So indeed a pointer.
所以确实是一个指针。

957
00:43:57,880 --> 00:43:59,082
A pointer to what, though?
但它指向什么呢？

958
00:43:59,082 --> 00:44:00,040
AUDIENCE: Another node.
观众：另一个节点。

959
00:44:00,040 --> 00:44:01,870
DAVID J. MALAN: A pointer to another node.
大卫·J·马兰：指向另一个节点的指针。

960
00:44:01,870 --> 00:44:04,330
And here's where the syntax gets a little weird.
这就是语法变得有点奇怪的地方。

961
00:44:04,330 --> 00:44:10,030
But how do I define there to be a pointer in here to another node?
但如何定义这里有一个指向另一个节点的指针呢？

962
00:44:10,030 --> 00:44:15,700
Well, you might be inclined to say node *next because this means next is
你可能倾向于说 node *next，因为这意味着 next 是

963
00:44:15,700 --> 00:44:18,310
the name of the property or the attribute the variable inside
结构体内的变量的属性或属性名。

964
00:44:18,310 --> 00:44:18,940
the struct.
结构体。

965
00:44:18,940 --> 00:44:20,640
Star means it's a pointer.
星号表示这是一个指针。

966
00:44:20,640 --> 00:44:21,640
What is it a pointer to?
它指向什么？

967
00:44:21,640 --> 00:44:22,480
Clearly a node.
显然是一个节点。

968
00:44:22,480 --> 00:44:24,640
But here's where C can bite you.
但这就是 C 语言会让你感到困惑的地方。

969
00:44:24,640 --> 00:44:29,830
The word node does not exist until you get to this last line of code.
直到你看到最后一行代码，节点这个词才会存在。

970
00:44:29,830 --> 00:44:31,610
C goes top to bottom, left to right.
C 语言从上到下，从左到右执行。

971
00:44:31,610 --> 00:44:36,760
So you literally can't use the word node here if it's not existing until here.
所以，如果节点在这里之前还不存在，你就不能在这里使用节点这个词。

972
00:44:36,760 --> 00:44:40,240
The simple fix for this is to actually use a slightly more verbose way
解决这个问题的简单方法是使用稍微更详细的方式

973
00:44:40,240 --> 00:44:41,560
of defining a structure.
来定义一个结构。

974
00:44:41,560 --> 00:44:42,700
You can actually do this.
你实际上可以这样做。

975
00:44:42,700 --> 00:44:44,260
And we didn't bother doing this with person
而我们没有费心在 person 上这样做

976
00:44:44,260 --> 00:44:45,677
because it didn't solve a problem.
因为这没有解决任何问题。

977
00:44:45,677 --> 00:44:48,520
But if you actually make your first line a little more verbose
但是，如果你将第一行代码稍微说得更详细一些

978
00:44:48,520 --> 00:44:54,280
and say, give me a definition for a structure called node, now in here
并说，给我一个名为节点的结构定义，现在在这里

979
00:44:54,280 --> 00:44:56,670
you can actually do this.
你实际上可以这样做。

980
00:44:56,670 --> 00:44:59,470
This is an annoying implementation detail
在 C 语言中实现结构时，这是一个令人烦恼的实现细节

981
00:44:59,470 --> 00:45:01,398
when it comes to implementing structures in C.
。

982
00:45:01,398 --> 00:45:03,190
But, essentially, we're leveraging the fact
但本质上，我们利用了这样一个事实

983
00:45:03,190 --> 00:45:05,440
that because C code is read from top to bottom
因为 C 语言代码是从上到下读取的

984
00:45:05,440 --> 00:45:08,890
if you give this structure a name called struct node,
如果你给这个结构命名为 struct node，

985
00:45:08,890 --> 00:45:10,750
now you can refer to it here.
你现在就可以在这里引用它。

986
00:45:10,750 --> 00:45:11,500
But you know what?
但你知道吗？

987
00:45:11,500 --> 00:45:14,770
It's annoying to write struct node, struct node, struct node everywhere
在你的代码中写 struct node，struct node，struct node 无处不在很烦人

988
00:45:14,770 --> 00:45:15,560
in your code.
。

989
00:45:15,560 --> 00:45:17,770
So this last line now just gives you a synonym.
所以，最后一行代码只是给你一个同义词。

990
00:45:17,770 --> 00:45:21,010
And it shortens struct node to just node.
它将 struct node 简化为 node。

991
00:45:21,010 --> 00:45:23,170
So long story short, this is a good template
简而言之，这是一个很好的模板

992
00:45:23,170 --> 00:45:27,460
for any time you implement some notion of a node as we will today.
用于你实现节点概念的任何时候，就像我们今天要做的那样。

993
00:45:27,460 --> 00:45:29,920
But it's fundamentally the same idea as a person
但它与 person 基本上是同一个概念

994
00:45:29,920 --> 00:45:32,620
just containing now a number and a pointer
只是现在包含一个数字和一个指针

995
00:45:32,620 --> 00:45:35,960
to the next as opposed to someone's name and phone number.
指向下一个，而不是某人的姓名和电话号码。

996
00:45:35,960 --> 00:45:38,110
So let me go ahead and walk through with some code
所以，让我继续用一些代码

997
00:45:38,110 --> 00:45:43,570
how we might actually implement this process of allocating a balloon
来演示我们如何实际实现分配气球的过程

998
00:45:43,570 --> 00:45:45,940
and putting a number on it, allocating another balloon
并在上面写上一个数字，再分配另一个气球

999
00:45:45,940 --> 00:45:49,420
and putting a number on it and then connecting those two balloons again
并在上面写上一个数字，然后将这两个气球连接起来

1000
00:45:49,420 --> 00:45:50,120
and again.
再连接一次。

1001
00:45:50,120 --> 00:45:52,570
So we'll do this step by step in a vacuum
所以，我们将一步一步地在真空中进行操作

1002
00:45:52,570 --> 00:45:55,570
so you can see the syntax that maps to each of these ideas.
这样你就可以看到映射到这些概念的语法。

1003
00:45:55,570 --> 00:45:58,240
Then we'll actually pull up VS Code and combine it all
然后我们实际上会打开 VS Code 并将所有这些结合起来

1004
00:45:58,240 --> 00:46:00,440
and make a demonstrative program.
并创建一个演示程序。

1005
00:46:00,440 --> 00:46:03,580
So here, for instance, is the single line of C code
所以，例如，这是 C 语言的一行代码

1006
00:46:03,580 --> 00:46:06,370
via which I can give myself the beginning of a linked
通过它我可以给自己一个链接列表的开头

1007
00:46:06,370 --> 00:46:10,180
list that is a pointer that will eventually be pointing to something.
列表，它是一个指针，最终会指向某个东西。

1008
00:46:10,180 --> 00:46:12,580
So metaphorically, it's like creating a pointer.
所以，从比喻意义上来说，这就像创建一个指针。

1009
00:46:12,580 --> 00:46:15,940
I know we've gotten some complaints about that in the audience.
我知道我们收到了观众的一些抱怨。

1010
00:46:15,940 --> 00:46:19,130
We'll use the Harvard one to represent a pointer to something.
我们将使用哈佛的例子来表示指向某个东西的指针。

1011
00:46:19,130 --> 00:46:22,180
But if I only do this and I only say give me
但是，如果我只做这个，并且我只说给我

1012
00:46:22,180 --> 00:46:25,840
a variable called list that is a pointer to a node,
一个名为 list 的变量，它是一个指向节点的指针，

1013
00:46:25,840 --> 00:46:28,190
that's going to leave a garbage value.
那就会留下一个垃圾值。

1014
00:46:28,190 --> 00:46:30,400
So this is like pointing to some random location
所以这就像指向某个随机位置

1015
00:46:30,400 --> 00:46:32,200
because it's previously some value.
因为它之前是某个值。

1016
00:46:32,200 --> 00:46:33,250
Who knows what it is.
谁知道它是什么。

1017
00:46:33,250 --> 00:46:34,540
But we can solve that how?
但我们该如何解决？

1018
00:46:34,540 --> 00:46:39,850
What would be a good initial value to set this equal to?
将此设置为一个好的初始值？

1019
00:46:39,850 --> 00:46:40,750
So null.
所以为空。

1020
00:46:40,750 --> 00:46:44,020
At least if it's null, we then know that this isn't a garbage value.
至少如果是空，我们就知道它不是一个垃圾值。

1021
00:46:44,020 --> 00:46:46,592
This is literally 0x0, a.k.a. null.
这实际上是 0x0，也就是空。

1022
00:46:46,592 --> 00:46:48,800
And I'm just going to leave it blank for cleanliness.
为了整洁，我将留空。

1023
00:46:48,800 --> 00:46:53,410
So this would be the right way to begin to create a linked list of size 0.
所以这将是开始创建大小为 0 的链表的正确方法。

1024
00:46:53,410 --> 00:46:54,520
There's nothing there.
那里什么都没有。

1025
00:46:54,520 --> 00:46:58,660
But at least now that foam finger is not pointing to some bogus chunk of memory,
但至少现在那个泡沫手指没有指向某个错误的内存块，

1026
00:46:58,660 --> 00:46:59,780
some garbage value.
某个垃圾值。

1027
00:46:59,780 --> 00:47:03,220
So this is how the world might exist now in the computer's memory.
所以这就是现在计算机内存中的世界可能存在的方式。

1028
00:47:03,220 --> 00:47:06,040
How do I go about allocating space now for a node?
我现在如何为节点分配空间？

1029
00:47:06,040 --> 00:47:08,110
Well, it's just ideas from last week.
好吧，这只是上周的想法。

1030
00:47:08,110 --> 00:47:12,040
Once the word node exists as via that typedef,
一旦节点这个词通过 typedef 存在，

1031
00:47:12,040 --> 00:47:16,060
I can just use malloc to ask for the size of a node.
我就可以使用 malloc 来请求节点的大小。

1032
00:47:16,060 --> 00:47:17,560
I don't have to do the math myself.
我不必自己进行计算。

1033
00:47:17,560 --> 00:47:19,120
I don't care how big a node is.
我不关心节点有多大。

1034
00:47:19,120 --> 00:47:21,380
Just let it do the math for me.
只要让它帮我计算就行。

1035
00:47:21,380 --> 00:47:24,880
Then that's going to return presumably the address of a chunk of memory
然后它将返回，大概是某个内存块的地址

1036
00:47:24,880 --> 00:47:27,010
big enough for that big rectangle.
足够大，可以容纳那个大矩形。

1037
00:47:27,010 --> 00:47:30,850
And I'm going to store that for now in a temporary variable called n
我将暂时将其存储在一个名为 n 的临时变量中

1038
00:47:30,850 --> 00:47:33,050
that itself is a pointer to a node.
它本身是指向节点的指针。

1039
00:47:33,050 --> 00:47:35,170
So this might look like a lot altogether.
所以这看起来可能很多。

1040
00:47:35,170 --> 00:47:39,400
But this is just like before when I allocated space for a string
但这就像之前我为字符串分配空间一样

1041
00:47:39,400 --> 00:47:41,680
or I allocated space for a bunch of numbers
或者我为一堆数字分配空间

1042
00:47:41,680 --> 00:47:45,770
and set it equal to a pointer to integers, for instance, [INAUDIBLE]
并将其设置为指向整数的指针，例如，[INAUDIBLE]

1043
00:47:45,770 --> 00:47:46,750
recently.
最近。

1044
00:47:46,750 --> 00:47:50,020
All right, so this gives me a box in memory.
好的，所以这给了我在内存中的一个框。

1045
00:47:50,020 --> 00:47:52,420
This gives me a pointer called n.
这给了我一个名为 n 的指针。

1046
00:47:52,420 --> 00:47:55,360
So it's similarly just a single square because it's just an address.
所以它同样只是一个方块，因为它只是一个地址。

1047
00:47:55,360 --> 00:47:57,730
And it similarly gives me a bigger chunk of memory
它也同样给了我在计算机内存中的更大内存块

1048
00:47:57,730 --> 00:48:01,060
somewhere in the computer's memory containing enough space
它包含足够的内存空间

1049
00:48:01,060 --> 00:48:04,570
for the number that's going to go there, a 1, a 2, or 3, or whatever,
用于存储要放在那里的数字，1、2、3 等等，

1050
00:48:04,570 --> 00:48:06,740
and a pointer to the next value.
以及指向下一个值的指针。

1051
00:48:06,740 --> 00:48:10,450
So these lines of code collectively, this half creates this in memory.
所以这些代码行共同创造了这些，这一半创造了这些。

1052
00:48:10,450 --> 00:48:12,430
This half creates this in memory.
这一半创造了这些。

1053
00:48:12,430 --> 00:48:15,880
And the assignment here, the equal sign, essentially
以及这里的赋值，等号，本质上

1054
00:48:15,880 --> 00:48:17,193
does the equivalent of that.
做了等效的操作。

1055
00:48:17,193 --> 00:48:19,360
I don't care what the address is, the actual number.
我不关心地址是什么，实际的数字是什么。

1056
00:48:19,360 --> 00:48:22,430
It's as though n is now pointing to that chunk of memory.
就好像 n 现在指向了那块内存。

1057
00:48:22,430 --> 00:48:24,170
But this isn't very useful.
但这没什么用。

1058
00:48:24,170 --> 00:48:27,960
If I want to store the number 1 here, with what code can I do that?
如果我想在这里存储数字 1，我该用什么代码来做到呢？

1059
00:48:27,960 --> 00:48:31,040
Well, I could do this, borrowing an idea from last week.
好吧，我可以这样做，借鉴上周的想法。

1060
00:48:31,040 --> 00:48:34,640
So *n presumes that n is a pointer.
所以 *n 假设 n 是一个指针。

1061
00:48:34,640 --> 00:48:38,420
*n means go there, go to whatever you're pointing at.
*n 意味着去那里，指向你所指向的东西。

1062
00:48:38,420 --> 00:48:41,240
The dot operator means if you're pointing at a structure,
点运算符意味着如果你指向一个结构体，

1063
00:48:41,240 --> 00:48:43,490
go inside of it to the number field.
进入该节点的数字字段。

1064
00:48:43,490 --> 00:48:47,000
And we did this a couple of weeks ago with number and person
几周前，我们在实现地址簿时，对数字和人员进行了类似操作。

1065
00:48:47,000 --> 00:48:48,590
when we implemented an address book.
我们实现了一个地址簿。

1066
00:48:48,590 --> 00:48:50,270
So star n is go there.
所以星号 n 表示指向那个位置。

1067
00:48:50,270 --> 00:48:53,178
And the dot operator means go to the number field.
而点运算符表示进入数字字段。

1068
00:48:53,178 --> 00:48:55,220
The one on the right hand side and the equal sign
右侧的等号

1069
00:48:55,220 --> 00:48:58,520
means set whatever is there equal to the number 1.
表示将该位置的值设置为数字 1。

1070
00:48:58,520 --> 00:49:00,800
It turns out this is the syntax, though, that I
事实证明，这种语法有点神秘，不太好记

1071
00:49:00,800 --> 00:49:04,310
alluded to being a little bit cryptic and not very pleasant to remember
或者打字。

1072
00:49:04,310 --> 00:49:04,940
or type.
或打字。

1073
00:49:04,940 --> 00:49:07,490
Here, though, is where you can synonymously
然而，在这里，你可以同义地

1074
00:49:07,490 --> 00:49:11,690
instead use this line of code, which most C programmers would use instead.
使用这行代码，大多数 C 程序员会使用它。

1075
00:49:11,690 --> 00:49:13,700
This means n is still a pointer.
这意味着 n 仍然是一个指针。

1076
00:49:13,700 --> 00:49:18,770
The arrow literally with a hyphen and a greater than sign means go there.
箭头，由连字符和大于号组成，表示指向那个位置。

1077
00:49:18,770 --> 00:49:22,160
It's the exact same thing as the parentheses with the star,
它与带星号的括号完全相同，

1078
00:49:22,160 --> 00:49:23,060
with the dot.
以及点运算符。

1079
00:49:23,060 --> 00:49:26,835
This just simplifies it to look like these actual pictorial arrows.
这只是将其简化为看起来像实际的箭头图片。

1080
00:49:26,835 --> 00:49:29,210
So this would be the most conventional way of doing this.
所以这将是最常用的方法。

1081
00:49:29,210 --> 00:49:31,100
How now do I update the next field?
我现在如何更新下一个字段？

1082
00:49:31,100 --> 00:49:33,260
Well, I think I'm going to just say the same thing,
好吧，我认为我会说同样的话，

1083
00:49:33,260 --> 00:49:39,050
n go there but go into the next field and set it equal to null.
n 指向那个位置，然后进入下一个字段，并将其设置为 null。

1084
00:49:39,050 --> 00:49:39,740
Why null?
为什么是 null？

1085
00:49:39,740 --> 00:49:44,420
If the whole point here was to allocate just one chunk of memory, one node,
如果这里的主要目的是分配一块内存，一个节点，

1086
00:49:44,420 --> 00:49:46,550
you don't want to leave this as a garbage value
你不想将其保留为垃圾值

1087
00:49:46,550 --> 00:49:49,130
because that value will be mistaken for an arrow pointing
因为该值会被误认为是指向

1088
00:49:49,130 --> 00:49:51,910
to some random location.
某个随机位置的箭头。

1089
00:49:51,910 --> 00:49:52,910
All right, that's a lot.
好吧，这很多。

1090
00:49:52,910 --> 00:49:54,900
And, again, we're doing it in isolation step
而且，我们再一次将它隔离，逐步进行

1091
00:49:54,900 --> 00:49:56,900
by step just to paint the picture on the screen.
一步一步地，只是为了在屏幕上描绘出这个画面。

1092
00:49:56,900 --> 00:50:01,550
But any questions on any of these steps?
对任何这些步骤有任何疑问吗？

1093
00:50:01,550 --> 00:50:05,030
Each picture translates to one line of code there.
每个图片对应一行代码。

1094
00:50:05,030 --> 00:50:10,340
All right, so if you're comfy enough with those lines there,
好的，如果你对那些代码行足够熟悉，

1095
00:50:10,340 --> 00:50:13,110
what can I proceed to now do?
我现在可以继续做什么？

1096
00:50:13,110 --> 00:50:18,620
Well, let me propose that what I could now do with this same approach
好吧，我建议我现在可以用同样的方法

1097
00:50:18,620 --> 00:50:20,588
is set list itself equal to n.
将 list 本身设置为等于 n。

1098
00:50:20,588 --> 00:50:22,880
Because if the whole goal is to build up a linked list,
因为如果最终目标是构建一个链表，

1099
00:50:22,880 --> 00:50:25,280
and list represents that linked list, list
而 list 代表该链表， list

1100
00:50:25,280 --> 00:50:29,090
equals n is essentially saying whatever address is here, put it here.
等于 n 实际上表示将这里的值放到这里。

1101
00:50:29,090 --> 00:50:32,420
And pictorially what that means is, temporarily point both pointers
从图示上看，这意味着暂时让两个指针

1102
00:50:32,420 --> 00:50:33,690
to the same exact place.
指向同一个位置。

1103
00:50:33,690 --> 00:50:34,190
Why?
为什么？

1104
00:50:34,190 --> 00:50:36,260
Because this is the list that I care about long term.
因为这是我长期关心的 list。

1105
00:50:36,260 --> 00:50:39,260
This is maybe my global variable that I'm going to keep around forever
这可能是我将在计算机内存中永远保留的全局变量。

1106
00:50:39,260 --> 00:50:40,412
in my computer's memory.
在我的计算机内存中。

1107
00:50:40,412 --> 00:50:43,370
This was just a temporary pointer so that I could get a chunk of memory
这只是一个临时指针，这样我就可以获取一块内存

1108
00:50:43,370 --> 00:50:46,500
and go to its locations and update it with those values.
并访问其位置，用这些值更新它。

1109
00:50:46,500 --> 00:50:49,500
So, eventually, this is probably going to go away altogether.
因此，最终，这个指针可能会完全消失。

1110
00:50:49,500 --> 00:50:51,800
And this then is a linked list of size 1.
然后，这是一个大小为 1 的链表。

1111
00:50:51,800 --> 00:50:54,350
This is what happened when Scully inflated one balloon,
这就是 Scully 吹了一个气球时发生的事情，

1112
00:50:54,350 --> 00:50:58,550
I wrote the number 1 on it, and I pointed at that single balloon.
我在上面写了数字 1，然后指向了那个气球。

1113
00:50:58,550 --> 00:51:01,200
All right, if I want to go ahead and do this again and again,
好的，如果我想一次又一次地重复这个过程，

1114
00:51:01,200 --> 00:51:02,700
we'll do this a little more quickly.
我们会更快一点。

1115
00:51:02,700 --> 00:51:05,040
But it's the same kind of code for now.
但现在代码类型是一样的。

1116
00:51:05,040 --> 00:51:08,200
Here's how I allocate space for another node.
以下是如何为另一个节点分配空间。

1117
00:51:08,200 --> 00:51:10,268
Here's how I can temporarily store it in n.
以下是如何将其暂时存储在 n 中。

1118
00:51:10,268 --> 00:51:13,560
And I'll re-delcare it here just to make clear that it's indeed just a pointer.
我将在此处重新声明它，以明确表示它确实只是一个指针。

1119
00:51:13,560 --> 00:51:15,720
So the left hand side of the expression gives me this.
所以表达式的左侧给了我这个。

1120
00:51:15,720 --> 00:51:17,760
The right hand side of the expression gives me this.
表达式的右侧给了我这个。

1121
00:51:17,760 --> 00:51:18,630
Where could it be?
它在哪里呢？

1122
00:51:18,630 --> 00:51:19,590
I mean, I put it here.
我的意思是，我把它放在这里。

1123
00:51:19,590 --> 00:51:20,310
It could have been there.
它可能在那里。

1124
00:51:20,310 --> 00:51:21,685
It could have been anywhere else.
它可能在其他任何地方。

1125
00:51:21,685 --> 00:51:23,810
But malloc gets to decide that for us.
但 malloc 会为我们决定。

1126
00:51:23,810 --> 00:51:28,950
n equals this, just sets that temporary pointer equal to that chunk of memory.
n 等于这个，只是将那个临时指针设置为与那块内存相等。

1127
00:51:28,950 --> 00:51:30,090
I should clean this up.
我应该清理一下。

1128
00:51:30,090 --> 00:51:33,150
How do I now put the number 2 into this node?
现在我如何将数字 2 放入这个节点？

1129
00:51:33,150 --> 00:51:34,530
Well, I start at n.
好吧，我从 n 开始。

1130
00:51:34,530 --> 00:51:35,670
I go there.
我去了那里。

1131
00:51:35,670 --> 00:51:38,040
I go to the number field, which I keep drawing on top.
我去了数字字段，我一直把它画在上面。

1132
00:51:38,040 --> 00:51:39,690
And I set it equal to 2.
然后我把它设置为 2。

1133
00:51:39,690 --> 00:51:43,600
Now, it's a little non-obvious what we should do here.
现在，我们应该做什么有点不太明显。

1134
00:51:43,600 --> 00:51:45,480
So I'm going to be a little lazy at first.
所以一开始我会有点懒。

1135
00:51:45,480 --> 00:51:49,230
And rather than put these numbers into the linked list in sorted order,
而不是按照排序顺序将这些数字放入链表中，

1136
00:51:49,230 --> 00:51:51,493
like ascending order 1, 2, 3, 4, I'm just
比如升序 1, 2, 3, 4，我只是

1137
00:51:51,493 --> 00:51:53,410
going to plop it at the beginning of the list.
将它放在列表的开头。

1138
00:51:53,410 --> 00:51:53,580
Why?
为什么呢？

1139
00:51:53,580 --> 00:51:55,380
Because it's actually a little simpler.
因为实际上它更简单。

1140
00:51:55,380 --> 00:51:58,292
Each time I allocate a new node, I just prepend it,
每次我分配一个新节点时，我都会把它放在前面，

1141
00:51:58,292 --> 00:52:00,000
so to speak, to the beginning of the list
可以这么说，放在列表的开头

1142
00:52:00,000 --> 00:52:02,770
even though it's going to end up looking backwards in this case.
即使在这种情况下，它最终看起来会是倒序的。

1143
00:52:02,770 --> 00:52:05,430
So, notice, at this point in the story, I've
所以，请注意，在这个故事的这个阶段，我已经

1144
00:52:05,430 --> 00:52:08,280
got list pointing to the original linked list.
让 list 指向原始的链表。

1145
00:52:08,280 --> 00:52:11,250
I've got n pointing to the brand new node.
让 n 指向全新的节点。

1146
00:52:11,250 --> 00:52:15,060
And, ultimately, I want to connect these just as Scully
最终，我想像 Scully 和我用绳子连接一样连接它们。

1147
00:52:15,060 --> 00:52:16,272
and I did with the strings.
和我用绳子做的一样。

1148
00:52:16,272 --> 00:52:17,230
This is just temporary.
这只是暂时的。

1149
00:52:17,230 --> 00:52:18,900
So I want to connect these things.
所以我想连接这些东西。

1150
00:52:18,900 --> 00:52:20,760
Here's how I could do it wrong.
以下是如何做错的。

1151
00:52:20,760 --> 00:52:25,920
If I proceed now and update, rather, after one more line setting this equal
如果我现在继续，并且更新，也就是说，再增加一行将它设置为

1152
00:52:25,920 --> 00:52:29,050
to null-- sorry, let's at least get rid of that garbage value--
为 null——抱歉，至少让我们去掉那个垃圾值——

1153
00:52:29,050 --> 00:52:31,720
here's how I could proceed to maybe do this wrong.
以下是如何继续可能会做错。

1154
00:52:31,720 --> 00:52:36,540
Let me go ahead and update, for instance, list equals n.
让我继续更新，例如，将 list 设置为 n。

1155
00:52:36,540 --> 00:52:40,560
So if I update list equaling n, that's going
所以，如果我更新 list 等于 n，那将会

1156
00:52:40,560 --> 00:52:43,980
to point the list at this new node.
让 list 指向这个新节点。

1157
00:52:43,980 --> 00:52:47,110
But what has just happened?
但发生了什么？

1158
00:52:47,110 --> 00:52:48,000
What did I do wrong?
我做错了什么？

1159
00:52:48,000 --> 00:52:48,255
Yeah?
是吧？

1160
00:52:48,255 --> 00:52:49,440
AUDIENCE: Nothing's pointing to 1.
观众：没有东西指向 1。

1161
00:52:49,440 --> 00:52:51,180
DAVID J. MALAN: So nothing's pointing to 1.
大卫·J·马兰：所以没有任何东西指向1。

1162
00:52:51,180 --> 00:52:54,030
And even though you and I obviously have this bird's eye view of everything
尽管你和我都明显地拥有对一切的鸟瞰视角

1163
00:52:54,030 --> 00:52:55,988
in the computer's memory, the computer doesn't.
但在计算机的内存中，计算机却并非如此。

1164
00:52:55,988 --> 00:52:58,620
If you have no variable remembering the location of that node,
如果你没有变量记住那个节点的位置，

1165
00:52:58,620 --> 00:53:00,667
for all intents and purposes, it is gone.
从本质上来说，它就不复存在了。

1166
00:53:00,667 --> 00:53:02,250
So what I've essentially done is this.
所以我本质上做的就是这个。

1167
00:53:02,250 --> 00:53:05,880
When I update that pointer to point at the number 2, it's as though--
当我更新那个指针指向数字2的时候，就好像——

1168
00:53:05,880 --> 00:53:08,440
this was a much nicer idea in theory when we talked about it.
这在理论上是一个非常棒的想法，当我们讨论它的时候。

1169
00:53:08,440 --> 00:53:09,607
But it's not really working.
但它实际上并不起作用。

1170
00:53:09,607 --> 00:53:13,230
But this is effectively what we've tried to achieve, which is I've orphaned,
但这实际上是我们试图达成的目标，也就是说我遗弃了，

1171
00:53:13,230 --> 00:53:14,413
so to speak, the number 1.
可以说是，数字1。

1172
00:53:14,413 --> 00:53:16,830
And that too is a technical term in the context of memory.
在内存的语境中，这也是一个专业术语。

1173
00:53:16,830 --> 00:53:20,100
If no one is pointing at it if no string is connected to it,
如果没有人指向它，如果没有任何字符串连接到它，

1174
00:53:20,100 --> 00:53:22,800
I have indeed orphaned a chunk of memory, a.k.a.
我确实遗弃了一块内存，也就是

1175
00:53:22,800 --> 00:53:23,760
a memory leak.
内存泄漏。

1176
00:53:23,760 --> 00:53:25,950
And Valgrind would not, in fact like this.
Valgrind 实际上不会喜欢这样。

1177
00:53:25,950 --> 00:53:28,540
And Valgrind would, in fact, notice this.
Valgrind 实际上会注意到这一点。

1178
00:53:28,540 --> 00:53:31,560
So what would be the better approach?
那么更好的方法是什么呢？

1179
00:53:31,560 --> 00:53:32,460
Let me rewind.
让我倒带一下。

1180
00:53:32,460 --> 00:53:36,510
Instead of updating that address to be that of this node, let's
与其更新那个地址指向这个节点，不如我们

1181
00:53:36,510 --> 00:53:39,720
rewind to where we were a moment ago where list is still
回到我们刚才所在的位置，在那里 list 仍然

1182
00:53:39,720 --> 00:53:42,914
pointing at the original, n is still pointing at the new chunk of memory.
指向原始的，n 仍然指向新的内存块。

1183
00:53:42,914 --> 00:53:44,122
And what should I do instead?
那我还应该做什么呢？

1184
00:53:44,122 --> 00:53:46,890
Well, what should I do is maybe this.
好吧，我应该做的事情可能是这个。

1185
00:53:46,890 --> 00:53:50,740
Let's go to the next field of the new node.
让我们去到新节点的下一个字段。

1186
00:53:50,740 --> 00:53:52,170
So follow the arrow.
所以沿着箭头走。

1187
00:53:52,170 --> 00:53:53,400
Go to the next field.
去到下一个字段。

1188
00:53:53,400 --> 00:53:55,560
And what should I put here instead?
那我应该在这里放什么东西呢？

1189
00:53:55,560 --> 00:54:00,120
Why don't I put the memory address of the original node?
为什么不我把原始节点的内存地址放进去呢？

1190
00:54:00,120 --> 00:54:01,150
How can I get that?
我怎样才能得到它呢？

1191
00:54:01,150 --> 00:54:02,650
Well, that's actually this.
好吧，实际上就是这个。

1192
00:54:02,650 --> 00:54:05,070
So if list is pointing at the original node,
所以如果 list 指向原始节点，

1193
00:54:05,070 --> 00:54:08,560
I can just copy that address into this next field,
我就可以把那个地址复制到这个下一个字段，

1194
00:54:08,560 --> 00:54:12,420
which has the effect of doing that, albeit in duplicate.
这将产生同样的效果，尽管是重复的。

1195
00:54:12,420 --> 00:54:15,420
I've updated the next field to point at the very thing
我更新了下一个字段，指向原始 list 已经指向的东西。

1196
00:54:15,420 --> 00:54:18,120
that the original list is already pointing at.
我更新了下一个字段，指向原始 list 已经指向的东西。

1197
00:54:18,120 --> 00:54:19,950
And now for the sake of discussion, let me
现在为了讨论起见，让我

1198
00:54:19,950 --> 00:54:22,530
get rid of my temporary node called n.
去掉我这个叫做 n 的临时节点。

1199
00:54:22,530 --> 00:54:26,850
And what you'll see, ultimately, is that once we
你最终会看到，一旦我们

1200
00:54:26,850 --> 00:54:30,990
set list equal to n and get rid of it, now
把 list 设置为 n，并去掉它，现在

1201
00:54:30,990 --> 00:54:37,410
we can just treat the whole linked list as being connected and linked this way.
我们就可以把整个链表视为以这种方式连接在一起的。

1202
00:54:37,410 --> 00:54:38,160
How do we do this?
我们怎样做到这一点呢？

1203
00:54:38,160 --> 00:54:39,660
Again, we won't belabor the point with more.
再说一次，我们不会用更多的话来强调这一点。

1204
00:54:39,660 --> 00:54:41,693
But suppose I want to allocate a third node.
但假设我想分配一个第三个节点。

1205
00:54:41,693 --> 00:54:43,110
I have to do the exact same thing.
我必须做完全相同的事情。

1206
00:54:43,110 --> 00:54:47,280
But I have to update this next field to point at the existing list
但我必须更新这个下一个字段，指向现有的列表

1207
00:54:47,280 --> 00:54:49,080
before I update list itself.
在我更新 list 本身之前。

1208
00:54:49,080 --> 00:54:53,020
Long story short, order of operations is going to be super important.
长话短说，操作顺序将非常重要。

1209
00:54:53,020 --> 00:54:55,932
And if I want to stitch these data structures together,
如果我想把这些数据结构缝合在一起，

1210
00:54:55,932 --> 00:54:58,140
I would encourage you to think ultimately-- certainly
我鼓励你最终要思考--当然

1211
00:54:58,140 --> 00:55:00,140
when it comes time to write something like this,
当要写这样东西的时候，

1212
00:55:00,140 --> 00:55:04,160
think about what it is that we're actually trying to tie together.
想想我们到底要将什么联系起来。

1213
00:55:04,160 --> 00:55:05,810
So let me go ahead and do this.
所以让我继续做下去。

1214
00:55:05,810 --> 00:55:08,200
I'm going to go over to VS Code here.
我要去到这里的VS Code。

1215
00:55:08,200 --> 00:55:10,780
I'm going to delete the old code for list.c.
我要删除list.c的旧代码。

1216
00:55:10,780 --> 00:55:14,380
And perhaps now we can transition away from our old approach
也许现在我们可以从旧方法过渡过来

1217
00:55:14,380 --> 00:55:18,530
and actually do something with these pointers instead.
并用这些指针做点实际的事情。

1218
00:55:18,530 --> 00:55:21,880
So I'm going to go ahead, and let's say #include
所以我会继续下去，假设#include

1219
00:55:21,880 --> 00:55:26,020
as before, #include standard io.h.
像之前一样，#include standard io.h。

1220
00:55:26,020 --> 00:55:29,920
Let's go ahead and include standard lib.h proactively.
让我们继续并提前包含standard lib.h。

1221
00:55:29,920 --> 00:55:31,910
And let's go ahead and create that data type.
让我们继续并创建那个数据类型。

1222
00:55:31,910 --> 00:55:34,990
So typedef a struct called node.
所以typedef一个叫做node的结构体。

1223
00:55:34,990 --> 00:55:38,440
And inside of this node, let's give us an integer called number
在这个节点里面，让我们赋予一个名为number的整数

1224
00:55:38,440 --> 00:55:40,300
to store the 1, the 2, the 3, the 4.
用于存储1、2、3、4。

1225
00:55:40,300 --> 00:55:44,980
And then let's create a struct node star value called next whose purpose in life
然后让我们创建一个名为next的结构体节点星型值，它的存在目的

1226
00:55:44,980 --> 00:55:47,860
is going to point to the next node in any such list.
将指向任何此类列表中的下一个节点。

1227
00:55:47,860 --> 00:55:51,130
I'm going to shorten the name of all of this to just node simply.
我将所有这些的名称简化为node。

1228
00:55:51,130 --> 00:55:53,680
And then in main, let's go ahead and do this.
然后在main中，让我们继续做下去。

1229
00:55:53,680 --> 00:55:56,410
We'll bring back our friend argc and argv
我们将会把我们的朋友argc和argv带回来

1230
00:55:56,410 --> 00:55:59,050
so that I can actually implement a program this time that
以便我这次可以实际实现一个程序，该程序

1231
00:55:59,050 --> 00:56:01,220
lets me construct a linked list using numbers
允许我使用数字构建一个链表

1232
00:56:01,220 --> 00:56:02,845
that I just passed at the command line.
我刚刚在命令行中传递了这些数字。

1233
00:56:02,845 --> 00:56:06,110
I don't want to bother with getInt again and again or the CS50 library.
我不希望一遍又一遍地使用getInt或CS50库。

1234
00:56:06,110 --> 00:56:10,490
So let's just use argc and argv.
所以让我们只使用argc和argv。

1235
00:56:10,490 --> 00:56:15,380
But with argv, recall string now as of last week is synonymous with char star.
但是关于argv，回想一下，从上周开始，字符串与字符星型是同义词。

1236
00:56:15,380 --> 00:56:20,240
So that's the exact same thing as we've used in week 2 onward for command line
所以这与我们在第2周开始为命令行使用的东西完全相同

1237
00:56:20,240 --> 00:56:21,030
arguments.
参数。

1238
00:56:21,030 --> 00:56:22,280
So what do I want to do?
那么我想要做什么呢？

1239
00:56:22,280 --> 00:56:24,470
My goal in life with this demonstration is
我用这个演示的目标是

1240
00:56:24,470 --> 00:56:30,180
to create and code this linked list here or at least the beginnings thereof.
在这里创建并编码这个链表，或者至少是它的开始。

1241
00:56:30,180 --> 00:56:31,650
So how can I do this?
那么我该如何做到呢？

1242
00:56:31,650 --> 00:56:33,320
Let me go back into VS Code.
让我回到VS Code。

1243
00:56:33,320 --> 00:56:37,640
Let me declare a linked list called list but initialize it to null.
让我声明一个名为list的链表，但将其初始化为null。

1244
00:56:37,640 --> 00:56:40,130
So there's nothing there just yet.
所以目前还没有任何内容。

1245
00:56:40,130 --> 00:56:44,300
How now can I go about building this linked list?
我现在该如何构建这个链表呢？

1246
00:56:44,300 --> 00:56:46,440
By taking numbers from the command line.
通过从命令行获取数字。

1247
00:56:46,440 --> 00:56:47,600
So let's do this.
所以让我们做这个。

1248
00:56:47,600 --> 00:56:55,970
For int i equals 1, i is less than argc i plus plus, let me go ahead
对于int i等于1，i小于argc，i加加，让我继续

1249
00:56:55,970 --> 00:56:57,142
and do this.
并做这个。

1250
00:56:57,142 --> 00:56:59,600
I'm going to go ahead, and just for the sake of discussion,
我会继续下去，为了讨论的方便，

1251
00:56:59,600 --> 00:57:02,220
let me print out where we're going with this.
让我打印出我们将要做什么。

1252
00:57:02,220 --> 00:57:07,925
Let me go ahead and print out %s backslash n whatever is in argv bracket
让我继续并打印出%s反斜杠n，argv括号中的任何内容

1253
00:57:07,925 --> 00:57:09,080
i.
i。

1254
00:57:09,080 --> 00:57:11,178
So I'm not doing anything interesting yet.
所以我现在还没有做任何有趣的事情。

1255
00:57:11,178 --> 00:57:13,470
But let's just demonstrate where we're going with this.
但让我们只是演示我们将要做什么。

1256
00:57:13,470 --> 00:57:16,640
Let me go ahead and make list, ./list.
让我继续并制作list，./list。

1257
00:57:16,640 --> 00:57:20,270
And let me put the numbers 1, 2 and 3 as command line arguments.
让我将数字1、2和3作为命令行参数输入。

1258
00:57:20,270 --> 00:57:21,050
Enter.
输入。

1259
00:57:21,050 --> 00:57:22,910
There, we just have those numbers spit out.
我们只是将这些数字输出。

1260
00:57:22,910 --> 00:57:25,190
I'm just jumping through this hoop to demonstrate
我只是为了演示

1261
00:57:25,190 --> 00:57:26,730
how I'm getting those values.
如何获取这些值。

1262
00:57:26,730 --> 00:57:30,620
But notice the values in argv are always strings, a.k.a.
但是注意，argv 中的值始终是字符串，也就是

1263
00:57:30,620 --> 00:57:31,580
char star.
字符星。

1264
00:57:31,580 --> 00:57:37,250
So if I actually want to convert a string to an integer like this,
因此，如果我确实想将字符串转换为像这样的整数，

1265
00:57:37,250 --> 00:57:38,750
how can I do this?
我该怎么做呢？

1266
00:57:38,750 --> 00:57:43,580
I want to set the number variable equal to argv bracket i.
我想将 number 变量设置为 argv 方括号 i。

1267
00:57:43,580 --> 00:57:44,930
But argv bracket i is a string.
但是 argv 方括号 i 是一个字符串。

1268
00:57:44,930 --> 00:57:49,425
How can I convert a string to a number anyone recall?
大家还记得如何将字符串转换为数字吗？

1269
00:57:49,425 --> 00:57:49,925
Yeah?
是吗？

1270
00:57:49,925 --> 00:57:51,150
AUDIENCE: Atoi.
观众：Atoi。

1271
00:57:51,150 --> 00:57:54,810
DAVID J. MALAN: Atoi, so ASCII to I, so ASCII to integer.
DAVID J. MALAN：Atoi，所以是 ASCII 到 I，也就是 ASCII 到整数。

1272
00:57:54,810 --> 00:58:00,420
So if I do atoi, I can actually convert one to the other in this way.
因此，如果我使用 atoi，就可以用这种方式将一个转换为另一个。

1273
00:58:00,420 --> 00:58:04,208
And now I can actually print this as an int instead of a string.
现在，我实际上可以将它打印为一个 int 而不是字符串。

1274
00:58:04,208 --> 00:58:06,750
Now, that's not going to change the aesthetics of the program
现在，如果我再次打印出来，这不会改变程序的美观性

1275
00:58:06,750 --> 00:58:07,830
if I print it out again.
如果我再次打印出来。

1276
00:58:07,830 --> 00:58:10,820
But it does, in fact, give me an integer to work with.
但是，它确实给了我一个可用的整数。

1277
00:58:10,820 --> 00:58:12,200
But let's not bother printing it.
但我们不要麻烦打印它。

1278
00:58:12,200 --> 00:58:16,310
Let's instead put this number and any other number at the command line
相反，让我们将这个数字和命令行中的任何其他数字

1279
00:58:16,310 --> 00:58:18,210
into a linked list.
放到一个链表中。

1280
00:58:18,210 --> 00:58:22,430
So let me go ahead and allocate a pointer called n.
所以，让我去分配一个名为 n 的指针。

1281
00:58:22,430 --> 00:58:25,820
Let me set it equal to the return value of malloc
让我将它设置为 malloc 的返回值

1282
00:58:25,820 --> 00:58:29,480
asking malloc for the size of one node.
向 malloc 请求一个节点的大小。

1283
00:58:29,480 --> 00:58:31,700
Ideally that will give me a chunk of memory
理想情况下，这将给我一块内存

1284
00:58:31,700 --> 00:58:34,280
that can fit this number and a pointer.
可以容纳这个数字和一个指针。

1285
00:58:34,280 --> 00:58:38,670
Just for good measure, I'm going to check, well, if n equals equals null,
为了确保，我要检查，如果 n 等于空，

1286
00:58:38,670 --> 00:58:41,400
then actually this isn't going to work.
那么实际上这将不起作用。

1287
00:58:41,400 --> 00:58:44,962
So we should probably free memory thus far.
所以我们应该释放到目前为止的内存。

1288
00:58:44,962 --> 00:58:46,670
So I'm just going to leave this like this
所以，我只是这样保留它

1289
00:58:46,670 --> 00:58:48,270
because there's a few steps involved.
因为这里涉及几个步骤。

1290
00:58:48,270 --> 00:58:51,110
So free memory thus far.
所以释放到目前为止的内存。

1291
00:58:51,110 --> 00:58:55,130
And then we can go ahead, for instance, and return 1.
然后，我们可以继续，例如，返回 1。

1292
00:58:55,130 --> 00:58:59,900
All right, if now I don't have an error and n is not in fact null,
好的，如果现在没有错误，并且 n 实际上不为空，

1293
00:58:59,900 --> 00:59:02,330
but it's a valid address, I can go into n.
但它是一个有效地址，我可以进入 n。

1294
00:59:02,330 --> 00:59:05,030
I can follow that pointer to the number field
我可以沿着该指针指向 number 字段

1295
00:59:05,030 --> 00:59:07,110
and set it equal to the actual number.
并将它设置为实际的数字。

1296
00:59:07,110 --> 00:59:08,902
So this is a little strange at first glance
所以，乍一看这有点奇怪

1297
00:59:08,902 --> 00:59:11,277
that I've got number on the left and number on the right.
我左边是 number，右边也是 number。

1298
00:59:11,277 --> 00:59:13,430
But they're different. n is currently pointing
但它们不同。n 当前指向

1299
00:59:13,430 --> 00:59:17,180
at a chunk of memory big enough to fit a node.
一块足够大的内存，可以容纳一个节点。

1300
00:59:17,180 --> 00:59:19,910
n arrow number means go to that chunk of memory
n 箭头 number 意味着转到那块内存

1301
00:59:19,910 --> 00:59:24,260
and go to the top half of the rectangle and update that number
并转到矩形的上半部分，更新该数字

1302
00:59:24,260 --> 00:59:28,340
to be whatever the human typed in after we've converted it on line 16
在将它转换为实际整数之后，该数字将变成用户在第 16 行输入的任何内容

1303
00:59:28,340 --> 00:59:31,880
here to an actual integer.
这里转换为实际的整数。

1304
00:59:31,880 --> 00:59:35,450
All right, what next do I do?
好的，接下来我该做什么？

1305
00:59:35,450 --> 00:59:39,500
n arrow next should probably be at this point initialized to null.
n 箭头 next 应该在此时初始化为空。

1306
00:59:39,500 --> 00:59:44,990
And how now do I actually add this node n to my original linked list?
现在，我如何将这个节点 n 添加到我的原始链表中？

1307
00:59:44,990 --> 00:59:47,180
Well, I could just do list equals n.
好吧，我可以直接将 list 设置为 n。

1308
00:59:47,180 --> 00:59:51,110
And that would update a la the foam finger my list variable
并且这将更新像泡沫手指一样我的列表变量

1309
00:59:51,110 --> 00:59:52,730
to point at this new node.
指向这个新节点。

1310
00:59:52,730 --> 00:59:55,250
But we said before that that's potentially bad.
但我们之前说过，这可能是糟糕的。

1311
00:59:55,250 --> 00:59:55,940
Why?
为什么？

1312
00:59:55,940 --> 00:59:59,080
Because if list is already pointing at something,
因为如果列表已经指向某个东西，

1313
00:59:59,080 --> 01:00:00,830
we can't just blow kindly change what it's
我们不能随便更改它正在

1314
01:00:00,830 --> 01:00:03,565
pointing at because we'll have orphaned any previous numbers.
指向的东西，因为我们将会使之前所有的数字成为孤儿。

1315
01:00:03,565 --> 01:00:05,690
It's not relevant at the moment because we're still
目前这并不重要，因为我们仍然

1316
01:00:05,690 --> 01:00:07,460
in the first iteration of this loop.
处于这个循环的第一次迭代。

1317
01:00:07,460 --> 01:00:10,320
But we don't want to orphan or leak any memory.
但我们不想使任何内存成为孤儿或泄露。

1318
01:00:10,320 --> 01:00:11,930
So what do I first want to do?
那么，我首先想做什么？

1319
01:00:11,930 --> 01:00:15,510
Before I actually point the linked list at that new node,
在我真正将链表指向那个新节点之前，

1320
01:00:15,510 --> 01:00:21,140
I'm going to instead say, go to this current node, arrow, next,
我将改为说，转到当前节点，箭头，next，

1321
01:00:21,140 --> 01:00:23,510
and actually set that equal to list.
并实际上将其设置为list。

1322
01:00:23,510 --> 01:00:27,140
So strictly speaking, I don't actually need to initialize it to null.
所以严格来说，我实际上不需要将其初始化为null。

1323
01:00:27,140 --> 01:00:34,020
I can initialize the next field of this new node to point at the existing list.
我可以将这个新节点的next字段初始化为指向现有的列表。

1324
01:00:34,020 --> 01:00:37,160
So what I'm going to do here is, instead of initializing the next field
所以我在这里要做的是，而不是将next字段初始化

1325
01:00:37,160 --> 01:00:42,020
equal to null, if I want to insert this new node in front of any nodes that
等于null，如果我想将这个新节点插入到任何节点的前面，

1326
01:00:42,020 --> 01:00:48,590
already exist, I can simply say set the node's next field equal to whatever
已经存在，我可以简单地说将节点的next字段设置为任何

1327
01:00:48,590 --> 01:00:49,760
the list currently is.
列表当前是什么。

1328
01:00:49,760 --> 01:00:53,960
And now in this last line I can update the list itself to point to n.
现在在这最后一行，我可以更新列表本身以指向n。

1329
01:00:53,960 --> 01:00:57,667
So after this, let's just go ahead and do something relatively simple even
所以在此之后，让我们继续做一些相对简单的事情，即使

1330
01:00:57,667 --> 01:01:00,750
though the syntax for this is going to look a little complicated at first.
尽管这的语法一开始看起来有点复杂。

1331
01:01:00,750 --> 01:01:04,270
How do I go about printing the whole list?
我如何打印整个列表？

1332
01:01:04,270 --> 01:01:06,270
So print whole list.
所以打印整个列表。

1333
01:01:06,270 --> 01:01:08,020
Well, there's a couple of ways to do this.
好吧，有几种方法可以做到这一点。

1334
01:01:08,020 --> 01:01:10,140
But if you imagine a world-- if we fast forward
但是，如果你想象一个世界 - 如果我们快进

1335
01:01:10,140 --> 01:01:14,350
to a world in which we now have a linked list of size 3, for instance,
到一个现在拥有一个大小为3的链表的世界，例如，

1336
01:01:14,350 --> 01:01:17,640
here's where we might be at some point in the computer's memory.
这就是我们可能在计算机内存中的某个时刻所在的位置。

1337
01:01:17,640 --> 01:01:18,900
We've inserted the 1.
我们插入了1。

1338
01:01:18,900 --> 01:01:20,100
Then we inserted the 2.
然后我们插入了2。

1339
01:01:20,100 --> 01:01:21,180
Then we inserted the 3.
然后我们插入了3。

1340
01:01:21,180 --> 01:01:24,810
But because we're prepending everything, it actually looks like 3, 2, 1.
但因为我们正在将所有内容追加到前面，所以它实际上看起来像3, 2, 1。

1341
01:01:24,810 --> 01:01:26,820
So how could I go about printing this?
那么我该如何打印它？

1342
01:01:26,820 --> 01:01:28,710
Well, ideally, I could do this.
好吧，理想情况下，我可以这样做。

1343
01:01:28,710 --> 01:01:31,260
If a computer can only look at one location at a time,
如果一台计算机一次只能查看一个位置，

1344
01:01:31,260 --> 01:01:36,060
I can grab my foam finger and point at the 3 and print it out, point at the 2
我可以抓住我的泡沫手指，指向3并打印出来，指向2

1345
01:01:36,060 --> 01:01:38,640
and print it out, point at the 1 and print it out.
并打印出来，指向1并打印出来。

1346
01:01:38,640 --> 01:01:42,090
And then because this is null, I'm all done pointing and printing.
然后，因为这是null，我已经完成了所有指向和打印操作。

1347
01:01:42,090 --> 01:01:44,730
But how can I translate this to actual code?
但是我如何将其转换为实际代码？

1348
01:01:44,730 --> 01:01:47,220
Well, I could implement that foam finger, so to speak,
好吧，我可以实现那个泡沫手指，可以这么说，

1349
01:01:47,220 --> 01:01:48,520
in the following way.
以以下方式。

1350
01:01:48,520 --> 01:01:51,990
I could give myself a pointer often abbreviated by computer scientists
我可以给自己一个指针，通常由计算机科学家缩写

1351
01:01:51,990 --> 01:01:57,690
as ptr, specify that that's indeed a pointer to a node, as per that star,
为ptr，指定它确实是指向节点的指针，根据那个星号，

1352
01:01:57,690 --> 01:02:00,490
and initialize that pointer to be the list itself.
并将该指针初始化为列表本身。

1353
01:02:00,490 --> 01:02:05,040
So this is the code equivalent of, if I have this same picture on the screen,
所以，如果我在屏幕上看到相同的照片，这就是代码等效的内容，

1354
01:02:05,040 --> 01:02:08,850
declaring a pointer variable and point it at whatever the list
声明一个指针变量，并将其指向列表本身存储的第一个元素。

1355
01:02:08,850 --> 01:02:12,330
itself is storing first.
本身存储的第一个元素。

1356
01:02:12,330 --> 01:02:15,540
And, now, that's akin to doing this.
现在，这类似于这样做。

1357
01:02:15,540 --> 01:02:19,360
If I now go back into my code, how can I do this?
如果我现在回到我的代码中，我该怎么做呢？

1358
01:02:19,360 --> 01:02:22,260
Well, so long as that pointer does not equal
只要该指针不等于

1359
01:02:22,260 --> 01:02:25,690
null-- that is, so long as that pointer is not at the end of the list,
空 - 也就是说，只要该指针不在列表的末尾，

1360
01:02:25,690 --> 01:02:31,890
let me go ahead and print out using printf an integer with percent i.
让我继续使用 printf 打印一个带百分号 i 的整数。

1361
01:02:31,890 --> 01:02:34,650
And then let's print out whatever I'm currently
然后让我们打印出我当前

1362
01:02:34,650 --> 01:02:37,930
pointing at in ptr arrow number.
指向的 ptr 箭头数字。

1363
01:02:37,930 --> 01:02:42,720
So whatever I'm pointing at, go there and print the number that you find.
所以，我指向的是什么，就去那里打印出你找到的数字。

1364
01:02:42,720 --> 01:02:44,970
After that, what do I want to go ahead and do?
在那之后，我想做什么呢？

1365
01:02:44,970 --> 01:02:49,590
I'm going to set pointer equal to pointer arrow next.
我将把指针设置为指针箭头 next。

1366
01:02:49,590 --> 01:02:50,650
So what does this mean?
所以这意味着什么？

1367
01:02:50,650 --> 01:02:53,400
If I go back to my picture here and I want
如果我回到我的图片，我想

1368
01:02:53,400 --> 01:02:56,790
to actually walk through this thing, that first line of code
真正遍历这个东西，第一行代码

1369
01:02:56,790 --> 01:03:00,720
ensures that this foam finger, a.k.a. ptr, represented here,
确保这个泡沫手指，也就是这里表示的 ptr，

1370
01:03:00,720 --> 01:03:02,910
is pointing at the first element of the list.
指向列表的第一个元素。

1371
01:03:02,910 --> 01:03:06,990
Once I've printed it out with printf, I'm then doing pointer
一旦我用 printf 打印出来，我就执行 pointer

1372
01:03:06,990 --> 01:03:10,950
equals pointer next, which is following this next arrow.
等于指针 next，它跟着下一个箭头走。

1373
01:03:10,950 --> 01:03:13,770
So ptr now points at the 2.
所以 ptr 现在指向 2。

1374
01:03:13,770 --> 01:03:16,590
I then print that out and set pointer equal to pointer next.
然后我打印出来，并将指针设置为指针 next。

1375
01:03:16,590 --> 01:03:20,340
That's like following this arrow and updating pointer to point at this node
这就像跟着这个箭头走，并将指针更新为指向这个节点

1376
01:03:20,340 --> 01:03:20,940
instead.
而不是。

1377
01:03:20,940 --> 01:03:24,030
At that point, the next step is going to be to point it to null.
在那个时候，下一步将是将其指向空。

1378
01:03:24,030 --> 01:03:26,470
So for all intents and purposes, I'm done.
所以，从各个方面来说，我已经完成了。

1379
01:03:26,470 --> 01:03:30,150
And that's why we can actually get away with this while loop
这就是我们实际上可以摆脱这个 while 循环的原因

1380
01:03:30,150 --> 01:03:36,040
because while pointer is not null, it's going to print and print and print.
因为只要指针不为空，它就会一直打印。

1381
01:03:36,040 --> 01:03:38,385
Now, let me go into my terminal window.
现在，让我进入我的终端窗口。

1382
01:03:38,385 --> 01:03:40,260
Let me go ahead and make list and really hope
让我继续创建列表，并真心希望

1383
01:03:40,260 --> 01:03:43,230
I didn't make any mistakes because this was a lot all at once.
我没有犯任何错误，因为这一切都太快了。

1384
01:03:43,230 --> 01:03:45,090
Seems to have compiled OK.
似乎编译正常。

1385
01:03:45,090 --> 01:03:48,240
When I run ./list of 1, 2, 3--
当我运行 ./list 1, 2, 3--

1386
01:03:48,240 --> 01:03:51,540
theoretically, this code is correct, should unbeknownst to me
理论上，这段代码是正确的，应该在我不知情的情况下

1387
01:03:51,540 --> 01:03:53,850
build up an entire linked list in memory.
在内存中建立一个完整的链表。

1388
01:03:53,850 --> 01:03:57,787
But what's it going to print out ultimately?
但它最终会打印出什么呢？

1389
01:03:57,787 --> 01:03:59,370
What do you think it's going to print?
你觉得它会打印什么？

1390
01:03:59,370 --> 01:04:01,710
Yeah?
对吗？

1391
01:04:01,710 --> 01:04:05,305
It could print out null if I really screwed up, yes.
如果我真的搞砸了，它可能会打印出空，是的。

1392
01:04:05,305 --> 01:04:05,805
What else?
还有什么？

1393
01:04:05,805 --> 01:04:06,843
AUDIENCE: 3, 2, 1.
观众：3, 2, 1。

1394
01:04:06,843 --> 01:04:08,760
DAVID J. MALAN: Or it could print out 3, 2, 1.
大卫·J·马兰：或者它可以打印出 3, 2, 1。

1395
01:04:08,760 --> 01:04:10,427
And frankly, that's what I'm hoping for.
坦率地说，这是我希望看到的。

1396
01:04:10,427 --> 01:04:14,888
So even though I've given it in argv 1, 2, 3,
所以，即使我在 argv 中给出了 1, 2, 3，

1397
01:04:14,888 --> 01:04:18,180
because I'm prepending to the beginning of the list, the beginning of the list,
因为我正在将它们添加到列表的开头，列表的开头，

1398
01:04:18,180 --> 01:04:20,370
beginning of the list each time, I think,
每次都添加到列表的开头，我认为，

1399
01:04:20,370 --> 01:04:23,040
indeed, we're going to see 3, 2, 1.
实际上，我们会看到 3, 2, 1。

1400
01:04:23,040 --> 01:04:24,060
Now, that's fine.
现在，这很好。

1401
01:04:24,060 --> 01:04:24,930
That's correct.
这是正确的。

1402
01:04:24,930 --> 01:04:28,380
But it's not necessarily what we might want.
但它不一定是我们想要的。

1403
01:04:28,380 --> 01:04:32,100
So how could we actually go about inserting things maybe?
那么我们如何才能真正地进行插入呢？

1404
01:04:32,100 --> 01:04:35,530
Otherwise, because, in fact, if we consider this algorithm,
否则，事实上，如果我们考虑这个算法，

1405
01:04:35,530 --> 01:04:38,670
what's the running time insert?
插入的运行时间是多少？

1406
01:04:38,670 --> 01:04:41,717
How many steps are required right now, given a linked list of size n
现在，给定一个大小为 n 的链表，需要多少步？

1407
01:04:41,717 --> 01:04:43,800
if you want to go ahead and insert one more node--
如果你想继续插入一个节点 -

1408
01:04:43,800 --> 01:04:48,270
there's actually a reason I took this lazy approach of prepending prepending.
我采用这种懒惰的预先添加方式，其实是有原因的。

1409
01:04:48,270 --> 01:04:53,115
In big O notation, how much does it cost us to insert into a linked list?
在大 O 符号中，插入到链表中需要多少代价？

1410
01:04:56,770 --> 01:04:57,770
Think about it this way.
这样想。

1411
01:04:57,770 --> 01:05:00,080
Does it matter how many nodes are already
链表中已经有多少个节点，重要吗？

1412
01:05:00,080 --> 01:05:04,220
in the linked list, whether it's 1 or 2 or 3 or 300 or 3,000.
是 1 个，还是 2 个，还是 3 个，或者 300 个，或者 3000 个，都没关系。

1413
01:05:04,220 --> 01:05:06,830
If you're prepending, it doesn't matter how long
如果你在开头添加，那么链的长度无关紧要，

1414
01:05:06,830 --> 01:05:09,152
that chain is, you're just constantly putting it
你只是不断地将它

1415
01:05:09,152 --> 01:05:11,360
at the beginning, at the beginning, at the beginning.
放在开头，放在开头，放在开头。

1416
01:05:11,360 --> 01:05:12,500
Now, how many steps is this?
现在，这需要多少步？

1417
01:05:12,500 --> 01:05:13,220
I don't know exactly.
我确切地不知道。

1418
01:05:13,220 --> 01:05:14,720
I'd have to count the lines of code.
我得数一下代码行数。

1419
01:05:14,720 --> 01:05:15,860
But it's some small number.
但它是一个很小的数字。

1420
01:05:15,860 --> 01:05:17,150
It's like two steps, three steps.
大约是两步，三步。

1421
01:05:17,150 --> 01:05:18,358
How many lines of code is it?
代码有多少行？

1422
01:05:18,358 --> 01:05:21,080
It's very few to prepend, prepend.
在开头添加，需要很少的代码行。

1423
01:05:21,080 --> 01:05:27,800
So I would dare say that the running time of insertion into a linked list
所以，我认为插入到链表中的运行时间

1424
01:05:27,800 --> 01:05:29,150
is actually constant time.
实际上是常数时间。

1425
01:05:29,150 --> 01:05:29,930
It's big O of 1.
它是 O(1)。

1426
01:05:29,930 --> 01:05:32,763
And that's super fast because it doesn't matter how big the list is.
这非常快，因为列表的大小无关紧要。

1427
01:05:32,763 --> 01:05:35,390
Boom, boom, boom, you've prepended to the list.
砰砰砰，你已经将它添加到链表开头了。

1428
01:05:35,390 --> 01:05:36,960
But there's a flip side.
但它也有不利的一面。

1429
01:05:36,960 --> 01:05:39,200
What's the running time of searching a linked list,
在链表中搜索的运行时间是多少？

1430
01:05:39,200 --> 01:05:43,710
looking for something in it, finding a number in it?
在其中寻找某样东西，找到其中的一个数字？

1431
01:05:43,710 --> 01:05:45,990
Well, if it looks like this, how long does
好吧，如果它看起来像这样，那么

1432
01:05:45,990 --> 01:05:47,760
it take you to find some arbitrary number
需要多长时间才能找到一个任意数字

1433
01:05:47,760 --> 01:05:50,040
that the human might ask you for?
是用户可能要求你的？

1434
01:05:50,040 --> 01:05:53,080
How many steps will it take to find me the number 1 if it's there?
如果 1 在那里，找到它需要多少步？

1435
01:05:53,080 --> 01:05:56,250
So big O of n-- because in the worst case, the number you're looking for
所以是 O(n) - 因为在最坏情况下，你正在寻找的数字

1436
01:05:56,250 --> 01:05:57,583
might be all the way at the end.
可能在链表的末尾。

1437
01:05:57,583 --> 01:06:00,083
And even though you and I, again, have this bird's eye view,
尽管你我，再一次，拥有这种上帝视角，

1438
01:06:00,083 --> 01:06:03,420
and we can obviously see where the 1 is, the only way we can get to the 1
我们可以清楚地看到 1 在哪里，我们获得 1 的唯一方式

1439
01:06:03,420 --> 01:06:05,200
is by starting at the 2.
是从 2 开始。

1440
01:06:05,200 --> 01:06:06,267
How do you get to the 2?
你如何到达 2？

1441
01:06:06,267 --> 01:06:07,350
You got to start at the 3.
你必须从 3 开始。

1442
01:06:07,350 --> 01:06:08,350
How do you get to the 3?
你如何到达 3？

1443
01:06:08,350 --> 01:06:11,290
You've got to start at the beginning of the list itself.
你必须从链表的开头开始。

1444
01:06:11,290 --> 01:06:14,280
And so whereas in the world of arrays where you had this contiguous
因此，在数组的世界中，你拥有这种连续的

1445
01:06:14,280 --> 01:06:16,988
chunk of memory, just like we had lockers on the stage weeks ago,
内存块，就像我们几周前在舞台上使用的储物柜一样，

1446
01:06:16,988 --> 01:06:19,738
and you could jump to the middle and then the middle of the middle
你可以跳到中间，然后跳到中间的中间

1447
01:06:19,738 --> 01:06:21,000
and the middle of the middle.
再到中间的中间。

1448
01:06:21,000 --> 01:06:23,260
That was all predicated on contiguousness.
这一切都是基于连续性。

1449
01:06:23,260 --> 01:06:23,760
Why?
为什么？

1450
01:06:23,760 --> 01:06:27,150
Because if you know where the first locker was, and you
因为如果你知道第一个储物柜在哪里，并且你

1451
01:06:27,150 --> 01:06:29,850
know where the last locker was, you can substract one
知道最后一个储物柜在哪里，你就可以减 1

1452
01:06:29,850 --> 01:06:31,680
from the other, divide by 2, and, boom, you
从另一个减去，除以 2，然后，砰，你

1453
01:06:31,680 --> 01:06:35,130
get the index or the location numerically of the middle locker.
就得到了中间储物柜的索引或位置。

1454
01:06:35,130 --> 01:06:36,870
And you can do that again and again.
你可以一遍又一遍地这样做。

1455
01:06:36,870 --> 01:06:39,510
I cannot do any such math here.
在这里我无法做任何这种计算。

1456
01:06:39,510 --> 01:06:42,160
The middle of this linked list is obviously here.
这个链表的中间显然在这里。

1457
01:06:42,160 --> 01:06:45,438
But it doesn't matter what the location of this one is in memory.
但它在内存中的位置并不重要。

1458
01:06:45,438 --> 01:06:47,230
It doesn't matter what the location of this
它在内存中的位置并不重要，

1459
01:06:47,230 --> 01:06:50,105
is in memory because they could be anywhere in the computer's memory.
因为它们可以在计算机内存的任何地方。

1460
01:06:50,105 --> 01:06:52,510
So you can subtract one from the other, divide by 2,
所以你可以从另一个中减去一个，除以 2，

1461
01:06:52,510 --> 01:06:55,000
and that's going to put you in some random location
这会把你放到一个随机的位置

1462
01:06:55,000 --> 01:06:58,690
because these chunks of memory are not back to back to back to back.
因为这些内存块不是紧挨着。

1463
01:06:58,690 --> 01:07:00,410
They're every which way.
它们是各种各样的。

1464
01:07:00,410 --> 01:07:03,040
So this is to say, what algorithm from week zero
所以也就是说，我们不能在链表上使用哪个算法？

1465
01:07:03,040 --> 01:07:05,650
can we not use on linked lists?
我们不能在链表上使用哪个算法？

1466
01:07:05,650 --> 01:07:07,100
So binary search.
所以是二分查找。

1467
01:07:07,100 --> 01:07:09,790
So that very algorithm we started the class with
所以，我们开始这门课时用的那个算法

1468
01:07:09,790 --> 01:07:13,540
was all predicated on contiguous chunks of memory, like an array.
都依赖于连续的内存块，比如数组。

1469
01:07:13,540 --> 01:07:15,470
The problem with an array of course, though,
当然，数组的问题是，

1470
01:07:15,470 --> 01:07:17,620
is that you paint yourself into this corner.
你会把自己逼到这个角落里。

1471
01:07:17,620 --> 01:07:20,950
And you have to in advance how many locations you want.
你必须提前知道你想要多少个位置。

1472
01:07:20,950 --> 01:07:22,805
And if you round up, you're wasting space.
如果你向上取整，就会浪费空间。

1473
01:07:22,805 --> 01:07:24,430
If you round down, you're wasting time.
如果你向下取整，就会浪费时间。

1474
01:07:24,430 --> 01:07:26,050
So you're screwed either way.
无论哪种方式你都会被困住。

1475
01:07:26,050 --> 01:07:27,820
A linked list avoids those problems.
链表可以避免这些问题。

1476
01:07:27,820 --> 01:07:30,220
It's more of a dynamic data structure that can grow.
它更像是一个可以增长的动态数据结构。

1477
01:07:30,220 --> 01:07:32,500
And frankly, if we code it up, it could even shrink.
坦白地说，如果我们把它编码起来，它甚至可以缩小。

1478
01:07:32,500 --> 01:07:34,820
We could remove these nodes back and forth.
我们可以来回删除这些节点。

1479
01:07:34,820 --> 01:07:39,220
And so we're not necessarily wasting time on insertion,
所以我们不一定会浪费时间在插入上，

1480
01:07:39,220 --> 01:07:41,650
but we are on searching this thing.
但我们是在搜索它。

1481
01:07:41,650 --> 01:07:45,940
We're back to Big O of n when it comes to searching a linked list as opposed
在搜索链表时，我们又回到了 O(n) 的时间复杂度，而不是

1482
01:07:45,940 --> 01:07:49,460
to it being log n, which was much, much better.
log(n)，这要好得多。

1483
01:07:49,460 --> 01:07:52,180
So the upside of prepending the nodes in this way
所以，用这种方式在链表头部添加节点的优点是

1484
01:07:52,180 --> 01:07:54,567
is that we have constant time insertion of new nodes
我们可以用常数时间插入新的节点

1485
01:07:54,567 --> 01:07:56,650
because we just continually insert, insert, insert
因为我们只是不断地插入、插入、插入

1486
01:07:56,650 --> 01:07:58,270
into the very beginning of the list.
到链表的开头。

1487
01:07:58,270 --> 01:08:01,030
Of course, a side effect of this is that the numbers
当然，这样做的一个副作用是数字

1488
01:08:01,030 --> 01:08:04,090
might end up in completely reverse order as they have here
可能最终会以完全相反的顺序出现，就像这里一样

1489
01:08:04,090 --> 01:08:05,710
because I first inserted 1.
因为我首先插入了 1。

1490
01:08:05,710 --> 01:08:07,030
But then I prepended 2.
然后我在头部添加了 2。

1491
01:08:07,030 --> 01:08:08,530
And then I prepended 3.
然后我在头部添加了 3。

1492
01:08:08,530 --> 01:08:11,230
Well, we could perhaps take a completely different approach
好吧，我们也许可以采取一种完全不同的方法

1493
01:08:11,230 --> 01:08:13,940
and append the nodes upon insertion instead.
在插入时将节点添加到链表尾部。

1494
01:08:13,940 --> 01:08:17,200
So, for instance, if I start off with an empty list, I could then insert 1.
例如，如果我从一个空链表开始，我就可以插入 1。

1495
01:08:17,200 --> 01:08:18,399
I can insert 2.
我可以插入 2。

1496
01:08:18,399 --> 01:08:19,571
And I can insert 3.
我可以插入 3。

1497
01:08:19,571 --> 01:08:22,029
And, in this case, I actually get a bit lucky that now they
而且，在这种情况下，我实际上有点幸运，因为现在它们

1498
01:08:22,029 --> 01:08:23,529
are in fact in sorted order.
实际上是有序的。

1499
01:08:23,529 --> 01:08:25,361
Now, to be fair, that's not guaranteed.
现在，公平地说，这不是保证的。

1500
01:08:25,361 --> 01:08:27,069
But let's at least consider what the code
但让我们至少考虑一下代码

1501
01:08:27,069 --> 01:08:30,520
would look like if we were to take this alternative approach of appending
如果我们采用这种在末尾添加节点的替代方法，它看起来会怎样？

1502
01:08:30,520 --> 01:08:32,187
nodes instead of prepending.
而不是在开头添加节点。

1503
01:08:32,187 --> 01:08:34,270
Well, rather than write out the code from scratch,
嗯，与其从头开始编写代码，

1504
01:08:34,270 --> 01:08:38,470
let me open up a premade version of list.c that even has some comments
让我打开一个预制的 list.c 版本，它甚至有一些注释

1505
01:08:38,470 --> 01:08:39,790
to explain what's going on.
来解释发生了什么。

1506
01:08:39,790 --> 01:08:42,130
Some of this code is pretty much the same.
其中一些代码基本相同。

1507
01:08:42,130 --> 01:08:45,609
But allow me to scroll down roughly to the middle where
但请允许我向下滚动到大约中间的位置，在那里

1508
01:08:45,609 --> 01:08:48,470
we'll see the actual logic in question.
我们将看到相关的实际逻辑。

1509
01:08:48,470 --> 01:08:51,939
So, first, on line 35 here, we're checking if the list is null.
所以，首先，在这里的第 35 行，我们检查列表是否为空。

1510
01:08:51,939 --> 01:08:54,399
Because if there's no list yet, it's actually pretty easy
因为如果还没有列表，实际上非常容易

1511
01:08:54,399 --> 01:08:55,899
to prepend or append.
在开头添加或在末尾添加。

1512
01:08:55,899 --> 01:08:58,120
We're just going to go ahead and update the list
我们将直接更新列表

1513
01:08:58,120 --> 01:09:01,090
variable to point to this new node n.
变量，使其指向这个新的节点 n。

1514
01:09:01,090 --> 01:09:04,450
But if the list isn't empty, and there's at least one node there already,
但如果列表不为空，并且至少已经存在一个节点，

1515
01:09:04,450 --> 01:09:07,430
well, then what we're going to do is this in line 45.
那么，我们将在第 45 行这样做。

1516
01:09:07,430 --> 01:09:10,840
We're going to iterate over that existing linked list.
我们将遍历那个现有的链表。

1517
01:09:10,840 --> 01:09:14,050
And I'm going to do so with a temporary variable called pointer,
我将使用一个名为指针的临时变量来进行操作，

1518
01:09:14,050 --> 01:09:17,950
or ptr for short, that's initialized to the beginning of the list, a foam
或者简称为 ptr，它被初始化为列表的开头，一根泡泡手指

1519
01:09:17,950 --> 01:09:20,260
finger pointing at that first node initially.
最初指向第一个节点。

1520
01:09:20,260 --> 01:09:23,800
I'm going to on every iteration update that pointer variable
在每次迭代中，我都会更新那个指针变量

1521
01:09:23,800 --> 01:09:28,090
to point to the next node, to the next node, pointing one node ahead
使其指向下一个节点，指向下一个节点，指向前面一个节点

1522
01:09:28,090 --> 01:09:29,109
with that foam finger.
用那根泡泡手指。

1523
01:09:29,109 --> 01:09:31,300
But on each iteration, I'm also going to make sure
但在每次迭代中，我还会确保

1524
01:09:31,300 --> 01:09:33,370
that the pointer variable is not null.
指针变量不为空。

1525
01:09:33,370 --> 01:09:37,090
Because if it is null, that means I'm pointing past the end of the list or,
因为如果它为空，这意味着我指向了列表的末尾，或者，

1526
01:09:37,090 --> 01:09:39,189
that is, the list has ended.
也就是说，列表已经结束了。

1527
01:09:39,189 --> 01:09:46,160
But if inside of that loop I notice that the current node's next field is null,
但如果在循环内部，我注意到当前节点的 next 字段为空，

1528
01:09:46,160 --> 01:09:48,819
I actually know logically that I'm at the end of the list
我实际上在逻辑上知道我已经到达了列表的末尾

1529
01:09:48,819 --> 01:09:50,300
without going past it.
而没有越过它。

1530
01:09:50,300 --> 01:09:53,300
So at that point, if my goal is to append this new node,
所以，在那个点，如果我的目标是追加这个新的节点，

1531
01:09:53,300 --> 01:09:56,230
I'm going to go ahead and set pointer arrow next,
我将继续设置指针箭头 next，

1532
01:09:56,230 --> 01:10:00,640
which is currently null, but set it equal to the address of this new node
它当前为空，但将其设置为这个新节点的地址

1533
01:10:00,640 --> 01:10:03,680
effectively appending that node to the end of the list.
有效地将该节点追加到列表的末尾。

1534
01:10:03,680 --> 01:10:07,990
So, for instance, if we started with a list of 1 and 2, what we've just done
例如，如果我们从包含 1 和 2 的列表开始，我们刚刚做的事情

1535
01:10:07,990 --> 01:10:14,170
is updated 2's next field to be equal to the address of the node containing 3.
是将 2 的 next 字段更新为等于包含 3 的节点的地址。

1536
01:10:14,170 --> 01:10:17,860
Meanwhile, the node containing 3's next field is null by default
同时，包含 3 的节点的 next 字段默认情况下为空

1537
01:10:17,860 --> 01:10:21,040
because it is now the new end of the list.
因为它现在是列表的新末尾。

1538
01:10:21,040 --> 01:10:25,330
Now, what are the implications for maybe performance or efficiency now?
现在，对性能或效率可能有什么影响呢？

1539
01:10:25,330 --> 01:10:28,120
Well, we are now appending to the list, which
嗯，我们现在正在追加到列表中，这

1540
01:10:28,120 --> 01:10:32,620
means we're no longer gaining constant time of insertion.
意味着我们不再获得恒定的插入时间。

1541
01:10:32,620 --> 01:10:36,088
Because any time we prepend it, it took us some finite number of steps.
因为每当我们在开头添加时，都需要一些有限的步骤。

1542
01:10:36,088 --> 01:10:39,130
We just had to update a couple of pointers at the beginning of the list--
我们只需要更新列表开头处的几个指针--

1543
01:10:39,130 --> 01:10:39,910
beginning of the list.
列表的开头。

1544
01:10:39,910 --> 01:10:42,070
And it doesn't actually matter how much longer the list
而且实际上并不重要列表有多长

1545
01:10:42,070 --> 01:10:43,778
is getting because we're never traversing
因为我们永远不会遍历

1546
01:10:43,778 --> 01:10:45,460
the list when we're prepending.
当我们进行前置时，列表就会出现。

1547
01:10:45,460 --> 01:10:48,700
But when we're appending, by definition we're finding the end of the list,
但是，当我们进行追加时，根据定义，我们是在寻找列表的末尾。

1548
01:10:48,700 --> 01:10:51,075
finding the end of the list, finding the end of the list.
寻找列表的末尾，寻找列表的末尾。

1549
01:10:51,075 --> 01:10:52,930
And so our running time now for insertion
因此，我们现在插入操作的运行时间

1550
01:10:52,930 --> 01:10:55,180
is no longer big O of 1 or constant time.
不再是 O(1) 或者常数时间了。

1551
01:10:55,180 --> 01:10:58,600
It's now big O of n because if there's n nodes in the list already,
它现在是 O(n) 了，因为如果列表中已经存在 n 个节点，

1552
01:10:58,600 --> 01:11:02,050
just to find the end of it we need to actually traverse the whole list
仅仅为了找到它的末尾，我们实际上需要遍历整个列表

1553
01:11:02,050 --> 01:11:04,790
to actually find where this new node should go.
来找到这个新节点应该放置的位置。

1554
01:11:04,790 --> 01:11:08,260
But even so, we've gotten lucky in this appending case
但即使如此，在这个追加情况下我们还是比较幸运的

1555
01:11:08,260 --> 01:11:10,278
that we inserted 1 then 2 then 3.
我们插入了 1、然后是 2、最后是 3。

1556
01:11:10,278 --> 01:11:12,070
That's just because of my choice of inputs.
这只是因为我选择了这些输入。

1557
01:11:12,070 --> 01:11:15,250
Suppose that we don't in advance what the inputs are going to be.
假设我们事先不知道输入将是什么。

1558
01:11:15,250 --> 01:11:18,610
They might be large numbers, small numbers, or anything in between.
它们可能是大数字、小数字，或者介于两者之间的任何数字。

1559
01:11:18,610 --> 01:11:21,140
But they might not necessarily be in order.
但是它们不一定是有序的。

1560
01:11:21,140 --> 01:11:24,100
But if we want to maintain this linked list in sorted order,
但如果我们想要让这个链表保持排序，

1561
01:11:24,100 --> 01:11:27,380
I think our logic's actually going to have to change.
我认为我们的逻辑实际上需要改变。

1562
01:11:27,380 --> 01:11:33,100
So let me actually go ahead and open up a new version of my linked list code,
所以让我实际操作一下，打开一个新的链表代码版本，

1563
01:11:33,100 --> 01:11:34,990
this one too made in advance.
这个也是事先做好的。

1564
01:11:34,990 --> 01:11:38,080
And in this version of my code, as we'll soon see,
在这个代码版本中，我们很快就会看到，

1565
01:11:38,080 --> 01:11:43,130
I've gone about changing the logic just a little bit so that I can actually
我稍微改变了一下逻辑，这样我实际上可以

1566
01:11:43,130 --> 01:11:48,560
now handle this additional case because when inserting nodes in arbitrary
现在处理这个额外的情况，因为当在任意位置插入节点时

1567
01:11:48,560 --> 01:11:51,650
order, if I wanted them to end up being sorted,
顺序中，如果我希望它们最终是排序的，

1568
01:11:51,650 --> 01:11:53,600
I have to consider a few possible scenarios.
我必须考虑几种可能的情况。

1569
01:11:53,600 --> 01:11:55,440
Maybe there's no list whatsoever.
也许根本没有列表。

1570
01:11:55,440 --> 01:11:56,810
So let's actually look for that.
所以让我们实际看一下。

1571
01:11:56,810 --> 01:11:59,870
Let me scroll down in this final version of my linked list code.
让我在这个链表代码的最终版本中向下滚动。

1572
01:11:59,870 --> 01:12:03,690
And, actually, that case here on line 35 is pretty much the same.
实际上，第 35 行的这种情况基本相同。

1573
01:12:03,690 --> 01:12:06,110
If there's no list there, and the list variable is null,
如果没有列表，并且列表变量为 null，

1574
01:12:06,110 --> 01:12:08,330
well, let's just update it to point to this new node.
那么，我们只需要更新它，使其指向这个新节点。

1575
01:12:08,330 --> 01:12:12,500
But things get more interesting when there is at least one node there.
但是，当至少存在一个节点时，事情变得更有趣了。

1576
01:12:12,500 --> 01:12:16,170
Because if the goal is to maintain sorted order, we now need to decide,
因为如果目标是保持排序，我们现在需要决定，

1577
01:12:16,170 --> 01:12:18,710
does this new node, whatever its number is,
这个新节点，无论它的数字是多少，

1578
01:12:18,710 --> 01:12:22,400
go before the beginning of the list, at the end of the list,
应该放在列表的开头、列表的末尾，

1579
01:12:22,400 --> 01:12:24,150
in the middle somewhere of the list?
还是放在列表的中间某个位置？

1580
01:12:24,150 --> 01:12:25,850
So let's break that down.
所以让我们分解一下。

1581
01:12:25,850 --> 01:12:32,670
If we find that the new node's number is less than the list's number here,
如果我们发现新节点的数字小于这里列表的数字，

1582
01:12:32,670 --> 01:12:35,060
well, then it belongs at the beginning of the list
那么，它应该放在列表的开头

1583
01:12:35,060 --> 01:12:37,620
because it's smaller than any of the numbers already there.
因为它比已经存在的任何数字都小。

1584
01:12:37,620 --> 01:12:41,450
So what I'm going to go ahead and do is update this new node's next field
所以我要做的就是更新这个新节点的 next 字段

1585
01:12:41,450 --> 01:12:43,940
to point at the current linked list.
使其指向当前的链表。

1586
01:12:43,940 --> 01:12:46,160
And then I'm going to update the linked list variable
然后我将更新链表变量

1587
01:12:46,160 --> 01:12:48,590
to equal the address of this new node.
使其等于这个新节点的地址。

1588
01:12:48,590 --> 01:12:53,240
The effect then is, no matter how long the existing list is if this new node's
然后，效果就是，无论现有列表有多长，如果这个新节点的

1589
01:12:53,240 --> 01:12:55,820
number is smaller than everything else in the list,
数字比列表中所有其他数字都小，

1590
01:12:55,820 --> 01:12:57,970
I want to just splice it in at the beginning.
我想要把它直接插入到开头。

1591
01:12:57,970 --> 01:13:00,470
So that's actually pretty straightforward with just a couple
所以这实际上非常简单，只需要几行代码

1592
01:13:00,470 --> 01:13:02,210
of pointer updates.
指针更新。

1593
01:13:02,210 --> 01:13:04,292
But the other scenario is that it doesn't just
但另一种情况是，它不只是

1594
01:13:04,292 --> 01:13:06,000
belong at the very beginning of the list.
属于列表的最开头。

1595
01:13:06,000 --> 01:13:07,370
It's somewhere else in the list.
它在列表的其他位置。

1596
01:13:07,370 --> 01:13:09,078
And that itself is two scenarios.
这本身就有两种情况。

1597
01:13:09,078 --> 01:13:10,620
Maybe it's in the middle of the list.
也许它在列表中间。

1598
01:13:10,620 --> 01:13:12,245
Maybe it's at the very end of the list.
也许它在列表的最末尾。

1599
01:13:12,245 --> 01:13:14,540
So let's consider those scenarios as well.
所以我们也来考虑一下这些情况。

1600
01:13:14,540 --> 01:13:15,860
Let me scroll down here.
让我向下滚动一下。

1601
01:13:15,860 --> 01:13:18,030
And in my else clause, it's a bit bigger this time.
在我的 else 子句中，这次代码量稍微多一些。

1602
01:13:18,030 --> 01:13:18,530
Why?
为什么？

1603
01:13:18,530 --> 01:13:23,030
Because on line 51, in this case, I'm going to induce another for loop
因为在第 51 行，在这种情况下，我将引入另一个 for 循环

1604
01:13:23,030 --> 01:13:23,970
as before.
和之前一样。

1605
01:13:23,970 --> 01:13:27,530
But this time I'm trying to determine if this node belongs at the end
但这次我试图确定这个节点属于末尾

1606
01:13:27,530 --> 01:13:29,070
or somewhere in the middle.
还是列表中间的某个位置。

1607
01:13:29,070 --> 01:13:31,100
So I'm not just looking for the end this time.
所以这次我不只是寻找末尾。

1608
01:13:31,100 --> 01:13:35,180
I'm actually comparing the value, the integer inside of this new node,
我实际上是在比较值，这个新节点中的整数，

1609
01:13:35,180 --> 01:13:37,290
against what is currently in the list.
与当前列表中的值进行比较。

1610
01:13:37,290 --> 01:13:41,150
So, for instance, if logically I actually find my way
例如，如果从逻辑上讲，我真的找到了我的路

1611
01:13:41,150 --> 01:13:43,130
all the way to the end of the list, whereby
一直到列表的末尾，当

1612
01:13:43,130 --> 01:13:47,510
the next field in the pointer variables node equals null,
指针变量节点中的下一个字段等于 null 时，

1613
01:13:47,510 --> 01:13:50,850
well, then logically I didn't find an earlier spot for this node.
那么，从逻辑上讲，我没有找到这个节点的更早位置。

1614
01:13:50,850 --> 01:13:54,380
So let me go ahead and update that pointer's next field
所以，让我继续更新该指针的下一个字段

1615
01:13:54,380 --> 01:13:56,260
to equal the address of this new node.
使其等于这个新节点的地址。

1616
01:13:56,260 --> 01:13:58,760
And then like before, let's just break out because I'm done.
然后，和之前一样，让我们直接退出，因为我已经完成了。

1617
01:13:58,760 --> 01:14:01,790
I somehow mathematically got all the way to the end of the list
我不知何故在数学上走到了列表的末尾

1618
01:14:01,790 --> 01:14:03,650
because there is that null pointer.
因为那里有一个空指针。

1619
01:14:03,650 --> 01:14:07,700
So it must be the case logically here that this new node belongs at the end.
所以，从逻辑上讲，这里这个新节点肯定属于末尾。

1620
01:14:07,700 --> 01:14:11,270
But this is the juicier, slightly more challenging one.
但这是更有趣，更具挑战性的部分。

1621
01:14:11,270 --> 01:14:13,910
But it's what ensures that we can maintain sorted order even
但它保证我们即使

1622
01:14:13,910 --> 01:14:16,140
if the new node belongs somewhere in the middle.
新节点属于中间的某个位置，也能保持排序顺序。

1623
01:14:16,140 --> 01:14:20,030
So down here on line 62, I'm going to ask this question.
所以，在第 62 行，我要问这个问题。

1624
01:14:20,030 --> 01:14:27,200
If the new node's number is less than the number in the next node-- that
如果新节点的数字小于下一个节点中的数字，也就是说

1625
01:14:27,200 --> 01:14:29,360
is to say, if my foam fingers pointing here,
我的泡沫手指指向这里，

1626
01:14:29,360 --> 01:14:34,520
but the number I'm trying to insert is smaller than the next node over there
但我想要插入的数字小于那边的下一个节点

1627
01:14:34,520 --> 01:14:39,140
and implicitly the same as or greater than the current node's number,
并且隐含地等于或大于当前节点的数字，

1628
01:14:39,140 --> 01:14:41,160
well, then I'm going to go ahead and do this.
那么，我将继续执行以下操作。

1629
01:14:41,160 --> 01:14:44,210
I'm going to update the new node's next pointer
我将更新新节点的下一个指针

1630
01:14:44,210 --> 01:14:48,810
to be equal to whatever the current node I'm pointing at next pointer
使其等于我指向的当前节点的下一个指针

1631
01:14:48,810 --> 01:14:54,800
so that I can then update that pointer's next field to equal the new node.
以便我可以更新该指针的下一个字段使其等于新节点。

1632
01:14:54,800 --> 01:14:59,240
And then I can break out altogether, doing a similar splice
然后，我可以完全退出，执行类似的拼接操作

1633
01:14:59,240 --> 01:15:03,020
in the middle of this list but manipulating a node effectively
在该列表中间，但有效地操作一个节点

1634
01:15:03,020 --> 01:15:06,450
to the left and the right to make room for this new node.
在左右两边腾出空间来容纳这个新节点。

1635
01:15:06,450 --> 01:15:08,480
So, collectively, what does this code do?
所以，总的来说，这段代码做了什么？

1636
01:15:08,480 --> 01:15:11,150
Well, if we start out with that initially empty list,
那么，如果我们从最初的空列表开始，

1637
01:15:11,150 --> 01:15:14,090
and maybe we insert the number 2, it just goes right there.
也许我们插入数字 2，它就会直接放在那里。

1638
01:15:14,090 --> 01:15:17,570
But suppose that we insert next the number 1, which, of course, is smaller,
但是假设我们接下来插入数字1，当然，它更小，

1639
01:15:17,570 --> 01:15:19,880
this code now ensures that the 1 is going to get
这个代码现在确保1将被

1640
01:15:19,880 --> 01:15:21,650
inserted at the beginning of the list.
插入到列表的开头。

1641
01:15:21,650 --> 01:15:25,310
If we then insert the number 4, well, that's bigger than 1 and bigger than 2.
如果我们然后插入数字4，好吧，它比1大，也比2大。

1642
01:15:25,310 --> 01:15:28,380
So it logically is going to end up at the end of the list.
所以它在逻辑上会最终出现在列表的末尾。

1643
01:15:28,380 --> 01:15:31,880
And, lastly, in this example, if we insert 3, which, again, is initially
最后，在这个例子中，如果我们插入3，它再次是最初

1644
01:15:31,880 --> 01:15:36,500
out of order, this code can ensure that we still insert it in sorted order
无序的，这段代码可以确保我们仍然按排序的顺序插入它

1645
01:15:36,500 --> 01:15:40,130
because it's going to end up in between nodes 2 and 4.
因为它最终会出现在节点2和4之间。

1646
01:15:40,130 --> 01:15:44,260
So here too in terms of running time, insertion is still big O of n.
因此，在运行时间方面，插入仍然是O(n)的。

1647
01:15:44,260 --> 01:15:46,548
It's not quite as bad in practice as always adding it
在实践中，它并不像总是添加到

1648
01:15:46,548 --> 01:15:48,340
to the end of the list, the end of the list
列表的末尾，列表的末尾

1649
01:15:48,340 --> 01:15:51,550
as was the case when we blindly appended new nodes.
就像我们盲目地追加新节点一样。

1650
01:15:51,550 --> 01:15:54,220
But it is going to be in big O of n because, in the worst case
但它将是O(n)的，因为在最坏的情况下

1651
01:15:54,220 --> 01:15:58,280
here, if we've got n nodes in the list already, then in the worst case
这里，如果我们列表中已经有了n个节点，那么在最坏的情况下

1652
01:15:58,280 --> 01:16:03,130
it might indeed be such a big number that it belongs at the end of the list.
它可能确实是一个很大的数字，它属于列表的末尾。

1653
01:16:03,130 --> 01:16:04,400
All right, that was a lot.
好吧，那是很多。

1654
01:16:04,400 --> 01:16:06,700
Let's go ahead and take a delicious cookie break here.
让我们在这里吃一个美味的饼干休息一下。

1655
01:16:06,700 --> 01:16:09,310
And we'll be back in 10.
我们10分钟后回来。

1656
01:16:09,310 --> 01:16:11,200
All right, we are back.
好了，我们回来了。

1657
01:16:11,200 --> 01:16:16,330
And to recap, the problems we've solved and the problems we've created are--
为了回顾，我们解决的问题和我们创造的问题是——

1658
01:16:16,330 --> 01:16:18,735
arrays were problematic because they were a fixed size.
数组之所以有问题，是因为它们是固定大小的。

1659
01:16:18,735 --> 01:16:20,110
And that can get us into trouble.
这可能会让我们陷入麻烦。

1660
01:16:20,110 --> 01:16:23,920
Or it causes us to waste more space preemptively
或者它导致我们预先浪费更多空间

1661
01:16:23,920 --> 01:16:25,580
even though we might not ever use it.
即使我们可能永远不会使用它。

1662
01:16:25,580 --> 01:16:29,470
So we introduce the linked lists again to solve that problem
所以我们再次引入链表来解决这个问题

1663
01:16:29,470 --> 01:16:31,840
by being more dynamic and only allocate as much memory
通过更加动态，并且只分配我们需要的内存

1664
01:16:31,840 --> 01:16:33,790
as we need on demand step by step.
根据需求，一步一步地。

1665
01:16:33,790 --> 01:16:36,790
But, of course, we're spending extra space for the pointers.
但当然，我们为指针花费了额外的空间。

1666
01:16:36,790 --> 01:16:40,940
We might gain performance if we at least prepend all of our elements to it.
如果我们至少将所有元素都预先添加到其中，我们可能会获得性能提升。

1667
01:16:40,940 --> 01:16:45,330
But we lose time again if we append or insert in sorted order.
但是，如果我们按排序顺序追加或插入，我们再次损失时间。

1668
01:16:45,330 --> 01:16:47,832
So it's not clear, frankly, I think, to me,
所以坦白地说，我认为，对我来说，

1669
01:16:47,832 --> 01:16:50,540
even hearing these upsides and downsides, if there's a clear win.
即使听到了这些优点和缺点，也不清楚是否有明显的优势。

1670
01:16:50,540 --> 01:16:53,810
But maybe there's a way to get the best of both worlds
但是也许有一种方法可以兼得两者的优势

1671
01:16:53,810 --> 01:16:58,070
by trying to capture the upsides of having information that
通过尝试捕捉拥有信息的优点，这些信息

1672
01:16:58,070 --> 01:17:03,200
is kept in sorted order that allows us to maybe divide and conquer still
以排序的顺序保存，这可能允许我们仍然进行分治

1673
01:17:03,200 --> 01:17:06,860
but still gives us the dynamism to grow or shrink the data structure.
但也仍然给我们提供动态性，让我们可以扩展或缩减数据结构。

1674
01:17:06,860 --> 01:17:08,910
And thus we're born trees.
因此，树诞生了。

1675
01:17:08,910 --> 01:17:13,820
So what we're about to explore are variants of these ideas of arrays
所以我们即将探索的是这些数组想法的变体

1676
01:17:13,820 --> 01:17:17,750
and linked lists and see if we can maybe mash up some of those building blocks
和链表，看看我们是否可以将一些那些构建块混合在一起

1677
01:17:17,750 --> 01:17:22,130
and create more interesting, more compelling solutions
并创造更有趣、更具吸引力的解决方案

1678
01:17:22,130 --> 01:17:25,010
that are even not just one-dimensional left to right
这些解决方案甚至不只是从左到右的一维

1679
01:17:25,010 --> 01:17:29,760
but are maybe two dimensional and have different axes to them or dimensions.
而是可能是二维的，并且拥有不同的轴或维度。

1680
01:17:29,760 --> 01:17:32,030
So a tree in the real world, of course, tends
所以，现实世界中的树，当然，往往

1681
01:17:32,030 --> 01:17:33,710
to grow up from the ground like this.
像这样从地面向上生长。

1682
01:17:33,710 --> 01:17:35,450
But it tends to branch out.
但是它往往会分支出去。

1683
01:17:35,450 --> 01:17:36,830
And branches branch.
而分支还会继续分支。

1684
01:17:36,830 --> 01:17:41,240
And that might already in your mind's eye evoke notions of forks
这可能已经在你的脑海中唤起了对岔路的印象，或者像我们之前看到的条件语句。

1685
01:17:41,240 --> 01:17:43,460
in the road or conditionals as we've seen.
或者像我们之前看到的条件语句。

1686
01:17:43,460 --> 01:17:45,620
And let me propose that we first consider what
我建议我们首先考虑一下

1687
01:17:45,620 --> 01:17:47,900
the world calls binary search trees.
世界所称的二叉搜索树。

1688
01:17:47,900 --> 01:17:51,050
And so bi is back in that we can do things in half and half and half
因此，"bi" 又回来了，我们可以把事情分成一半、一半、再一半

1689
01:17:51,050 --> 01:17:54,590
somehow if maybe we think about arrays a little bit more cleverly.
只要我们稍微聪明一点，考虑一下数组。

1690
01:17:54,590 --> 01:17:56,375
So here's an array of size 7.
这是一个大小为 7 的数组。

1691
01:17:56,375 --> 01:17:59,000
And I chose that deliberately because there's a perfect middle.
我故意这么选择，因为它有一个完美的中间。

1692
01:17:59,000 --> 01:18:02,370
There's a middle of middle and so forth, just like the lockers a few weeks back.
中间的中间，再中间，等等，就像几周前我们谈到的储物柜一样。

1693
01:18:02,370 --> 01:18:04,370
So when the world of arrays--
所以，当我们谈到数组的时候——

1694
01:18:04,370 --> 01:18:06,380
this was actually pretty efficient because we
这实际上非常有效，因为我们

1695
01:18:06,380 --> 01:18:09,920
can do binary search and middle of middle, middle of middle, and so forth.
可以进行二分查找，找到中间的中间，再找到中间的中间，等等。

1696
01:18:09,920 --> 01:18:12,560
And that gave us logarithmic running time.
这给了我们对数级的运行时间。

1697
01:18:12,560 --> 01:18:14,390
But its only size 7.
但它只有 7 个元素。

1698
01:18:14,390 --> 01:18:17,270
And we concluded that it's going to be like big O of n headache
我们得出结论，要把这些数据复制到一个稍微大一点的数组中，释放旧内存，

1699
01:18:17,270 --> 01:18:20,418
to copy this into a slightly bigger array, free the old memory,
要把这些数据复制到一个稍微大一点的数组中，释放旧内存，

1700
01:18:20,418 --> 01:18:20,960
and so forth.
等等。

1701
01:18:20,960 --> 01:18:22,310
And thus were born linked list.
于是，链表就诞生了。

1702
01:18:22,310 --> 01:18:26,460
But with linked lists, we lost log of n running time.
但是，在链表中，我们失去了对数级的运行时间。

1703
01:18:26,460 --> 01:18:26,960
Why?
为什么？

1704
01:18:26,960 --> 01:18:29,360
Because we have to always start at the beginning to
因为我们必须始终从开头开始，

1705
01:18:29,360 --> 01:18:33,013
get, for instance, to the middle or to the end of the list in the worst case.
才能在最坏情况下找到中间或者链表的末尾。

1706
01:18:33,013 --> 01:18:36,180
But what if we start to think a little more cleverly in multiple dimensions?
但如果我们在多个维度上稍微更聪明一些呢？

1707
01:18:36,180 --> 01:18:39,500
So just for the sake of discussion, let me highlight the middle of this here
为了便于讨论，让我用高亮标出这个数组的中间位置。

1708
01:18:39,500 --> 01:18:40,010
array.
数组。

1709
01:18:40,010 --> 01:18:41,480
Let me highlight the middle of the middle
让我用高亮标出中间的中间

1710
01:18:41,480 --> 01:18:42,920
and then the middle of the middle.
然后是中间的中间。

1711
01:18:42,920 --> 01:18:45,920
So there's implicit structure here.
这里存在着一种隐含的结构。

1712
01:18:45,920 --> 01:18:47,220
There's a pattern of sorts.
存在着某种模式。

1713
01:18:47,220 --> 01:18:49,400
And, in fact, just to make this more obvious,
事实上，为了更清楚地说明这一点，

1714
01:18:49,400 --> 01:18:53,270
let me not treat this as one dimension left to right but how about two
让我不要把它看作一个从左到右的一维结构，而是把它看作二维结构

1715
01:18:53,270 --> 01:18:54,950
and give myself a bit of vertical space.
并给自己留一些垂直空间。

1716
01:18:54,950 --> 01:18:56,270
So it's the exact same array.
所以，它还是同一个数组。

1717
01:18:56,270 --> 01:18:58,335
But allow me to just think about it now as
但是现在请允许我把它想象成

1718
01:18:58,335 --> 01:18:59,960
though the middle elements way up here.
中间的元素在上面。

1719
01:18:59,960 --> 01:19:01,880
The middle of the middles are slightly lower.
中间的中间略微低一些。

1720
01:19:01,880 --> 01:19:03,710
And the middle of the middles or the leaves
而中间的中间，或者说叶子

1721
01:19:03,710 --> 01:19:05,600
really are at the bottom of this tree.
实际上都在树的底部。

1722
01:19:05,600 --> 01:19:06,780
And that word is deliberate.
这个词是故意选择的。

1723
01:19:06,780 --> 01:19:09,072
We actually borrowed vernacular from the world of trees
我们实际上借用了树世界中的词汇

1724
01:19:09,072 --> 01:19:13,550
where the leaf nodes or leaves are the ones at the very bottom.
在那里，叶子节点或叶子位于最底部。

1725
01:19:13,550 --> 01:19:16,567
And the root node is the one at the very top.
而根节点位于最顶部。

1726
01:19:16,567 --> 01:19:18,650
So for the sake of discussion, computer scientists
所以，为了方便讨论，计算机科学家

1727
01:19:18,650 --> 01:19:20,930
draw trees like this, instead of this.
会这样画树，而不是那样画。

1728
01:19:20,930 --> 01:19:22,820
But it's the exact same idea.
但它们的想法是一样的。

1729
01:19:22,820 --> 01:19:26,990
They just tend to grow down in discussions, more like a family tree
它们在讨论中往往向下生长，更像是家族谱

1730
01:19:26,990 --> 01:19:29,580
if you drew those growing up, for instance.
比如，如果你画的是向上生长的家族谱。

1731
01:19:29,580 --> 01:19:32,360
So what's interesting here?
那么这里有什么有趣的地方呢？

1732
01:19:32,360 --> 01:19:35,480
Well, at the moment, we've broken the array model
嗯，目前我们已经打破了数组模型

1733
01:19:35,480 --> 01:19:38,690
because this memory is absolutely not contiguous because this number is here.
因为这块内存绝对不是连续的，因为这个数字在这里。

1734
01:19:38,690 --> 01:19:40,160
This number is here, here, here, and here.
这个数字在这里，在这里，在这里，还有这里。

1735
01:19:40,160 --> 01:19:41,390
It's all over the place.
它到处都是。

1736
01:19:41,390 --> 01:19:44,840
But we do have pointers now in our toolkit, whereby
但是我们现在在我们的工具包中有指针，通过它们

1737
01:19:44,840 --> 01:19:47,540
even if these numbers are anywhere in the computer's memory,
即使这些数字位于计算机内存中的任何地方，

1738
01:19:47,540 --> 01:19:51,350
we can stitch them together like we did string and those balloons.
我们可以像我们用绳子和气球做的那样把它们缝合在一起。

1739
01:19:51,350 --> 01:19:53,990
Now, it's not sufficient just to have one piece of string
现在，仅仅有一条绳子是不够的

1740
01:19:53,990 --> 01:19:56,000
for each node or one pointer.
用于每个节点或一个指针。

1741
01:19:56,000 --> 01:19:59,480
But what if we actually give each of these nodes, not just a number,
但是如果我们实际上给每个节点，不仅仅是一个数字，

1742
01:19:59,480 --> 01:20:01,460
like the number 4, the number 2, the number 6--
比如数字 4，数字 2，数字 6 --

1743
01:20:01,460 --> 01:20:05,690
let's give them each a number and two pointers, a so-called left child
让我们给它们每个一个数字和两个指针，一个所谓的左子节点

1744
01:20:05,690 --> 01:20:08,160
and a right child so to speak.
以及一个右子节点，可以这么说。

1745
01:20:08,160 --> 01:20:09,650
So we could do this.
所以我们可以这样做。

1746
01:20:09,650 --> 01:20:12,050
And I'm going to abstract away now.
我现在要抽象化。

1747
01:20:12,050 --> 01:20:13,550
They're not even rectangles anymore.
它们甚至不再是矩形了。

1748
01:20:13,550 --> 01:20:15,050
They're really long rectangles.
它们是真正很长的矩形。

1749
01:20:15,050 --> 01:20:18,740
Or they're upside down Ts that have three boxes to them.
或者它们是倒置的 T，有三个盒子。

1750
01:20:18,740 --> 01:20:22,220
But I'm just going to abstract away nodes now as just simple squares.
但我现在要把节点抽象成简单的正方形。

1751
01:20:22,220 --> 01:20:25,880
And it's an implementation detail as to what the structs actually are.
而结构体到底是什么是一个实现细节。

1752
01:20:25,880 --> 01:20:30,515
But the arrows suggest that each of these nodes now has two pointers.
但是箭头表明这些节点现在都有两个指针。

1753
01:20:30,515 --> 01:20:31,640
You don't have to use them.
你并不一定要用它们。

1754
01:20:31,640 --> 01:20:33,307
The leaf nodes have nothing to point to.
叶子节点没有指向任何东西。

1755
01:20:33,307 --> 01:20:35,330
So those can all be null probably.
所以那些可能都是空的。

1756
01:20:35,330 --> 01:20:38,870
But each of these nodes now has two pointers.
但是这些节点现在都有两个指针。

1757
01:20:38,870 --> 01:20:40,720
Now, what's the implication of this?
现在，这意味着什么？

1758
01:20:40,720 --> 01:20:43,990
This is what we call a binary search tree
这就是我们所说的二叉搜索树

1759
01:20:43,990 --> 01:20:46,990
because, one and first and foremost, it's obviously a tree.
因为，首先也是最重要的是，它显然是一棵树。

1760
01:20:46,990 --> 01:20:51,310
But it also is a data structure that's kept in sorted order,
但它也是一种以排序顺序存储数据的结构，

1761
01:20:51,310 --> 01:20:52,780
whereby notice what is true.
因此要注意什么是真的。

1762
01:20:52,780 --> 01:20:55,760
If you pick any node in this tree, like the number 4,
如果你在这棵树中选择任何节点，比如数字 4，

1763
01:20:55,760 --> 01:21:00,530
everything to the left of it, its left subtree so to speak, is smaller.
它左侧的所有东西，可以这么说它的左子树，都更小。

1764
01:21:00,530 --> 01:21:04,097
Everything to the right of it, its right subtree, is larger.
它右侧的所有东西，它的右子树，都更大。

1765
01:21:04,097 --> 01:21:05,180
And that's true elsewhere.
在其他地方也是如此。

1766
01:21:05,180 --> 01:21:05,847
Look at the six.
看看 6。

1767
01:21:05,847 --> 01:21:07,400
Everything to the left is smaller.
左侧的所有东西都更小。

1768
01:21:07,400 --> 01:21:11,000
Everything to the right is bigger and same thing over here.
右侧的所有东西都更大，这里也是一样。

1769
01:21:11,000 --> 01:21:13,930
So in some sense, this is a recursive data structure
从某种意义上说，这是一种递归数据结构

1770
01:21:13,930 --> 01:21:17,080
because you can say the same thing about each of these nodes
因为你可以对这些节点中的每一个都这么说

1771
01:21:17,080 --> 01:21:20,950
because each of these subtrees compose a larger tree.
因为这些子树中的每一棵都构成了更大的树。

1772
01:21:20,950 --> 01:21:23,920
Or, conversely, this big tree is a composition
反之，这棵大树是

1773
01:21:23,920 --> 01:21:26,645
of 1, 2 subtrees plus one more node.
由 1，2 棵子树加上一个节点组成。

1774
01:21:26,645 --> 01:21:29,020
So think back to our [INAUDIBLE] example in those bricks.
所以回想起我们在那些砖块中的 [听不见] 例子。

1775
01:21:29,020 --> 01:21:30,880
Well, what's a pyramid of height 4?
那么，高度为 4 的金字塔是什么？

1776
01:21:30,880 --> 01:21:33,280
Well, just a pyramid of height 3 plus one more row.
好吧，只是一座高度为 3 的金字塔加上一排。

1777
01:21:33,280 --> 01:21:35,020
What's a tree of height 3?
高度为 3 的树是什么？

1778
01:21:35,020 --> 01:21:39,440
Well, it's two subtrees of height 2 plus one more row or really
嗯，它是两棵高度为 2 的子树加上一排，或者说实际上

1779
01:21:39,440 --> 01:21:41,790
one new root node to connect them.
一个新的根节点来连接它们。

1780
01:21:41,790 --> 01:21:44,972
So this already is a recursive data structure by that logic.
所以根据这个逻辑，这已经是一个递归的数据结构了。

1781
01:21:44,972 --> 01:21:46,430
How do we translate this into code?
我们如何把它转换成代码？

1782
01:21:46,430 --> 01:21:49,700
Well, we won't sludge through so much low level C code this time around.
好吧，这次我们不会再费力地去处理那么多的低级 C 代码了。

1783
01:21:49,700 --> 01:21:52,790
But let me propose that we could implement a node now
但是我建议我们现在可以实现一个节点

1784
01:21:52,790 --> 01:21:56,450
as being similar in spirit to what we did last time where every node used
它在精神上类似于我们上次做的事情，在那里每个节点都使用

1785
01:21:56,450 --> 01:21:58,652
to have a number and a next pointer.
一个数字和一个下一个指针。

1786
01:21:58,652 --> 01:22:00,860
But, now, let's actually make some room for ourselves
但是，现在，让我们实际为我们自己留出一些空间

1787
01:22:00,860 --> 01:22:05,840
and redefine a node as still having a number but now having two pointers.
并重新定义一个节点，它仍然有一个数字，但现在有两个指针。

1788
01:22:05,840 --> 01:22:08,008
And I'll call them obviously left and right
我显然会称它们为左和右

1789
01:22:08,008 --> 01:22:09,800
though we could call them anything we want.
尽管我们可以随心所欲地称呼它们。

1790
01:22:09,800 --> 01:22:11,217
I could call it next and previous.
我可以称它为下一个和上一个。

1791
01:22:11,217 --> 01:22:14,720
But really left and right would seem to make more sense with children
但是，左和右对一个节点的子节点来说更有意义

1792
01:22:14,720 --> 01:22:16,590
of a given node like this.
像这样。

1793
01:22:16,590 --> 01:22:19,820
So this in C is how we might implement, therefore,
所以在 C 中，这就是我们可能实现的方式，因此，

1794
01:22:19,820 --> 01:22:22,460
a node in a binary search tree.
二叉搜索树中的一个节点。

1795
01:22:22,460 --> 01:22:25,235
And so let's consider pictorially what the running time is
让我们以图示的方式考虑一下运行时间是多少

1796
01:22:25,235 --> 01:22:26,360
of searching for something.
搜索某样东西。

1797
01:22:26,360 --> 01:22:29,780
If this here is the tree and it follows that binary search tree
如果这里就是树，并且它遵循二叉搜索树

1798
01:22:29,780 --> 01:22:33,020
definition where everything to the left is smaller everything to the right
定义，其中左侧的所有内容都比右侧的所有内容更小

1799
01:22:33,020 --> 01:22:35,930
is bigger, well, how many steps might it take if you
更大，那么，如果你有

1800
01:22:35,930 --> 01:22:38,750
have n nodes in a tree like this?
n 个节点在像这样的树中？

1801
01:22:38,750 --> 01:22:41,750
Well, it's not going to take me n steps because I certainly
好吧，它不会花费我 n 步，因为我当然

1802
01:22:41,750 --> 01:22:43,370
don't have to look through every node.
不需要查看每个节点。

1803
01:22:43,370 --> 01:22:45,650
And, in fact, just like a linked list starts
事实上，就像一个链表从

1804
01:22:45,650 --> 01:22:47,250
on the left hand side, so to speak.
左侧开始，可以这么说。

1805
01:22:47,250 --> 01:22:48,792
So that's just an artist's rendition.
所以那只是艺术家的演绎。

1806
01:22:48,792 --> 01:22:51,230
Just as a linked list starts on one end and you
就像链表从一端开始，然后你

1807
01:22:51,230 --> 01:22:54,380
have to traverse the whole thing, a tree, because it's two dimensional,
必须遍历整个链表，一个树，因为它是一个二维的，

1808
01:22:54,380 --> 01:22:56,940
always starts in memory at the root node.
总是在内存中的根节点开始。

1809
01:22:56,940 --> 01:22:59,750
So this is always where you start any operation, insertion,
所以，这总是你开始任何操作的地方，插入、

1810
01:22:59,750 --> 01:23:01,160
deletion, searching.
删除、搜索。

1811
01:23:01,160 --> 01:23:04,670
So by that logic, in the worst case if there's n nodes here,
所以根据这个逻辑，在最坏的情况下，如果有 n 个节点在这里，

1812
01:23:04,670 --> 01:23:07,280
how many steps would it seem to take?
它看起来需要多少步？

1813
01:23:07,280 --> 01:23:09,620
It's not big O of n.
它不是 O(n)。

1814
01:23:09,620 --> 01:23:12,470
So it's actually back to bi O of log n.
所以它实际上回到了 O(log n)。

1815
01:23:12,470 --> 01:23:13,070
Why?
为什么？

1816
01:23:13,070 --> 01:23:14,987
Because, actually, if you think of the height,
因为，实际上，如果你考虑高度，

1817
01:23:14,987 --> 01:23:16,490
there's roughly eight nodes in here.
这里大约有八个节点。

1818
01:23:16,490 --> 01:23:18,260
And log base 2 of 8 is actually 3.
以 2 为底的对数 8 实际上是 3。

1819
01:23:18,260 --> 01:23:20,790
And so 1, 2, 3 is the height of this tree.
所以 1、2、3 就是这棵树的高度。

1820
01:23:20,790 --> 01:23:23,300
So in the worst case at the moment, it seems
所以，在目前最坏的情况下，似乎

1821
01:23:23,300 --> 01:23:26,630
that it's only going to take me like 1 node, 2 nodes, 3 nodes, or really
它只花费我 1 个节点、2 个节点、3 个节点，或者实际上

1822
01:23:26,630 --> 01:23:29,390
just two steps to get to the very bottom of this tree
只需要两步就能到达这棵树的最底部

1823
01:23:29,390 --> 01:23:32,430
to decide is a number there or not.
来决定那里是否有一个数字。

1824
01:23:32,430 --> 01:23:35,130
I certainly can ignore this entire subtree.
我当然可以忽略这整个子树。

1825
01:23:35,130 --> 01:23:35,630
Why?
为什么？

1826
01:23:35,630 --> 01:23:37,340
Because I'm searching for the number 7.
因为我正在搜索数字 7。

1827
01:23:37,340 --> 01:23:41,480
Just like the phone book from week 0, I can divide and conquer this problem.
就像第 0 周的电话簿一样，我可以分而治之来解决这个问题。

1828
01:23:41,480 --> 01:23:43,730
If I'm looking for 7, I don't need to bother
如果我正在寻找 7， 我就不需要费心

1829
01:23:43,730 --> 01:23:48,680
wasting any time looking at this entire subtree, which is almost 50%
浪费任何时间去看这整个子树，它几乎占了屏幕上的图片的 50%

1830
01:23:48,680 --> 01:23:50,640
of the picture on the screen.
屏幕上的图片

1831
01:23:50,640 --> 01:23:53,210
And so I can focus on this half then this half.
所以我可以关注这一半，然后这一半

1832
01:23:53,210 --> 01:23:54,920
And, boom, I'm done.
然后，砰，就完成了

1833
01:23:54,920 --> 01:23:57,230
So we sort have binary search back.
所以我们有点像二分搜索

1834
01:23:57,230 --> 01:24:01,400
We have the metaphor of the lockers back by operating now in two dimensions
我们又有了储物柜的隐喻，现在我们在二维空间中操作

1835
01:24:01,400 --> 01:24:04,790
to mitigate the reality that our memory is no longer contiguous.
以减轻我们的内存不再连续的现实

1836
01:24:04,790 --> 01:24:05,720
But that's fine.
但这没关系

1837
01:24:05,720 --> 01:24:07,160
We can follow these arrows.
我们可以沿着这些箭头走

1838
01:24:07,160 --> 01:24:12,120
We can use these pointers instead to get anywhere that we actually want.
我们可以使用这些指针来获得我们真正想要到达的任何地方

1839
01:24:12,120 --> 01:24:16,230
So any questions now on trees or specifically binary search trees,
所以现在关于树，或者更具体地说关于二叉搜索树，有什么问题吗？

1840
01:24:16,230 --> 01:24:19,970
which I dare say are the best of both worlds, all of the upsides of an array.
我敢说，它们是两全其美，拥有数组的所有优点

1841
01:24:19,970 --> 01:24:21,650
And it's log n running time.
而且它的运行时间是 log n

1842
01:24:21,650 --> 01:24:24,680
And all of the upsides of the dynamism of linked list because this thing
以及链表的动态性的所有优点，因为这个东西

1843
01:24:24,680 --> 01:24:29,450
can grow and shrink and doesn't need to be contiguous.
可以增长和缩小，并且不需要是连续的

1844
01:24:29,450 --> 01:24:32,550
Any questions on this?
对此有什么问题吗？

1845
01:24:32,550 --> 01:24:36,890
All right, well, the code too lends itself to relative simplicity.
好吧，代码本身也相对简单

1846
01:24:36,890 --> 01:24:40,770
And here's where recursion applies not just to the structure of the data
这就是递归不仅适用于数据结构

1847
01:24:40,770 --> 01:24:42,082
but also the code itself.
而且也适用于代码本身

1848
01:24:42,082 --> 01:24:44,540
So just for the sake of discussion, we won't run this code.
所以为了讨论的缘故，我们不会运行这段代码

1849
01:24:44,540 --> 01:24:46,082
We'll just look at it on screen here.
我们只是在屏幕上看看它

1850
01:24:46,082 --> 01:24:49,340
Suppose you're implementing a function called search whose purpose in life
假设你正在实现一个名为 search 的函数，它的生命意义

1851
01:24:49,340 --> 01:24:51,740
is to search a tree and return, true or false,
是在树中搜索并返回真或假，

1852
01:24:51,740 --> 01:24:53,360
I found the number you're looking for.
我找到了你正在寻找的数字

1853
01:24:53,360 --> 01:24:55,027
Well, here's the number I'm looking for.
嗯，这就是我要找的数字

1854
01:24:55,027 --> 01:24:56,180
It's one of the arguments.
这是参数之一

1855
01:24:56,180 --> 01:25:00,170
And the first argument more importantly is actually a pointer to the tree
更重要的是，第一个参数实际上是指向树的指针

1856
01:25:00,170 --> 01:25:02,450
itself a pointer to the root of the tree.
本身是指向树根的指针

1857
01:25:02,450 --> 01:25:04,880
And that's all the information we need to search a tree
这就是我们搜索树所需的所有信息

1858
01:25:04,880 --> 01:25:06,600
and go left, go right, go left, go right.
然后向左，向右，向左，向右

1859
01:25:06,600 --> 01:25:07,100
How?
怎么做呢？

1860
01:25:07,100 --> 01:25:08,120
Well, let me do this.
好吧，让我来做这个

1861
01:25:08,120 --> 01:25:11,360
As always, we'll have a base case when it comes to recursion.
和往常一样，当涉及递归时，我们将有一个基本情况

1862
01:25:11,360 --> 01:25:13,280
Because if there's no tree there, then it
因为如果那里没有树，那么它

1863
01:25:13,280 --> 01:25:14,870
makes no sense to even ask me this question.
甚至问我这个问题都没有意义

1864
01:25:14,870 --> 01:25:16,162
I'm just going to return false.
我将直接返回 false

1865
01:25:16,162 --> 01:25:19,140
If you hand me null, there's nothing to do, return false.
如果你给我 null，就没什么可做的，返回 false

1866
01:25:19,140 --> 01:25:21,650
But suppose that you don't hand me null.
但是假设你没有给我 null

1867
01:25:21,650 --> 01:25:23,750
And suppose that the number I'm looking for
假设我要找的数字

1868
01:25:23,750 --> 01:25:28,385
is less than the number in the tree at the moment, the number at that root.
小于此时树中的数字，即根节点处的数字

1869
01:25:28,385 --> 01:25:29,510
Well, what do I want to do?
好吧，我想做什么？

1870
01:25:29,510 --> 01:25:31,010
I effectively want to go left.
我实际上想要向左走

1871
01:25:31,010 --> 01:25:32,540
I want to search the left subtree.
我想搜索左子树

1872
01:25:32,540 --> 01:25:33,690
How do I do that?
我要怎么做呢？

1873
01:25:33,690 --> 01:25:38,720
I'm going to return the recursive return value from the same search
我将返回来自同一 search 函数的递归返回值

1874
01:25:38,720 --> 01:25:42,800
function passing in a slightly smaller tree, a so-called subtree
函数，传入一棵稍微小一点的树，即所谓的子树

1875
01:25:42,800 --> 01:25:44,160
but the same number.
但数字相同

1876
01:25:44,160 --> 01:25:46,190
And this is where recursion is beautiful.
这就是递归的魅力所在。

1877
01:25:46,190 --> 01:25:48,290
Look at the relative simplicity of this.
看看它的相对简洁性。

1878
01:25:48,290 --> 01:25:51,267
If search exists, which it doesn't exist in its entirety yet.
如果搜索存在，它还没有完全存在。

1879
01:25:51,267 --> 01:25:52,100
But we'll get there.
但我们会实现的。

1880
01:25:52,100 --> 01:25:55,430
If you want to search half of the tree, just go there.
如果你想搜索树的一半，直接去那里。

1881
01:25:55,430 --> 01:25:56,810
So go to the root of the tree.
所以到树的根部。

1882
01:25:56,810 --> 01:25:59,840
Follow the left child pointer and pass that in because it's a tree.
沿着左子节点指针，传入它，因为它是一棵树。

1883
01:25:59,840 --> 01:26:02,540
It's just a smaller tree but pass in the same number.
它只是一棵更小的树，但传入相同的数字。

1884
01:26:02,540 --> 01:26:04,138
What if, though, it's a bigger number?
但是，如果它是一个更大的数字呢？

1885
01:26:04,138 --> 01:26:05,930
So what if the number you're looking for is
那么，如果你要找的数字是

1886
01:26:05,930 --> 01:26:09,140
bigger than the number at the root of the tree?
大于树根处的数字呢？

1887
01:26:09,140 --> 01:26:12,630
Well, then just search the right subtree instead.
那么，就搜索右子树。

1888
01:26:12,630 --> 01:26:15,980
And now, logically, what's the fourth and final case?
现在，从逻辑上讲，第四种也是最后一种情况是什么？

1889
01:26:19,140 --> 01:26:22,490
So I can express that as if the number you're looking for equals
所以我可以这样表达，如果你要找的数字等于

1890
01:26:22,490 --> 01:26:26,098
equals the number in the tree, that is, the root of the tree,
等于树中的数字，也就是树根，

1891
01:26:26,098 --> 01:26:27,890
then I'm going to go ahead and return true.
那么我将返回真。

1892
01:26:27,890 --> 01:26:29,660
And you might remember from our days with Scratch
你可能还记得我们用Scratch的那些日子

1893
01:26:29,660 --> 01:26:31,010
even this conditional is not necessary.
即使这个条件也不必要。

1894
01:26:31,010 --> 01:26:32,310
I just did it to be explicit.
我只是把它写出来，以便清楚明白。

1895
01:26:32,310 --> 01:26:35,460
We can tighten it up as just an else instead.
我们可以把它简化为一个else。

1896
01:26:35,460 --> 01:26:36,600
And that's it.
就是这样。

1897
01:26:36,600 --> 01:26:38,810
And this is where, again, recursion finally
而在这里，递归最终

1898
01:26:38,810 --> 01:26:42,420
is maybe a little more accessible, a little more obvious in its cleanliness.
可能更容易理解，在简洁性上更明显。

1899
01:26:42,420 --> 01:26:44,350
There's relatively little logic here.
这里的逻辑相对很少。

1900
01:26:44,350 --> 01:26:48,420
But what's important is that these recursive calls here and here are
但重要的是，这里和这里的递归调用

1901
01:26:48,420 --> 01:26:50,890
dividing and conquering the problem implicitly.
隐式地将问题分而治之。

1902
01:26:50,890 --> 01:26:51,390
Why?
为什么？

1903
01:26:51,390 --> 01:26:54,090
Because it's solving the same problem search for a number.
因为它在解决同一个问题——搜索一个数字。

1904
01:26:54,090 --> 01:26:57,960
But it's doing it on just half of the tree or the other half of the tree.
但它只在树的一半或另一半上进行。

1905
01:26:57,960 --> 01:26:59,920
And because we have this base case here, even
而且因为我们这里有这个基本情况，即使

1906
01:26:59,920 --> 01:27:01,920
if you get all the way to the bottom of the tree
你到达了树的底部

1907
01:27:01,920 --> 01:27:05,045
and you try to go down the left child or you try to go down the right child
并且你试图沿着左子节点或右子节点向下移动

1908
01:27:05,045 --> 01:27:07,290
but those pointers are null, then you know
但是这些指针为空，那么你就知道

1909
01:27:07,290 --> 01:27:10,080
you didn't find it because you would have returned true sooner
你没有找到它，因为如果你找到了，你就会更早地返回真

1910
01:27:10,080 --> 01:27:12,480
if anything had been in fact equal.
如果任何东西实际上是相等的。

1911
01:27:12,480 --> 01:27:16,620
So that then is recursive code for searching a binary search tree, which
所以这就是搜索二叉搜索树的递归代码，它

1912
01:27:16,620 --> 01:27:19,140
is, again, just to connect the dots of what we introduced
再次，只是为了将我们之前介绍的内容联系起来

1913
01:27:19,140 --> 01:27:22,650
last time of actually doing things now recursively
上一次实际上是递归地做事

1914
01:27:22,650 --> 01:27:25,230
and revisiting some of our own week 0 problems.
并重新审视我们自己的第 0 周的一些问题。

1915
01:27:25,230 --> 01:27:28,380
But I'm kind of lying to you here.
但我在这里有点在骗你。

1916
01:27:28,380 --> 01:27:29,880
Yes, this is a binary search tree.
是的，这是一棵二叉搜索树。

1917
01:27:29,880 --> 01:27:31,712
But it's not always as pretty as this.
但它并不总是像这样漂亮。

1918
01:27:31,712 --> 01:27:33,420
It's certainly not always seven elements.
它肯定并不总是七个元素。

1919
01:27:33,420 --> 01:27:37,380
But it doesn't actually have to be as well-balanced as this one here is.
但它实际上不必像这里的那样平衡。

1920
01:27:37,380 --> 01:27:40,860
In fact, suppose that we insert the following numbers
事实上，假设我们插入以下数字

1921
01:27:40,860 --> 01:27:42,802
into an empty list starting with 2.
到一个空列表中，从 2 开始。

1922
01:27:42,802 --> 01:27:44,010
I can plop the 2 right there.
我可以把 2 放在那里。

1923
01:27:44,010 --> 01:27:45,990
That's the current root of this tree.
那是这棵树的当前根节点。

1924
01:27:45,990 --> 01:27:49,050
Suppose, though, that I insert next the number--
但是，假设我接下来插入数字——

1925
01:27:49,050 --> 01:27:49,890
how about 1?
1 怎么样？

1926
01:27:49,890 --> 01:27:52,510
Well, it stands to reason that it should go now to the left.
好吧，它应该去左边，这很合理。

1927
01:27:52,510 --> 01:27:55,230
And so now this is the tree of size 2.
所以现在这棵树的大小是 2。

1928
01:27:55,230 --> 01:27:57,810
Now, I insert the number, say, 3.
现在，我插入一个数字，比如 3。

1929
01:27:57,810 --> 01:27:59,413
It, of course, can go there.
当然，它可以放在那里。

1930
01:27:59,413 --> 01:28:00,580
So that makes perfect sense.
这很有道理。

1931
01:28:00,580 --> 01:28:01,770
And I just got lucky.
我只是运气好。

1932
01:28:01,770 --> 01:28:04,830
Because I inserted these numbers as 2 then one then 3,
因为我插入的数字是 2 然后 1 然后 3，

1933
01:28:04,830 --> 01:28:10,650
I very cleanly got a balanced tree that waited properly left and right.
我非常干净地得到了一棵平衡树，它左右都处于适当的位置。

1934
01:28:10,650 --> 01:28:14,100
But what if you have a more perverse set of inputs so to speak.
但如果你有更多“病态”的输入呢，可以这么说。

1935
01:28:14,100 --> 01:28:15,030
You're not lucky.
你没有那么幸运。

1936
01:28:15,030 --> 01:28:17,670
And the worst possible situation happens in terms
在人类输入数据顺序方面，最糟糕的情况发生了

1937
01:28:17,670 --> 01:28:19,950
of the order in which the human is inputting data
人类输入数据顺序方面，最糟糕的情况发生了

1938
01:28:19,950 --> 01:28:21,090
into this data structure.
到这个数据结构中。

1939
01:28:21,090 --> 01:28:22,680
What if the human inserts 1 first?
如果人类首先插入 1 呢？

1940
01:28:22,680 --> 01:28:24,690
OK, well, it goes as the root of the tree.
好的，它就作为树的根节点。

1941
01:28:24,690 --> 01:28:27,150
But here's where things start to devolve.
但事情从这里开始恶化。

1942
01:28:27,150 --> 01:28:29,160
What if the human then inserts 2?
如果人类接着插入 2 呢？

1943
01:28:29,160 --> 01:28:30,240
OK, it goes there.
好的，它就在那里。

1944
01:28:30,240 --> 01:28:31,800
What if the human then inserts 3?
如果人类接着插入 3 呢？

1945
01:28:31,800 --> 01:28:34,410
Well, according to our definition, it goes there.
好吧，根据我们的定义，它就在那里。

1946
01:28:34,410 --> 01:28:37,620
It looks like part of a tree because of how I've drawn it.
因为它是我画的，所以看起来像树的一部分。

1947
01:28:37,620 --> 01:28:42,900
But what is it really if you tilt your head, right?
但如果你歪着头看，它究竟是什么呢？

1948
01:28:42,900 --> 01:28:45,000
It looks really just like a linked list.
它看起来真的就像一个链表。

1949
01:28:45,000 --> 01:28:47,160
And there really is no second dimension.
实际上它没有第二个维度。

1950
01:28:47,160 --> 01:28:48,240
I've drawn it this way.
我这样画了它。

1951
01:28:48,240 --> 01:28:51,280
But this for all intents and purposes is a linked list of size 3.
但就所有意图和目的而言，这是一个大小为 3 的链表。

1952
01:28:51,280 --> 01:28:51,780
Why?
为什么？

1953
01:28:51,780 --> 01:28:53,040
Because there's no halving.
因为没有二分。

1954
01:28:53,040 --> 01:28:56,130
There's no actual choosing left or right.
实际上没有选择左边或右边。

1955
01:28:56,130 --> 01:28:57,390
Now, this is fixable.
现在，这是可以修复的。

1956
01:28:57,390 --> 01:28:58,420
How could you fix this?
你如何修复它？

1957
01:28:58,420 --> 01:29:00,000
It's still the same numbers 1, 2, 3.
它仍然是相同的数字 1、2、3。

1958
01:29:00,000 --> 01:29:03,510
And it does adhere to the binary search tree definition.
它确实符合二叉搜索树的定义。

1959
01:29:03,510 --> 01:29:05,340
Every number to the right is greater.
右边的每个数字都更大。

1960
01:29:05,340 --> 01:29:06,960
Every number to the right is greater.
右边的每个数字都更大。

1961
01:29:06,960 --> 01:29:09,210
Every number to the left is-- well, it's inapplicable.
左边的每个数字...好吧，它不适用。

1962
01:29:09,210 --> 01:29:11,280
But it certainly doesn't violate that definition.
但这当然没有违反那个定义。

1963
01:29:11,280 --> 01:29:14,880
Could you fix this tree somehow and make it
你能以某种方式修复这棵树，并使其

1964
01:29:14,880 --> 01:29:17,940
balanced so it's not devolving into big O of n
平衡，这样它就不会退化为 O(n)

1965
01:29:17,940 --> 01:29:20,820
but is still technically log of n?
但仍然在技术上是 log(n)？

1966
01:29:20,820 --> 01:29:22,305
What should be the root?
根节点应该是什么？

1967
01:29:22,305 --> 01:29:25,510
AUDIENCE: You just reverse the pointer from 1 to 2.
观众：你只需将指向 1 的指针反转到指向 2。

1968
01:29:25,510 --> 01:29:28,890
DAVID J. MALAN: So I could reverse the pointer from 1 to 2.
David J. Malan：所以我可以将指向 1 的指针反转到指向 2。

1969
01:29:28,890 --> 01:29:31,140
And so sort of pictorially if I take this
所以如果我从图像上来看，把这个

1970
01:29:31,140 --> 01:29:35,400
and I just swing everything over and make 2 the new route,
把所有东西都移过去，让 2 成为新的根节点，

1971
01:29:35,400 --> 01:29:37,800
then, indeed, this could be the new root up here.
那么，确实，这个可以作为这里的新根节点。

1972
01:29:37,800 --> 01:29:42,270
1 could be hanging off of it over here and 3 can be hanging off of the 2
1 可以从这里挂在它上面，3 可以从 2 上挂下来

1973
01:29:42,270 --> 01:29:42,900
as is.
就这样。

1974
01:29:42,900 --> 01:29:47,340
So long story short, when it comes to binary search trees, by themselves
所以长话短说，当谈到二叉搜索树本身时，

1975
01:29:47,340 --> 01:29:49,870
they don't necessarily guarantee any balance.
它们不一定能保证任何平衡。

1976
01:29:49,870 --> 01:29:53,730
So even though theoretically, yes, it's big O of log n, which is fantastic,
所以即使从理论上讲，是的，它是 log n 的 O 大，这太棒了，

1977
01:29:53,730 --> 01:29:55,740
not if you get a perverse set of inputs that
但如果你得到了一组反常的输入，

1978
01:29:55,740 --> 01:29:58,770
just happen to be, for instance, the worst possible scenario-- now,
恰好是，例如，最糟糕的场景——现在，

1979
01:29:58,770 --> 01:29:59,460
it is fixable.
是可以解决的。

1980
01:29:59,460 --> 01:30:01,877
And, in fact, in higher level courses in computer science,
事实上，在计算机科学的高级课程中，

1981
01:30:01,877 --> 01:30:03,900
specifically on algorithms and data structures,
特别是关于算法和数据结构的课程中，

1982
01:30:03,900 --> 01:30:07,020
you'll be introduced, if you go down that road, of how
如果你走上这条路，你会被介绍到如何

1983
01:30:07,020 --> 01:30:12,180
you can tweak the code for insertion and deletion in a binary search tree
调整二叉搜索树中插入和删除的代码

1984
01:30:12,180 --> 01:30:14,500
to make these fixes along the way.
以便沿途进行这些修复。

1985
01:30:14,500 --> 01:30:17,040
And it's going to cost you a few more steps to fix things
修复这些问题会让你多花几步。

1986
01:30:17,040 --> 01:30:18,180
when they get out of whack.
当它们变得不正常时。

1987
01:30:18,180 --> 01:30:21,090
But if you do it every insertion or every deletion,
但是如果你在每次插入或删除时都这样做，

1988
01:30:21,090 --> 01:30:23,805
at least you can maintain a balanced tree.
至少你可以保持树的平衡。

1989
01:30:23,805 --> 01:30:26,180
And you'll learn about different types of balanced trees.
你将学习不同类型的平衡树。

1990
01:30:26,180 --> 01:30:28,480
But for our purposes now, we don't necessarily
但对于我们现在的目的，我们不一定

1991
01:30:28,480 --> 01:30:31,720
get that property even if we do want log n unless you
能得到那个属性，即使我们确实想要 log n，除非你

1992
01:30:31,720 --> 01:30:34,130
keep it balanced along the way.
一路保持它的平衡。

1993
01:30:34,130 --> 01:30:38,255
Now, what about other combinations of arrays and linked lists?
现在，数组和链表的其他组合呢？

1994
01:30:38,255 --> 01:30:41,380
We can really start to mash these things up and see what comes out of them.
我们可以真正开始将这些东西混合在一起，看看会产生什么。

1995
01:30:41,380 --> 01:30:45,130
Dictionaries are another abstract data type
字典是另一种抽象数据类型

1996
01:30:45,130 --> 01:30:49,750
similar in spirit to stacks and queues in that you can implement them
与堆栈和队列类似，因为你可以用不同的方式实现它们

1997
01:30:49,750 --> 01:30:50,590
in different ways.
以不同的方式。

1998
01:30:50,590 --> 01:30:54,520
A dictionary is a data structure that stores keys and values.
字典是一种存储键和值的数据结构。

1999
01:30:54,520 --> 01:30:56,870
And those are technical terms, keys and values.
而这些是专业术语，键和值。

2000
01:30:56,870 --> 01:31:00,730
The analog in the human world would be literally a dictionary
在人类世界中，它的类似物就是一本真正的字典

2001
01:31:00,730 --> 01:31:03,700
that you'd have in a classroom, a dictionary with words
你将在教室里拥有的字典，一本包含单词的字典

2002
01:31:03,700 --> 01:31:07,850
and definitions, more generally known as keys and values.
和定义，更广为人知的键和值。

2003
01:31:07,850 --> 01:31:09,550
So that's all a dictionary is.
这就是字典的全部内容。

2004
01:31:09,550 --> 01:31:12,038
It associates keys with values.
它将键与值关联起来。

2005
01:31:12,038 --> 01:31:14,080
So, for instance, you could think of it almost as
所以，例如，你可以把它看成几乎像

2006
01:31:14,080 --> 01:31:16,270
like two columns in a spreadsheet, where on the left
电子表格中的两列，左边

2007
01:31:16,270 --> 01:31:18,370
you put the key, on the right you put the value.
你放键，右边你放值。

2008
01:31:18,370 --> 01:31:21,620
Or, specifically, you put the word in a dictionary and the definition
或者，具体来说，你在字典中放单词，然后放定义

2009
01:31:21,620 --> 01:31:22,120
thereafter.
在那之后。

2010
01:31:22,120 --> 01:31:25,750
And that's roughly how the printed pages in a dictionary are laid out.
字典中打印的页面大致就是这样排列的。

2011
01:31:25,750 --> 01:31:29,950
So dictionaries associate words with definitions or more generally
所以字典将单词与定义相关联，或者更一般地

2012
01:31:29,950 --> 01:31:31,360
keys with values.
将键与值相关联。

2013
01:31:31,360 --> 01:31:33,393
But it's an abstract data type in that we could
但它是一种抽象数据类型，因为我们可以

2014
01:31:33,393 --> 01:31:34,810
implement this in a bunch of ways.
用很多种方式实现它。

2015
01:31:34,810 --> 01:31:37,840
We could use maybe two arrays, one array for the keys,
我们可以使用两个数组，一个数组用于键，

2016
01:31:37,840 --> 01:31:39,310
one array for the definitions.
一个数组用于定义。

2017
01:31:39,310 --> 01:31:41,500
And you just hope that they line up.
你只需要希望它们排成一行。

2018
01:31:41,500 --> 01:31:44,620
Bracket i in this one maps to bracket i in this one.
这个数组中的索引 i 对应于这个数组中的索引 i。

2019
01:31:44,620 --> 01:31:48,070
But an array is not going to give us the dynamism that we want.
但数组不会给我们我们想要的那种动态性。

2020
01:31:48,070 --> 01:31:52,000
You might run out of space when Merriam-Webster or whoever
当韦氏词典或其他机构

2021
01:31:52,000 --> 01:31:53,950
adds new words to the English language.
将新单词添加到英语中时，你可能会用光空间。

2022
01:31:53,950 --> 01:31:55,630
You might not want to be using an array.
你可能不想使用数组。

2023
01:31:55,630 --> 01:31:57,130
You might want to use a linked list.
你可能想使用链表。

2024
01:31:57,130 --> 01:31:59,620
But, again, linked lists then devolve into big O of n.
但是，同样地，链表会退化为O(n)的时间复杂度。

2025
01:31:59,620 --> 01:32:02,710
And that's not good for dictionaries and spell checking.
这对字典和拼写检查来说是不利的。

2026
01:32:02,710 --> 01:32:05,710
If you have to check every possible word to find something,
如果你必须检查每个可能的单词来查找某个东西，

2027
01:32:05,710 --> 01:32:08,420
getting something that's a little faster than that is compelling.
找到比这更快的方法就很有吸引力。

2028
01:32:08,420 --> 01:32:12,520
So let's consider how maybe Apple, maybe Google, maybe others are actually
所以让我们考虑一下苹果，谷歌，或者其他公司是如何实现通讯录的。

2029
01:32:12,520 --> 01:32:14,380
implementing contacts.
通讯录的。

2030
01:32:14,380 --> 01:32:18,370
Because even though I implied in week 0 and maybe outright said,
因为虽然我在第零周暗示过，也可能直接说，

2031
01:32:18,370 --> 01:32:23,530
it's an array-- it's a big list of all of your names of contacts maybe of some
它是一个数组——它是一个包含你所有联系人名字的很大的列表，可能是固定大小的

2032
01:32:23,530 --> 01:32:24,460
fixed size--
固定大小的——

2033
01:32:24,460 --> 01:32:29,170
they probably better be using some variant of a linked list, otherwise,
他们可能最好使用链表的某种变体，否则，

2034
01:32:29,170 --> 01:32:31,420
you could never add more friends potentially.
你可能永远无法添加更多朋友。

2035
01:32:31,420 --> 01:32:32,020
You'd max out.
你会达到上限。

2036
01:32:32,020 --> 01:32:34,478
And they'd say you have to unfriend someone just to fit it.
他们会说你必须取消关注某个人才能容纳下来。

2037
01:32:34,478 --> 01:32:37,120
As an aside, this is sort of true in the social media world.
顺便说一句，这在社交媒体的世界里是有点真实的。

2038
01:32:37,120 --> 01:32:40,162
Once you have 5,000 friends on Facebook, you can't have 5,001.
一旦你在 Facebook 上有 5000 个朋友，你就不能再有 5001 个朋友了。

2039
01:32:40,162 --> 01:32:43,120
Once you have some number on LinkedIn, you can't have more connections.
一旦你在 LinkedIn 上有一定数量的连接，你就不能再有更多连接了。

2040
01:32:43,120 --> 01:32:45,162
That's not necessarily that they're using arrays.
这并不一定意味着他们使用的是数组。

2041
01:32:45,162 --> 01:32:47,320
But it is the same implication that they've
但这意味着他们已经

2042
01:32:47,320 --> 01:32:50,000
chosen some finite size for memory.
为内存选择了某个有限的大小。

2043
01:32:50,000 --> 01:32:53,650
So how might we consider implementing a dictionary specifically
那么我们该如何考虑专门为你的地址簿或联系人实现字典，

2044
01:32:53,650 --> 01:32:55,810
for your address book or your contacts so you
这样你就可以

2045
01:32:55,810 --> 01:32:58,300
can store the names of everyone ideally alphabetically
存储所有人的姓名，理想情况下按字母顺序排序，

2046
01:32:58,300 --> 01:33:01,300
but also their phone numbers and maybe anything else?
但也要存储他们的电话号码，以及可能的其他信息？

2047
01:33:01,300 --> 01:33:04,000
Well, ultimately, we want to be able to get at someone's name
好吧，最终，我们希望能够获取某人的姓名

2048
01:33:04,000 --> 01:33:05,650
and lead to their number.
并找到他们的号码。

2049
01:33:05,650 --> 01:33:07,660
So the keys and values for our discussion
因此，在我们讨论中，键和值

2050
01:33:07,660 --> 01:33:11,140
here will be names are the keys and phone numbers or the values.
将是姓名作为键，电话号码作为值。

2051
01:33:11,140 --> 01:33:14,890
But the values themselves could also include email address and a mailing
但值本身还可以包含电子邮件地址和邮寄地址等等。

2052
01:33:14,890 --> 01:33:15,910
address and all of that.
地址等等。

2053
01:33:15,910 --> 01:33:18,555
But we'll keep it simple, names and phone numbers.
但我们会保持简单，姓名和电话号码。

2054
01:33:18,555 --> 01:33:20,680
So here's how you might think about this or draw it
所以你可以这样思考或画出来，

2055
01:33:20,680 --> 01:33:24,010
on a chalkboard, two columns or in a spreadsheet, left and right.
在黑板上画两列，或者在电子表格中画两列，左边和右边。

2056
01:33:24,010 --> 01:33:26,470
But how could we actually implement this in memory?
但我们如何在内存中实现它呢？

2057
01:33:26,470 --> 01:33:29,878
Because, ideally, we don't want it to devolve into something linear.
因为理想情况下，我们不希望它退化为线性结构。

2058
01:33:29,878 --> 01:33:32,170
We don't want to have to look through all of my friends
我们不想必须查看我所有朋友的

2059
01:33:32,170 --> 01:33:34,628
and family and colleagues to find someone whose name starts
家人和同事，才能找到一个名字以

2060
01:33:34,628 --> 01:33:37,090
with Z, for instance, or anything else.
Z 开头的人，或者其他任何名字的人。

2061
01:33:37,090 --> 01:33:41,050
It would be nice to have something logarithmic with binary search.
如果能有对数时间复杂度的东西，使用二分搜索就好了。

2062
01:33:41,050 --> 01:33:47,440
But with binary search again, we have to maybe use a tree instead.
但再次使用二分搜索，我们可能需要使用树。

2063
01:33:47,440 --> 01:33:49,930
But now we have to use two pointers instead of one.
但现在我们必须使用两个指针而不是一个。

2064
01:33:49,930 --> 01:33:51,310
there's a lot of trade offs here.
这里有很多权衡。

2065
01:33:51,310 --> 01:33:54,130
But let's see how else we could solve this same problem.
但让我们看看如何用其他方法解决同一个问题。

2066
01:33:54,130 --> 01:33:57,530
Because wouldn't it be nice-- and we've not really talked about this before--
因为不是很好吗——我们以前没有真正谈论过这个——

2067
01:33:57,530 --> 01:34:01,300
if we instead aspire to this Holy Grail of algorithms?
如果我们渴望得到这种算法的圣杯呢？

2068
01:34:01,300 --> 01:34:05,140
The best algorithm out there is surely one that's big O of 1,
最好的算法一定是 O(1) 的算法，

2069
01:34:05,140 --> 01:34:07,900
like constant time, because what that means
比如常数时间，因为这意味着

2070
01:34:07,900 --> 01:34:10,870
is it doesn't matter if you have 1 friend, 10 friends, 100, 1,000,
无论你有 1 个朋友、10 个朋友、100 个朋友、1000 个朋友，

2071
01:34:10,870 --> 01:34:12,170
a million, a billion friends--
一百万个朋友、十亿个朋友——

2072
01:34:12,170 --> 01:34:15,040
it doesn't matter how big n is, your searches will always
无论 n 的大小，你的搜索总是

2073
01:34:15,040 --> 01:34:17,710
take you the same amount of time.
花费相同的时间。

2074
01:34:17,710 --> 01:34:19,390
It is independent of n.
它与 n 无关。

2075
01:34:19,390 --> 01:34:24,270
And that's why it's sort of the ultimate goal for performance.
这就是为什么它被认为是性能的终极目标。

2076
01:34:24,270 --> 01:34:27,230
So can we get to this aspiration?
所以我们能实现这个目标吗？

2077
01:34:27,230 --> 01:34:28,880
Well, a couple of building blocks.
嗯，几个组成部分。

2078
01:34:28,880 --> 01:34:31,550
There's this notion in computing known as hashing.
在计算机中有一个叫做哈希的概念。

2079
01:34:31,550 --> 01:34:33,920
And hashing is a technique, literally a function
哈希是一种技术，实际上是一个函数

2080
01:34:33,920 --> 01:34:39,290
in math or in code that actually takes any number of inputs and maps
在数学或代码中，它可以接受任意数量的输入并将它们映射

2081
01:34:39,290 --> 01:34:41,430
them to a finite number of outputs.
到有限数量的输出。

2082
01:34:41,430 --> 01:34:44,480
So if you think back to high school math, domains, and ranges,
所以如果你回忆一下高中数学中的定义域和值域，

2083
01:34:44,480 --> 01:34:47,480
you can take an infinite domain with any values in the world.
你可以取一个无限的定义域，它可以包含世界上任何值。

2084
01:34:47,480 --> 01:34:51,840
But it reduces them, a hash function, to a finite range of specific values.
但是哈希函数将它们简化为一个有限的值域。

2085
01:34:51,840 --> 01:34:55,190
So, for instance, it's no accident that we have these four buckets on the stage
例如，我们现在舞台上的这四个桶并非偶然，

2086
01:34:55,190 --> 01:34:58,880
now, each of which has a suit from a deck of cards.
它们分别代表一副扑克牌中的一个花色。

2087
01:34:58,880 --> 01:35:01,430
We got for visibility's sake the biggest cards we can.
为了便于观察，我们选用了最大的扑克牌。

2088
01:35:01,430 --> 01:35:03,380
These are the super, jumbo playing cards.
这些是超大型的扑克牌。

2089
01:35:03,380 --> 01:35:06,680
And in this box are a bunch of randomly ordered playing cards.
这个箱子里放着一堆随机排列的扑克牌。

2090
01:35:06,680 --> 01:35:09,140
And, typically, if you were to ever play some game
通常，如果你要玩一些游戏，

2091
01:35:09,140 --> 01:35:11,360
or you wanted to these for some reason, how would
或者出于某种原因，你想使用它们，你会怎么做？

2092
01:35:11,360 --> 01:35:14,990
you go about sorting them by suit and also by number?
你会如何按花色和数字对它们进行排序？

2093
01:35:14,990 --> 01:35:17,930
Odds are if you're like me, you'd probably take some shortcuts
如果你像我一样，你可能会采取一些捷径，

2094
01:35:17,930 --> 01:35:21,290
and maybe pull out all of the hearts, pull out all of the spades,
比如把所有的红桃都拿出来，把所有的黑桃都拿出来，

2095
01:35:21,290 --> 01:35:25,200
pull out all of the clubs, or you bucketize it into categories.
把所有的梅花都拿出来，或者你把它们分类到不同的桶里。

2096
01:35:25,200 --> 01:35:26,910
And that term is actually technical.
这个词实际上是专业的术语。

2097
01:35:26,910 --> 01:35:29,310
Here are four buckets to make this clear.
这里有四个桶来使这一点更清楚。

2098
01:35:29,310 --> 01:35:32,367
And, for instance, if the first card I find is the five of hearts,
例如，如果我找到的第一张牌是红桃 5，

2099
01:35:32,367 --> 01:35:32,950
you know what?
你知道吗？

2100
01:35:32,950 --> 01:35:36,033
Just to make my life easier, I'm going to put that into the hearts bucket.
为了方便起见，我要把它放到红桃的桶里。

2101
01:35:36,033 --> 01:35:37,260
Or here we have 4.
或者这里有 4。

2102
01:35:37,260 --> 01:35:39,120
Here we have 5.
这里有 5。

2103
01:35:39,120 --> 01:35:40,980
Here we have 6.
这里有 6。

2104
01:35:40,980 --> 01:35:43,290
Here we have queen.
这里有 Q。

2105
01:35:43,290 --> 01:35:46,740
And notice that I'm putting these cards into the appropriate buckets.
请注意，我正在把这些牌放到合适的桶里。

2106
01:35:46,740 --> 01:35:47,310
Why?
为什么呢？

2107
01:35:47,310 --> 01:35:50,760
Because, ultimately, then I'm going to have four problems but of smaller
因为最终，我将有四个问题，但它们都更小，

2108
01:35:50,760 --> 01:35:53,700
size, a 13 size problem, 13, 13, 13.
规模，13 个问题，13 个，13 个，13 个。

2109
01:35:53,700 --> 01:35:56,460
And, frankly, it's just going to be easier cognitively, daresay
坦率地说，从认知上讲，这将更容易，甚至可以这么说，

2110
01:35:56,460 --> 01:36:00,690
algorithmically, to then sort each of the 13 cards in these buckets
从算法上讲，然后对这些桶里的 13 张牌进行排序

2111
01:36:00,690 --> 01:36:04,063
rather than deal with four suits somehow combined all together.
比将四种花色混合在一起处理要容易得多。

2112
01:36:04,063 --> 01:36:07,230
So if you've ever in life made piles-- if you've ever literally used buckets
所以如果你在生活中曾经做过一堆堆的东西——如果你曾经用过像这样的桶

2113
01:36:07,230 --> 01:36:09,390
like this, you are hashing.
那么你就是在使用哈希。

2114
01:36:09,390 --> 01:36:12,240
I'm taking some number of inputs, 52 in this case.
我正在接收一些输入，本例中是 52 个。

2115
01:36:12,240 --> 01:36:16,650
And I'm mapping it to a finite number of outputs, 4 in this case.
我将它们映射到有限数量的输出，本例中是 4 个。

2116
01:36:16,650 --> 01:36:20,850
So hashing, again, just takes in inputs and hashes them
所以哈希，再次强调，它接收输入并对其进行哈希处理

2117
01:36:20,850 --> 01:36:22,900
to output values in this way.
以这种方式输出值。

2118
01:36:22,900 --> 01:36:25,020
So beyond that terminology, let's consider
除了术语之外，让我们考虑一下

2119
01:36:25,020 --> 01:36:27,600
what we can now do with hash functions that's
现在我们可以用哈希函数做些什么，它

2120
01:36:27,600 --> 01:36:30,600
a little more germane to storing things like our friends and family
与存储像朋友、家人这样东西更相关

2121
01:36:30,600 --> 01:36:33,450
and colleagues in dictionaries.
以及同事在字典中。

2122
01:36:33,450 --> 01:36:35,760
A hash function is just one that does that.
哈希函数就是这样做的。

2123
01:36:35,760 --> 01:36:39,210
I as the human was just implementing or behaving like a hash function.
作为人类，我只是在实现或模拟一个哈希函数。

2124
01:36:39,210 --> 01:36:41,160
But technically a hash function is actually
但从技术上讲，一个哈希函数实际上是

2125
01:36:41,160 --> 01:36:44,160
a math function or a function in C or scratch
一个数学函数，或者一个 C 语言函数或 Scratch 函数

2126
01:36:44,160 --> 01:36:48,660
or soon Python or other languages that takes as input some value,
或者很快的 Python 或其他语言，它接收一个值作为输入，

2127
01:36:48,660 --> 01:36:51,990
be it a physical card or a name or a number or something else,
无论是实体卡、姓名、数字还是其他东西，

2128
01:36:51,990 --> 01:36:53,740
and outputs some value.
并输出一个值。

2129
01:36:53,740 --> 01:36:58,020
And we can use hashing as an operation to implement
我们可以使用哈希作为一种操作来实现

2130
01:36:58,020 --> 01:37:00,120
what we'll call hash tables.
我们所说的哈希表。

2131
01:37:00,120 --> 01:37:01,917
And that's what that dictionary was.
这就是那个字典。

2132
01:37:01,917 --> 01:37:04,500
If you think about how I drew it on the screen as two columns,
如果你想想我在屏幕上如何将其绘制成两列，

2133
01:37:04,500 --> 01:37:08,440
it's like a table of information, keys on the left, values on the right.
它就像一张信息表，左边是键，右边是值。

2134
01:37:08,440 --> 01:37:10,020
So what is a hash table?
那么什么是哈希表呢？

2135
01:37:10,020 --> 01:37:12,300
The simplest way to think about it is that this
最简单的理解方式是，它

2136
01:37:12,300 --> 01:37:17,190
is an amalgam, a combination of arrays and linked lists right.
是一个融合体，数组和链表的组合。

2137
01:37:17,190 --> 01:37:20,400
We borrowed some ideas of linked lists a moment ago
我们借用了链表的一些概念

2138
01:37:20,400 --> 01:37:22,540
to give us trees in two dimensions.
来构建二维树。

2139
01:37:22,540 --> 01:37:25,620
What if we stick with this idea of having two-dimensional worlds
如果我们坚持二维世界的概念

2140
01:37:25,620 --> 01:37:28,140
but now use an array initially?
但现在最初使用一个数组呢？

2141
01:37:28,140 --> 01:37:31,270
So we get the speed benefits of arrays because everything's contiguous.
这样我们就获得了数组的速度优势，因为所有元素都是连续的。

2142
01:37:31,270 --> 01:37:33,720
We can do simple arithmetic and jump to the middle or the middle or the middle
我们可以进行简单的算术运算，并跳转到中间，或中间，或中间

2143
01:37:33,720 --> 01:37:35,735
or the first or the last very easily.
或者第一个或最后一个，非常容易。

2144
01:37:35,735 --> 01:37:36,870
And then you know what?
然后你猜怎么着？

2145
01:37:36,870 --> 01:37:39,480
Let's use the horizontal part of the screen
让我们使用屏幕的水平部分

2146
01:37:39,480 --> 01:37:41,560
to give us linked lists as needed.
来提供我们所需的链表。

2147
01:37:41,560 --> 01:37:45,150
So, for instance, if the goal at hand is to implement the contacts in my cell
例如，如果当前的目标是实现我的手机、Mac 或 PC 中的联系人，

2148
01:37:45,150 --> 01:37:50,520
phone or my Mac or PC, let me propose that we start at least in English
我建议我们至少用英语开始

2149
01:37:50,520 --> 01:37:52,590
with an array of size 26.
一个大小为 26 的数组。

2150
01:37:52,590 --> 01:37:53,790
Of course, it's 0 index.
当然，它是 0 索引。

2151
01:37:53,790 --> 01:37:56,350
So it's really location 0 through 25.
所以实际上它是位置 0 到 25。

2152
01:37:56,350 --> 01:37:59,520
And for the sake of discussion, let me propose that location 0 represents
为了讨论，我建议位置 0 代表

2153
01:37:59,520 --> 01:38:01,860
A. Location 25 represents z.
A，位置 25 代表 z。

2154
01:38:01,860 --> 01:38:03,730
And then everything else in between.
然后是介于两者之间的所有其他字母。

2155
01:38:03,730 --> 01:38:04,230
Why?
为什么？

2156
01:38:04,230 --> 01:38:07,290
We know from C that we can convert thanks to ASCII and Unicode
我们从 C 语言中得知，我们可以借助 ASCII 和 Unicode 进行转换

2157
01:38:07,290 --> 01:38:09,730
from letters to numbers and back and forth.
将字母转换为数字，反之亦然。

2158
01:38:09,730 --> 01:38:13,560
So in constant time, we can find location A. In constant time
所以我们可以用恒定时间找到位置 A，用恒定时间

2159
01:38:13,560 --> 01:38:15,630
we can find location Z. Why?
我们可以找到位置 Z。为什么？

2160
01:38:15,630 --> 01:38:19,200
Because we're using an array just like in week 2.
因为我们使用的是数组，就像第 2 周一样。

2161
01:38:19,200 --> 01:38:21,360
All right, well, suppose that I want to think
好吧，假设我想考虑一下

2162
01:38:21,360 --> 01:38:24,457
about these more as letters of the alphabet, the English alphabet
将这些更多地看作字母表，即英语字母表

2163
01:38:24,457 --> 01:38:25,290
rather than numbers.
而不是数字。

2164
01:38:25,290 --> 01:38:27,630
So it's equivalent to label them A through Z.
所以，相当于将它们标记为从 A 到 Z。

2165
01:38:27,630 --> 01:38:31,260
And suppose now I want to start adding friends and family and contacts
假设现在我想开始添加朋友、家人和联系人

2166
01:38:31,260 --> 01:38:32,550
to my address book.
到我的通讯录中。

2167
01:38:32,550 --> 01:38:33,700
How might this look?
这可能是什么样子？

2168
01:38:33,700 --> 01:38:35,730
Well, if the first one I want to add is Mario--
嗯，如果我想添加的第一个是马里奥——

2169
01:38:35,730 --> 01:38:39,570
Mario's name starts with an M. And so that's A, B, C, D, E, F--
马里奥的名字以 M 开头。所以，这是 A、B、C、D、E、F——

2170
01:38:39,570 --> 01:38:41,200
OK, M goes there.
好的，M 放在那里。

2171
01:38:41,200 --> 01:38:46,050
So I'm going to put Mario at that location in the array.
所以我要将马里奥放在数组中的那个位置。

2172
01:38:46,050 --> 01:38:49,140
After that, I add a second person, for instance, how about Luigi?
在那之后，我添加第二个人，例如，路易吉怎么样？

2173
01:38:49,140 --> 01:38:51,210
Well, L comes just before M. So it stands
嗯，L 在 M 之前。所以，它代表

2174
01:38:51,210 --> 01:38:53,940
to reason that it goes there in the array.
可以理解，它应该放在数组中的那个位置。

2175
01:38:53,940 --> 01:38:56,820
Meanwhile, if I go and add another character like peach,
同时，如果我去添加另一个角色，例如碧奇，

2176
01:38:56,820 --> 01:39:00,360
she's going to go there a few spots away because her name starts
她将会放在离那个位置几个位置的地方，因为她的名字以

2177
01:39:00,360 --> 01:39:03,960
with P. Meanwhile, here's a whole bunch of other Nintendo characters
P 开头。同时，这里有一堆其他任天堂角色

2178
01:39:03,960 --> 01:39:07,680
that happen to have unique letters of their first names.
碰巧他们的名字首字母都是唯一的。

2179
01:39:07,680 --> 01:39:10,950
And there's room for everyone, room for everyone on the board A
而且每个人都有空间，每个人在 A 上都有空间

2180
01:39:10,950 --> 01:39:12,750
through Z with some blanks in the middle.
到 Z，中间有一些空白。

2181
01:39:12,750 --> 01:39:14,730
But you can perhaps see where this is going.
但也许你可以看到事情的发展方向。

2182
01:39:14,730 --> 01:39:17,622
When and where might a problem arise with this array-based approach?
这种基于数组的方法何时何地会遇到问题？

2183
01:39:17,622 --> 01:39:19,080
AUDIENCE: When you add [INAUDIBLE].
观众：当你添加 [听不清]。

2184
01:39:19,080 --> 01:39:21,240
DAVID J. MALAN: Yeah, so when we add someone
大卫·马兰：是的，所以当我们添加某人

2185
01:39:21,240 --> 01:39:25,240
else who's name collides with one of these existing characters,
其他人，他们的名字与这些现有角色之一冲突，

2186
01:39:25,240 --> 01:39:28,820
just because by accident, they have a name that starts with the same letter--
仅仅因为偶然，他们的名字首字母相同——

2187
01:39:28,820 --> 01:39:33,220
So, for instance, there's Lakitu here who collides with Luigi potentially.
例如，这里有拉基图，他可能会与路易吉冲突。

2188
01:39:33,220 --> 01:39:35,830
Here is Link who collides with both of them.
这里有林克，他与他们两个都冲突。

2189
01:39:35,830 --> 01:39:38,500
But I've drawn a solution to this along the way.
但我已经沿途绘制了解决方案。

2190
01:39:38,500 --> 01:39:42,580
I could if I was Kronion just remove Luigi from the data structure
如果我是克罗尼翁，我可以从数据结构中删除路易吉

2191
01:39:42,580 --> 01:39:45,770
and put Lakitu in or remove and then put Link in there instead.
并将拉基图放进去，或者删除然后将林克放进去。

2192
01:39:45,770 --> 01:39:49,480
But that's stupid if you can only have one friend whose name starts with L.
但如果你的朋友中只有一个名字以 L 开头，那就太蠢了。

2193
01:39:49,480 --> 01:39:51,250
That's just bad design.
这仅仅是糟糕的设计。

2194
01:39:51,250 --> 01:39:56,680
But what if we now in the off chance I have two friends whose names start
但如果现在碰巧我有两个朋友的名字以

2195
01:39:56,680 --> 01:40:00,490
with the same letter, well, I'll just string them together,
相同字母开头，好吧，我只要把它们串在一起，

2196
01:40:00,490 --> 01:40:03,880
link them together, no pun intended, using pointers of sorts.
将它们连接起来，没有双关语的意思，使用指针之类的东西。

2197
01:40:03,880 --> 01:40:06,065
So my vertical here is an array.
所以这里我的垂直方向是一个数组。

2198
01:40:06,065 --> 01:40:07,690
And this is just an artist's rendition.
这只是一个艺术家的描绘。

2199
01:40:07,690 --> 01:40:10,815
There's no actual notion of up, down, left, right in the computer's memory.
在计算机的内存中没有向上、向下、向左、向右的实际概念。

2200
01:40:10,815 --> 01:40:13,510
But this is my array always of size 26.
但我的这个数组始终大小为 26。

2201
01:40:13,510 --> 01:40:17,740
And each of the elements in this array are now not a simple number.
而且这个数组中的每个元素现在不再是一个简单的数字。

2202
01:40:17,740 --> 01:40:20,380
But it's a pointer to a linked list.
而它指向一个链表。

2203
01:40:20,380 --> 01:40:24,020
And if there's nothing there, it's just null, null, null, null.
如果那里什么也没有，它就是 null、null、null、null。

2204
01:40:24,020 --> 01:40:27,330
But, otherwise, it's a valid address that points to the first node.
但，否则，它是一个有效的地址，指向第一个节点。

2205
01:40:27,330 --> 01:40:28,080
And you know what?
你知道吗？

2206
01:40:28,080 --> 01:40:30,080
If we have multiple names with the same letters,
如果我们有多个名字有相同的字母，

2207
01:40:30,080 --> 01:40:35,550
we can just string these nodes together together using pointers as well.
我们也可以使用指针将这些节点串联在一起。

2208
01:40:35,550 --> 01:40:40,820
So a hash table then as implemented here is an array of linked lists.
因此，这里实现的哈希表是一个链接列表数组。

2209
01:40:40,820 --> 01:40:43,730
And that allows us to, one, get some speed benefit
这让我们可以，首先，获得一些速度优势

2210
01:40:43,730 --> 01:40:47,000
because look how fast we inserted or found Mario, Luigi, and Peach.
因为你看我们插入或找到马里奥、路易吉和碧奇的速度有多快。

2211
01:40:47,000 --> 01:40:50,420
But it still covers the scenario where, OK, some people
但这仍然涵盖了这样的情况，好吧，有些人

2212
01:40:50,420 --> 01:40:51,830
can have the same first letters.
可能会有相同的首字母。

2213
01:40:51,830 --> 01:40:54,080
Some of these names will collide.
这些名字中的一些会发生冲突。

2214
01:40:54,080 --> 01:40:57,440
So collisions are an expected problem with a hash table,
所以冲突是哈希表中预期的一个问题，

2215
01:40:57,440 --> 01:41:03,345
whereby two values from some domain happen to map to the same value.
即来自某个域的两个值恰好映射到同一个值。

2216
01:41:03,345 --> 01:41:04,970
And, frankly, you'll see this here too.
坦白地说，你在这里也会看到这一点。

2217
01:41:04,970 --> 01:41:07,250
So these buckets are technically a finite size.
所以这些桶在技术上是有限大小的。

2218
01:41:07,250 --> 01:41:09,860
They're definitely big enough for 13 cards each.
它们肯定足够大，每个桶可以容纳 13 张牌。

2219
01:41:09,860 --> 01:41:13,860
But you could imagine a world where if I'm using 2 decks, 3 decks, or 4 decks,
但你可以想象一个世界，如果我使用 2 副牌、3 副牌或 4 副牌，

2220
01:41:13,860 --> 01:41:15,110
I'm going to run out of space.
我将耗尽空间。

2221
01:41:15,110 --> 01:41:17,585
And then my data structure can't fit any more information.
然后我的数据结构无法容纳更多信息。

2222
01:41:17,585 --> 01:41:19,460
But we're not going to have this problem here
但我们在这里不会遇到这个问题

2223
01:41:19,460 --> 01:41:22,430
because the linked lists, as we've seen, can grow and even shrink
因为我们已经看到，链接列表可以增长甚至缩小

2224
01:41:22,430 --> 01:41:23,420
as much as they want.
它们想要多大就多大。

2225
01:41:23,420 --> 01:41:25,962
In the world of Nintendo there's actually lots of collisions.
在任天堂的世界里，实际上有很多冲突。

2226
01:41:25,962 --> 01:41:28,650
And these aren't even all of the characters.
而且这些甚至不是所有的角色。

2227
01:41:28,650 --> 01:41:30,660
So that's then a hash table.
这就是哈希表。

2228
01:41:30,660 --> 01:41:34,370
So with a hash table in mind, how fast is it?
那么，考虑到哈希表，它的速度有多快？

2229
01:41:34,370 --> 01:41:37,610
Did we achieve that Holy Grail of constant time?
我们是否实现了常数时间的圣杯？

2230
01:41:37,610 --> 01:41:41,570
Well, for some of these names if I back up, yeah, it's kind of constant time.
嗯，对于其中的一些名字，如果我后退，是的，它有点像常数时间。

2231
01:41:41,570 --> 01:41:45,650
Yoshi and Zelda, boom, constant time, location 24, location 25.
耀西和塞尔达，砰，常数时间，位置 24，位置 25。

2232
01:41:45,650 --> 01:41:48,860
Some of them, though, like Luigi, Link, it's
然而，其中一些，比如路易吉、林克，它

2233
01:41:48,860 --> 01:41:52,760
not quite constant time because I first have to get to Luigi's location.
不是完全的常数时间，因为我首先要到达路易吉的位置。

2234
01:41:52,760 --> 01:41:54,990
And then I have to follow this linked list.
然后我必须沿着这个链接列表走。

2235
01:41:54,990 --> 01:42:01,040
So, technically, then what's the running time of searching a hash table?
所以，从技术上讲，搜索哈希表的时间复杂度是多少？

2236
01:42:01,040 --> 01:42:02,390
Sometimes you'll get lucky.
有时你会很幸运。

2237
01:42:02,390 --> 01:42:04,520
But sometimes you won't.
但有时你不会。

2238
01:42:04,520 --> 01:42:06,140
Consider the worst case.
考虑最坏的情况。

2239
01:42:06,140 --> 01:42:08,280
Big O is often used to describe worst case.
大 O 通常用来描述最坏情况。

2240
01:42:08,280 --> 01:42:11,300
So what would be the worst case in your own context?
那么在你自己的语境中，最坏的情况是什么？

2241
01:42:11,300 --> 01:42:12,880
A little louder.
大声点。

2242
01:42:12,880 --> 01:42:13,530
So NY.
所以纽约。

2243
01:42:13,530 --> 01:42:15,480
AUDIENCE: Because you might use [INAUDIBLE]..
观众：因为你可能会使用 [听不清]..

2244
01:42:15,480 --> 01:42:16,480
DAVID J. MALAN: Correct.
大卫·J·马兰：没错。

2245
01:42:16,480 --> 01:42:18,820
And so to summarize in some weird scenario
所以，概括地说，在某种奇怪的情况下

2246
01:42:18,820 --> 01:42:20,950
all of your friends and family and contacts
你所有的朋友、家人和联系人

2247
01:42:20,950 --> 01:42:23,200
could have names that start with the same letter.
可能都有以同一个字母开头的名字。

2248
01:42:23,200 --> 01:42:25,780
And then it doesn't matter that this is a hash table
然后，这个哈希表是什么就无关紧要了

2249
01:42:25,780 --> 01:42:27,730
with an array of linked lists.
这是一个链接列表数组。

2250
01:42:27,730 --> 01:42:30,760
For all intents and purposes, if your friends names only
从本质上来说，如果你的朋友的名字只

2251
01:42:30,760 --> 01:42:33,640
start with the same letter, all you have is a linked list.
以同一个字母开头，你拥有的就是一个链接列表。

2252
01:42:33,640 --> 01:42:37,960
Much like with a tree, if you don't keep it balanced, all you have really
就像树一样，如果你不保持它的平衡，你拥有的实际上

2253
01:42:37,960 --> 01:42:38,960
is a linked list.
就是一个链接列表。

2254
01:42:38,960 --> 01:42:44,470
So technically speaking, yes, hash tables are big O of n
所以从技术上讲，是的，哈希表的复杂度是 O(n)

2255
01:42:44,470 --> 01:42:47,230
even if you're good about--
即使你很擅长--

2256
01:42:47,230 --> 01:42:49,390
even if you have--
即使你拥有--

2257
01:42:49,390 --> 01:42:51,590
in the worst case, hash tables are big O of n.
在最坏的情况下，哈希表的时间复杂度为 O(n)。

2258
01:42:51,590 --> 01:42:52,090
Why?
为什么？

2259
01:42:52,090 --> 01:42:54,220
Because it can devolve into this perverse scenario
因为哈希表可能会演变成这种奇怪的情况

2260
01:42:54,220 --> 01:42:57,370
where you just have lots and lots of collisions all at the same values.
你会有很多很多碰撞，而且它们都发生在相同的键值上。

2261
01:42:57,370 --> 01:42:59,680
But there's got to be a way to fix this.
但一定有办法解决这个问题。

2262
01:42:59,680 --> 01:43:03,488
How could we chip away at the length of these chains so to speak?
我们可以用什么方法缩短这些链条的长度呢？

2263
01:43:03,488 --> 01:43:05,530
Could I decrease the length of these linked lists
我可以减少这些链表的长度吗？

2264
01:43:05,530 --> 01:43:08,320
so that with much higher probability there's no collisions?
这样碰撞发生的概率就会大大降低？

2265
01:43:08,320 --> 01:43:12,190
Well, maybe the problem is that I started with just 26 buckets.
也许问题在于我一开始只用了 26 个桶。

2266
01:43:12,190 --> 01:43:14,140
I mean, four buckets here, 26 here.
也就是说，这里有 4 个桶，这里有 26 个桶。

2267
01:43:14,140 --> 01:43:16,140
Maybe the problem is the size of my array.
也许问题在于我的数组的大小。

2268
01:43:16,140 --> 01:43:18,415
So what if I instead just give myself a bigger array,
那么，如果我给我的数组分配更大的空间呢？

2269
01:43:18,415 --> 01:43:20,040
and it's too big to fit on the screen--
而且它太大了，无法显示在屏幕上——

2270
01:43:20,040 --> 01:43:24,950
but what if I instead have a dollar for names that start with Laa and Lab,
但是，如果我为以 Laa 和 Lab 开头的名字分配一个桶呢？

2271
01:43:24,950 --> 01:43:27,930
and Lac, Lad, do, dot, dot, all the way down?
还有 Lac、Lad、do、dot、dot，一直到最后？

2272
01:43:27,930 --> 01:43:33,380
Now, when I hash these names into my hash table,
现在，当我将这些名字哈希到我的哈希表中时，

2273
01:43:33,380 --> 01:43:35,720
Lakitu is going to end up at their own location
Lakitu 将会落到它自己的位置

2274
01:43:35,720 --> 01:43:39,390
here, link at their own location here, Luigi at their own location here.
在这里，link 落到它自己的位置在这里，Luigi 落到它自己的位置在这里。

2275
01:43:39,390 --> 01:43:42,140
And so now I don't have linked lists.
所以现在我就不再有链表了。

2276
01:43:42,140 --> 01:43:44,910
I really just have an array of names.
我实际上只有一个包含名字的数组。

2277
01:43:44,910 --> 01:43:47,520
So now I'm actually back to constant time.
所以我现在又回到了常数时间。

2278
01:43:47,520 --> 01:43:48,020
Why?
为什么？

2279
01:43:48,020 --> 01:43:52,220
Because so long as every letter of the alphabet has an ASCII value,
因为只要字母表中的每个字母都有一个 ASCII 值，

2280
01:43:52,220 --> 01:43:53,660
I can get that in constant time.
我就能在常数时间内得到它。

2281
01:43:53,660 --> 01:43:55,710
And we did that as far back as week one.
我们早在第一周就做过这个了。

2282
01:43:55,710 --> 01:43:59,390
And so I can figure out what the arithmetic location
所以我可以计算出每个桶的算术位置

2283
01:43:59,390 --> 01:44:01,280
is of each of these buckets just by looking
只需要看一看

2284
01:44:01,280 --> 01:44:05,820
at 1, 2, 3 characters or the total number of letters that I care about,
1、2、3 个字符，或者我关注的字母总数，

2285
01:44:05,820 --> 01:44:07,620
which is just 3 in this case.
在本例中，它只有 3 个。

2286
01:44:07,620 --> 01:44:08,870
So this feels like a solution.
所以这看起来像是一个解决方案。

2287
01:44:08,870 --> 01:44:10,620
Even though I haven't drawn all the names,
虽然我没有画出所有的名字，

2288
01:44:10,620 --> 01:44:12,380
it feels like we've solved the problem.
但感觉我们已经解决了这个问题。

2289
01:44:12,380 --> 01:44:16,355
But what's the downside or trade off of what we've just done?
但是，我们刚做的有什么缺点或权衡呢？

2290
01:44:16,355 --> 01:44:17,063
AUDIENCE: Memory.
观众：内存。

2291
01:44:17,063 --> 01:44:17,980
DAVID J. MALAN: Sorry?
大卫·马兰：抱歉？

2292
01:44:17,980 --> 01:44:18,832
AUDIENCE: Memory.
观众：内存。

2293
01:44:18,832 --> 01:44:19,790
DAVID J. MALAN: Memory.
大卫·马兰：内存。

2294
01:44:19,790 --> 01:44:22,940
So not pictured here is the dot, dot, dot, and everything
所以这里没有画出点、点、点，以及所有

2295
01:44:22,940 --> 01:44:24,380
above and everything below.
上面的和下面的东西。

2296
01:44:24,380 --> 01:44:29,250
This just exploded in terms of the number of locations in this array.
从数组中位置数量的角度来看，这简直是爆炸式增长。

2297
01:44:29,250 --> 01:44:29,750
Why?
为什么？

2298
01:44:29,750 --> 01:44:32,250
Because if I'm taking into account not just the first letter
因为如果我不仅仅考虑第一个字母，

2299
01:44:32,250 --> 01:44:36,380
but the first, the second, and third, that's 26 to the third power,
还要考虑第一个、第二个和第三个字母，那就是 26 的三次方，

2300
01:44:36,380 --> 01:44:38,940
26 times 26 times 26.
26 乘以 26 乘以 26。

2301
01:44:38,940 --> 01:44:42,260
And even though there's going to be a crazy number of names
虽然会有很多名字根本不存在——

2302
01:44:42,260 --> 01:44:43,460
that just don't exist--
我不认为有一个任天堂角色的名字是以 Laa 开头的——

2303
01:44:43,460 --> 01:44:47,090
I can't think of a Nintendo character whose name starts with Laa--
你仍然需要那个桶。

2304
01:44:47,090 --> 01:44:48,510
you still need that bucket.
为什么？

2305
01:44:48,510 --> 01:44:49,010
Why?
因为，否则，你就无法保持连续性。

2306
01:44:49,010 --> 01:44:51,260
Because, otherwise, you don't have contiguousness.


2307
01:44:51,260 --> 01:44:53,670
You can't just arbitrarily label these buckets.
你不能随意给这些桶贴标签。

2308
01:44:53,670 --> 01:44:55,687
If you want to be able to use a function that
如果你想使用一个函数，

2309
01:44:55,687 --> 01:44:58,520
looks at first, second, third letter and then arithmetically figures
它可以查看第一个、第二个、第三个字母，然后算出

2310
01:44:58,520 --> 01:45:04,640
out where to go, whether it's 0 to 25 or 0 to 26 to the third power minus 1
应该去哪里，无论是从 0 到 25 还是从 0 到 26 的三次方减 1，

2311
01:45:04,640 --> 01:45:06,522
being the number of buckets there--
作为桶的数量——

2312
01:45:06,522 --> 01:45:07,730
so there's a trade off there.
所以这里有一个权衡。

2313
01:45:07,730 --> 01:45:11,420
You're wasting a huge amount of memory just to give yourself that time.
你只是为了给自己争取时间而浪费了大量的内存。

2314
01:45:11,420 --> 01:45:14,250
But that would then give us constant time.
但这会让我们获得恒定时间。

2315
01:45:14,250 --> 01:45:17,840
So in that sense, if we have an ideal hash function whereby
从这个意义上说，如果我们有一个理想的哈希函数，

2316
01:45:17,840 --> 01:45:21,260
the function ensures that no values collide,
该函数确保没有值发生冲突，

2317
01:45:21,260 --> 01:45:25,550
we do actually obtain that that Grail of big O of 1 because it only
我们实际上得到了那个 O(1) 的圣杯，因为它只需要

2318
01:45:25,550 --> 01:45:30,068
takes one or maybe three steps to find that names location.
一到三步就能找到那个名字的位置。

2319
01:45:30,068 --> 01:45:33,110
Now, to make this clear, how do we translate this to something like code?
现在，为了说明这一点，我们如何将其转化成类似代码的东西呢？

2320
01:45:33,110 --> 01:45:36,470
Well, here again is the struct we used last time for that of a person
好吧，这里又是我们上次使用过的结构体，用于表示一个人

2321
01:45:36,470 --> 01:45:38,330
and a person had a name and a number.
一个人有名字和号码。

2322
01:45:38,330 --> 01:45:42,030
Here, for a hash table, we might do something a little bit differently.
这里，对于哈希表，我们可能会做一些不同的事情。

2323
01:45:42,030 --> 01:45:47,150
We might now have a node in a hash table storing the person's name,
我们现在可能在哈希表中有一个节点，它存储着该人的姓名，

2324
01:45:47,150 --> 01:45:51,440
person's phone number, and a pointer to the next such person
电话号码，以及指向下一个此类人的指针

2325
01:45:51,440 --> 01:45:53,245
in that chain if needed.
在该链中，如果需要。

2326
01:45:53,245 --> 01:45:56,120
Hopefully this is going to be null most of the time, all of the time.
希望这在大多数情况下，都是空的。

2327
01:45:56,120 --> 01:45:58,460
But we need it just in case we do have that collision.
但我们需要它，以防万一发生冲突。

2328
01:45:58,460 --> 01:46:01,577
We've seen in our pictures the names, like Mario, Luigi, and so forth.
我们已经看到了我们的图片中的名字，比如马里奥、路易吉等等。

2329
01:46:01,577 --> 01:46:02,660
We didn't see the numbers.
我们没有看到数字。

2330
01:46:02,660 --> 01:46:05,270
But that's what's inside of those boxes on the picture.
但这就是图片中那些方框里的内容。

2331
01:46:05,270 --> 01:46:09,650
But that node would give us what we need to build up these linked lists.
但那个节点会给我们构建这些链表所需的东西。

2332
01:46:09,650 --> 01:46:13,610
Meanwhile what is the hash table itself, that vertical strip along the left?
同时，哈希表本身是什么，左边那条垂直的条带？

2333
01:46:13,610 --> 01:46:15,650
Well, it's really just a variable.
嗯，它实际上只是一个变量。

2334
01:46:15,650 --> 01:46:18,860
We could call it table for short of size 26.
我们可以简称为 table，大小为 26。

2335
01:46:18,860 --> 01:46:21,950
And each of the locations in that array that was on the side
而且该数组中每个位于侧面位置的

2336
01:46:21,950 --> 01:46:26,130
here, at least in the simple, small version, was a pointer to a node.
东西，至少在简单的小版本中，都是指向一个节点的指针。

2337
01:46:26,130 --> 01:46:29,180
So it's null if there's no one there or it's
所以，如果那里没有人，它就是空值，或者它就是

2338
01:46:29,180 --> 01:46:32,850
a valid address of the first node in the linked list.
链表中第一个节点的有效地址。

2339
01:46:32,850 --> 01:46:34,760
So this then is a hash table.
所以，这就是哈希表。

2340
01:46:34,760 --> 01:46:38,580
And each of those nodes, to be clear, would be defined as follows.
为了明确起见，每个节点的定义如下。

2341
01:46:38,580 --> 01:46:40,640
So what's the takeaway then with a hash table?
那么，哈希表的要点是什么？

2342
01:46:40,640 --> 01:46:44,300
Ideally, with a good hash function and with a good set
理想情况下，使用一个好的哈希函数和一个好的集合

2343
01:46:44,300 --> 01:46:47,750
of inputs where you're not presented with some perverse set of inputs that's
输入，你不会遇到一些奇怪的输入集，这些输入集

2344
01:46:47,750 --> 01:46:50,720
all of the friends whose names start with the same letter,
都是名字以同一个字母开头的朋友，

2345
01:46:50,720 --> 01:46:53,900
ideally what the hash function will be doing for you is this.
理想情况下，哈希函数为你做的是这件事。

2346
01:46:53,900 --> 01:46:55,700
The input is going to be someone's name.
输入将是某人的名字。

2347
01:46:55,700 --> 01:46:58,242
The algorithm in the middle is going to be the hash function.
中间的算法将是哈希函数。

2348
01:46:58,242 --> 01:47:01,880
And the output is the so-called hash value or location in this case.
输出是所谓的哈希值，在本例中也就是位置。

2349
01:47:01,880 --> 01:47:04,880
So, for instance, in the case of Mario, when we had just--
例如，在马里奥的情况下，当我们只有——

2350
01:47:04,880 --> 01:47:08,810
when we had just 26 buckets total, the input to the hash function
当我们只有 26 个桶时，哈希函数的输入

2351
01:47:08,810 --> 01:47:09,680
would be Mario.
这将是马里奥。

2352
01:47:09,680 --> 01:47:11,450
That hash function would really just look
这个哈希函数实际上只是查看

2353
01:47:11,450 --> 01:47:15,580
at the first letter, M in that case, and would ideally output the number 12.
第一个字母，在这种情况下是M，理想情况下会输出数字12。

2354
01:47:15,580 --> 01:47:16,540
I did the same thing.
我做了同样的事情。

2355
01:47:16,540 --> 01:47:20,230
But in my head, whenever I pulled out a card like the five of diamonds here,
但在我脑海里，每当我抽出一张牌，比如这里的一张方块5，

2356
01:47:20,230 --> 01:47:26,110
I figured out, OK, that's location 0 out of my 0, 1, 2, 3, 4 four total buckets.
我就能算出来，好的，这是我的0、1、2、3、4四个桶中的第0个位置。

2357
01:47:26,110 --> 01:47:28,220
Here we're doing it instead alphabetically.
这里我们按字母顺序排列。

2358
01:47:28,220 --> 01:47:32,230
And so someone like Luigi meanwhile would have a hash value of 11.
所以像路易吉这样的人，他的哈希值为11。

2359
01:47:32,230 --> 01:47:34,330
These numbers would be bigger, of course,
这些数字当然会更大，

2360
01:47:34,330 --> 01:47:39,010
though, if we're looking at 1, 2, 3 letters instead of just one.
不过，如果我们查看1、2、3个字母，而不是只有一个字母。

2361
01:47:39,010 --> 01:47:44,320
So with that said, if we were to implement this in actual code,
所以说，如果我们要在实际代码中实现这个，

2362
01:47:44,320 --> 01:47:45,220
a hash function?
哈希函数？

2363
01:47:45,220 --> 01:47:48,590
I did it physically by acting out the cards.
我通过实际操作牌来实现它。

2364
01:47:48,590 --> 01:47:50,800
Here is how we might implement this in code
以下是我们在代码中实现这个方法的方式

2365
01:47:50,800 --> 01:47:55,390
using C. I could have a function called hash whose argument is a string, a.k.a.
使用C语言。我可以有一个名为hash的函数，它的参数是一个字符串，也就是

2366
01:47:55,390 --> 01:47:58,990
char star, a name of which is word where the word is
char star，它的名字是word，这个word就是

2367
01:47:58,990 --> 01:48:01,340
like the first word in their name.
他们名字中的第一个词。

2368
01:48:01,340 --> 01:48:03,280
We want this function to return an int, which
我们希望这个函数返回一个int，它

2369
01:48:03,280 --> 01:48:07,270
ideally in this case of 26 buckets would be a number from 0 to 26.
理想情况下，在这种26个桶的情况下，它将是一个从0到26的数字。

2370
01:48:07,270 --> 01:48:08,560
And how do we achieve that?
我们如何实现呢？

2371
01:48:08,560 --> 01:48:11,920
Well, if we use our old friend ctype, which had a function like toUpper
好吧，如果我们使用我们的老朋友ctype，它有一个像toUpper这样的函数

2372
01:48:11,920 --> 01:48:17,150
from a couple of weeks back, we could pass in the first letter of that word,
从几周前开始，我们可以传入该词的第一个字母，

2373
01:48:17,150 --> 01:48:21,800
capitalize it, which is going to give us a number that's 65, 66, 67
将其大写，这将给我们一个数字，分别是65、66、67

2374
01:48:21,800 --> 01:48:24,030
on up for the 26 English letters.
一直到26个英文字母。

2375
01:48:24,030 --> 01:48:27,722
And if I subtract 65, a.k.a., quote, unquote--
如果我减去65，也就是“引号”

2376
01:48:27,722 --> 01:48:29,180
single quotes because it's a char--
单引号，因为它是一个char

2377
01:48:29,180 --> 01:48:35,300
that's going to mathematically give me a number between 0 and 25 inclusive.
这将从数学上给我一个0到25之间的数字，包括0和25。

2378
01:48:35,300 --> 01:48:36,590
There's a potential bug.
这里有一个潜在的错误。

2379
01:48:36,590 --> 01:48:40,580
If I pass in punctuation or anything that's not alphabetical,
如果我传入标点符号或任何不是字母的东西，

2380
01:48:40,580 --> 01:48:41,640
bad things will happen.
就会出现问题。

2381
01:48:41,640 --> 01:48:43,765
So I should probably have some more error checking,
所以我可能应该做一些额外的错误检查，

2382
01:48:43,765 --> 01:48:45,980
but this is the simplest way in code that I
但这在我能够实现的代码中，是最简单的方式

2383
01:48:45,980 --> 01:48:48,140
could implement a hash function that looks only
来实现一个只查看

2384
01:48:48,140 --> 01:48:49,650
at the first letter of their name.
他们名字的首字母的哈希函数。

2385
01:48:49,650 --> 01:48:52,490
Probably not ideal because I can think of friends in the real world who have
可能不太理想，因为我能想到现实生活中的一些朋友，他们

2386
01:48:52,490 --> 01:48:54,140
the same first letter of their name.
名字的首字母相同。

2387
01:48:54,140 --> 01:48:57,710
Whether this is better or worse than looking a 2 letters, 3 letters, 4
这比查看2个字母、3个字母、4个字母

2388
01:48:57,710 --> 01:49:00,500
letters, it's going to depend on how much memory you want to spend
好还是坏，取决于你想花多少内存

2389
01:49:00,500 --> 01:49:02,990
and how much time you want to ultimately save.
以及你最终想节省多少时间。

2390
01:49:02,990 --> 01:49:04,820
Let me tweak this though a little bit.
不过，让我稍微修改一下。

2391
01:49:04,820 --> 01:49:07,400
It's conventional in C, just so you know,
在C语言中，你要知道，

2392
01:49:07,400 --> 01:49:11,120
that if you're passing in a string that is a char star to a function
如果你向一个函数传入一个字符串，它是一个char star，

2393
01:49:11,120 --> 01:49:14,750
and you have no intention of letting that function change the string,
而且你没有打算让那个函数改变这个字符串，

2394
01:49:14,750 --> 01:49:18,230
you should probably declare the argument to the function as const.
你应该将函数的参数声明为const。

2395
01:49:18,230 --> 01:49:20,840
And that will tell the compiler to please
这样会告诉编译器请

2396
01:49:20,840 --> 01:49:23,720
don't let the human programmer actually change
不要让程序员实际改变

2397
01:49:23,720 --> 01:49:25,160
that actual word in this function.
这个函数中的实际单词。

2398
01:49:25,160 --> 01:49:26,877
It's just not their place to do so.
这不在他们的职责范围内。

2399
01:49:26,877 --> 01:49:28,460
And we can actually do something else.
我们实际上可以做些其他事情。

2400
01:49:28,460 --> 01:49:32,900
In a hash function because you're using in this case, the output, the integer
在散列函数中，因为你正在使用这种情况，输出，整数

2401
01:49:32,900 --> 01:49:37,070
as a location in an array, it had better not be negative You want it to be
作为数组中的位置，最好不要是负数，你希望它是

2402
01:49:37,070 --> 01:49:38,910
or positive.
或正数。

2403
01:49:38,910 --> 01:49:41,960
And so, technically, if you want to impose that in code, you
因此，从技术上讲，如果你想在代码中强制执行，你

2404
01:49:41,960 --> 01:49:46,370
can specify that the int that's being returned has to be unsigned, that is,
可以指定返回的 int 必须是无符号的，也就是说，

2405
01:49:46,370 --> 01:49:48,800
it's 0 on up through the positive numbers.
它从 0 开始一直到正数。

2406
01:49:48,800 --> 01:49:50,670
It is not a negative value.
它不是负值。

2407
01:49:50,670 --> 01:49:53,090
So this is slightly better than the previous version
所以这比之前的版本稍微好一些

2408
01:49:53,090 --> 01:49:56,960
where we didn't have these defenses in place.
我们没有这些防御措施。

2409
01:49:56,960 --> 01:50:00,800
All right, so what does this actually mean in practice?
好吧，那么这在实践中到底意味着什么呢？

2410
01:50:00,800 --> 01:50:04,790
You don't get to necessarily pick the hash function based
你不能根据你的朋友的名字来选择散列函数。

2411
01:50:04,790 --> 01:50:06,080
on the names of your friends.
朋友的名字。

2412
01:50:06,080 --> 01:50:08,390
Presumably, Apple and Google and others already
可以推测，苹果、谷歌和其他公司已经

2413
01:50:08,390 --> 01:50:11,900
chose their hash function independent of what your friends names are.
独立于你朋友的名字选择了他们的散列函数。

2414
01:50:11,900 --> 01:50:16,100
So ideally, they want to pick a hash function that generally is quite fast,
所以理想情况下，他们希望选择一个通常速度很快的散列函数，

2415
01:50:16,100 --> 01:50:17,060
big O of 1.
O(1)。

2416
01:50:17,060 --> 01:50:19,730
But practically speaking, in a hash table
但实际上，在哈希表中

2417
01:50:19,730 --> 01:50:24,050
unless you get really lucky with the inputs, which you generally won't,
除非你在输入方面非常幸运，但通常不会，

2418
01:50:24,050 --> 01:50:26,460
really it's big O of n running time.
实际上，它的运行时间是 O(n)。

2419
01:50:26,460 --> 01:50:26,960
Why?
为什么？

2420
01:50:26,960 --> 01:50:30,590
Because in the worst possible scenario, you might have one long linked list.
因为在最坏的情况下，你可能只有一个很长的链表。

2421
01:50:30,590 --> 01:50:32,838
But in practice, ideally--
但在实践中，理想情况下——

2422
01:50:32,838 --> 01:50:34,880
and this is a little naive-- but suppose that you
这有点天真，但假设你

2423
01:50:34,880 --> 01:50:39,500
have a uniform distribution of friends in the world where 126 of them
在世界上有均匀分布的朋友，其中 126 个人

2424
01:50:39,500 --> 01:50:43,610
have names starting with and then another 126 out of B
的名字以 A 开头，然后另外 126 个人以 B 开头

2425
01:50:43,610 --> 01:50:47,330
and then dot, dot, dot Z. That would be a nice uniform distribution of friends.
等等，一直到 Z。 那将是一个很好的均匀分布的朋友。

2426
01:50:47,330 --> 01:50:50,660
Technically then, your running time of a hash table
从技术上讲，你的哈希表的运行时间

2427
01:50:50,660 --> 01:50:53,000
for searching it or deleting or inserting
用于搜索它、删除它或插入它

2428
01:50:53,000 --> 01:50:55,790
would technically be big O of n divided by k, where
从技术上讲，将是 O(n/k)，其中

2429
01:50:55,790 --> 01:50:57,810
k is the number of buckets, a constant.
k 是桶的数量，一个常数。

2430
01:50:57,810 --> 01:51:00,890
So it's technically big O of n divided by 26.
所以从技术上讲，它是 O(n/26)。

2431
01:51:00,890 --> 01:51:05,690
Now, again, per our discussion of big O notation, that's still the same thing.
现在，再次根据我们对大 O 符号的讨论，这仍然是一回事。

2432
01:51:05,690 --> 01:51:07,290
You get rid of constant factors.
你消除了常数因子。

2433
01:51:07,290 --> 01:51:09,410
So, yes, it's 26 times faster.
所以，是的，它快了 26 倍。

2434
01:51:09,410 --> 01:51:11,960
The chains are 126 the length.
链长是 126。

2435
01:51:11,960 --> 01:51:16,430
But asymptotically in terms of big O notation, it's still big O of n.
但就大 O 符号的渐近性而言，它仍然是 O(n)。

2436
01:51:16,430 --> 01:51:18,890
And here's where now we can start to veer away
这就是我们现在可以开始偏离的地方

2437
01:51:18,890 --> 01:51:22,970
from what is theoretically right versus what is practically right.
理论上的正确性与实际上的正确性。

2438
01:51:22,970 --> 01:51:26,600
In reality, in the real world, if you work for Google, Microsoft, Apple,
在现实中，在现实世界中，如果你在谷歌、微软、苹果工作，

2439
01:51:26,600 --> 01:51:31,280
and others, 26 times faster is actually faster in the real world
和其他公司，快了 26 倍实际上在现实世界中更快

2440
01:51:31,280 --> 01:51:34,590
even though a mathematician might say, that's really the same thing.
尽管数学家可能会说，这实际上是一回事。

2441
01:51:34,590 --> 01:51:35,480
But it's not.
但事实并非如此。

2442
01:51:35,480 --> 01:51:38,000
The real world wall clock time, if you watch
现实世界中的挂钟时间，如果你观察

2443
01:51:38,000 --> 01:51:41,120
the number of seconds passing on the clock, n over k
时钟上经过的秒数，n/k

2444
01:51:41,120 --> 01:51:43,998
is a much better running time than big O of n.
这是一个比大O(n)运行时间要好得多的运行时间。

2445
01:51:43,998 --> 01:51:46,790
So here too we're getting to the point where the conversations need
所以在这里，我们也到了谈话需要的时候

2446
01:51:46,790 --> 01:51:49,250
to become a little more sophisticated.
变得更加复杂一点。

2447
01:51:49,250 --> 01:51:52,080
It's not quite as simple as theory versus practice.
这并不像理论与实践之间的区别那样简单。

2448
01:51:52,080 --> 01:51:54,990
It depends on what matters ultimately to you.
这取决于对你来说最终重要的是什么。

2449
01:51:54,990 --> 01:51:59,840
But ideally and literally if somehow or other they picked an ideal hash
但理想情况下，如果他们以某种方式选择了理想的哈希函数

2450
01:51:59,840 --> 01:52:03,350
function, big O of 1 would really be the ideal here,
函数，大O(1)在这里将是理想的选择，

2451
01:52:03,350 --> 01:52:05,270
would really be the running time we achieve.
这将是我们能够达到的运行时间。

2452
01:52:05,270 --> 01:52:07,280
And what you'll generally find in the real world
而且你会在现实世界中普遍发现

2453
01:52:07,280 --> 01:52:09,738
is that you don't use hash functions that are as simplistic
你不会使用那些像简单地

2454
01:52:09,738 --> 01:52:11,120
as just look at the first letter.
看看第一个字母那样简单的哈希函数。

2455
01:52:11,120 --> 01:52:13,130
And, honestly, they won't generally look at the first
而且，老实说，他们通常不会看第一个

2456
01:52:13,130 --> 01:52:14,630
and the second and the third letter.
第二个和第三个字母。

2457
01:52:14,630 --> 01:52:17,680
They'll use some even fancier math to put real downward pressure
他们会使用一些更高级的数学来真正降低

2458
01:52:17,680 --> 01:52:21,260
on the probability of collisions so that, yes, they will still happen.
冲突的概率，所以，是的，它们仍然会发生。

2459
01:52:21,260 --> 01:52:25,660
But most of the time a really good hash function, even if it's not quite ideal,
但是大多数时候，一个非常好的哈希函数，即使它不完全是理想的，

2460
01:52:25,660 --> 01:52:30,460
will be darn close to constant time, which makes hash tables and in turn
几乎是常数时间，这使得哈希表，进而

2461
01:52:30,460 --> 01:52:35,080
dictionaries one of the most universally compelling data structures to use.
字典成为最普遍使用的、最有说服力的数据结构之一。

2462
01:52:35,080 --> 01:52:38,812
Now, with that said, we have time for just another data structure or so.
现在，说了这么多，我们还有时间再讲一个数据结构。

2463
01:52:38,812 --> 01:52:39,770
And this is not a typo.
这不是拼写错误。

2464
01:52:39,770 --> 01:52:41,210
This one's called and try.
这个叫做“尝试”。

2465
01:52:41,210 --> 01:52:44,860
And a try is short for retrieval, which is weird because you say retrieval.
而“尝试”是“检索”的简称，这很奇怪，因为你读的是“检索”。

2466
01:52:44,860 --> 01:52:45,687
But you say try.
但你说的是“尝试”。

2467
01:52:45,687 --> 01:52:47,020
But that's the etymology of try.
但这却是“尝试”的词源。

2468
01:52:47,020 --> 01:52:50,830
And a try is of the weirdest amalgamation
而“尝试”是这些东西中最奇怪的混合体

2469
01:52:50,830 --> 01:52:55,670
of all of these things, whereby a try is a tree of arrays.
所有这些东西，一个“尝试”是一棵数组树。

2470
01:52:55,670 --> 01:52:59,560
So a hash table is an array of linked lists.
所以哈希表是一个链表数组。

2471
01:52:59,560 --> 01:53:03,608
A try is a tree of arrays.
“尝试”是一棵数组树。

2472
01:53:03,608 --> 01:53:05,650
So at some point computer scientists just started
所以，在某个时候，计算机科学家们就开始

2473
01:53:05,650 --> 01:53:07,622
mashing together all of these different inputs,
将所有这些不同的输入混在一起，

2474
01:53:07,622 --> 01:53:09,080
and let's see what comes out of it.
看看会有什么结果。

2475
01:53:09,080 --> 01:53:11,380
But a try is actually really interesting.
但“尝试”实际上非常有趣。

2476
01:53:11,380 --> 01:53:14,710
And what you're about to see is a data structure that is literally
你将要看到的是一个真正的大O(1)时间，常数时间的数据结构。

2477
01:53:14,710 --> 01:53:18,010
big O of one time, constant time.
但有一个缺点。

2478
01:53:18,010 --> 01:53:19,580
But there is a downside.
所以，在“尝试”中，每个节点都是一个数组。

2479
01:53:19,580 --> 01:53:23,830
So in a try, every node is an array.
并且那个数组中的每个位置通常

2480
01:53:23,830 --> 01:53:26,500
And every location in that array generally
代表字母表中的一个字母。

2481
01:53:26,500 --> 01:53:28,210
represents a letter of the alphabet.
但你也可以将其推广到单词之外。

2482
01:53:28,210 --> 01:53:31,430
But you could generalize this away from words too.
在这种情况下，如果我们有一个根节点，那个根节点

2483
01:53:31,430 --> 01:53:34,720
In this case, if we have a root node, that root node
实际上是一个具有26个位置的大数组。

2484
01:53:34,720 --> 01:53:37,610
is technically a big array with 26 locations.
如果你想更一般地将名称或单词插入到“尝试”中，你需要做的是：

2485
01:53:37,610 --> 01:53:42,700
And if you want to insert names or words more generally into a try, what you do
这样做。

2486
01:53:42,700 --> 01:53:43,450
is this.
你一次又一次地进行哈希，为你的单词中的每一个字母创建一个数组。

2487
01:53:43,450 --> 01:53:47,980
You hash again and again and again creating one array
那么我的意思是什么呢？

2488
01:53:47,980 --> 01:53:49,880
for every letter in your word.
如果这里有26个元素，这将

2489
01:53:49,880 --> 01:53:51,020
So what do I mean by that?
代表A，这将代表Z。

2490
01:53:51,020 --> 01:53:53,980
If we've got 26 elements here, this would
。

2491
01:53:53,980 --> 01:53:55,990
be representing A. This would be representing Z.
。

2492
01:53:55,990 --> 01:53:59,620
And initially these are all null by default when you have just this root.
最初，当你只有这个根节点时，这些都是默认的空值。

2493
01:53:59,620 --> 01:54:02,920
But suppose I want to insert a few friends of mine, including
但是假设我想插入一些我的朋友，包括

2494
01:54:02,920 --> 01:54:03,880
Toad for instance.
比如蟾蜍。

2495
01:54:03,880 --> 01:54:05,870
T-O-A-D is the name.
T-O-A-D 是他的名字。

2496
01:54:05,870 --> 01:54:07,400
So how would I do that?
那么我该怎么做呢？

2497
01:54:07,400 --> 01:54:12,130
I would first find the location for T based on its number 0 through 25.
我首先会根据 T 的数字 0 到 25 找到它的位置。

2498
01:54:12,130 --> 01:54:14,080
And if this is T, what would I then do?
如果这是 T，我接下来该做什么呢？

2499
01:54:14,080 --> 01:54:18,320
I would change the null to actually be a pointer to another node, a.k.a.
我会将空值更改为指向另一个节点的指针，即

2500
01:54:18,320 --> 01:54:19,490
Another array.
另一个数组。

2501
01:54:19,490 --> 01:54:21,890
And then I would go into the second array
然后我会进入第二个数组

2502
01:54:21,890 --> 01:54:25,280
and hash on the second letter of Toad's name which is, of course O.
并对蟾蜍名字的第二个字母进行哈希运算，当然就是 O。

2503
01:54:25,280 --> 01:54:28,040
And then I would set a pointer to a third node
然后我会设置一个指向第三个节点的指针

2504
01:54:28,040 --> 01:54:34,160
in my tree, which would be represented here, so another 26 pointers.
在我的树中，这里会显示它，所以还有另外 26 个指针。

2505
01:54:34,160 --> 01:54:36,110
Then I would find the pointer representing A.
然后我会找到表示 A 的指针。

2506
01:54:36,110 --> 01:54:41,150
And I would create finally a fourth node, another ray representing
最后我会创建一个第四个节点，另一个代表

2507
01:54:41,150 --> 01:54:43,280
the fourth letter of Toad's name.
蟾蜍名字的第四个字母的数组。

2508
01:54:43,280 --> 01:54:48,110
But because Toad's name ends with D and therefore
但是因为蟾蜍的名字以 D 结尾，因此

2509
01:54:48,110 --> 01:54:52,760
I already have four nodes here, we need to specially color
我已经有了四个节点，我们需要特别地用颜色标记

2510
01:54:52,760 --> 01:54:55,880
though we could probably use an actual variable here.
虽然我们可能可以使用一个实际的变量在这里。

2511
01:54:55,880 --> 01:54:59,120
I need to somehow indicate that Toad's name stops here.
我需要用某种方式表明蟾蜍的名字到这里就结束了。

2512
01:54:59,120 --> 01:55:03,530
So it's not null per se, this actually means that T-O-A-D is in this data
所以它并不是严格意义上的空值，这实际上意味着 T-O-A-D 在这个数据中

2513
01:55:03,530 --> 01:55:04,160
structure.
结构中。

2514
01:55:04,160 --> 01:55:06,260
But I did this deliberately because another friend of mine
但我这样做是故意的，因为我的另一个朋友

2515
01:55:06,260 --> 01:55:08,090
might be Toadette in the Nintendo World.
可能是任天堂世界里的碧奇公主。

2516
01:55:08,090 --> 01:55:10,340
And Toadette, of course, is a superstring
当然，碧奇公主是蟾蜍的超字符串

2517
01:55:10,340 --> 01:55:13,700
of Toad, that is, it's longer but it shares a common prefix.
也就是说，它更长，但它有一个共同的前缀。

2518
01:55:13,700 --> 01:55:15,080
So Toadette could continue.
所以碧奇公主可以继续。

2519
01:55:15,080 --> 01:55:17,840
And I could have another node for the E, another node for the T,
我可以为 E 设立另一个节点，为 T 设立另一个节点，

2520
01:55:17,840 --> 01:55:20,780
another node for the second T, and another node for the last E.
为第二个 T 设立另一个节点，为最后一个 E 设立另一个节点。

2521
01:55:20,780 --> 01:55:25,620
But I somehow have to mark that E as the end of her name as well.
但我必须用某种方式标记那个 E 也是她名字的结尾。

2522
01:55:25,620 --> 01:55:28,370
So even though they share a common prefix,
所以即使它们有共同的前缀，

2523
01:55:28,370 --> 01:55:33,080
the fact that there's two green boxes on the screen means that T-O-A-D is
屏幕上出现两个绿色框的事实意味着 T-O-A-D 是

2524
01:55:33,080 --> 01:55:38,772
in this dictionary as a key as T-O-A-D-E-T-T-E is another key.
在这个字典中作为一个键，而 T-O-A-D-E-T-T-E 是另一个键。

2525
01:55:38,772 --> 01:55:40,730
And technically speaking, what's in these boxes
从技术上讲，这些框里

2526
01:55:40,730 --> 01:55:41,980
too-- it's not just a pointer.
也是——它不仅仅是一个指针。

2527
01:55:41,980 --> 01:55:44,870
It's probably Toad and Toadette's phone number and email
它可能是蟾蜍和碧奇公主的电话号码和电子邮件

2528
01:55:44,870 --> 01:55:49,040
address and the actual value of the dictionary, which is to say,
地址和字典的实际值，也就是说，

2529
01:55:49,040 --> 01:55:51,060
this too is in fact a dictionary.
它实际上也是一个字典。

2530
01:55:51,060 --> 01:55:54,420
A dictionary is just an abstract data type, a collection of key value pairs,
字典只是一种抽象数据类型，它是一组键值对，

2531
01:55:54,420 --> 01:55:56,600
just like I claimed a stack and a queue was.
就像我之前所说的栈和队列一样。

2532
01:55:56,600 --> 01:55:58,280
And how you implement it can differ.
而你的实现方式可以不同。

2533
01:55:58,280 --> 01:56:01,070
You could implement it with a hash table an, array of linked lists
你可以用哈希表和一个链表数组来实现

2534
01:56:01,070 --> 01:56:07,370
as we just did, or you can implement a dictionary as a try, a tree of arrays.
就像我们刚刚做的那样，或者你可以将字典实现为一个 try，一个数组树。

2535
01:56:07,370 --> 01:56:11,298
And let me add one more name to the mix, Tom, for instance,
让我再添加一个名字，比如汤姆，

2536
01:56:11,298 --> 01:56:12,590
a valid name from the universe.
一个来自这个宇宙的有效名字。

2537
01:56:12,590 --> 01:56:18,030
T-O-M just means that, OK, that name exists in this structure as well.
T-O-M 仅仅意味着，好的，这个名字也存在于这个结构中。

2538
01:56:18,030 --> 01:56:21,920
Now, what is the implication of storing the names
现在，存储名称的意义是什么？

2539
01:56:21,920 --> 01:56:24,500
in this way, which is implicitly.
以这种隐含的方式。

2540
01:56:24,500 --> 01:56:31,100
I'm effectively storing Toad and Toadette and Tom in this data structure
我实际上将 Toad、Toadette 和 Tom 存储在这个数据结构中

2541
01:56:31,100 --> 01:56:35,690
without actually storing T or O or A or D or any of the other letters.
而没有实际存储 T、O、A、D 或任何其他字母。

2542
01:56:35,690 --> 01:56:38,000
I'm just implicitly storing those letters
我只是隐含地存储这些字母

2543
01:56:38,000 --> 01:56:41,490
by actually using valid pointers that lead to another node.
通过使用指向另一个节点的有效指针。

2544
01:56:41,490 --> 01:56:43,970
And so what's the implication of this encode?
那么，这种编码的意义是什么呢？

2545
01:56:43,970 --> 01:56:45,980
Well, encode it might look like this.
嗯，它的编码可能看起来像这样。

2546
01:56:45,980 --> 01:56:52,160
Every node in a try is now redefined as being an array of size 26--
try 中的每个节点现在被重新定义为一个大小为 26 的数组——

2547
01:56:52,160 --> 01:56:55,100
and I'll call it children just to borrow the family tree metaphor--
我称它为 children，借用家族树的隐喻——

2548
01:56:55,100 --> 01:56:59,510
and that in each of these nodes there is room for the person's phone number,
并且每个节点都有空间存放该人的电话号码，

2549
01:56:59,510 --> 01:57:02,190
for instance, a.k.a. a string or char star.
例如，即一个字符串或 char 星号。

2550
01:57:02,190 --> 01:57:03,450
So what does this mean?
所以这意味着什么？

2551
01:57:03,450 --> 01:57:06,260
Well, if there's actually a non-null number there,
嗯，如果那里确实存在一个非空号码，

2552
01:57:06,260 --> 01:57:08,240
that's equivalent to there being a green box.
这就等同于存在一个绿色方框。

2553
01:57:08,240 --> 01:57:11,240
If you actually see plus 1, 617 dash whatever there,
如果你确实看到了加 1、617 减去任何东西，

2554
01:57:11,240 --> 01:57:14,320
that means there's a green box because Toad's number is right here.
就意味着那里有一个绿色方框，因为 Toad 的号码就在这里。

2555
01:57:14,320 --> 01:57:16,000
Or Toadette's number is down here.
或者 Toadette 的号码在下面。

2556
01:57:16,000 --> 01:57:17,480
Or Tom's is over there.
或者 Tom 的在那边。

2557
01:57:17,480 --> 01:57:21,100
But if this is null, that just means that maybe this is the T or the O
但是，如果它是空值，就意味着这可能是 T 或 O

2558
01:57:21,100 --> 01:57:25,270
or the E, which are not actually ends of people's names.
或者 E，它们实际上并不是人名的结尾。

2559
01:57:25,270 --> 01:57:27,850
So that's all these nodes actually are.
所以这些节点实际上就是这样。

2560
01:57:27,850 --> 01:57:31,480
And if we think back now to what this data structure looks like,
现在，如果我们回过头来看一下这个数据结构的样子，

2561
01:57:31,480 --> 01:57:37,010
this is in fact a data structure that can be navigated in constant time.
它实际上是一个可以在常数时间内进行遍历的数据结构。

2562
01:57:37,010 --> 01:57:37,510
Why?
为什么呢？

2563
01:57:37,510 --> 01:57:40,960
Well, all we need to keep track of this data structure is literally one pointer
嗯，我们只需要跟踪这个数据结构的唯一一个指针

2564
01:57:40,960 --> 01:57:44,530
called try that's a pointer to the first of these nodes, the so-called root
叫做 try，它指向第一个节点，即所谓的根

2565
01:57:44,530 --> 01:57:45,115
of the try.
这个 try 的根。

2566
01:57:45,115 --> 01:57:49,150
And when it comes to now thinking about the running time of a try, well,
现在，当我们考虑 try 的运行时间时，嗯，

2567
01:57:49,150 --> 01:57:49,930
what is it?
它是什么呢？

2568
01:57:49,930 --> 01:57:53,020
Well, if you've got n friends in your contacts already
嗯，如果你在你的联系人中已经有了 n 个朋友

2569
01:57:53,020 --> 01:57:56,720
or if there's n keys in that data structure,
或者在这个数据结构中有 n 个键，

2570
01:57:56,720 --> 01:57:59,560
how many steps does it take to find anyone?
找到任何人需要多少步？

2571
01:57:59,560 --> 01:58:03,730
Well, whether I have three names, Toad, Toadette, or Tom or three million names
嗯，无论我有三个名字，Toad、Toadette 或 Tom，还是三百万人，

2572
01:58:03,730 --> 01:58:07,870
in that data structure, how many steps will it take me to find Toad ever?
在这个数据结构中，找到 Toad 需要多少步呢？

2573
01:58:07,870 --> 01:58:10,750
T-O-A-D. How many steps for Toadette?
T-O-A-D。找到 Toadette 需要多少步？

2574
01:58:10,750 --> 01:58:13,870
T-O-A-D-E-T-T-E. Eight steps.
T-O-A-D-E-T-T-E。八步。

2575
01:58:13,870 --> 01:58:14,620
How about for Tom?
那么 Tom 呢？

2576
01:58:14,620 --> 01:58:15,700
1 2, 3.
1 2，3。

2577
01:58:15,700 --> 01:58:17,680
And, frankly, I'm sure if we looked it up,
而且，坦白地说，我相信如果我们查一下，

2578
01:58:17,680 --> 01:58:21,440
there's probably a limit on the number of characters in a Nintendo character's
任天堂角色的名字中可能存在字符数量的限制

2579
01:58:21,440 --> 01:58:21,940
name.
名字。

2580
01:58:21,940 --> 01:58:24,790
Maybe it's 20 characters total or maybe a little longer, 30.
也许总共是 20 个字符，或者可能更长一点，30 个。

2581
01:58:24,790 --> 01:58:25,960
There's some fixed value.
存在一个固定的值。

2582
01:58:25,960 --> 01:58:26,802
It's not unbounded.
它不是无界的。

2583
01:58:26,802 --> 01:58:28,510
There's not an infinite number of letters
任天堂角色的名字中没有无限个字母

2584
01:58:28,510 --> 01:58:30,080
in any Nintendo character's name.
在任何任天堂角色的名字中。

2585
01:58:30,080 --> 01:58:31,720
So there's some constant value.
所以存在一个常数。

2586
01:58:31,720 --> 01:58:32,770
Call it k.
我们称它为 k。

2587
01:58:32,770 --> 01:58:35,020
So no matter whose name you're looking for,
所以无论你在寻找谁的名字，

2588
01:58:35,020 --> 01:58:36,790
it's going to take you maximally k steps.
你最多需要 k 步才能找到。

2589
01:58:36,790 --> 01:58:37,840
But k is a constant.
但 k 是一个常数。

2590
01:58:37,840 --> 01:58:42,820
And we always said that big O of k is the same thing as big O of 1.
我们一直说，k 的大 O 和 1 的大 O 是相同的。

2591
01:58:42,820 --> 01:58:46,300
So for all intents and purposes, even though we're taking a bit of liberty
所以，就所有意图和目的而言，尽管我们在这里有点自由

2592
01:58:46,300 --> 01:58:50,425
here, searching a try, inserting into a try, deleting from a try
搜索一个 trie，插入一个 trie，从一个 trie 中删除

2593
01:58:50,425 --> 01:58:51,940
is constant time.
都是常数时间。

2594
01:58:51,940 --> 01:58:55,715
Because if you have a billion names in the dictionary already,
因为如果你已经在字典里存了一百万个名字，

2595
01:58:55,715 --> 01:58:57,590
it's going to take up a huge amount of space.
它将占用大量的空间。

2596
01:58:57,590 --> 01:59:03,370
But it does not affect how many steps it takes to find Toad or Toadette or Tom.
但这不会影响找到 Toad 或 Toadette 或 Tom 需要多少步。

2597
01:59:03,370 --> 01:59:05,500
That depends only on the length of their names
这仅仅取决于他们的名字的长度

2598
01:59:05,500 --> 01:59:08,050
which effectively is a constant value.
这实际上是一个常数值。

2599
01:59:08,050 --> 01:59:09,610
But there is a downside here.
但这里有一个缺点。

2600
01:59:09,610 --> 01:59:11,230
And it's a big one.
而且这是一个大问题。

2601
01:59:11,230 --> 01:59:14,740
In practice, I daresay most computers, most systems,
实际上，我敢说大多数计算机，大多数系统，

2602
01:59:14,740 --> 01:59:18,940
would actually use hash tables, not tries,
实际上使用的是哈希表，而不是 trie，

2603
01:59:18,940 --> 01:59:21,490
to implement dictionaries, collections of key value pairs.
来实现字典，键值对的集合。

2604
01:59:21,490 --> 01:59:26,590
What's the downside of this here data structure might you think?
你可能认为这个数据结构的缺点是什么？

2605
01:59:26,590 --> 01:59:31,360
And this is just a representative picture for Toad, Tom, and Toadette.
这只是 Toad、Tom 和 Toadette 的一个代表性图片。

2606
01:59:31,360 --> 01:59:32,990
All the space it takes up--
它占用的所有空间——

2607
01:59:32,990 --> 01:59:36,550
I mean, even for these three names, look at how many empty pointers there are.
我的意思是，即使对于这三个名字，看看有多少空指针。

2608
01:59:36,550 --> 01:59:38,110
So they're null to be sure.
所以可以肯定它们是空的。

2609
01:59:38,110 --> 01:59:42,310
But there's 25 unused spaces here, another 25 unused spaces here,
但这里有 25 个未使用的空间，这里还有 25 个未使用的空间，

2610
01:59:42,310 --> 01:59:43,900
24 unused spaces here.
这里有 24 个未使用的空间。

2611
01:59:43,900 --> 01:59:46,630
And what's not pictured is if I've got more and more names,
而没有画出来的是，如果我有越来越多的名字，

2612
01:59:46,630 --> 01:59:50,410
this thing's just going to blow up with more and more and more and more arrays
这个东西就会因为越来越多的数组而爆炸

2613
01:59:50,410 --> 01:59:53,140
even though there's not going to be someone whose name starts
即使不会有人名字以

2614
01:59:53,140 --> 01:59:56,620
with like Laa or Lba or Lbb.
Laa 或 Lba 或 Lbb 开头。

2615
01:59:56,620 --> 01:59:58,990
There's going to be so many combinations of letters
会有很多字母的组合

2616
01:59:58,990 --> 02:00:01,490
where it's just going to be null pointers instead.
它们只会是空指针。

2617
02:00:01,490 --> 02:00:03,980
So it takes up a huge amount of space.
所以它占用大量的空间。

2618
02:00:03,980 --> 02:00:05,710
But it does give us constant time.
但它确实给了我们常数时间。

2619
02:00:05,710 --> 02:00:08,270
And that then is this here trade off.
这就是这里的权衡。

2620
02:00:08,270 --> 02:00:11,710
So I would encourage you here on out as we exit the world of C
所以，我鼓励你在这里离开 C 的世界

2621
02:00:11,710 --> 02:00:14,590
and so much of today's code in the past several weeks code
以及过去几周的代码，今天的大部分代码

2622
02:00:14,590 --> 02:00:17,457
will soon be reduced in a week's time to just one
很快就会在一周内减少到只有一行代码，两行代码。

2623
02:00:17,457 --> 02:00:18,790
line of code, two lines of code.
一行代码，两行代码。

2624
02:00:18,790 --> 02:00:21,430
Because Python and the authors of Python will
因为 Python 和 Python 的作者将

2625
02:00:21,430 --> 02:00:24,550
have implemented all of this week's and last week's and prior week's
已经为我们实现了本周、上周和前几周的

2626
02:00:24,550 --> 02:00:28,390
ideas for us, we'll be able to operate at a higher level of abstraction.
想法，我们将能够在更高的抽象层面上操作。

2627
02:00:28,390 --> 02:00:30,550
And just think about what problems we want to solve
想想我们想要解决什么问题

2628
02:00:30,550 --> 02:00:33,970
and how we want to do so algorithmically and with data structures.
以及我们想如何用算法和数据结构来解决。

2629
02:00:33,970 --> 02:00:37,390
And data structures in conclusion are everywhere.
总之，数据结构无处不在。

2630
02:00:37,390 --> 02:00:43,300
Has anyone recognized this spot in Harvard Square?
有人认出哈佛广场的这个地方吗？

2631
02:00:43,300 --> 02:00:44,010
Anyone?
有人吗？

2632
02:00:44,010 --> 02:00:44,980
What are we looking at?
我们在看什么？

2633
02:00:44,980 --> 02:00:46,458
AUDIENCE: Is that Sweetgreen?
观众：那是 Sweetgreen 吗？

2634
02:00:46,458 --> 02:00:49,000
DAVID J. MALAN: So this is Sweetgreen, a popular salad place.
DAVID J. MALAN：所以这是 Sweetgreen，一家很受欢迎的沙拉店。

2635
02:00:49,000 --> 02:00:53,480
And this is actually a dictionary or really a hash table of sorts.
这实际上是一个字典，或者更确切地说，是一个哈希表。

2636
02:00:53,480 --> 02:00:53,980
Why?
为什么？

2637
02:00:53,980 --> 02:00:56,590
Well, if you buy a very expensive salad at Sweetgreen,
嗯，如果你在 Sweetgreen 买了一份很贵的沙拉，

2638
02:00:56,590 --> 02:00:59,830
they put it on the shelf for you if you've ordered via the app or online
如果你通过应用程序或在线订购，他们会帮你把沙拉放在货架上

2639
02:00:59,830 --> 02:01:00,343
in advance.
提前。

2640
02:01:00,343 --> 02:01:02,260
And if I, for instance, were to order a salad,
比如，如果我要点一份沙拉，

2641
02:01:02,260 --> 02:01:03,970
it would probably go under the D heading.
它可能会放在 D 部分。

2642
02:01:03,970 --> 02:01:07,510
If Carter were to order a salad, it would go under C, Julia under y.
如果 Carter 要点一份沙拉，它会放在 C 部分，Julia 则在 y 部分。

2643
02:01:07,510 --> 02:01:11,110
And so they hash the salads based on your first name
所以他们根据你的名字对沙拉进行哈希

2644
02:01:11,110 --> 02:01:12,760
to a particular location on the shelf.
到货架上的特定位置。

2645
02:01:12,760 --> 02:01:13,880
Why is that a good thing?
为什么那是一件好事？

2646
02:01:13,880 --> 02:01:16,750
Well, if it were just one long shelf that wasn't even alphabetical,
嗯，如果它只是一排长长的货架，而且不是按字母顺序排列，

2647
02:01:16,750 --> 02:01:19,360
it would be big O of n for me to find my salad
我找到我的沙拉的时间复杂度将为 O(n)

2648
02:01:19,360 --> 02:01:21,100
and for Carter and Julia to find theirs.
Carter 和 Julia 也是如此。

2649
02:01:21,100 --> 02:01:24,070
Because they've got 26 letters here, it's big O of 1.
因为他们这里有 26 个字母，所以时间复杂度是 O(1)。

2650
02:01:24,070 --> 02:01:26,740
It's one step for any of us to find our salads.
我们每个人只需要一步就能找到自己的沙拉。

2651
02:01:26,740 --> 02:01:30,040
Except, again, in perverse situations, where
当然，除了在一些极端情况下，比如

2652
02:01:30,040 --> 02:01:36,220
to might this system devolve at like 12:30 PM in the afternoon for instance?
下午 12:30 左右，这个系统可能会变得混乱。

2653
02:01:36,220 --> 02:01:37,195
What could go wrong?
会有什么问题？

2654
02:01:37,195 --> 02:01:38,970
AUDIENCE: A lot of people with names with the same first letter
观众：很多人的名字首字母相同

2655
02:01:38,970 --> 02:01:39,772
order a salad.
订购沙拉。

2656
02:01:39,772 --> 02:01:42,480
DAVID J. MALAN: Yeah, a lot of people with the same first letters
DAVID J. MALAN：没错，很多人名字的首字母都一样

2657
02:01:42,480 --> 02:01:43,938
of their names might order a salad.
可能会点沙拉。

2658
02:01:43,938 --> 02:01:46,937
So there's lots of like D, D, D. Where do we put the next person?
所以有很多 D、D、D。我们把下一个人放在哪里？

2659
02:01:46,937 --> 02:01:49,770
OK, well, maybe we overflow to E. What if there's a lot of E people?
好吧，也许我们会溢出到 E。如果有很多 E 开头名字的人怎么办？

2660
02:01:49,770 --> 02:01:50,437
It overflows to.
它会溢出到

2661
02:01:50,437 --> 02:01:51,660
F What if it overflows?
F。如果它溢出了怎么办？

2662
02:01:51,660 --> 02:01:54,870
Then we go to G. And it devolves anyway into a linked
然后我们转到 G。无论如何，它最终会变成一个链表

2663
02:01:54,870 --> 02:01:58,680
list or really multiple arrays that you have to search in big O of n time?
或者说，多个数组，你必须在 O(n) 时间内进行搜索？

2664
02:01:58,680 --> 02:02:01,182
I've even been to Sweetgreen at non-popular times.
我甚至在 Sweetgreen 非高峰时间去过。

2665
02:02:01,182 --> 02:02:04,140
And sometimes the staff just don't even choose to use the dictionaries.
有时工作人员甚至不选择使用字典。

2666
02:02:04,140 --> 02:02:06,003
They just put what's closest to them.
他们只是把沙拉放在离他们最近的地方。

2667
02:02:06,003 --> 02:02:07,920
So you have to search the same thing anywhere.
所以你必须在任何地方搜索相同的物品。

2668
02:02:07,920 --> 02:02:10,500
But you'll start to see now that you've seen some of these building blocks
但你会发现，当你看到这些基本的构件时

2669
02:02:10,500 --> 02:02:13,200
that data structures are everywhere algorithms are everywhere.
数据结构无处不在，算法也无处不在。

2670
02:02:13,200 --> 02:02:17,410
And among the goals of CS50 now are to harness these ideas most efficiently.
CS50 目标之一就是最有效地利用这些理念。

2671
02:02:17,410 --> 02:02:18,120
So that's a wrap.
所以就是这样。

2672
02:02:18,120 --> 02:02:19,590
We'll see you next time.
我们下次再见。

2673
02:02:19,590 --> 02:02:22,940
[MUSIC PLAYING]
[音乐播放]
