1
00:00:00,000 --> 00:00:03,486
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,752 --> 00:01:03,600
SPEAKER 1: All right.
好的。

3
00:01:03,600 --> 00:01:06,200
So this is CS50, and this is week four.
所以这是 CS50，这是第四周。

4
00:01:06,200 --> 00:01:07,950
And this is actually one of the weeks that
实际上，这是其中一周，

5
00:01:07,950 --> 00:01:11,040
really makes CS50, CS50, insofar as we'll
真正让 CS50 成为了 CS50，因为我们将会

6
00:01:11,040 --> 00:01:13,590
take an even lower level look at how computers work,
从更低的层次来了解计算机是如何工作的，

7
00:01:13,590 --> 00:01:16,050
and in turn, what it is you're doing when you write code
进而了解当你编写代码时，你在做什么

8
00:01:16,050 --> 00:01:18,900
toward an end of really giving you a complete mental model of what's
最终目标是给你一个完整的计算机内部运行的思维模型，以便

9
00:01:18,900 --> 00:01:21,983
going on inside, so that when you run to solve some problem, when you want
当你运行代码来解决某个问题时，当你想要

10
00:01:21,983 --> 00:01:25,050
to fix, solve some problem, when you want to write some code,
修复，解决某个问题时，当你想要编写一些代码时，

11
00:01:25,050 --> 00:01:28,260
you actually know what those building blocks inside of the computer
你实际上会知道计算机内部的那些构建块

12
00:01:28,260 --> 00:01:29,570
itself actually are.
到底是什么。

13
00:01:29,570 --> 00:01:32,070
We'll, ultimately, too, take off some of the training wheels
最终，我们还会去掉一些辅助轮

14
00:01:32,070 --> 00:01:34,570
that we've had on for the past few weeks, particularly in C,
我们在过去几周一直使用的，尤其是在 C 语言中，

15
00:01:34,570 --> 00:01:37,150
and we'll also introduce more familiar media types.
我们还会介绍更多熟悉的媒体类型。

16
00:01:37,150 --> 00:01:39,750
So files, like images are sort of everywhere.
所以，像图片这样的文件无处不在。

17
00:01:39,750 --> 00:01:41,730
And we'll introduce you to exactly what's
我们会带你了解当你看到一张照片，或者一个 GIF 时，

18
00:01:41,730 --> 00:01:43,980
going on when you just look at a photograph, or a GIF,
或者一个 PNG，或者你屏幕上看到的任何图像，比如这里这个。

19
00:01:43,980 --> 00:01:47,190
or a PNG, or any kind of image on your screen like this one here.
到底发生了什么。

20
00:01:47,190 --> 00:01:51,240
And it will become clear that, unlike Hollywood TV shows and movies,
你会发现，与好莱坞的电视剧和电影不同，

21
00:01:51,240 --> 00:01:53,790
if you try to enhance a picture like this
如果你想增强像这样的图片

22
00:01:53,790 --> 00:01:57,450
to look closer, and closer, and closer, in the movies typically
越来越近，越来越近，在电影中通常

23
00:01:57,450 --> 00:02:00,540
trying to figure out who the bad guy is, for instance, eventually,
试图找出谁是坏人，例如，最终，

24
00:02:00,540 --> 00:02:04,600
you run out of information because there's only a finite number of bits
你会发现没有更多信息，因为构成这些文件的比特数是有限的

25
00:02:04,600 --> 00:02:06,392
or bytes that compose these files.
或字节。

26
00:02:06,392 --> 00:02:08,350
So any time you've seen computers that you just
所以，当你看到计算机仅仅

27
00:02:08,350 --> 00:02:11,410
hit a button, and boom, it's enhanced, and all of a sudden the suspect
按下按钮，砰的一声，画面就被增强了，突然之间嫌疑人

28
00:02:11,410 --> 00:02:14,770
is clear, that's a lot more Hollywood than it is computer science.
就很清晰了，这比计算机科学更像好莱坞电影。

29
00:02:14,770 --> 00:02:16,720
But with that said, later in the term, we
但话说回来，在本学期后期，我们会

30
00:02:16,720 --> 00:02:18,850
will talk about artificial intelligence.
谈论人工智能。

31
00:02:18,850 --> 00:02:22,270
And even though there might not be that information there,
即使那里可能没有那些信息，

32
00:02:22,270 --> 00:02:25,720
through statistical reasoning, and modeling, and predictions,
通过统计推理、建模和预测，

33
00:02:25,720 --> 00:02:28,090
can computers increasingly actually create
计算机可以越来越多地创建

34
00:02:28,090 --> 00:02:30,520
information, where perhaps there was none, just based
信息，即使可能之前没有，仅仅基于

35
00:02:30,520 --> 00:02:32,080
on what's most likely to be there?
最有可能存在的东西？

36
00:02:32,080 --> 00:02:34,030
So more on that before long, too.
所以很快我们会详细讲解。

37
00:02:34,030 --> 00:02:37,220
But you'll see that all of these dots on the screen, all of these pixels,
但你会发现屏幕上的所有这些点，所有这些像素，

38
00:02:37,220 --> 00:02:39,610
so to speak, are just a grid up, down, left, right that
可以这么说，只是一张上下左右的网格，

39
00:02:39,610 --> 00:02:40,720
compose these pictures.
构成这些图片。

40
00:02:40,720 --> 00:02:43,300
And we're fortunate to have three volunteers on stage who
我们很幸运有三位志愿者在台上，

41
00:02:43,300 --> 00:02:47,620
kindly, just before the lecture began, created their own pixel artwork,
在讲座开始前，他们很友好地创作了自己的像素艺术作品，

42
00:02:47,620 --> 00:02:49,870
so to speak, on this here easel.
可以这么说，在这个画架上。

43
00:02:49,870 --> 00:02:52,310
If you guys would like to spin this around,
如果你们愿意把它转过来，

44
00:02:52,310 --> 00:02:57,260
let's see what it is you've been working on.
让我们看看你们一直在做些什么。

45
00:02:57,260 --> 00:03:00,010
And if you'd like to introduce yourselves as our three artists
如果你愿意介绍一下你们自己，作为我们今天的三位艺术家

46
00:03:00,010 --> 00:03:00,700
today, first.
首先。

47
00:03:00,700 --> 00:03:03,090
SPEAKER 2: Yes, I'm Talia.
好的，我是塔莉娅。

48
00:03:03,090 --> 00:03:07,000
I'm a junior at the college studying economics with a possible computer
我是一名大三学生，在大学学习经济学，可能会辅修计算机，

49
00:03:07,000 --> 00:03:08,470
science secondary.
科学中学。

50
00:03:08,470 --> 00:03:09,450
SPEAKER 3: Hi.
演讲者 3：你好。

51
00:03:09,450 --> 00:03:10,440
My name is Bulut.
我的名字是 Bulut。

52
00:03:10,440 --> 00:03:12,310
I'm from BU.
我来自 BU。

53
00:03:12,310 --> 00:03:13,470
SPEAKER 1: Welcome.
演讲者 1：欢迎。

54
00:03:13,470 --> 00:03:16,530
SPEAKER 4: I'm a Assalo Caesar, self-taught computer science student.
演讲者 4：我叫 Assalo Caesar，是一位自学成才的计算机科学学生。

55
00:03:16,530 --> 00:03:19,230
I've been working as a software engineer since age 16.
我从 16 岁起就开始做软件工程师。

56
00:03:19,230 --> 00:03:20,010
SPEAKER 1: Nice.
演讲者 1：不错。

57
00:03:20,010 --> 00:03:21,160
Well, welcome to you all.
欢迎大家。

58
00:03:21,160 --> 00:03:22,830
And if you would like to give us a description of what it
如果你想描述一下你

59
00:03:22,830 --> 00:03:24,510
is that you built out of pixels here.
用像素构建的东西。

60
00:03:24,510 --> 00:03:27,330
SPEAKER 2: So we built a firework.
演讲者 2：我们制作了一支烟花。

61
00:03:27,330 --> 00:03:28,920
SPEAKER 1: OK, nice.
演讲者 1：好的，不错。

62
00:03:28,920 --> 00:03:31,710
And it's very blocky because what we've given
而且它非常块状，因为我们给他们的

63
00:03:31,710 --> 00:03:34,890
them is post-it notes, each of which represents one of these pixels or dots.
是便利贴，每个便利贴代表这些像素或点中的一个。

64
00:03:34,890 --> 00:03:36,930
Now, typically, it might be black or white,
通常，它可能是黑色或白色，

65
00:03:36,930 --> 00:03:39,580
but the post-it notes we have here are pink or blue.
但我们这里的便利贴是粉色或蓝色。

66
00:03:39,580 --> 00:03:41,580
So each of these represents a dot on the screen.
所以这些中的每一个代表屏幕上的一个点。

67
00:03:41,580 --> 00:03:43,740
And I gather you did one other that actually
我听说你们还做了一个，它实际上

68
00:03:43,740 --> 00:03:47,820
conveys maybe a bit more information, if you want to reveal version two.
可能传递了更多信息，如果你想展示版本二。

69
00:03:47,820 --> 00:03:50,550
And thus we have yet more pixel art.
因此，我们还有更多的像素艺术。

70
00:03:50,550 --> 00:03:54,510
So maybe round of applause for what our volunteers were able to do using
所以，也许大家可以为我们的志愿者用

71
00:03:54,510 --> 00:03:55,380
pixels alone.
像素做出的东西鼓掌。

72
00:03:55,380 --> 00:03:56,010
Thank you.
谢谢。

73
00:03:56,010 --> 00:04:00,420
We have, as always, limited supply of delicious Super Mario Brothers
我们，一如既往，供应有限的美味超级马里奥兄弟

74
00:04:00,420 --> 00:04:01,500
Oreos for each of you.
奥利奥，每人一块。

75
00:04:01,500 --> 00:04:03,160
Thank you so much for coming up.
非常感谢你们的参与。

76
00:04:03,160 --> 00:04:03,858
But thank you.
但谢谢你们。

77
00:04:03,858 --> 00:04:05,650
But the point here, really, is that there's
但重点是，真的，就是只有

78
00:04:05,650 --> 00:04:08,320
only so much you can do when you just have dots on the screen.
在屏幕上只有点的时候，你所能做的事情有限。

79
00:04:08,320 --> 00:04:10,960
Now, of course, the image that we saw a moment ago of these
当然，我们刚才看到的那个

80
00:04:10,960 --> 00:04:13,510
here stress balls is much higher quality.
减压球的图片质量要高得多。

81
00:04:13,510 --> 00:04:17,360
It's much higher fidelity, or more specifically, much higher resolution.
它的保真度要高得多，或者更准确地说，分辨率要高得多。

82
00:04:17,360 --> 00:04:20,490
And resolution just refers to how many dots or pixels are on the screen.
而分辨率指的是屏幕上有多少个点或像素。

83
00:04:20,490 --> 00:04:22,240
And the smaller they are, and the more you
它们越小，你塞得越多

84
00:04:22,240 --> 00:04:25,850
cram in on the screen, the clearer, and clearer the images are.
在屏幕上，图像就越清晰。

85
00:04:25,850 --> 00:04:28,960
But at the end of the day, even this here pixel art
但归根结底，即使是这像素艺术

86
00:04:28,960 --> 00:04:32,950
represents what's going on your phone, your laptop, your desktop, your TV
也代表了你的手机、笔记本电脑、台式机、电视

87
00:04:32,950 --> 00:04:36,160
nowadays, because all it is this grid of pixels.
现在的显示原理，因为它们都是由像素网格组成的。

88
00:04:36,160 --> 00:04:39,820
Now, before we can actually write code that actually manipulates
现在，在我们实际编写代码来操作之前

89
00:04:39,820 --> 00:04:42,130
these kinds of images, we need to understand,
这些类型的图像，我们需要理解，

90
00:04:42,130 --> 00:04:44,980
and we need to have some new syntax for navigating files.
我们需要一些新的语法来导航文件。

91
00:04:44,980 --> 00:04:48,400
So not just text, but files stored somewhere on the computer,
所以不仅仅是文本，还有存储在计算机上的文件，

92
00:04:48,400 --> 00:04:49,570
somewhere on the server.
存储在服务器上。

93
00:04:49,570 --> 00:04:52,580
But let's consider how we might store even information like this.
但是让我们考虑一下我们如何存储像这样的信息。

94
00:04:52,580 --> 00:04:53,740
But we'll make it simpler.
但我们将把它简化。

95
00:04:53,740 --> 00:04:57,190
Here is a grid of zeros and ones, clearly.
这里是一个零和一的网格，很明显。

96
00:04:57,190 --> 00:04:59,740
But I would argue that each of these might as well represent
但我认为这些中的每一个也可能代表

97
00:04:59,740 --> 00:05:01,450
a pixel, an individual dot.
一个像素，一个单独的点。

98
00:05:01,450 --> 00:05:04,720
And if that dot is a zero, it's representing the color black.
如果那个点是零，它就代表黑色。

99
00:05:04,720 --> 00:05:09,040
If that dot is a one, it's representing the color white.
如果那个点代表的是1，它代表的颜色是白色。

100
00:05:09,040 --> 00:05:15,940
Given that, can anyone see what this grid is a picture of,
考虑到这一点，有人能看出来这个网格代表的图片是什么吗？

101
00:05:15,940 --> 00:05:20,920
even though it's using zeros and ones and not post-it notes, like this here?
即使它使用的是零和一而不是便利贴，就像这里一样？

102
00:05:20,920 --> 00:05:23,360
Yeah, in the back?
是的，在后面？

103
00:05:23,360 --> 00:05:25,010
It's a smiley face.
这是一个笑脸。

104
00:05:25,010 --> 00:05:26,150
How do you see that?
你怎么看出来的？

105
00:05:26,150 --> 00:05:28,260
Well, in a moment it's going to be super obvious.
嗯，过一会儿就会非常明显了。

106
00:05:28,260 --> 00:05:32,600
But if I actually get rid of the ones, leaving just the zeros,
但是如果我把所有的1去掉，只留下0，

107
00:05:32,600 --> 00:05:35,467
there you have the zeros that were there just a moment ago.
现在你看到的这些0，就是刚才那些1的位置。

108
00:05:35,467 --> 00:05:37,550
So what this translates to, typically on a screen,
所以，这通常在屏幕上显示的，

109
00:05:37,550 --> 00:05:40,670
is not a pattern of zeros and ones literally on the screen,
并不是屏幕上真正显示的零和一的模式，

110
00:05:40,670 --> 00:05:41,970
but a pattern of dots.
而是一系列点的模式。

111
00:05:41,970 --> 00:05:46,070
So again, white might be one, and black might be--
所以，再次强调，白色可能是1，黑色可能是——

112
00:05:46,070 --> 00:05:48,110
one might be white.
1可能是白色。

113
00:05:48,110 --> 00:05:49,220
Zero might be black.
0可能是黑色。

114
00:05:49,220 --> 00:05:52,130
But we picture it, of course, on our screens as this actual grid.
当然，我们把它们想象成我们屏幕上的实际网格。

115
00:05:52,130 --> 00:05:53,570
But that's really all we need.
但这确实是我们需要的全部。

116
00:05:53,570 --> 00:05:55,880
Inside of a file to store something like an image,
在一个用于存储像图像这样的东西的文件中，

117
00:05:55,880 --> 00:05:58,070
we just need a pattern of zeros and ones.
我们只需要一个零和一的模式。

118
00:05:58,070 --> 00:06:00,770
But of course, having more colors would be more interesting.
当然，拥有更多颜色会更有趣。

119
00:06:00,770 --> 00:06:04,400
And if you actually have a larger grid, you can do even more with pixel art.
如果你真的有更大的网格，你就可以用像素艺术做更多的事情。

120
00:06:04,400 --> 00:06:06,740
And in fact for fun, at the beginning of the semester,
实际上，为了好玩，在学期开始的时候，

121
00:06:06,740 --> 00:06:10,220
we have a staff training with all of the teaching fellows, course assistants,
我们对所有的助教、课程助理，

122
00:06:10,220 --> 00:06:13,580
teaching assistants, and we gave them all this Google spreadsheet.
助教进行了培训，并给他们每个人发了这个谷歌表格。

123
00:06:13,580 --> 00:06:16,280
And we sort of resized all of the rows and columns
我们调整了所有行和列的尺寸

124
00:06:16,280 --> 00:06:19,440
to just be squares instead of the default rectangles.
让它们变成正方形，而不是默认的矩形。

125
00:06:19,440 --> 00:06:21,980
And then we encouraged them to create something out of this.
然后我们鼓励他们用这个表格创作一些东西。

126
00:06:21,980 --> 00:06:25,230
And in fact, just a few weeks ago, here are some of this year's creations,
实际上，就在几周前，这里有一些今年的创作，

127
00:06:25,230 --> 00:06:28,410
creating, essentially, images using Google Spreadsheets
用谷歌表格创建，本质上，是图片

128
00:06:28,410 --> 00:06:32,080
by treating each of the cells as just a dot on the screen.
通过把每个单元格看作是屏幕上的一个点。

129
00:06:32,080 --> 00:06:33,960
So here, we have a team who in a few minutes
所以，这里，我们有一个团队，他们在几分钟内

130
00:06:33,960 --> 00:06:36,550
made a Super Mario World, a bigger canvas, of course,
制作了一个超级马里奥世界，当然，画布更大，

131
00:06:36,550 --> 00:06:37,680
than this here easel.
比这里的画架更大。

132
00:06:37,680 --> 00:06:42,030
Here we have a pixel based version of Scratch.
这里，我们有一个基于像素的Scratch版本。

133
00:06:42,030 --> 00:06:46,080
Here, we had an homage to the Harvard-Yale football competition.
这里，我们对哈佛-耶鲁橄榄球比赛致敬。

134
00:06:46,080 --> 00:06:48,960
And then here, we had a character of some sort.
然后，这里，我们有一个人物。

135
00:06:48,960 --> 00:06:50,670
So this is what the team here did.
所以，这就是这个团队做的。

136
00:06:50,670 --> 00:06:52,290
And actually, if you'd like to play along at home
实际上，如果你想在家玩

137
00:06:52,290 --> 00:06:54,582
at the risk of distracting you the entirety of lecture,
冒着让你整堂课分心的风险，

138
00:06:54,582 --> 00:06:56,880
if you go to this URL here, it'll actually give you
如果你访问这里这个网址，它实际上会给你

139
00:06:56,880 --> 00:06:59,430
a copy of that same blank spreadsheet.
一个相同的空白表格的副本。

140
00:06:59,430 --> 00:07:02,010
But let's talk about representing, not just zeros and ones,
但让我们谈谈如何表示，不仅仅是零和一，

141
00:07:02,010 --> 00:07:03,930
and black and white, but actual colors.
还有黑色和白色，而是实际的颜色。

142
00:07:03,930 --> 00:07:06,630
And so recall from week zero when we talked
所以，还记得我们在第零周讲到的

143
00:07:06,630 --> 00:07:09,120
about how to represent information, colors among,
关于如何表示信息，包括颜色，

144
00:07:09,120 --> 00:07:12,850
them we introduced RGB, which stands for red, green, blue.
我们介绍了RGB，代表红色、绿色、蓝色。

145
00:07:12,850 --> 00:07:15,600
And it's just this kind of convention of using some amount of red,
它只是使用一定量的红色，的一种约定，

146
00:07:15,600 --> 00:07:18,660
some amount of green, and some amount of blue mixed together to give you
绿色和蓝色的混合量，混合在一起就能得到

147
00:07:18,660 --> 00:07:20,895
the actual color that you want.
你想要的实际颜色。

148
00:07:20,895 --> 00:07:22,770
Well, it turns out in the world of computers,
事实证明，在计算机的世界里，

149
00:07:22,770 --> 00:07:27,460
there's a standard way for describing those amounts of red, green, and blue.
有一种标准的方式来描述红、绿、蓝的这些量。

150
00:07:27,460 --> 00:07:29,460
At the end of the day, it's of course just bits.
最终，它只是位。

151
00:07:29,460 --> 00:07:33,040
And equivalently, it's just numbers, like 72, 73,
同样，它也只是一些数字，例如72，73，

152
00:07:33,040 --> 00:07:37,180
33 was the arbitrary example we used in week zero for the color yellow.
33是我们在第零周中使用的黄色颜色示例。

153
00:07:37,180 --> 00:07:40,500
But there actually tends to be a different notation by convention
但实际上，按照惯例，通常会有一种不同的表示法

154
00:07:40,500 --> 00:07:43,320
for representing colors that we'll actually see today, too,
来表示我们今天要看到的颜色，

155
00:07:43,320 --> 00:07:45,160
as we explore the world of memory.
当我们探索内存的世界时。

156
00:07:45,160 --> 00:07:46,958
So here's a screenshot of Photoshop.
这是Photoshop的截图。

157
00:07:46,958 --> 00:07:49,500
If you've never used it before, this is like the color picker
如果你以前从未使用过它，它就像颜色选择器

158
00:07:49,500 --> 00:07:52,620
that you can pull up, just to pick any number of millions of colors
你可以调出来，用来选择数百万种颜色中的任意一种

159
00:07:52,620 --> 00:07:54,750
by clicking and dragging, or typing in numbers.
通过单击和拖动，或者输入数字。

160
00:07:54,750 --> 00:07:56,190
But notice down here.
但请注意这里。

161
00:07:56,190 --> 00:07:58,680
We've picked at the moment the color black by moving
我们现在选择了黑色，方法是移动

162
00:07:58,680 --> 00:08:01,480
the slider all the way down here to the bottom left hand corner.
滑块到左下角。

163
00:08:01,480 --> 00:08:03,480
And what this user interface is telling us
这个用户界面告诉我们

164
00:08:03,480 --> 00:08:06,060
is that there's zero red, zero green, zero blue.
这里没有红色，没有绿色，没有蓝色。

165
00:08:06,060 --> 00:08:09,630
And a conventional way of writing this on a screen
在屏幕上写这个的传统方法是

166
00:08:09,630 --> 00:08:14,040
would be, literally, a hash symbol, and then three pairs of digits.
字面上，一个井号，然后三对数字。

167
00:08:14,040 --> 00:08:18,150
zero, zero for red, zero, zero for green, zero, zero for blue.
红色为0，0，绿色为0，0，蓝色为0，0。

168
00:08:18,150 --> 00:08:22,530
If by contrast, you were to pick the color, say, white in Photoshop,
相反，如果你在Photoshop中选择白色，

169
00:08:22,530 --> 00:08:23,580
it gets a little weird.
它就有点奇怪了。

170
00:08:23,580 --> 00:08:27,210
Now it's a lot of red, a lot of green, a lot of blue, as you might expect,
现在它有很多红色，很多绿色，很多蓝色，正如你所料，

171
00:08:27,210 --> 00:08:28,800
cranking all of those values up.
把所有这些值都调高。

172
00:08:28,800 --> 00:08:31,950
But the way you write it conventionally is not using decimal,
但你通常使用的方式不是十进制，

173
00:08:31,950 --> 00:08:34,710
but using letters of the alphabet, it would seem here.
而是使用字母，至少看起来是这样。

174
00:08:34,710 --> 00:08:38,130
So FF for red, FF, for Green, FF for blue.
所以红色是FF，绿色是FF，蓝色是FF。

175
00:08:38,130 --> 00:08:39,270
More on that in a moment.
稍后详细介绍。

176
00:08:39,270 --> 00:08:43,350
When it comes to representing red, here's a lot of red, 255.
说到红色，这里有很多红色，255。

177
00:08:43,350 --> 00:08:44,880
Zero green, zero blue.
绿色为0，蓝色为0。

178
00:08:44,880 --> 00:08:48,930
And so the pattern is now FF0000.
所以，现在模式是FF0000。

179
00:08:48,930 --> 00:08:52,740
Before I reveal what green is, what probably should it be?
在我揭示绿色是什么之前，它应该是什么？

180
00:08:52,740 --> 00:08:53,520
What pattern?
什么模式？

181
00:08:53,520 --> 00:08:56,250
Yeah.
是的。

182
00:08:56,250 --> 00:08:56,760
Close.
接近了。

183
00:08:56,760 --> 00:09:04,050
Not 0000FF, but 00FF00 because it seems to be following this pattern, indeed,
不是0000FF，而是00FF00，因为它似乎确实遵循了这种模式，

184
00:09:04,050 --> 00:09:05,940
from left to right of red, green, blue.
从左到右，分别是红色，绿色，蓝色。

185
00:09:05,940 --> 00:09:11,190
So zero red, 255 green, zero blue, and thus 00FF00.
所以是红色为0，绿色为255，蓝色为0，因此是00FF00。

186
00:09:11,190 --> 00:09:15,150
And then lastly, if we do solid blue, it's zero red, zero green,
最后，如果我们选择纯蓝色，那就是红色为0，绿色为0，

187
00:09:15,150 --> 00:09:18,660
a lot of blue, and thus 0000FF.
很多蓝色，因此是0000FF。

188
00:09:18,660 --> 00:09:24,712
So somehow or other, FF is apparently representing the number 255.
所以，FF似乎以某种方式代表了数字255。

189
00:09:24,712 --> 00:09:26,170
And we'll see why in just a moment.
我们会马上看到原因。

190
00:09:26,170 --> 00:09:27,920
But recall that in the world of computers,
但请记住，在计算机的世界里，

191
00:09:27,920 --> 00:09:29,430
they just speak zeros and ones.
它们只说0和1。

192
00:09:29,430 --> 00:09:31,872
And we've seen that already in black and white form.
我们在黑白形式中已经看到了这一点。

193
00:09:31,872 --> 00:09:34,830
We of course, in the real world, tend to use decimal instead of binary.
当然，在现实世界中，我们倾向于使用十进制而不是二进制。

194
00:09:34,830 --> 00:09:38,400
So we have 10 digits at our disposal, zero through nine.
所以我们有 10 个数字可以使用，从零到九。

195
00:09:38,400 --> 00:09:42,130
But it turns out that in the world of graphics and colors,
但事实证明，在图形和颜色领域，

196
00:09:42,130 --> 00:09:44,430
turns out in the world of computer memory,
事实证明，在计算机内存领域，

197
00:09:44,430 --> 00:09:48,480
it tends to be convenient not to use binary, per se, not to use decimal,
它往往更方便，不使用二进制，严格来说，也不使用十进制，

198
00:09:48,480 --> 00:09:50,880
per se, but to use something called hexadecimal,
而是使用一种叫做十六进制的东西，

199
00:09:50,880 --> 00:09:54,480
where as soon as you need more than 10 digits total,
当您需要超过 10 个数字时，

200
00:09:54,480 --> 00:09:56,460
you start stealing from the English alphabet.
就开始从英文字母表中偷取。

201
00:09:56,460 --> 00:09:58,950
So the next few numbers, or digits rather,
所以接下来的几个数字，或者更确切地说是数字，

202
00:09:58,950 --> 00:10:04,080
are A, B, C, D, E, F. And there's other systems that
是 A、B、C、D、E、F。 还有其他系统，

203
00:10:04,080 --> 00:10:06,720
use even more letters of the alphabet, but this is probably
使用更多字母表中的字母，但这可能是

204
00:10:06,720 --> 00:10:08,680
the last we'll discuss in any detail.
我们将详细讨论的最后一个。

205
00:10:08,680 --> 00:10:12,750
So in this case, we have a total of 10 plus one, two, three, four, five,
所以在这个例子中，我们总共有 10 加上 1、2、3、4、5，

206
00:10:12,750 --> 00:10:15,180
six, so 16 total, a.k.a.
六，所以总共有 16 个，也就是

207
00:10:15,180 --> 00:10:18,262
hexadecimal, or what we might call base 16.
十六进制，或者我们可以称之为 16 进制。

208
00:10:18,262 --> 00:10:20,220
And the capitalization actually doesn't matter.
而且大小写实际上并不重要。

209
00:10:20,220 --> 00:10:22,825
It's conventional to use uppercase or lowercase,
通常使用大写或小写，

210
00:10:22,825 --> 00:10:24,450
so long as you're generally consistent.
只要你大体上保持一致。

211
00:10:24,450 --> 00:10:26,710
So hexa, implying 16, decimal.
所以 hexa，表示 16，十进制。

212
00:10:26,710 --> 00:10:30,360
So hexadecimal notation here, or otherwise known as base 16,
所以这里的十六进制表示法，或者也称为 16 进制，

213
00:10:30,360 --> 00:10:34,440
for mathematical reasons that go back to our discussion in week zero.
因为数学原因，可以追溯到我们第零周的讨论。

214
00:10:34,440 --> 00:10:37,500
So here's some of that same reasoning from week zero.
所以这里是一些来自第零周的相同推理。

215
00:10:37,500 --> 00:10:40,350
How might we go about representing using two
我们如何使用两个

216
00:10:40,350 --> 00:10:44,980
digits in hexadecimal, different numbers that you and I know as decimal?
十六进制数字，你和我所知道的不同的十进制数字？

217
00:10:44,980 --> 00:10:49,925
Well, if we consider this as being the 16 to the zeros place, 16
好吧，如果我们认为这是 16 的零位，16

218
00:10:49,925 --> 00:10:52,300
to the ones place, and if we do out that math, of course,
到一位，如果我们把这个算出来，当然，

219
00:10:52,300 --> 00:10:54,730
that gives us the ones place and the sixteens place.
这给了我们一位和十六位。

220
00:10:54,730 --> 00:10:57,750
So we've only changed the base, not the story from week zero.
所以我们只改变了进制，而不是第零周的故事。

221
00:10:57,750 --> 00:11:01,680
So if we were to start representing actual values in hexadecimal,
所以如果我们开始用十六进制表示实际值，

222
00:11:01,680 --> 00:11:03,930
here are two zeros.
这里有两个零。

223
00:11:03,930 --> 00:11:07,530
So that's 1 times 0 plus 16 times 0, which, of course, gives us
所以这是 1 乘以 0 加上 16 乘以 0，这当然给了我们

224
00:11:07,530 --> 00:11:08,970
the number you and I know is zero.
你我所知道的数字是零。

225
00:11:08,970 --> 00:11:12,030
So in hexadecimal, and in binary, and in decimal, it's
所以在十六进制、二进制和十进制中，它都是

226
00:11:12,030 --> 00:11:15,030
the same way to represent the number you and I know as zero.
用相同的方式表示你我所知道的数字零。

227
00:11:15,030 --> 00:11:17,640
But here now is the number one in hexadecimal.
但这里现在是十六进制中的数字 1。

228
00:11:17,640 --> 00:11:18,930
Here's the number two.
这里是数字 2。

229
00:11:18,930 --> 00:11:24,340
Here's the number three, four, five, six, seven, eight, nine.
这里是数字 3、4、5、6、7、8、9。

230
00:11:24,340 --> 00:11:28,120
So it's identical up until this point to our world of decimal.
所以它一直到这一点都与我们的十进制世界相同。

231
00:11:28,120 --> 00:11:32,590
But how do I count up to what you and I would call 10 in decimal,
但是我如何计数到我们称为十进制的 10 呢，

232
00:11:32,590 --> 00:11:36,130
according to what we're seeing here thus far?
根据我们目前看到的？

233
00:11:36,130 --> 00:11:36,640
Yeah.
是的。

234
00:11:36,640 --> 00:11:39,970
So now it goes up to A, because A would, apparently,
所以现在它上升到 A，因为 A 显然，

235
00:11:39,970 --> 00:11:41,940
represent what you and I know as 10.
表示我们所知道的 10。

236
00:11:41,940 --> 00:11:43,420
B represents 11.
B 代表 11。

237
00:11:43,420 --> 00:11:47,740
C represents 12, 13, 14, 15.
C 代表 12、13、14、15。

238
00:11:47,740 --> 00:11:50,890
How, though, do I count up to 16?
但是，我如何计数到 16 呢？

239
00:11:50,890 --> 00:11:52,330
Yeah.
是的。

240
00:11:52,330 --> 00:11:53,080
Exactly.
正是。

241
00:11:53,080 --> 00:11:56,320
So not 10, quote unquote, but one, zero because the one
所以不是 10，打引号，而是 1，0，因为这个 1

242
00:11:56,320 --> 00:11:59,920
in the second column here to the left actually represents the sixteens place.
在左边第二列实际上表示十六位。

243
00:11:59,920 --> 00:12:05,180
So it's 16 times 1 gives you 16, plus 1 times 0 gives you 0, so 16 in total.
所以，16 乘以 1 等于 16，加上 1 乘以 0 等于 0，总共是 16。

244
00:12:05,180 --> 00:12:09,350
So this now is the way the number you and I would think of as 17,
所以，这个现在是您和我认为的 17，

245
00:12:09,350 --> 00:12:13,990
18, 19, 20, 21, dot, dot, dot.
18，19，20，21，等等。

246
00:12:13,990 --> 00:12:16,690
And if we go all the way up, as high up as we
如果我们一直往上走，尽可能高，

247
00:12:16,690 --> 00:12:20,450
can count, well, what's the largest digit, apparently, in hexadecimal?
可以计数，那么十六进制中最大的数字是什么？

248
00:12:20,450 --> 00:12:23,980
The smallest is clearly zero, and the biggest I said was F.
最小的显然是零，而我说的最大是 F。

249
00:12:23,980 --> 00:12:26,680
So once you get to FF, the math gets a little annoying.
所以一旦你到了 FF，数学就有点烦人了。

250
00:12:26,680 --> 00:12:33,250
But this is now 16 times 15 plus 1 times 15.
但现在是 16 乘以 15 加上 1 乘以 15。

251
00:12:33,250 --> 00:12:37,820
And what that gives us, actually, is the number you and I know as 255.
而这实际上给了我们一个数字，我们知道它是 255。

252
00:12:37,820 --> 00:12:39,045
So we saw it in Photoshop.
我们在 Photoshop 中看到了它。

253
00:12:39,045 --> 00:12:40,420
We've seen it now in hexadecimal.
我们现在在十六进制中看到了它。

254
00:12:40,420 --> 00:12:42,545
This is not math that you would ever do frequently,
这不是你经常会做的数学运算，

255
00:12:42,545 --> 00:12:45,610
but indeed, it's the exact same system as week zero,
但事实上，它与第零周的系统完全相同，

256
00:12:45,610 --> 00:12:46,930
just with a different base.
只是底数不同。

257
00:12:46,930 --> 00:12:48,890
But why all of this additional complexity?
但为什么会有如此多的复杂性？

258
00:12:48,890 --> 00:12:51,640
Why are we jumping through these hoops introducing yet another one
为什么我们要跳过这些障碍，引入另一个

259
00:12:51,640 --> 00:12:54,370
to give us just some pattern like this of FF?
来给我们提供像 FF 这样的模式？

260
00:12:54,370 --> 00:12:57,070
Well, it turns out that hexadecimal is just convenient.
事实证明，十六进制只是很方便。

261
00:12:57,070 --> 00:12:57,640
Why?
为什么？

262
00:12:57,640 --> 00:13:00,400
Well, if you have 16 digits in your alphabet,
好吧，如果你的字母表中有 16 个数字，

263
00:13:00,400 --> 00:13:04,450
zero through F, how many bits, how many zeros and ones
从零到 F，你需要多少位，多少个零和一

264
00:13:04,450 --> 00:13:09,330
do you need to represent 16 different values?
来表示 16 个不同的值？

265
00:13:09,330 --> 00:13:10,520
It's four, right?
是四个，对吧？

266
00:13:10,520 --> 00:13:14,210
Because if you've got four bits, that's two possibilities for the first times
因为如果你有四位，那就是第一个位的两种可能性乘以

267
00:13:14,210 --> 00:13:16,070
2, times 2, times 2.
2，乘以 2，乘以 2。

268
00:13:16,070 --> 00:13:17,660
So that's 16 possibilities.
所以有 16 种可能性。

269
00:13:17,660 --> 00:13:18,900
2 to the fourth power.
2 的四次方。

270
00:13:18,900 --> 00:13:22,190
And if you've got four bits represented by a single digit,
如果你用一个数字表示四位，

271
00:13:22,190 --> 00:13:25,970
it's just convenient in practice for computer scientists and programmers.
对于计算机科学家和程序员来说，在实践中这只是很方便。

272
00:13:25,970 --> 00:13:29,000
So F might indeed represent 1111.
所以 F 可能确实代表 1111。

273
00:13:29,000 --> 00:13:31,280
But that's not a full byte, which is eight bits.
但这不是一个完整的字节，而是一个字节是八位。

274
00:13:31,280 --> 00:13:33,950
And no one counts in units of four in computing.
在计算中，没有人用四位为单位计数。

275
00:13:33,950 --> 00:13:38,790
It's always in units of, like, eight, or 16, or 32, or 64, or the like.
它总是以八位、十六位、三十二位或六十四位为单位。

276
00:13:38,790 --> 00:13:42,110
So it turns out, though, because hexadecimal lends itself
所以事实证明，由于十六进制适合

277
00:13:42,110 --> 00:13:46,070
to representing four bits at a time, well, if you just use two of them,
一次表示四位，如果你只使用两个，

278
00:13:46,070 --> 00:13:47,960
you can represent eight bits at a time.
你可以一次表示八位。

279
00:13:47,960 --> 00:13:51,560
And eight bits is a byte, which is a common unit of measure.
八位是一个字节，这是一个常用的计量单位。

280
00:13:51,560 --> 00:13:56,270
And this is why even Photoshop uses this convention, as do color programs,
这就是为什么即使 Photoshop 也使用这种约定，颜色程序也是如此，

281
00:13:56,270 --> 00:14:01,040
as does web development, more generally, of using two hexadecimal digits just
web 开发也是如此，更普遍的是，使用两个十六进制数字来表示

282
00:14:01,040 --> 00:14:02,895
to represent single bytes.
单个字节。

283
00:14:02,895 --> 00:14:06,020
Because the one on the left represents the first bits, the first four bits.
因为左边的那个代表第一个位，前四个位。

284
00:14:06,020 --> 00:14:08,250
The one on the right represents the second four bits.
右边的那个代表第二个四个位。

285
00:14:08,250 --> 00:14:10,020
So it's not a big deal, per se.
所以它本身不是什么大事。

286
00:14:10,020 --> 00:14:14,040
It's just convenient, even though this might feel like a lot all at once.
这只是很方便，即使这可能感觉一下子很多。

287
00:14:14,040 --> 00:14:18,000
Any questions then on hexadecimal?
那么关于十六进制还有问题吗？

288
00:14:18,000 --> 00:14:20,370
Yeah, in the middle.
是的，在中间。

289
00:14:20,370 --> 00:14:21,690
No.
没有。

290
00:14:21,690 --> 00:14:22,680
OK, no.
好的，没有。

291
00:14:22,680 --> 00:14:24,480
Questions on hexadecimal.
关于十六进制的问题。

292
00:14:24,480 --> 00:14:25,380
All right.
好的。

293
00:14:25,380 --> 00:14:32,220
So with this system in mind, let's go about considering where else we might
考虑到这个系统，让我们来考虑一下，我们还可以在哪里

294
00:14:32,220 --> 00:14:34,110
see this in the computing world.
在计算机领域看到它。

295
00:14:34,110 --> 00:14:37,320
And I would propose that we consider, as we've done in the past,
我建议我们考虑，就像我们过去所做的那样，

296
00:14:37,320 --> 00:14:40,420
that our computer is really just this grid of memory, for instance,
我们的计算机实际上只是一个内存网格，例如，

297
00:14:40,420 --> 00:14:42,990
where each of these squares represents a single byte.
其中每个方块代表一个字节。

298
00:14:42,990 --> 00:14:45,660
And I proposed a couple of times already that, when
我已经提出过几次，当

299
00:14:45,660 --> 00:14:47,580
we talk about a computer's memory, we can
我们谈论计算机的内存时，我们可以

300
00:14:47,580 --> 00:14:50,970
think of them as each of these squares as having an individual location.
将它们想象成每个方块都有一个单独的位置。

301
00:14:50,970 --> 00:14:53,850
Like, I spitballed back in the day that maybe this is the first byte,
就像我以前随口说的一样，也许这是第一个字节，

302
00:14:53,850 --> 00:14:55,350
the second byte, the third byte.
第二个字节，第三个字节。

303
00:14:55,350 --> 00:14:57,840
Maybe this is the billionth byte, so we can number
也许这是十亿字节，所以我们可以对

304
00:14:57,840 --> 00:14:59,670
of the bytes inside of a computer.
计算机内的字节进行编号。

305
00:14:59,670 --> 00:15:02,040
Well, it turns out, as we'll see today in code,
事实证明，正如我们今天将在代码中看到的那样，

306
00:15:02,040 --> 00:15:06,330
computers typically use numbers, indeed, to represent
计算机通常使用数字，实际上，来表示

307
00:15:06,330 --> 00:15:08,880
all of the bytes in their memory, and they typically
内存中的所有字节，并且它们通常

308
00:15:08,880 --> 00:15:11,740
use hexadecimal notation for such by convention.
按照惯例使用十六进制表示法。

309
00:15:11,740 --> 00:15:12,900
So what do I mean by that?
我的意思是什么？

310
00:15:12,900 --> 00:15:15,000
Technically, if we were to start numbering these
从技术上讲，如果我们要开始对这些

311
00:15:15,000 --> 00:15:17,190
and count at zero, as most programmers would,
进行编号，并且从零开始计数，正如大多数程序员会做的那样，

312
00:15:17,190 --> 00:15:19,960
this is byte zero, one, two, three, dot, dot, dot.
这是字节零、一、二、三，等等。

313
00:15:19,960 --> 00:15:21,580
This is byte 15.
这是字节 15。

314
00:15:21,580 --> 00:15:25,060
But if I wanted to keep going, it would be then 16, 17, 18,
但如果我想继续下去，那将是 16、17、18，

315
00:15:25,060 --> 00:15:27,560
but that's not the true in hexadecimal.
但这在十六进制中并不正确。

316
00:15:27,560 --> 00:15:30,040
So instead in hexadecimal, once you hit the nine,
因此，在十六进制中，一旦你达到九，

317
00:15:30,040 --> 00:15:33,160
you'd actually use A through F, just as I've proposed.
你实际上会使用 A 到 F，正如我提出的那样。

318
00:15:33,160 --> 00:15:37,270
Meanwhile, if you kept going thereafter, you would have one zero.
同时，如果你继续下去，你将有一个零。

319
00:15:37,270 --> 00:15:39,010
But as you noted, this is not 10.
但正如你指出的，这不是 10。

320
00:15:39,010 --> 00:15:44,270
This is 16 here, 17, 18, 19.
这是 16，17、18、19。

321
00:15:44,270 --> 00:15:46,250
And so here's where things get a little weird.
所以，事情在这里变得有点奇怪。

322
00:15:46,250 --> 00:15:47,680
I'm saying 16.
我说的是 16。

323
00:15:47,680 --> 00:15:51,460
I'm saying 17, and you're obviously seeing what any reasonable person would
我说的是 17，很明显，你会看到任何一个理性的人都会

324
00:15:51,460 --> 00:15:53,200
read as 10 and 11.
读作 10 和 11。

325
00:15:53,200 --> 00:15:56,170
So there's this dichotomy, and so we need some convention
所以，存在这种二分法，因此我们需要一些约定

326
00:15:56,170 --> 00:15:59,690
for making clear to the reader that these are hexadecimal numbers, not
让读者清楚地知道这些是十六进制数字，而不是

327
00:15:59,690 --> 00:16:00,190
decimal.
十进制。

328
00:16:00,190 --> 00:16:01,960
Otherwise, it's completely ambiguous.
否则，它完全是模棱两可的。

329
00:16:01,960 --> 00:16:04,877
And the convention there, which you might have seen in the real world,
那里的约定，你可能已经在现实世界中见过，

330
00:16:04,877 --> 00:16:09,215
even though it's a bit weird, is just to prefix hexadecimal numbers with zero X.
尽管有点奇怪，但只是在十六进制数字前面加上零 X。

331
00:16:09,215 --> 00:16:10,840
It's not doing anything mathematically.
它在数学上没有做任何事情。

332
00:16:10,840 --> 00:16:12,790
It's not multiplication or anything like that.
它不是乘法，也不是任何类似的东西。

333
00:16:12,790 --> 00:16:17,380
Just zero X means, here comes a hexadecimal number hereafter, just
只是零 X 表示，接下来将是一个十六进制数字，只是

334
00:16:17,380 --> 00:16:20,170
to distinguish it from decimal.
为了将其与十进制区分开来。

335
00:16:20,170 --> 00:16:24,190
And you can see that, even though we don't have enough room for 255 bytes,
你可以看到，即使我们没有足够的空间容纳 255 个字节，

336
00:16:24,190 --> 00:16:26,482
you start to see patterns that we haven't even
你开始看到我们甚至没有

337
00:16:26,482 --> 00:16:29,440
talked about yet because we're just using those two columns as the ones
谈论过，因为我们只是将这两列作为个位

338
00:16:29,440 --> 00:16:32,620
place, the 16th place, and so forth.
位、十六位，等等。

339
00:16:32,620 --> 00:16:35,540
Capital or uppercase is fine.
大写或小写都可以。

340
00:16:35,540 --> 00:16:36,040
All right.
好的。

341
00:16:36,040 --> 00:16:39,820
So with that said, let's actually do things more technically interesting,
也就是说，让我们做一些技术上更有趣的事情，

342
00:16:39,820 --> 00:16:42,220
like looking back at some code that we've already seen
例如回顾一下我们已经看过的代码

343
00:16:42,220 --> 00:16:47,560
and seeing what we can actually glean from this newfound representation
并看看我们能从这种新发现的表示中获得什么

344
00:16:47,560 --> 00:16:48,450
of memory location.
内存位置。

345
00:16:48,450 --> 00:16:51,700
So I'm going to go over to VS Code here, where I've opened my terminal window,
所以我要去到 VS Code 这里，我已经打开了我的终端窗口，

346
00:16:51,700 --> 00:16:53,020
but no code file yet.
但还没有代码文件。

347
00:16:53,020 --> 00:16:56,470
And I'm going to go ahead and create a file called addresses.c
我要创建一个名为 addresses.c 的文件

348
00:16:56,470 --> 00:17:01,270
because I want to start playing around now with the addresses of information
因为我现在想开始玩弄信息的地址

349
00:17:01,270 --> 00:17:02,390
in my computer.
在我的电脑里。

350
00:17:02,390 --> 00:17:05,170
And to do this, let me do something super simple first.
为了做到这一点，让我先做一些超级简单的事情。

351
00:17:05,170 --> 00:17:07,480
Let me include standard io.h.
让我包含标准 io.h。

352
00:17:07,480 --> 00:17:10,490
Let me do an int main void, no command line arguments.
让我做一个 int main void，没有命令行参数。

353
00:17:10,490 --> 00:17:13,359
And then in here, let me do exactly the line of code we just saw.
然后在这里，让我做我们刚刚看到的代码行。

354
00:17:13,359 --> 00:17:18,069
Declare an int called n, set it equal to a default value of 50.
声明一个名为 n 的整型变量，将其设置为默认值 50。

355
00:17:18,069 --> 00:17:20,920
And just so that the program does something noteworthy,
为了使程序做一些值得注意的事情，

356
00:17:20,920 --> 00:17:24,339
let's have it actually print out %i backslash n,
让它打印出 %i 反斜杠 n，

357
00:17:24,339 --> 00:17:25,960
and plug-in that value of n.
并插入 n 的值。

358
00:17:25,960 --> 00:17:28,720
So this is, like, week one stuff, just creating a variable,
所以这是第一周的内容，只是创建一个变量，

359
00:17:28,720 --> 00:17:32,030
and printing out its value, just to make sure that we're on the same page.
并打印出它的值，以确保我们都在同一个页面上。

360
00:17:32,030 --> 00:17:35,800
So let me do make addresses in my terminal window, enter.
所以让我在我的终端窗口中输入 make addresses，然后回车。

361
00:17:35,800 --> 00:17:38,140
And when I do dot slash addresses, no surprise.
当我输入点斜杠 addresses 时，不出所料。

362
00:17:38,140 --> 00:17:40,780
I should indeed see the number 50.
我应该看到数字 50。

363
00:17:40,780 --> 00:17:45,200
But let's consider what that actually does inside of the computer
但是让我们考虑一下它在计算机内部实际上做了什么

364
00:17:45,200 --> 00:17:48,640
now by flipping over, for instance, to this same line of code,
现在，例如，翻到这一行代码，

365
00:17:48,640 --> 00:17:50,505
and translating it into this same grid.
并将其翻译成相同的网格。

366
00:17:50,505 --> 00:17:52,630
So here's a grid of memory, and I don't necessarily
这是一个内存网格，我不一定

367
00:17:52,630 --> 00:17:54,370
know where in the computer's memory it's going to end up.
知道它会在计算机的哪个内存位置结束。

368
00:17:54,370 --> 00:17:56,140
So I'm picking spots arbitrarily.
所以我随意选择了一些位置。

369
00:17:56,140 --> 00:18:01,120
But I know that an int, typically, is four bytes on most systems.
但我知道在一个整型变量通常在大多数系统中是四个字节。

370
00:18:01,120 --> 00:18:03,700
And so I've used one, two, three, four squares.
所以我使用了 1, 2, 3, 4 个方格。

371
00:18:03,700 --> 00:18:06,610
And the first four that I assume are available are down here,
我假设可用的前四个方格在下面，

372
00:18:06,610 --> 00:18:09,220
and I'm calling this n, and I'm putting the value 50 in it.
我将它命名为 n，并将其值设置为 50。

373
00:18:09,220 --> 00:18:13,900
So literally, when you write that line of code, int n equals 50 semicolon,
所以实际上，当您写下那行代码，int n 等于 50 分号，

374
00:18:13,900 --> 00:18:16,960
the computer's doing something like this underneath the hood.
计算机在幕后做的事情就像这样。

375
00:18:16,960 --> 00:18:20,630
Might be over here, might be over there, but I've drawn it simply down there.
可能在这里，可能在那里，但我简单地把它画在了下面。

376
00:18:20,630 --> 00:18:24,760
But that means that that 50 and that variable n,
但这意味着 50 和变量 n，

377
00:18:24,760 --> 00:18:28,790
in particular, live somewhere in the computer's memory.
尤其是在计算机的内存中。

378
00:18:28,790 --> 00:18:30,187
And where might it live?
它可能住在哪里？

379
00:18:30,187 --> 00:18:31,270
Well, I don't really know.
嗯，我真的不知道。

380
00:18:31,270 --> 00:18:34,850
And frankly, I'm not going to care, ultimately, after today.
坦率地说，今天之后，我最终不会在意。

381
00:18:34,850 --> 00:18:39,220
But let me propose that, if all of these bytes are numbered from zero on down,
但让我假设，如果所有这些字节从零开始向下编号，

382
00:18:39,220 --> 00:18:42,823
maybe this is address OX123, for the sake of discussion.
也许这个地址是 OX123，为了讨论起见。

383
00:18:42,823 --> 00:18:44,740
So it's a hexadecimal number, one, two, three.
所以它是一个十六进制数，1，2，3。

384
00:18:44,740 --> 00:18:46,240
It's not 123.
它不是 123。

385
00:18:46,240 --> 00:18:48,340
It's one, two, three, but in hexadecimal,
它是 1，2，3，但使用十六进制，

386
00:18:48,340 --> 00:18:50,140
just because it's a little easy to say.
仅仅因为它说起来容易。

387
00:18:50,140 --> 00:18:55,510
But that variable n clearly must live at some address.
但很显然，变量n必须存储在某个地址。

388
00:18:55,510 --> 00:18:57,860
So can we maybe see this?
所以我们能看到这个地址吗？

389
00:18:57,860 --> 00:19:02,710
Well, it turns out that in C, there is a bit more syntax we can introduce today
事实证明，在C语言中，我们今天可以引入更多语法

390
00:19:02,710 --> 00:19:08,770
that actually gives you access to the locations of variables
这些语法实际上可以让你访问变量的位置

391
00:19:08,770 --> 00:19:10,810
inside of the computer's memory.
在计算机内存中。

392
00:19:10,810 --> 00:19:13,000
The first of these is literally an ampersand,
第一个符号是“&”，

393
00:19:13,000 --> 00:19:15,670
and you might pronounce that the address of operator.
你可以把它称为取地址符。

394
00:19:15,670 --> 00:19:18,250
Using a single ampersand, you can actually ask the computer
使用一个“&”，你可以直接询问计算机

395
00:19:18,250 --> 00:19:19,990
at what address is this variable.
这个变量的地址在哪。

396
00:19:19,990 --> 00:19:22,330
And then the asterisk here might be known
然后这里的星号可能被称为

397
00:19:22,330 --> 00:19:25,720
as the dereference operator, which allows you to take an address
解引用运算符，它允许你获取一个地址

398
00:19:25,720 --> 00:19:28,720
and go to it, kind of like following a map.
并访问它，就像跟着地图走。

399
00:19:28,720 --> 00:19:29,620
X marks the spot.
X 标记地点。

400
00:19:29,620 --> 00:19:32,630
The star will take you to that location in memory,
星号将带你到内存中的那个位置，

401
00:19:32,630 --> 00:19:34,520
so you can see what's actually there.
这样你就可以看到那里实际存储了什么。

402
00:19:34,520 --> 00:19:35,720
So what do I mean by that?
我的意思是什么呢？

403
00:19:35,720 --> 00:19:38,770
Well, let me go back over to VS Code here, and let me go ahead
好吧，让我回到 VS Code，然后我继续

404
00:19:38,770 --> 00:19:43,070
and change my program to be ever so slightly different, as follows.
修改我的程序，使其略微不同，如下所示。

405
00:19:43,070 --> 00:19:46,870
I'm going to still declare n, just as before, to have the value of 50.
我仍然像以前一样声明 n，使其值为 50。

406
00:19:46,870 --> 00:19:49,630
But instead of printing out an integer, per se,
但我不再输出一个整数，

407
00:19:49,630 --> 00:19:51,790
I'm going to print out an address.
我要输出一个地址。

408
00:19:51,790 --> 00:19:56,380
And it turns out the format code for that, using printf, is %p.
事实证明，使用 printf 输出地址的格式代码是 %p。

409
00:19:56,380 --> 00:20:00,130
And if I want to print out now the address of n,
如果我现在想输出 n 的地址，

410
00:20:00,130 --> 00:20:02,950
recall that I have these two new capabilities, the first of which
请回忆我介绍了两种新功能，其中第一个

411
00:20:02,950 --> 00:20:03,670
is germane.
至关重要。

412
00:20:03,670 --> 00:20:07,120
The ampersand will get me the address of n.
“&” 会获取 n 的地址。

413
00:20:07,120 --> 00:20:09,970
So let me go back now to VS Code, and let me make a change,
所以现在让我回到 VS Code，并进行一个修改，

414
00:20:09,970 --> 00:20:13,150
whereby I'm going to change the %i to %p,
即将 %i 改为 %p，

415
00:20:13,150 --> 00:20:16,720
which is going to show me an address, as opposed to an integer, per se.
这样就会显示地址而不是整数。

416
00:20:16,720 --> 00:20:20,960
But I need to tell printf what address to show, so I don't want to print out n
但我需要告诉 printf 显示哪个地址，所以我不希望输出 n

417
00:20:20,960 --> 00:20:22,700
because that's literally the number 50.
因为它实际上是数字 50。

418
00:20:22,700 --> 00:20:26,640
I want to print out the address of n, like, where is it in memory.
我想要输出 n 的地址，就像，它在内存中的哪个位置。

419
00:20:26,640 --> 00:20:28,940
So here I prefix it with an ampersand.
所以这里我在它前面加上“&”。

420
00:20:28,940 --> 00:20:32,990
And now if I go back into my terminal window, make addresses again,
现在如果我回到我的终端窗口，再次运行 addresses 程序，

421
00:20:32,990 --> 00:20:34,520
dot slash addresses.
./addresses。

422
00:20:34,520 --> 00:20:37,953
I'm not going to get as lucky as seeing OX123, probably,
我可能不会像之前一样幸运地看到 OX123，

423
00:20:37,953 --> 00:20:40,370
because I got even more memory than that in this computer.
因为这台计算机的内存更大。

424
00:20:40,370 --> 00:20:44,300
But when I hit enter, I do indeed see OX something.
但当我按下回车键，我确实看到了 OX 开头的地址。

425
00:20:44,300 --> 00:20:46,940
And if I zoom in here, enhance, if you will,
如果我放大，加强，

426
00:20:46,940 --> 00:20:51,090
it happens to be at this moment in time, on this server, OX7FFC3A7CFFBC.
目前在服务器上，它恰好位于 OX7FFC3A7CFFBC。

427
00:20:54,980 --> 00:20:56,180
So it's a big address.
这是一个很大的地址。

428
00:20:56,180 --> 00:20:59,030
That's a really big number if we actually did all of the math.
如果我们真的算一下，这将是一个很大的数字。

429
00:20:59,030 --> 00:21:00,290
But who really cares?
但谁在乎呢？

430
00:21:00,290 --> 00:21:04,430
Just the fact that it exists somewhere is the only point for now.
目前唯一重要的是它存在于某个地方。

431
00:21:04,430 --> 00:21:10,670
So this %p symbol that we're passing into printf as a format code is
所以，我们传递给 printf 的这个 %p 格式代码

432
00:21:10,670 --> 00:21:15,350
leveraging the fact that C supports what are known as pointers.
利用了 C 语言支持指针这一事实。

433
00:21:15,350 --> 00:21:20,000
So a pointer is really just an address, the address of some variable
所以指针实际上只是一个地址，某个变量的地址

434
00:21:20,000 --> 00:21:24,840
that you can even store in another variable called itself a pointer.
你甚至可以将其存储在另一个名为指针的变量中。

435
00:21:24,840 --> 00:21:26,130
So what do I mean by this?
我的意思是？

436
00:21:26,130 --> 00:21:29,750
Well, if a pointer is an address, we can start to tinker with this same idea
如果指针是一个地址，我们可以开始修改这个想法

437
00:21:29,750 --> 00:21:30,390
as follows.
如下。

438
00:21:30,390 --> 00:21:33,590
Let me actually go back to VS Code once more
让我再回到 VS Code 一次

439
00:21:33,590 --> 00:21:35,940
and play around with syntax like this.
然后尝试这样的语法。

440
00:21:35,940 --> 00:21:39,890
So let me still declare a variable called n and set it equal to 50.
所以让我声明一个名为 n 的变量，并将其设置为 50。

441
00:21:39,890 --> 00:21:43,010
But let's actually create an actual pointer,
但让我们创建一个真正的指针，

442
00:21:43,010 --> 00:21:47,000
a variable whose purpose in life is not to store a boring number like 50,
一个变量，它存在的目的不是存储一个像 50 这样的无聊数字，

443
00:21:47,000 --> 00:21:49,380
but the address of some value.
而是存储某个值的地址。

444
00:21:49,380 --> 00:21:51,920
And so the syntax for that is admittedly weird.
这的语法不可否认地很奇怪。

445
00:21:51,920 --> 00:21:55,850
If you want p to be a pointer, a variable that stores an address,
如果你想让 p 成为一个指针，一个存储地址的变量，

446
00:21:55,850 --> 00:21:59,838
you literally say int star for reasons we'll sort of see.
你就得写 int star，至于为什么，我们等下会看到。

447
00:21:59,838 --> 00:22:02,630
And this is different from the star I mentioned earlier for reasons
这与我之前提到的星号不同，原因

448
00:22:02,630 --> 00:22:03,530
we'll also see soon.
我们很快就会明白。

449
00:22:03,530 --> 00:22:06,710
But int star p means, hey compiler, give me
但 int star p 的意思是，嘿编译器，给我

450
00:22:06,710 --> 00:22:12,262
a variable called p, inside of which I can store the address of an integer.
一个名为 p 的变量，我可以在其中存储一个整数的地址。

451
00:22:12,262 --> 00:22:13,970
What address do you want to put in there?
你想放哪个地址？

452
00:22:13,970 --> 00:22:16,640
Well, now I can borrow that same syntax from a moment ago.
好了，现在我可以借用刚才的语法。

453
00:22:16,640 --> 00:22:19,970
I can use ampersand n, which is going to say, hey compiler, give me-- or hey
我可以使用 &n，它会告诉编译器，嘿，给我 - 或者嘿

454
00:22:19,970 --> 00:22:23,690
computer, give me the address of n itself.
电脑，给我 n 本身的地址。

455
00:22:23,690 --> 00:22:25,580
Previously, I didn't bother with a variable.
之前，我没有使用变量。

456
00:22:25,580 --> 00:22:28,760
I just sent the address of n into printf directly.
我只是直接将 n 的地址发送到 printf。

457
00:22:28,760 --> 00:22:30,660
But I can now play with it as follows.
但我现在可以这样玩。

458
00:22:30,660 --> 00:22:32,240
Let me go back to VS Code here.
让我回到 VS Code 这里。

459
00:22:32,240 --> 00:22:33,770
I'll clear my terminal window.
我会清空我的终端窗口。

460
00:22:33,770 --> 00:22:36,510
And let's just play around with two variables.
让我们用两个变量玩玩。

461
00:22:36,510 --> 00:22:41,060
So int star p-- so it's an asterisk, but most people would say star--
所以 int star p - 它是星号，但大多数人会说星号 -

462
00:22:41,060 --> 00:22:43,760
equals the address of n.
等于 n 的地址。

463
00:22:43,760 --> 00:22:47,270
And now, I can just tweak line seven ever so slightly.
现在，我可以稍微调整一下第七行。

464
00:22:47,270 --> 00:22:50,780
Instead of printing out in duplicate ampersand n,
不用重复打印 &n，

465
00:22:50,780 --> 00:22:53,630
I can literally just pass in p for pointer.
我可以直接传入 p 来表示指针。

466
00:22:53,630 --> 00:22:56,930
So I've not done anything really that interesting, other than add a variable,
所以除了添加一个变量，我并没有做任何真正有趣的事情，

467
00:22:56,930 --> 00:22:58,940
but just to show you the syntax via which
但只是为了向你展示语法，通过它

468
00:22:58,940 --> 00:23:01,400
you can create a variable whose purpose in life
你可以创建一个变量，它存在的目的是

469
00:23:01,400 --> 00:23:03,170
is to store one of these addresses.
存储这些地址之一。

470
00:23:03,170 --> 00:23:08,180
So let me go ahead and now and do make addresses once more.
所以让我继续，现在，再次运行 make addresses。

471
00:23:08,180 --> 00:23:09,320
Dot slash addresses.
./addresses

472
00:23:09,320 --> 00:23:13,760
And we should see, indeed, pretty much the same idea, the address
我们应该看到，确实，基本相同的思路，n 所处的地址

473
00:23:13,760 --> 00:23:19,850
at which n happens to be, now that I've recompiled and actually run my code.
现在我已经重新编译并运行了我的代码。

474
00:23:19,850 --> 00:23:22,550
But it gets a little more interesting than that.
但比这更有趣。

475
00:23:22,550 --> 00:23:26,000
I can do one more thing when it comes to my computer's memory.
在计算机内存方面，我还可以做一件事。

476
00:23:26,000 --> 00:23:29,840
In VS Code here, let me clear my terminal again, and let me see
在 VS Code 这里，让我再次清空终端，然后让我看看

477
00:23:29,840 --> 00:23:32,840
if I can perhaps reverse this process.
我是否可以反转这个过程。

478
00:23:32,840 --> 00:23:38,120
If n is 50, and p is storing the address of n,
如果 n 是 50，p 存储 n 的地址，

479
00:23:38,120 --> 00:23:43,880
wouldn't it be interesting if I could somehow express, go to the address of n
如果我可以通过某种方式表示，转到 n 的地址，那不是很酷吗？

480
00:23:43,880 --> 00:23:45,500
and tell me what is there.
并告诉我那里有什么。

481
00:23:45,500 --> 00:23:48,770
So to do that, I'm just kind of undoing all of the intellectual work
所以要做到这一点，我只是在取消所有智力工作

482
00:23:48,770 --> 00:23:49,470
I'm doing here.
我在做的。

483
00:23:49,470 --> 00:23:53,480
But if I want to print out an integer at some location, I can go back to %i,
但如果我想在某个位置打印一个整数，我可以回到 %i，

484
00:23:53,480 --> 00:23:55,400
just print an integer as always.
像往常一样打印一个整数。

485
00:23:55,400 --> 00:23:58,670
But p now is storing the address of someplace.
但现在 p 存储的是某个地方的地址。

486
00:23:58,670 --> 00:24:00,600
It is the treasure map, so to speak.
可以这么说，它就是藏宝图。

487
00:24:00,600 --> 00:24:02,840
So if I want to go where X marks the spot,
所以如果我想去 X 标记的地方，

488
00:24:02,840 --> 00:24:07,490
the syntax for that I claimed a moment ago is star p.
我刚才提到的语法是星号 p。

489
00:24:07,490 --> 00:24:09,980
So star p means go to that address.
所以星号 p 表示转到那个地址。

490
00:24:09,980 --> 00:24:12,230
Don't print the address, go to that address,
不要打印地址，转到那个地址，

491
00:24:12,230 --> 00:24:15,450
and show me what's inside of the computer's memory there.
然后向我展示那里计算机内存中的内容。

492
00:24:15,450 --> 00:24:18,410
So now, if I go into my terminal and do make addresses,
所以现在，如果我进入我的终端并创建地址，

493
00:24:18,410 --> 00:24:22,580
and do dot slash addresses, what should I see on the screen when I hit enter?
然后执行点斜杠地址，当我按下回车键时，我应该在屏幕上看到什么？

494
00:24:22,580 --> 00:24:23,630
50.
50。

495
00:24:23,630 --> 00:24:26,060
So I indeed see now 50.
所以我确实看到了 50。

496
00:24:26,060 --> 00:24:29,600
Now, here's where it's an unfortunate choice of syntax
现在，这就是 C 语言作者几十年前不幸的选择语法

497
00:24:29,600 --> 00:24:32,120
from the authors of C decades ago.
的地方。

498
00:24:32,120 --> 00:24:34,713
Clearly, I'm using star in two different locations.
很明显，我在两个不同的位置使用星号。

499
00:24:34,713 --> 00:24:37,130
And suffice it to say, it doesn't represent multiplication
我只能说，它并不代表乘法

500
00:24:37,130 --> 00:24:37,880
in either of them.
在任何一个中。

501
00:24:37,880 --> 00:24:40,190
It's being used to represent addresses somehow.
它以某种方式被用来表示地址。

502
00:24:40,190 --> 00:24:44,750
When, on line six, I specify a data type like int,
当我在第六行指定一个像 int 这样的数据类型时，

503
00:24:44,750 --> 00:24:47,330
and then I have a star, and then the name of a variable,
然后我有一个星号，然后是一个变量的名称，

504
00:24:47,330 --> 00:24:51,470
that is the syntax for declaring a pointer, for declaring
这就是声明指针的语法，用来声明

505
00:24:51,470 --> 00:24:53,690
a variable that will store an address.
一个将存储地址的变量。

506
00:24:53,690 --> 00:24:54,530
What address?
什么地址？

507
00:24:54,530 --> 00:24:57,440
Well, ampersand n, whatever that is, OX something.
嗯，&n，无论是什么，都是 0X 某样东西。

508
00:24:57,440 --> 00:25:03,590
When you do a star and then the name of a pointer without specifying a type,
当你使用一个星号，然后是一个指针的名称，而没有指定类型时，

509
00:25:03,590 --> 00:25:05,670
this just means, go there.
这只是意味着，去那里。

510
00:25:05,670 --> 00:25:09,530
So the star clearly is related to addresses.
所以星号显然与地址有关。

511
00:25:09,530 --> 00:25:11,322
It's unfortunate that it's the same symbol.
不幸的是，它使用的是同一个符号。

512
00:25:11,322 --> 00:25:13,947
It would have been nice if they picked maybe a different symbol
如果他们选择了可能不同的符号就好了

513
00:25:13,947 --> 00:25:14,660
of punctuation.
的标点符号。

514
00:25:14,660 --> 00:25:17,090
But they mean slightly different things in that context.
但在那种情况下，它们的含义略有不同。

515
00:25:17,090 --> 00:25:19,460
On line six, we're declaring the pointer,
在第六行，我们声明了指针，

516
00:25:19,460 --> 00:25:23,910
declaring a variable called p that's going to point to an integers location.
声明一个名为 p 的变量，它将指向一个整数的位置。

517
00:25:23,910 --> 00:25:28,230
But when I say star p, that means go to that actual location.
但当我使用星号 p 时，这意味着转到那个实际位置。

518
00:25:28,230 --> 00:25:32,430
So just try to keep that in mind, even though it's ever so slightly subtly
所以试着记住这一点，即使它非常细微地略有不同

519
00:25:32,430 --> 00:25:33,070
different.
。

520
00:25:33,070 --> 00:25:36,060
So what's going on then inside of the computer's actual memory?
那么计算机的实际内存中发生了什么呢？

521
00:25:36,060 --> 00:25:38,320
Well, let's consider that in pictorial form again.
好吧，让我们再次以图示形式考虑这个问题。

522
00:25:38,320 --> 00:25:41,370
So even though I've written the pointer in this way,
所以尽管我以这种方式写了指针，

523
00:25:41,370 --> 00:25:45,740
int then a space, then star p equals ampersand n semicolon, that
int 然后是一个空格，然后是星号 p 等于 &n 分号，那就是

524
00:25:45,740 --> 00:25:46,740
is the conventional way.
传统的方法。

525
00:25:46,740 --> 00:25:49,157
That's how you'll see it on most websites, most textbooks.
这就是你在大多数网站、大多数教科书上看到的方式。

526
00:25:49,157 --> 00:25:51,990
Technically speaking, I will admit that it might actually
严格地说，我承认它实际上

527
00:25:51,990 --> 00:25:54,630
be easier to understand if you actually move
更容易理解，如果你真的移动

528
00:25:54,630 --> 00:25:57,990
the asterisk a little to the left, because this makes, visually,
星号稍微向左一点，因为这样从视觉上来说，

529
00:25:57,990 --> 00:26:03,570
I think, it even more clear that int star is the type of the variable p, as
我认为，更清楚的是，int star 是变量 p 的类型，因为

530
00:26:03,570 --> 00:26:06,970
opposed to the star being somehow attached to the variable name itself.
与星号以某种方式附加到变量名本身相反。

531
00:26:06,970 --> 00:26:10,050
However, you might also see it written with a space on either side, which
然而，你可能也看到它在两边都用空格写，这

532
00:26:10,050 --> 00:26:11,467
I don't think really helps anyone.
我认为对任何人都没有帮助。

533
00:26:11,467 --> 00:26:14,640
But the point is that white space does not matter in this context.
但关键是空格在这个上下文中并不重要。

534
00:26:14,640 --> 00:26:17,880
And the conventional way is to do it by prefixing
而常规的做法是用星号作为前缀

535
00:26:17,880 --> 00:26:19,320
the variable's name with the star.
变量名。

536
00:26:19,320 --> 00:26:21,390
And this avoids getting into trouble when you
这样可以避免你在

537
00:26:21,390 --> 00:26:23,470
declare multiple variables at a time.
一次声明多个变量时遇到麻烦。

538
00:26:23,470 --> 00:26:26,970
But if it helps you to think about it, you can think of it as int star
但如果你觉得这样更容易理解，你可以把它想象成 int star

539
00:26:26,970 --> 00:26:28,410
as being the type.
作为类型。

540
00:26:28,410 --> 00:26:30,970
It's not just an int, per se.
它不仅仅是一个 int，本身而言。

541
00:26:30,970 --> 00:26:34,890
So with that said, let's consider now the canvas of computer's memory inside
因此，现在让我们考虑计算机内存的画布，其中

542
00:26:34,890 --> 00:26:36,930
of which we're storing n, and now, p.
我们存储着 n，现在是 p。

543
00:26:36,930 --> 00:26:39,840
So previously, I proposed that n is maybe, yeah,
所以之前，我建议 n 可能，是的，

544
00:26:39,840 --> 00:26:42,670
maybe it's done in the bottom right hand corner of the screen.
可能它是在屏幕的右下角完成的。

545
00:26:42,670 --> 00:26:45,660
So n is storing the number 50 here.
所以 n 这里存储着数字 50。

546
00:26:45,660 --> 00:26:47,460
But technically, n lives somewhere.
但从技术上讲，n 存在于某个地方。

547
00:26:47,460 --> 00:26:51,720
And for simplicity, I'm going to claim it's at OX123, rather than the bigger
为了简单起见，我将声称它在 OX123，而不是我们刚才看到的更大的

548
00:26:51,720 --> 00:26:53,290
actual address we just saw.
实际地址。

549
00:26:53,290 --> 00:26:54,660
But what about p?
但 p 又如何呢？

550
00:26:54,660 --> 00:26:58,530
Well, p itself is another variable that I declared separately,
嗯，p 本身是另一个我单独声明的变量，

551
00:26:58,530 --> 00:27:01,090
so it's got to live somewhere in the computer's memory.
所以它必须存在于计算机内存的某个地方。

552
00:27:01,090 --> 00:27:05,460
And it turns out, by convention, pointers take up more space.
事实证明，按照惯例，指针占用的空间更大。

553
00:27:05,460 --> 00:27:09,150
They typically use eight bytes nowadays, rather than just four.
如今，它们通常使用八个字节，而不是四个。

554
00:27:09,150 --> 00:27:09,720
Why is that?
为什么呢？

555
00:27:09,720 --> 00:27:11,910
Well, if you've got eight bytes, you can count even higher.
嗯，如果你有八个字节，你可以数到更高的数字。

556
00:27:11,910 --> 00:27:13,050
You can have even more addresses.
你可以拥有更多地址。

557
00:27:13,050 --> 00:27:15,660
You can have more memory in your Mac, your PC, and phone.
你的 Mac、PC 和手机可以拥有更多的内存。

558
00:27:15,660 --> 00:27:16,630
That's a good thing.
这是好事。

559
00:27:16,630 --> 00:27:18,870
So pointers tend to be eight bytes, which
所以指针往往是八个字节，这

560
00:27:18,870 --> 00:27:21,900
is why I've used eight squares on the screen here.
是我在这里使用屏幕上的八个方块的原因。

561
00:27:21,900 --> 00:27:25,050
But what is actually p storing?
但 p 实际上存储的是什么？

562
00:27:25,050 --> 00:27:27,300
Well, it's just storing a number.
嗯，它只是存储着一个数字。

563
00:27:27,300 --> 00:27:29,610
Yes, it's technically an integer, but that integer
是的，从技术上讲它是一个整数，但那个整数

564
00:27:29,610 --> 00:27:34,900
is itself should be thought of as the address of some other value.
本身应该被认为是某个其他值的地址。

565
00:27:34,900 --> 00:27:39,380
So n is down here at OX123. p is up here at who knows what address.
所以 n 在下面的 OX123。p 在上面的某个不知道地址的地方。

566
00:27:39,380 --> 00:27:41,130
Doesn't matter for the sake of discussion,
为了讨论的目的，这并不重要，

567
00:27:41,130 --> 00:27:46,050
but its value, what it's storing with its pattern of 64 bits
但它的值，它用 64 位模式存储的东西

568
00:27:46,050 --> 00:27:49,200
is apparently OX123.
显然是 OX123。

569
00:27:49,200 --> 00:27:51,070
So how does this help us?
那么这如何帮助我们呢？

570
00:27:51,070 --> 00:27:54,032
Well, if you think about this a little more abstractly, who
嗯，如果你更抽象地思考一下，谁

571
00:27:54,032 --> 00:27:56,490
cares about what else is going on in the computer's memory?
关心计算机内存中其他发生了什么？

572
00:27:56,490 --> 00:27:59,317
It actually tends to be helpful to think about this pictorially
实际上，用图片来思考这个问题会更有帮助

573
00:27:59,317 --> 00:28:00,900
as being a little something like this.
就像这样。

574
00:28:00,900 --> 00:28:02,700
At the end of the day, you and I, even when
归根结底，你和我都一样，即使

575
00:28:02,700 --> 00:28:05,760
we start writing code in C that uses pointers,
我们开始用 C 语言编写使用指针的代码，

576
00:28:05,760 --> 00:28:09,270
generally, you and I are never going to care about the actual addresses.
通常情况下，你和我都不会关心实际的地址。

577
00:28:09,270 --> 00:28:12,000
Even though I showed you OX7 something, that's
即使我向你展示了OX7的东西，但这

578
00:28:12,000 --> 00:28:13,930
not generally useful information.
并不是一般有用的信息。

579
00:28:13,930 --> 00:28:16,500
It's suffices to know that it exists somewhere,
知道它存在于某个地方就足够了，

580
00:28:16,500 --> 00:28:19,030
and let the computer figure out how to get there.
然后让计算机弄清楚如何到达那里。

581
00:28:19,030 --> 00:28:22,980
And so very often when talking about pointers and addresses more generally,
因此，在更广泛地谈论指针和地址时，

582
00:28:22,980 --> 00:28:25,275
people actually abstract them away, so to speak.
人们实际上是将它们抽象化了，可以这么说。

583
00:28:25,275 --> 00:28:27,150
So instead of literally writing on the screen
所以，与其在屏幕上直接写

584
00:28:27,150 --> 00:28:30,990
or the whiteboard when discussing this, OX123, what the actual address is,
或者在讨论这个问题时写在白板上，OX123，实际地址是什么，

585
00:28:30,990 --> 00:28:32,130
who cares what it is?
谁在乎它是什么？

586
00:28:32,130 --> 00:28:36,630
It suffices that it's a value that leads me to the other value
它是一个可以让我找到另一个值的数值就够了，

587
00:28:36,630 --> 00:28:41,320
that I care about, sort of the treasure map, as I described it earlier.
我所关注的另一个值，就像我之前描述的藏宝图一样。

588
00:28:41,320 --> 00:28:45,360
So let's now connect this maybe a little more metaphorically.
现在让我们用更具比喻性的方式来连接它。

589
00:28:45,360 --> 00:28:47,220
So Carter, maybe here you might have noticed
所以，卡特，也许你在这里可能已经注意到

590
00:28:47,220 --> 00:28:50,670
that we've had for a while now these two mailboxes on the stage.
我们现在已经有一段时间在舞台上放了这两个邮箱了。

591
00:28:50,670 --> 00:28:55,590
So this white one here is labeled p to represent our pointer variable.
所以，这里这个白色的邮箱被标注为p，代表我们的指针变量。

592
00:28:55,590 --> 00:28:59,490
Carter's is labeled n, representing our actual integer.
卡特那个邮箱被标注为n，代表我们的实际整数。

593
00:28:59,490 --> 00:29:01,350
And what's really kind of going on here is
而这里真正发生的事情是

594
00:29:01,350 --> 00:29:06,450
that, if I were to access the value inside of p,
如果我要访问p内部的值，

595
00:29:06,450 --> 00:29:10,950
much like we saw it up here, that's like opening this up and figuring out
就像我们在上面看到的那样，就像打开这个邮箱并弄清楚

596
00:29:10,950 --> 00:29:12,300
what the actual value is.
实际值是什么。

597
00:29:12,300 --> 00:29:13,870
Now, this itself is a little arcane.
现在，这本身有点深奥。

598
00:29:13,870 --> 00:29:14,790
OX123.
OX123。

599
00:29:14,790 --> 00:29:17,370
And so if we actually do this a little more metaphorically,
所以，如果我们用更具比喻性的方式来做这件事，

600
00:29:17,370 --> 00:29:24,690
we can maybe do this and point our way, if you don't mind.
我们也许可以这样做，并且指明我们的方向，如果你不介意的话。

601
00:29:24,690 --> 00:29:30,082
So here we have a big pointer.
所以，这里有一个大指针。

602
00:29:30,082 --> 00:29:31,137
Oh, forgive me.
哦，请原谅我。

603
00:29:31,137 --> 00:29:32,470
I guess we'll use this one here.
我想我们会使用这个。

604
00:29:32,470 --> 00:29:33,100
OK.
好的。

605
00:29:33,100 --> 00:29:36,490
So we have this big pointer that's essentially
所以，我们有一个大指针，它本质上

606
00:29:36,490 --> 00:29:39,460
pointing at the location in memory that we care about, be it OX123,
指向我们所关心的内存位置，无论是OX123，

607
00:29:39,460 --> 00:29:40,210
or something else.
还是其他东西。

608
00:29:40,210 --> 00:29:43,120
And then if we dereference this, that is, use the star notation,
然后，如果我们对它进行解引用，也就是说，使用星号符号，

609
00:29:43,120 --> 00:29:46,870
star p, that's like asking Carter to go to that location,
星号p，就像让卡特去那个位置，

610
00:29:46,870 --> 00:29:48,850
open up the mailbox, and voila.
打开邮箱，瞧。

611
00:29:48,850 --> 00:29:50,620
What value do you have there?
你那里有什么值？

612
00:29:50,620 --> 00:29:51,250
Voila.
瞧。

613
00:29:51,250 --> 00:29:53,950
Maybe a big round of applause for Carter for having
也许让我们为卡特热烈鼓掌，因为

614
00:29:53,950 --> 00:29:57,670
practiced this beforehand with me.
之前和我一起练习了这个。

615
00:29:57,670 --> 00:29:58,318
All right.
好的。

616
00:29:58,318 --> 00:30:00,860
That was mostly just an excuse to use the foam fingers today.
这基本上只是今天用泡沫手指的借口。

617
00:30:00,860 --> 00:30:03,580
But with that said, that's hopefully a helpful metaphor,
但话说回来，这希望能是一个有用的比喻，

618
00:30:03,580 --> 00:30:06,820
honestly, because these pointers, these addresses actually
说实话，因为这些指针，这些地址实际上

619
00:30:06,820 --> 00:30:08,828
tend to be among the more arcane topics in C
在C语言中，它们往往是最深奥的话题之一，

620
00:30:08,828 --> 00:30:11,620
that, even if things are kind of clicking right now, as soon as you
即使现在事情很顺利，一旦你

621
00:30:11,620 --> 00:30:13,780
start writing code involving addresses, it's
开始编写涉及地址的代码，就会

622
00:30:13,780 --> 00:30:16,090
easy to get lost in some of the details.
很容易迷失在一些细节中。

623
00:30:16,090 --> 00:30:18,220
But metaphorically, these mailboxes are meant
但从比喻意义上说，这些邮箱的目的是

624
00:30:18,220 --> 00:30:20,110
to represent, really, what's going on.
来真正地代表正在发生的事情。

625
00:30:20,110 --> 00:30:22,990
Mailboxes in the physical human world have addresses.
现实世界中的邮箱都有地址。

626
00:30:22,990 --> 00:30:26,710
I can go to that address, open it up, and then I can go to another address
我可以去那个地址，打开它，然后我可以去另一个地址

627
00:30:26,710 --> 00:30:30,230
by following that treasure map, if you will, or pictorially here,
如果你愿意，就按照这条宝藏地图，或者这里用图来表示，

628
00:30:30,230 --> 00:30:33,840
the arrow that's pointing from one location to another.
指向从一个位置到另一个位置的箭头。

629
00:30:33,840 --> 00:30:36,890
So even though it's very weird syntax with ampersands, and asterisks,
所以即使它使用与符号和星号非常奇怪的语法，

630
00:30:36,890 --> 00:30:39,920
and the like, it's just addresses in memory,
等等，它仅仅是内存中的地址，

631
00:30:39,920 --> 00:30:42,780
much like mailboxes in the real world.
就像现实世界中的邮箱一样。

632
00:30:42,780 --> 00:30:46,940
So with that said, let's maybe begin to take off certain training
所以，让我们开始移除一些训练

633
00:30:46,940 --> 00:30:51,030
wheels by revisiting what strings are, as we've been using them thus far.
内容，通过重新回顾字符串是什么，因为我们一直都在使用它们。

634
00:30:51,030 --> 00:30:55,100
So here's a line of code in C that we've been using since week one,
所以这里有一行 C 语言代码，我们从第一周就开始使用它，

635
00:30:55,100 --> 00:30:59,210
really, where I declare a string variable called s, and set it equal to,
实际上，我声明了一个名为 s 的字符串变量，并将其设置为等于，

636
00:30:59,210 --> 00:31:00,500
quote unquote, hi.
引号中的 "hi"。

637
00:31:00,500 --> 00:31:05,240
Now, technically "hi" is three letters, or two letters in a punctuation symbol.
从技术上讲，“hi” 是三个字母，或者是一个标点符号中的两个字母。

638
00:31:05,240 --> 00:31:10,130
But how many bytes is that string taking up?
但是这个字符串占用多少字节呢？

639
00:31:10,130 --> 00:31:13,268
Is it one, two, three, or was it--
是 1、2、3，还是--

640
00:31:13,268 --> 00:31:14,060
I'm seeing it here.
我在这里看到它。

641
00:31:14,060 --> 00:31:14,510
It's four.
是 4。

642
00:31:14,510 --> 00:31:15,010
Why?
为什么？

643
00:31:17,440 --> 00:31:20,660
Yeah, there's always a null character that, even though you don't see it
是的，总有一个空字符，即使你没有看到它

644
00:31:20,660 --> 00:31:25,440
on the screen, that is what terminates every string, we claimed, a while back.
在屏幕上，它就是终止每个字符串的东西，我们之前就说过。

645
00:31:25,440 --> 00:31:27,368
So if I were to draw this maybe "hi" ends up
所以，如果我要画一下，也许 "hi" 最终会

646
00:31:27,368 --> 00:31:29,910
in the computer's memory down here, bottom right hand corner.
出现在电脑内存的底部右下角。

647
00:31:29,910 --> 00:31:32,270
But it is indeed four bytes, not just three
但它确实是 4 个字节，不仅仅是 3 个字节

648
00:31:32,270 --> 00:31:35,060
because, secretly, there's always been that null character,
因为，秘密地，总是存在着那个空字符，

649
00:31:35,060 --> 00:31:36,950
even though we as programmers don't often
即使我们作为程序员并不经常

650
00:31:36,950 --> 00:31:38,630
have to type it explicitly ourselves.
需要显式地自己输入它。

651
00:31:38,630 --> 00:31:40,500
That's what the double quotes do for us.
这就是双引号为我们做的事情。

652
00:31:40,500 --> 00:31:42,770
It terminates the string with that null character.
它用空字符终止字符串。

653
00:31:42,770 --> 00:31:46,190
Now, recall from week two when we talked about arrays,
现在，回想一下我们在第二周谈论数组的时候，

654
00:31:46,190 --> 00:31:48,710
we started playing around with strings as really
我们开始把字符串当做

655
00:31:48,710 --> 00:31:50,340
just being arrays of characters.
字符数组来处理。

656
00:31:50,340 --> 00:31:53,840
So we call them a string, but we could treat them as arrays of char,
所以我们称它们为字符串，但我们可以将它们当作字符数组来处理，

657
00:31:53,840 --> 00:31:54,720
so to speak.
可以说是这样。

658
00:31:54,720 --> 00:31:58,670
So if the string was called s, s bracket zero would give us the first char,
所以，如果字符串叫 s，s 方括号 0 就会给出第一个字符，

659
00:31:58,670 --> 00:32:00,900
s bracket one the second, s bracket two the third.
s 方括号 1 是第二个，s 方括号 2 是第三个。

660
00:32:00,900 --> 00:32:03,410
And if you're really curious, s bracket three
如果你真的很好奇，s 方括号 3

661
00:32:03,410 --> 00:32:05,730
would give you the last hidden null character,
会给你最后一个隐藏的空字符，

662
00:32:05,730 --> 00:32:08,150
which we saw on the screen as just a zero
我们把它打印到屏幕上时，它显示为一个零

663
00:32:08,150 --> 00:32:11,450
when we printed it out, while tinkering with some actual code.
在调整一些实际代码的时候。

664
00:32:11,450 --> 00:32:14,390
But technically, today, logically, it would
但从技术上讲，在今天，逻辑上，它应该是

665
00:32:14,390 --> 00:32:17,300
seem that it's also true that H-I exclamation
看起来，这也的确是正确的，H-I 感叹号

666
00:32:17,300 --> 00:32:20,570
point and the null character must clearly live at some address.
以及空字符，显然必须存在于某个地址。

667
00:32:20,570 --> 00:32:23,940
They must clearly live in their own mailbox, so to speak.
它们必须存在于它们自己的邮箱中，可以这么说。

668
00:32:23,940 --> 00:32:28,610
So maybe, for the sake of discussion, this H today is at OX123.
所以，为了讨论，我们假设今天的 H 在 OX123 上。

669
00:32:28,610 --> 00:32:33,840
But recall that arrays are characterized by contiguousness from left to right.
但请记住，数组的特征是从左到右的连续性。

670
00:32:33,840 --> 00:32:41,600
So if H is at OX123, it must be the case that I is at OX124, I is at 125,
所以如果 H 在 OX123 上，那么 I 就必须在 OX124 上，I 在 125 上，

671
00:32:41,600 --> 00:32:46,917
and the null character is at OX126 because those are one byte apart.
而空字符在 OX126 上，因为它们彼此相隔一个字节。

672
00:32:46,917 --> 00:32:48,750
And I deliberately chose numbers here where,
而且我在这里故意选择了一些数字，其中，

673
00:32:48,750 --> 00:32:51,090
whether it's decimal or hexadecimal, it doesn't matter.
无论是十进制还是十六进制，都没关系。

674
00:32:51,090 --> 00:32:53,970
These differ by just one byte themselves.
它们本身只相差一个字节。

675
00:32:53,970 --> 00:32:55,760
So that's what implies that they're indeed
所以，这暗示着它们确实是

676
00:32:55,760 --> 00:32:57,740
adjacent, or contiguous in memory.
相邻的，或者在内存中连续的。

677
00:32:57,740 --> 00:32:59,000
But what is s then?
但s是什么呢？

678
00:32:59,000 --> 00:33:02,540
When I declared s to be a string, what is
当我声明s是一个字符串时，是什么

679
00:33:02,540 --> 00:33:04,640
it that's been going in s all of this time
一直在s里面存在

680
00:33:04,640 --> 00:33:08,090
if, clearly, s is actually this thing here?
如果，很明显，s实际上是这里的东西？

681
00:33:08,090 --> 00:33:11,060
Well, strings have kind of been a white lie for a few weeks
好吧，字符串在过去几周里有点像一个善意的谎言

682
00:33:11,060 --> 00:33:16,130
because s itself, technically, is a pointer.
因为s本身，从技术上讲，是一个指针。

683
00:33:16,130 --> 00:33:18,720
s is the address of this string.
s是这个字符串的地址。

684
00:33:18,720 --> 00:33:20,810
So the string is somewhere in memory, but s
所以字符串在内存中的某个地方，但s

685
00:33:20,810 --> 00:33:23,870
itself is a separate variable that gives you
本身是一个单独的变量，它给你

686
00:33:23,870 --> 00:33:26,820
a clue as how to find all of those characters in memory.
一个线索，告诉你如何在内存中找到所有这些字符。

687
00:33:26,820 --> 00:33:28,820
So if you had to guess just intuitively now,
所以如果你现在必须凭直觉猜测，

688
00:33:28,820 --> 00:33:32,270
if this is the string actually in memory, that is, this
如果这是实际上在内存中的字符串，也就是说，这个

689
00:33:32,270 --> 00:33:35,180
is the array of chars in memory, what would logically
是内存中的字符数组，那么逻辑上会

690
00:33:35,180 --> 00:33:38,702
make sense to put as the value of s?
有意义地作为s的值？

691
00:33:38,702 --> 00:33:39,590
A pointer.
一个指针。

692
00:33:39,590 --> 00:33:40,430
Specifically?
具体来说？

693
00:33:43,190 --> 00:33:44,270
A pointer to h.
指向h的指针。

694
00:33:44,270 --> 00:33:45,830
And how would I express that?
我该如何表达呢？

695
00:33:45,830 --> 00:33:46,940
What's the actual value?
实际值是什么？

696
00:33:46,940 --> 00:33:54,800
OX123 might very well suffice as the value here of s.
OX123很可能足够作为s的值。

697
00:33:54,800 --> 00:33:57,150
Now, why might that be?
现在，为什么可能是这样呢？

698
00:33:57,150 --> 00:33:59,780
Well, that essentially gives you enough information
好吧，这本质上给了你足够的信息

699
00:33:59,780 --> 00:34:03,950
to find the beginning of the string, "hi" in this case.
来找到字符串的开头，在这种情况下是"hi"。

700
00:34:03,950 --> 00:34:05,700
Now, you might think, well, wait a minute.
现在，你可能会想，等等。

701
00:34:05,700 --> 00:34:07,910
How does it know about the second character and the third character?
它怎么知道第二个字符和第三个字符？

702
00:34:07,910 --> 00:34:10,327
But now, if you kind of rewind in time, oh, wait a minute,
但现在，如果你倒回到过去，哦，等等，

703
00:34:10,327 --> 00:34:14,420
maybe now the null character actually makes even more sense from week two.
也许现在空字符从第二周开始就更有意义了。

704
00:34:14,420 --> 00:34:15,050
Why?
为什么？

705
00:34:15,050 --> 00:34:18,139
Because if s technically storing the location
因为如果s从技术上讲存储了位置

706
00:34:18,139 --> 00:34:20,420
of the beginning of the string, someone's
字符串开头的，有人

707
00:34:20,420 --> 00:34:23,330
got to keep track of where the string ends, presumably.
必须跟踪字符串在哪里结束，大概是。

708
00:34:23,330 --> 00:34:26,780
And that's effectively the string itself because humans decided decades ago,
而这实际上就是字符串本身，因为人类几十年前决定，

709
00:34:26,780 --> 00:34:29,870
let's just null terminate every string with a special
让我们用一个特殊的空字符来结束每一个字符串

710
00:34:29,870 --> 00:34:35,300
so character, zero, all zero bits, eight zero bits, specifically.
特殊字符，零，全是零位，八个零位，具体来说。

711
00:34:35,300 --> 00:34:36,929
But and that's enough information.
但是，这足够信息了。

712
00:34:36,929 --> 00:34:39,679
The sort of treasure map leads you to the beginning of the string,
这种藏宝图会把你带到字符串的开头，

713
00:34:39,679 --> 00:34:41,719
and then you can use a for loop, a while loop,
然后你可以使用for循环，while循环，

714
00:34:41,719 --> 00:34:44,880
or whatever to walk through the string, and that's what printf does.
或其他任何方法来遍历字符串，这就是printf所做的。

715
00:34:44,880 --> 00:34:48,690
And you just stop as soon as you see that null character.
你只要看到空字符就停止。

716
00:34:48,690 --> 00:34:52,444
So this then is what a string actually is.
所以这就是字符串的实际情况。

717
00:34:52,444 --> 00:34:57,440
s is and has always been, since week one, a pointer, so to speak,
s从第一周开始就一直是一个指针，可以这么说，

718
00:34:57,440 --> 00:35:01,710
that actually refers to the start of that array of characters.
它实际上指的是那个字符数组的开头。

719
00:35:01,710 --> 00:35:04,550
And frankly, again, who cares about the OX123 specifics?
坦率地说，再次强调，谁会在乎OX123的细节？

720
00:35:04,550 --> 00:35:07,550
We can abstract that away and actually just treat
我们可以将其抽象出来，实际上只是将

721
00:35:07,550 --> 00:35:11,690
s as, literally, an arrow that points to the beginning of that string
s视为，从字面上说，一个指向那个字符串开头的箭头。

722
00:35:11,690 --> 00:35:15,350
because it will be rare that we actually care about where this thing
因为我们很少会关心这个东西

723
00:35:15,350 --> 00:35:18,800
physically is in the computer's memory.
在计算机内存中的实际位置。

724
00:35:18,800 --> 00:35:23,390
Now, before we see this in code, any questions on this revelation?
现在，在我们看到代码之前，对此揭示有什么疑问吗？

725
00:35:23,390 --> 00:35:23,900
Yeah.
是的。

726
00:35:23,900 --> 00:35:27,530
AUDIENCE: Have pointers gotten larger as computer memories
观众：指针的大小随着计算机内存的增加而增加了吗？

727
00:35:27,530 --> 00:35:28,863
have increased over the decades?
在过去几十年里？

728
00:35:28,863 --> 00:35:29,488
SPEAKER 1: Yes.
演讲者 1：是的。

729
00:35:29,488 --> 00:35:32,840
Have pointers gotten larger as computers memory has increased over the decades?
指针的大小随着计算机内存的增加而增加了吗？

730
00:35:32,840 --> 00:35:33,650
Short answer, yes.
简短的回答是，是的。

731
00:35:33,650 --> 00:35:36,530
Like, back in my day, we were limited to, like, two gigabytes
就像，在我那个时代，我们被限制在 2 GB

732
00:35:36,530 --> 00:35:37,760
of memory total.
的总内存。

733
00:35:37,760 --> 00:35:38,600
Well, why two?
为什么是 2 GB 呢？

734
00:35:38,600 --> 00:35:42,260
Well, if you had 32-bit memory, or if you use 32 bits
好吧，如果你有 32 位内存，或者如果你使用 32 位

735
00:35:42,260 --> 00:35:45,650
to represent addresses, a.k.a. four bytes, as was conventional,
来表示地址，也就是 4 个字节，这是一种常规做法，

736
00:35:45,650 --> 00:35:48,650
you can count recall as high as 4 billion values.
你可以计算出高达 40 亿个值。

737
00:35:48,650 --> 00:35:52,050
But generally, numbers are both negative and positive, so that halves it.
但一般来说，数字既有负数也有正数，所以要减半。

738
00:35:52,050 --> 00:35:54,890
So the reason decades ago, computers, PCs, Macs
所以，几十年前，电脑、个人电脑、苹果电脑

739
00:35:54,890 --> 00:35:58,670
could have no more than two gigabytes of memory was because, literally,
只能拥有不超过 2 GB 的内存，是因为，从字面上来说，

740
00:35:58,670 --> 00:36:01,250
the integers being used, the pointers being used
正在使用的整数，正在使用的指针

741
00:36:01,250 --> 00:36:03,830
were only four bits, that is 32 bits.
只有 4 个字节，也就是 32 位。

742
00:36:03,830 --> 00:36:06,620
Sorry, four bytes, that is, 32 bits long.
抱歉，是 4 个字节，也就是 32 位。

743
00:36:06,620 --> 00:36:08,750
And so you literally could buy more memory.
因此，你实际上可以购买更多内存。

744
00:36:08,750 --> 00:36:10,833
You could buy a third gigabyte, a fourth gigabyte,
你可以购买第三个千兆字节，第四个千兆字节，

745
00:36:10,833 --> 00:36:13,280
but you literally had no way mathematically
但从数学上来说，你根本没有办法

746
00:36:13,280 --> 00:36:16,530
to express all of those bigger locations.
来表示所有这些更大的位置。

747
00:36:16,530 --> 00:36:18,470
So it was effectively useless, in that case.
因此，在这种情况下，它实际上是无用的。

748
00:36:18,470 --> 00:36:21,680
In more modern times, computers tend now to use 64 bits, which
在更现代的时代，计算机现在倾向于使用 64 位，它

749
00:36:21,680 --> 00:36:23,220
allows you to count crazy high.
允许你计算出惊人的高值。

750
00:36:23,220 --> 00:36:27,140
And that's more than enough to address bigger chunks of memory.
这足以用来处理更大的内存块。

751
00:36:27,140 --> 00:36:28,100
Really good question.
真是个好问题。

752
00:36:28,100 --> 00:36:32,257
Others on memory thus far.
其他关于内存的疑问。

753
00:36:32,257 --> 00:36:32,840
No, all right.
没有，好的。

754
00:36:32,840 --> 00:36:36,810
Well, let's translate this a bit to code by going back over to VS Code here.
好吧，让我们通过回到 VS Code 中来将这段内容翻译成代码。

755
00:36:36,810 --> 00:36:41,390
And let me propose now that we revisit maybe a simpler string
现在，我建议我们重新看一下一个更简单的字符串

756
00:36:41,390 --> 00:36:43,110
example, as opposed to these integers.
示例，与这些整数相比。

757
00:36:43,110 --> 00:36:46,430
So let me go ahead and throw away all of this integer related code.
所以，让我先把所有与整数相关的代码都删掉。

758
00:36:46,430 --> 00:36:49,910
Let me go ahead and, for the moment, include CS50.h
让我先暂时包含 CS50.h

759
00:36:49,910 --> 00:36:53,030
so that we have access to string and other things as in week one.
这样我们就可以像第一周一样使用字符串和其他东西了。

760
00:36:53,030 --> 00:36:56,240
And let me do a string s equals quote unquote "HI" in all caps.
我定义一个字符串 s，它的值是双引号里的"HI"，全部大写。

761
00:36:56,240 --> 00:37:00,845
And let me do a simple safety check %s backslash n s,
我执行一个简单的安全检查 %s 反斜杠 n s，

762
00:37:00,845 --> 00:37:04,100
just to make sure everything works as it did in week one.
只是为了确保一切都像第一周那样工作。

763
00:37:04,100 --> 00:37:07,310
So make addresses, dot slash addresses, and I should indeed
所以，构建地址，点斜杠地址，我应该能够看到

764
00:37:07,310 --> 00:37:09,320
see "HI" on the screen.
屏幕上的"HI"。

765
00:37:09,320 --> 00:37:12,680
Well, let's now kind of tinker with what's going on underneath the hood.
好吧，现在让我们来修改一下内部正在发生的事情。

766
00:37:12,680 --> 00:37:17,100
And now, things can get a little more memory specific.
现在，事情会变得更具体一些，与内存有关。

767
00:37:17,100 --> 00:37:19,610
So I'm still going to declare s as a string up here.
所以，我仍然要在上面声明 s 作为一个字符串。

768
00:37:19,610 --> 00:37:20,360
But you know what?
但你知道吗？

769
00:37:20,360 --> 00:37:22,610
Instead of printing out the string itself,
与其直接打印字符串本身，

770
00:37:22,610 --> 00:37:26,870
let me actually treat s as the pointer I claim it is.
不如让我把 s 当作我所说的那个指针来对待。

771
00:37:26,870 --> 00:37:30,210
I claim a string is just an address, so I have this new syntax today,
我声称字符串只是一个地址，所以我今天有这种新的语法，

772
00:37:30,210 --> 00:37:33,120
%p to print out pointers, to print out addresses.
%p 用于打印指针，即打印地址。

773
00:37:33,120 --> 00:37:35,340
Let's see what s actually is.
让我们看看 s 实际上是什么。

774
00:37:35,340 --> 00:37:39,870
Let me do make addresses again, dot slash addresses, and there it is.
让我再次执行 make addresses，然后执行 dot slash addresses，它就在那里。

775
00:37:39,870 --> 00:37:50,110
It's not as simple as OX123, but it is at location OX55C670878004.
它不像 OX123 那样简单，但它位于 OX55C670878004 位置。

776
00:37:50,110 --> 00:37:50,610
All right.
好的。

777
00:37:50,610 --> 00:37:52,180
Who really cares, specifically?
具体来说，谁会在乎呢？

778
00:37:52,180 --> 00:37:55,450
But if we poke around a bit more, things might make a bit more sense.
但如果我们再深入研究一下，事情可能就会更有意义。

779
00:37:55,450 --> 00:37:56,100
Let's do this.
让我们这样做。

780
00:37:56,100 --> 00:38:01,740
Let's also print out the address using %p of, how about the very first
我们还可以使用 %p 打印出... 比如第一个的地址...

781
00:38:01,740 --> 00:38:02,805
character of s.
s 的字符。

782
00:38:02,805 --> 00:38:06,720
So the very first character of is known as s bracket zero.
因此，第一个字符被称为 s 中括号零。

783
00:38:06,720 --> 00:38:10,000
We did that in week two, treating a string as an array.
我们在第二周做过，将字符串视为数组。

784
00:38:10,000 --> 00:38:13,110
But how do I get the address of a character?
但我如何获取字符的地址？

785
00:38:13,110 --> 00:38:15,750
Well, I have our new symbol today, ampersand.
好吧，我今天有了我们的新符号，&。

786
00:38:15,750 --> 00:38:18,750
So even though this looks like a mouthful, ampersand, s, square bracket,
所以，即使看起来很复杂，&、s、方括号，

787
00:38:18,750 --> 00:38:21,015
zero, square bracket, it's just two ideas combined.
零、方括号，它只是将两个想法结合起来。

788
00:38:21,015 --> 00:38:24,900
s bracket zero gives you the first character in the string, s.
s 中括号零会给你字符串 s 中的第一个字符。

789
00:38:24,900 --> 00:38:28,620
And adding an ampersand at the beginning says, tell me what that address is.
在开头添加 & 表示，告诉我那个地址是什么。

790
00:38:28,620 --> 00:38:34,260
So if I recompile this code, make addresses, dot slash addresses,
所以，如果我重新编译这段代码，执行 make addresses，然后执行 dot slash addresses，

791
00:38:34,260 --> 00:38:37,680
even if you don't remember the value OX whatever,
即使你不记得 OX 的值是什么，

792
00:38:37,680 --> 00:38:43,510
what are we going to see on the screen at a higher level?
我们在屏幕上会看到什么更高级的东西？

793
00:38:43,510 --> 00:38:46,780
Perhaps the same exact thing.
也许是完全相同的东西。

794
00:38:46,780 --> 00:38:47,320
Why?
为什么？

795
00:38:47,320 --> 00:38:49,070
Well, s is just an address.
好吧，s 只是一个地址。

796
00:38:49,070 --> 00:38:50,120
But what does that mean?
但这意味着什么？

797
00:38:50,120 --> 00:38:52,900
Well, it's just the address of its first character.
好吧，它只是其第一个字符的地址。

798
00:38:52,900 --> 00:38:56,030
And we saw that per our picture a moment ago.
我们刚才在图片中看到了这一点。

799
00:38:56,030 --> 00:38:58,000
So can I see the contiguousness of this?
所以，我能看到这一点的连续性吗？

800
00:38:58,000 --> 00:39:00,400
Well, I'm going to resort to some copy paste just for time's sake,
好吧，为了节省时间，我将使用一些复制粘贴，

801
00:39:00,400 --> 00:39:01,960
even though this is going to look a little silly,
即使这看起来有点傻，

802
00:39:01,960 --> 00:39:03,730
and I could certainly use a loop instead.
我当然可以使用循环代替。

803
00:39:03,730 --> 00:39:07,420
But let me print out the second location, the third location, and heck,
但让我打印出第二个位置、第三个位置，还有...

804
00:39:07,420 --> 00:39:12,050
even the fourth location, whoops, the fourth location of that null character.
甚至第四个位置，哎呀，那个空字符的第四个位置。

805
00:39:12,050 --> 00:39:15,850
If I now do make addresses again and dot slash addresses, and zoom in,
如果我现在再次执行 make addresses，然后执行 dot slash addresses，并放大，

806
00:39:15,850 --> 00:39:18,580
I don't really care about what these are, specifically.
我并不真正关心这些是什么，具体来说。

807
00:39:18,580 --> 00:39:22,560
But notice the first two are indeed the same because the first represents s.
但请注意，前两个确实相同，因为第一个代表 s。

808
00:39:22,560 --> 00:39:24,640
The first represents the first character of s,
第一个代表 s 的第一个字符，

809
00:39:24,640 --> 00:39:27,320
which now I reveal are exactly the same idea.
现在我揭示了它们实际上是一样的。

810
00:39:27,320 --> 00:39:30,580
And the next ones are literally just one byte
而接下来的几个实际上只是相差一个字节，

811
00:39:30,580 --> 00:39:34,490
away, ending in five, six, and seven, respectively.
分别以五、六和七结尾。

812
00:39:34,490 --> 00:39:36,340
So again, the numbers in and of themselves
所以，再次强调，这些数字本身

813
00:39:36,340 --> 00:39:38,950
are not useful, actionable information, but it
不是有用的、可操作的信息，但它

814
00:39:38,950 --> 00:39:44,240
does let us actually see what's going on underneath the hood.
确实让我们能够看到幕后发生了什么。

815
00:39:44,240 --> 00:39:47,420
So just to rewind for a moment, let me actually go back to the original
所以，为了回顾一下，让我回到原始版本，

816
00:39:47,420 --> 00:39:51,480
version, where I'm printing out the string itself, using %s.
版本，我使用 %s 打印出字符串本身。

817
00:39:51,480 --> 00:39:57,410
Let me remake addresses to make sure that, OK, it still prints out "HI".
让我重新执行 make addresses 以确保... 好的，它仍然打印出 "HI"。

818
00:39:57,410 --> 00:40:00,290
But what has been going on now all this time?
但是这段时间到底发生了什么呢？

819
00:40:00,290 --> 00:40:02,368
Well, let me go back to our simple line of code
那么，让我回到我们简单的代码行

820
00:40:02,368 --> 00:40:04,160
that we've been using since week one, which
从第一周开始我们一直在使用的代码行，它

821
00:40:04,160 --> 00:40:07,730
gave us a string called s, setting it equal to the value of "HI".
给了我们一个名为s的字符串，将其设置为“HI”的值。

822
00:40:07,730 --> 00:40:12,380
Let me propose now that strings were indeed this white lie.
我现在要提出，字符串其实就是一个善意的谎言。

823
00:40:12,380 --> 00:40:14,750
And if I can unnecessarily dramatically say,
如果我可以用一种不必要的戏剧性方式来说，

824
00:40:14,750 --> 00:40:18,470
here we take the training wheels off and reveal
现在我们摘掉了辅助轮，揭示了

825
00:40:18,470 --> 00:40:30,080
that, all this time, string, string is probably, actually, what, technically?
一直以来，字符串，字符串可能，实际上，从技术上来说是什么？

826
00:40:30,080 --> 00:40:32,180
Yeah.
是的。

827
00:40:32,180 --> 00:40:35,210
A char star.
一个字符指针。

828
00:40:35,210 --> 00:40:36,270
That was amazing.
太棒了。

829
00:40:36,270 --> 00:40:37,080
Thank you for that.
谢谢你的解答。

830
00:40:37,080 --> 00:40:39,100
So yeah.
所以是的。

831
00:40:39,100 --> 00:40:43,720
So it's a char star, which admittedly at first glance,
所以它是一个字符指针，尽管乍一看，

832
00:40:43,720 --> 00:40:46,870
just makes a simple idea look unnecessarily complicated.
它让一个简单的概念看起来不必要地复杂。

833
00:40:46,870 --> 00:40:50,410
And that's why in week one, we indeed introduced these training wheels,
这就是为什么在第一周，我们确实引入了这些辅助轮，

834
00:40:50,410 --> 00:40:55,720
whereby we, CS50, invented the datatype called string, just to kind of hide
通过它，我们，CS50，发明了名为字符串的数据类型，仅仅是为了隐藏

835
00:40:55,720 --> 00:40:57,085
this lower level detail.
这个底层细节。

836
00:40:57,085 --> 00:40:58,960
If you will, string for us is an abstraction.
如果你愿意，对我们来说字符串是一个抽象的概念。

837
00:40:58,960 --> 00:41:02,170
Now, that is to say string is not a CS50 specific word.
现在，也就是说，字符串不是 CS50 特有的词。

838
00:41:02,170 --> 00:41:05,500
Every programmer in the world knows what a string is.
世界上每个程序员都知道什么是字符串。

839
00:41:05,500 --> 00:41:07,690
It is a sequence of characters.
它是一系列字符。

840
00:41:07,690 --> 00:41:09,190
It is an array of characters.
它是一个字符数组。

841
00:41:09,190 --> 00:41:12,220
But in C, technically, decades ago when it was invented,
但在 C 语言中，从技术上讲，几十年前它被发明的时候，

842
00:41:12,220 --> 00:41:16,150
they didn't think, they didn't decide to create an actual data type called
他们没有想过，他们没有决定创建一个名为

843
00:41:16,150 --> 00:41:19,570
string because, especially if they were among those more comfortable,
字符串的数据类型，因为，尤其是如果他们属于那些更习惯于

844
00:41:19,570 --> 00:41:23,470
char star is equivalent, and it achieves the exact same thing,
字符指针的人，字符指针是等效的，它实现了完全相同的功能，

845
00:41:23,470 --> 00:41:26,800
even though at a glance, we didn't want to start week one with that lower level
即使乍一看，我们不想用那个底层

846
00:41:26,800 --> 00:41:27,670
detail.
细节开始第一周。

847
00:41:27,670 --> 00:41:28,990
Question here in front.
前面有提问吗？

848
00:41:33,020 --> 00:41:33,980
Sure.
当然。

849
00:41:33,980 --> 00:41:36,450
Can I clarify how the star makes it a string?
我能解释一下星号如何使它成为一个字符串吗？

850
00:41:36,450 --> 00:41:39,240
So we've, up until now, been just calling it a string
所以我们，到目前为止，一直称之为字符串

851
00:41:39,240 --> 00:41:40,560
so that's s is a string.
因此，s 是一个字符串。

852
00:41:40,560 --> 00:41:42,930
And that's a sufficient mental model.
这是一种足够的心理模型。

853
00:41:42,930 --> 00:41:44,900
But technically, what is a string?
但从技术上讲，什么是字符串？

854
00:41:44,900 --> 00:41:48,110
I claimed pictorially with my grid of memory
我用我的内存网格进行了图形化的说明

855
00:41:48,110 --> 00:41:50,670
that a string is really just an address.
一个字符串实际上只是一个地址。

856
00:41:50,670 --> 00:41:53,240
It's really just the address of its first character.
它实际上只是其第一个字符的地址。

857
00:41:53,240 --> 00:41:57,410
I then tried to demonstrate as much in code by using percent p
然后我尝试使用百分号 p 在代码中演示这一点

858
00:41:57,410 --> 00:42:01,370
and showing you, literally, s is a value, like, OX something.
并向您展示，实际上，s 是一个值，比如，OX 某个东西。

859
00:42:01,370 --> 00:42:05,220
And literally, its first character is at that same address, OX something.
而且实际上，它的第一个字符位于同一个地址，OX 某个东西。

860
00:42:05,220 --> 00:42:09,050
So here, when I claim that string has never really existed,
所以在这里，当我声称字符串实际上从未存在过，

861
00:42:09,050 --> 00:42:13,250
except within the confines of CS50, technically, the data type of a string
除了在 CS50 的范围内，从技术上讲，字符串的数据类型

862
00:42:13,250 --> 00:42:15,450
is best expressed as char star.
最好用字符指针来表示。

863
00:42:15,450 --> 00:42:15,950
Why?
为什么？

864
00:42:15,950 --> 00:42:19,760
Well, a string clearly can't just be a char because a char, by definition,
好吧，字符串显然不能仅仅是一个字符，因为根据定义，

865
00:42:19,760 --> 00:42:20,720
is a single character.
它是一个单字符。

866
00:42:20,720 --> 00:42:23,460
A string, we already know, is a sequence of characters.
我们已经知道，一个字符串是一系列字符。

867
00:42:23,460 --> 00:42:25,670
But how can you represent a sequence of characters?
但是如何表示一系列字符呢？

868
00:42:25,670 --> 00:42:29,480
You can call it a char star, which is a different data type that we're
你可以称之为 char star，这是我们今天第一次介绍的一种不同的数据类型。

869
00:42:29,480 --> 00:42:31,100
introducing today for the first time.
我们今天第一次介绍它。

870
00:42:31,100 --> 00:42:34,320
And the star just means that s itself is not a char.
而星号只是意味着 s 本身不是一个 char。

871
00:42:34,320 --> 00:42:38,400
The star means that s is the address of a char.
星号意味着 s 是一个 char 的地址。

872
00:42:38,400 --> 00:42:42,700
And by convention, it's the address of the first char in a string.
按照惯例，它是字符串中第一个 char 的地址。

873
00:42:42,700 --> 00:42:48,090
So with that said, if I go back to my actual VS Code over here,
所以，如果我回到我这里的 VS Code，

874
00:42:48,090 --> 00:42:55,820
I can change, literally, char string to char star s.
我可以改变，实际上，char string 到 char star s。

875
00:42:55,820 --> 00:42:59,220
I can get rid of the CS50 library, our so-called training wheels,
我可以去掉 CS50 库，也就是我们所谓的辅助轮，

876
00:42:59,220 --> 00:43:02,220
which has been the goal for the past few weeks, to put them on initially
这在过去几周一直是我们的目标，最初要安装它们

877
00:43:02,220 --> 00:43:04,300
and then take them off quite quickly.
然后很快地把它们取下来。

878
00:43:04,300 --> 00:43:08,613
So now this is the same program, and %s is still the same. s is still the same.
所以现在这个程序是一样的，而且 %s 还是一样的。s 还是一样的。

879
00:43:08,613 --> 00:43:10,030
Everything else is still the same.
其他一切仍然相同。

880
00:43:10,030 --> 00:43:12,600
All I've done is change, quote unquote, string to,
我所做的只是改变，引号里的 “string” 到，

881
00:43:12,600 --> 00:43:16,200
quote unquote, char star, which obviates the need for the CS50 library.
引号里的 “char star”，这就不需要 CS50 库了。

882
00:43:16,200 --> 00:43:18,870
And if I now do make addresses and dot slash addresses,
如果我现在执行 make addresses 和 dot slash addresses，

883
00:43:18,870 --> 00:43:21,570
"HI" behaves exactly as it would.
“HI” 的行为完全一样。

884
00:43:21,570 --> 00:43:25,470
So this is now raw native C code without any training wheels,
所以现在这是原始的 C 代码，没有任何辅助轮，

885
00:43:25,470 --> 00:43:30,840
without any CS50 scaffolding, that just uses these basic building
没有任何 CS50 脚手架，它只使用这些基本的构建

886
00:43:30,840 --> 00:43:32,310
blocks and primitives.
块和基本类型。

887
00:43:32,310 --> 00:43:33,455
Other questions on this?
还有其他问题吗？

888
00:43:33,455 --> 00:43:36,890
AUDIENCE: Could you please clarify why we don't use the end symbol for that
听众：你能解释一下为什么我们不使用那个符号

889
00:43:36,890 --> 00:43:38,310
s, as opposed to the other ones?
s，而不是其他的符号？

890
00:43:38,310 --> 00:43:39,180
SPEAKER 1: Correct.
发言人 1：没错。

891
00:43:39,180 --> 00:43:44,320
Why don't we use the ampersand symbol for this, though we did earlier?
为什么我们不在这里使用取地址符，虽然我们在之前用过？

892
00:43:44,320 --> 00:43:47,670
So in this case, there's no reason for an ampersand
所以，在这种情况下，没有必要使用取地址符

893
00:43:47,670 --> 00:43:52,620
because the ampersand tells you what the address of a variable is.
因为取地址符会告诉你一个变量的地址是什么。

894
00:43:52,620 --> 00:43:55,170
I'll concede that it probably would be a little more
我承认这可能更

895
00:43:55,170 --> 00:43:59,430
consistent for us to do this, which is maybe where your mind is going.
一致，也许这就是你在想的地方。

896
00:43:59,430 --> 00:44:02,880
Now, never mind the fact that looks even worse, I think, syntactically.
现在，别管它看起来更糟糕了，我认为，从语法上来说。

897
00:44:02,880 --> 00:44:06,930
It's a reasonable instinct, but it turns out
这是一个合理的直觉，但事实证明

898
00:44:06,930 --> 00:44:09,150
that two is what the double quotes are doing for you.
双引号正在为你做的事情就是这两个。

899
00:44:09,150 --> 00:44:11,790
The C compiler, called Clang, is smart enough
C 编译器，叫做 Clang，足够聪明

900
00:44:11,790 --> 00:44:15,060
to realize that when it sees double quotes around a sequence of characters,
它能够意识到，当它看到围绕着一系列字符的双引号时，

901
00:44:15,060 --> 00:44:20,550
it wants to put the address of that first char in the variable for you.
它会将第一个字符的地址放到变量中。

902
00:44:20,550 --> 00:44:23,850
But when we had a variable like n, which we created,
但是，当我们有一个像 n 这样的变量，我们创建了它，

903
00:44:23,850 --> 00:44:26,020
you have to distinguish n from its address.
你必须区分 n 和它的地址。

904
00:44:26,020 --> 00:44:28,620
So that's why we prefixed n with an ampersand.
所以这就是我们用取地址符作为 n 的前缀的原因。

905
00:44:28,620 --> 00:44:30,540
But the double quotes take care of it for you.
但是，双引号为你处理了这个问题。

906
00:44:30,540 --> 00:44:36,240
Other questions on these here addresses?
关于这些地址还有其他问题吗？

907
00:44:36,240 --> 00:44:36,880
No?
没有？

908
00:44:36,880 --> 00:44:37,380
All right.
好的。

909
00:44:37,380 --> 00:44:43,530
Well, beyond that, let me propose that we tinker with one other idea
除此之外，让我建议我们尝试一下另一个想法

910
00:44:43,530 --> 00:44:46,170
to see how we actually invented this thing called a string.
看看我们是如何发明了这个叫做字符串的东西。

911
00:44:46,170 --> 00:44:48,180
Well, I claim that string is just char star.
好吧，我声称字符串就是 char star。

912
00:44:48,180 --> 00:44:50,430
You've actually seen this technique before.
你之前已经见过这种技巧了。

913
00:44:50,430 --> 00:44:54,630
It was just a week ago that we tinkered with structures, custom data types
就在一周前，我们尝试了结构体，自定义数据类型。

914
00:44:54,630 --> 00:44:55,890
to represent a person.
用来代表一个人。

915
00:44:55,890 --> 00:44:59,530
And recall that we had a structure of a name and a number representing
回想一下，我们有一个包含姓名和数字的结构，代表着

916
00:44:59,530 --> 00:45:00,030
a person.
一个人。

917
00:45:00,030 --> 00:45:03,030
But more importantly, we had this keyword typedef,
但更重要的是，我们有这个关键字 typedef，

918
00:45:03,030 --> 00:45:05,940
which defines your own type to be whatever you want.
它定义了你自己的类型，可以是你想要的任何类型。

919
00:45:05,940 --> 00:45:08,160
Now, we used it a little more powerfully last time
现在，上次我们更强大地使用了它

920
00:45:08,160 --> 00:45:11,880
to actually represent a whole structure of a person, having a name,
来真正地代表一个包含姓名、

921
00:45:11,880 --> 00:45:12,790
and having a number.
以及数字的完整结构。

922
00:45:12,790 --> 00:45:15,623
But at the end of the day, we really just invented our own data type
但最终，我们实际上只是发明了自己的数据类型

923
00:45:15,623 --> 00:45:17,910
that we called, obviously, person.
我们很明显地把它叫做 person。

924
00:45:17,910 --> 00:45:20,400
But and that represented, indeed, this structure.
而它确实代表了这个结构。

925
00:45:20,400 --> 00:45:23,380
But typedef was really the enabling element there.
但是 typedef 才是真正的关键元素。

926
00:45:23,380 --> 00:45:25,470
And so it turns out with typedef, you can create
所以事实证明，使用 typedef，你可以创建

927
00:45:25,470 --> 00:45:27,060
any number of data types of your own.
任意数量你自己的数据类型。

928
00:45:27,060 --> 00:45:28,860
For instance, if you just really can't get
例如，如果你真的无法接受

929
00:45:28,860 --> 00:45:31,140
the hang of calling an integer an int, you
把整数叫做 int，你可以

930
00:45:31,140 --> 00:45:34,230
can create your own data type called integer
创建一个你自己的数据类型叫做 integer

931
00:45:34,230 --> 00:45:37,403
that itself is a synonym for int, because the way typedef works,
它本身是 int 的同义词，因为 typedef 的工作方式是，

932
00:45:37,403 --> 00:45:39,570
even though this one's even simpler than the struct,
即使它比结构体还要简单，

933
00:45:39,570 --> 00:45:42,310
is you can read it from right to left.
你可以从右到左阅读它。

934
00:45:42,310 --> 00:45:47,662
This means give me a data type called integer that is actually an int.
这意味着给我一个叫做 integer 的数据类型，它实际上是一个 int。

935
00:45:47,662 --> 00:45:49,870
And that's the same thing that happened a moment ago.
这和刚才发生的事情是一样的。

936
00:45:49,870 --> 00:45:53,130
Give me a data type called person that is actually this whole structure.
给我一个叫做 person 的数据类型，它实际上是这个完整的结构。

937
00:45:53,130 --> 00:45:54,760
But an integer is even simpler.
但整数更简单。

938
00:45:54,760 --> 00:45:56,340
Now, most people wouldn't do this.
现在，大多数人不会这样做。

939
00:45:56,340 --> 00:45:59,820
This really doesn't create any intellectual enhancement of the data
这实际上不会对数据类型进行任何智力上的增强，

940
00:45:59,820 --> 00:46:02,130
types, but you could do it if you really wanted.
但是如果你真的想要，你可以这样做。

941
00:46:02,130 --> 00:46:05,070
More commonly, and as you'll see this in code in the future,
更常见的是，你将在未来的代码中看到，

942
00:46:05,070 --> 00:46:07,470
would be not just a typedef something like an integer.
不仅仅是像 integer 这样的 typedef。

943
00:46:07,470 --> 00:46:11,460
But it turns out, curiously, C has no data type for a byte.
但事实证明，奇怪的是，C 语言没有表示字节的数据类型。

944
00:46:11,460 --> 00:46:15,750
Like, there's no built in obvious way to represent eight bits
比如，没有内置的明显方法来表示八位

945
00:46:15,750 --> 00:46:17,830
and store whatever you want in them.
并将你想要的东西存储在其中。

946
00:46:17,830 --> 00:46:21,720
However, you can use what's called a uint8_t, t
但是，你可以使用所谓的 uint8_t，

947
00:46:21,720 --> 00:46:25,530
which is a data type that comes with C. And frankly, those more comfortable
它是一个与 C 语言一起提供的數據類型。坦率地说，那些更熟悉

948
00:46:25,530 --> 00:46:27,600
might simply use this data type once you sort of
的人可能会在你能记住它存在之后直接使用这个数据类型。

949
00:46:27,600 --> 00:46:29,070
commit to memory that it exists.
记住它存在。

950
00:46:29,070 --> 00:46:32,680
But honestly, for most of us, it's a lot more convenient to think of a byte
但老实说，对我们大多数人来说，将字节视为

951
00:46:32,680 --> 00:46:34,210
as being its own data type.
它自己的数据类型会更方便。

952
00:46:34,210 --> 00:46:37,540
When you want to write code that manipulates one or two or more bytes,
当你想要编写操作一个、两个或多个字节的代码时，

953
00:46:37,540 --> 00:46:39,850
wouldn't it be nice to have a data type called byte?
拥有一个叫做 byte 的数据类型不是很好吗？

954
00:46:39,850 --> 00:46:43,630
So it turns out that you can represent a byte, which is eight bits using
所以事实证明，你可以用

955
00:46:43,630 --> 00:46:45,830
an unsigned integer with 8 bits.
一个 8 位的无符号整数来表示一个字节，它有八位。

956
00:46:45,830 --> 00:46:49,900
And this is just a data type that's declared in some other C header file.
而这只是一个在其他 C 头文件中声明的数据类型。

957
00:46:49,900 --> 00:46:52,870
But long story short, you'll see and use this before long.
但长话短说，你很快就会看到并使用它。

958
00:46:52,870 --> 00:46:56,290
But it's just a synonym to make things a little more user friendly,
但它只是一个同义词，让事情更方便，

959
00:46:56,290 --> 00:46:58,885
like person, like string, like byte.
就像 person，就像 string，就像 byte。

960
00:46:58,885 --> 00:47:02,860
So what is in the CS50 header file, among other things?
那么 CS50 头文件中除了其他东西之外，还包含什么呢？

961
00:47:02,860 --> 00:47:04,750
Literally, this line of code.
实际上，就是这行代码。

962
00:47:04,750 --> 00:47:07,180
This is the single line of code that we deploy
这是我们从第一周开始部署的唯一一行代码

963
00:47:07,180 --> 00:47:11,260
in week one onward that teaches Clang to think of the word string
它告诉 Clang 从第一周开始将字符串理解为

964
00:47:11,260 --> 00:47:15,550
as being synonymous with char star, so that you all never have to type,
与字符指针是同义词，这样你们就永远不必输入，

965
00:47:15,550 --> 00:47:20,470
or know, or think about char star until, wonderfully, today in week four,
或者知道，或者去思考字符指针，直到今天，神奇的是，我们到了第四周，

966
00:47:20,470 --> 00:47:22,670
a couple of weeks later instead.
也就是几周后。

967
00:47:22,670 --> 00:47:24,340
So that's all we've been doing.
这就是我们一直在做的事情。

968
00:47:24,340 --> 00:47:27,430
That is the technical implementation of the training wheels.
这就是辅助轮的技术实现。

969
00:47:27,430 --> 00:47:32,870
It's just using a custom data type in this way.
它只是以这种方式使用了自定义数据类型。

970
00:47:32,870 --> 00:47:37,970
So how about one other maybe pair of examples here with our addresses,
那么我们用地址再举一对例子，

971
00:47:37,970 --> 00:47:40,340
such that we can tinker a little bit further?
这样我们可以进一步研究一下？

972
00:47:40,340 --> 00:47:44,600
It turns out that, once everything in the world
事实证明，一旦世界上所有事物

973
00:47:44,600 --> 00:47:48,470
is addressable using these pointers, like using numeric addresses
都可以使用这些指针进行寻址，就像使用数字地址一样

974
00:47:48,470 --> 00:47:50,870
to represent where things are in memory, you can actually
来表示事物在内存中的位置，你实际上

975
00:47:50,870 --> 00:47:52,700
do something called pointer arithmetic.
可以做一些叫做指针运算的事情。

976
00:47:52,700 --> 00:47:54,680
And here, too, we the programmers generally
而且这里，我们程序员通常

977
00:47:54,680 --> 00:47:59,640
don't care what the specific values are, but we care that they do exist.
并不关心具体的值是什么，但我们关心它们是否存在。

978
00:47:59,640 --> 00:48:02,600
And if they do exist, we can maybe do some arithmetic on them
如果它们确实存在，我们也许可以对它们进行一些运算

979
00:48:02,600 --> 00:48:05,750
and add one to go to the next byte, add two to go to the next, next byte,
加一去到下一个字节，加二去到下下一个字节，

980
00:48:05,750 --> 00:48:08,400
add three to go to the next, next, net byte, and so forth.
加三去到下下下一个字节，等等。

981
00:48:08,400 --> 00:48:12,710
So pointer arithmetic literally refers to doing math on addresses.
因此，指针运算实际上是指对地址进行数学运算。

982
00:48:12,710 --> 00:48:15,260
So how do we translate this into something actionable?
那么我们如何将其转化为可操作的东西呢？

983
00:48:15,260 --> 00:48:18,410
Let me actually go back to VS Code here, and let
让我回到 VS Code，然后

984
00:48:18,410 --> 00:48:21,210
me propose that we do something like the following.
我建议我们做以下事情。

985
00:48:21,210 --> 00:48:25,040
I'm going to throw away my first printf here.
我将丢弃这里第一个 printf。

986
00:48:25,040 --> 00:48:28,400
And I'm instead going to print out this string character by character,
我将改为逐个字符地打印这个字符串，

987
00:48:28,400 --> 00:48:30,920
just like we did in week two.
就像我们在第二周做的那样。

988
00:48:30,920 --> 00:48:36,950
Let me go ahead and call printf, pass in %c for a single char, backslash n,
让我继续调用 printf，传入 %c 来打印单个字符，反斜杠 n，

989
00:48:36,950 --> 00:48:40,610
comma, and now I want to print out the first character in s.
逗号，现在我想要打印出 s 中的第一个字符。

990
00:48:40,610 --> 00:48:45,250
Using array notation, what do I type to print the first character in s?
使用数组表示法，我应该输入什么来打印 s 中的第一个字符？

991
00:48:48,250 --> 00:48:49,530
Yep, over here.
没错，在那边。

992
00:48:49,530 --> 00:48:50,430
s bracket zero.
s 中括号 0。

993
00:48:50,430 --> 00:48:52,950
So s bracket zero gives me the first character in s.
所以 s 中括号 0 给了我 s 中的第一个字符。

994
00:48:52,950 --> 00:48:55,320
And let me copy paste just for demonstration sake
为了演示，让我复制粘贴一下

995
00:48:55,320 --> 00:48:58,200
here inside of my same curly braces, and print out
在我的同一个花括号中，打印出来

996
00:48:58,200 --> 00:48:59,520
the second char, and the third.
第二个字符，和第三个字符。

997
00:48:59,520 --> 00:49:00,840
And I don't care about the null character.
我不关心空字符。

998
00:49:00,840 --> 00:49:03,160
I just want to print the string itself for now.
我现在只是想打印出字符串本身。

999
00:49:03,160 --> 00:49:07,095
So even though this is jumping through way more hoops than just using %s
所以即使这比仅仅使用 %s 跳了很多圈

1000
00:49:07,095 --> 00:49:10,530
and print the whole thing at once, it's again, just demonstrating how we can,
并直接打印整个内容，但这又一次证明了我们如何可以，

1001
00:49:10,530 --> 00:49:12,840
at a lower level, manipulate these strings.
在更底层上，操纵这些字符串。

1002
00:49:12,840 --> 00:49:15,270
So let me do make addresses, dot slash addresses.
所以让我做 make addresses，点斜杠 addresses。

1003
00:49:15,270 --> 00:49:18,090
And yet again, we see, somewhat stupidly, one
再一次，我们看到，有点愚蠢的是，一行一个

1004
00:49:18,090 --> 00:49:21,630
per line, H-I exclamation point.
H-I 感叹号。

1005
00:49:21,630 --> 00:49:23,940
I can, of course fix that by getting rid of this.
当然，我可以通过去掉这个来解决它。

1006
00:49:23,940 --> 00:49:27,052
I can get rid of this, and I can leave the last backslash n.
我可以去掉这个，留下最后一个反斜杠 n。

1007
00:49:27,052 --> 00:49:29,010
So let's just make it a look a little prettier.
让我们让它看起来更漂亮一些。

1008
00:49:29,010 --> 00:49:32,070
Make addresses, dot slash addresses, enter,
创建地址，点斜杠地址，回车，

1009
00:49:32,070 --> 00:49:34,320
and I can print it out all on one line.
我就可以在一行上打印出来。

1010
00:49:34,320 --> 00:49:37,140
But now using pointer notation, it turns out
但是现在使用指针符号，结果发现

1011
00:49:37,140 --> 00:49:40,230
we can do one other thing, which admittedly, for now,
我们可以做另外一件事，诚然，目前来说，

1012
00:49:40,230 --> 00:49:42,450
is going to feel like unnecessary complexity.
会让人觉得不必要的复杂。

1013
00:49:42,450 --> 00:49:46,420
But it's actually a really helpful tool to add to our toolkit, so to speak,
但实际上，它是一个非常有用的工具，可以添加到我们的工具箱中，这么说吧，

1014
00:49:46,420 --> 00:49:48,820
whereby I could instead do this.
我可以这样做。

1015
00:49:48,820 --> 00:49:54,370
To print out the first character in s, yes, I can treat it as an array
要打印出 s 中的第一个字符，是的，我可以将其视为一个数组

1016
00:49:54,370 --> 00:49:56,560
and get the zeroth index.
并获取第零个索引。

1017
00:49:56,560 --> 00:49:59,800
However, what is s? s is just the address of a string.
然而，s 是什么呢？s 只是字符串的地址。

1018
00:49:59,800 --> 00:50:03,710
What does that mean? s is the address of the first char in the string.
这意味着什么呢？s 是字符串中第一个字符的地址。

1019
00:50:03,710 --> 00:50:09,560
So if I do star s, what's that going to print?
所以如果我用星号表示 s，会打印什么呢？

1020
00:50:09,560 --> 00:50:11,090
Presumably h, right?
应该是 h，对吧？

1021
00:50:11,090 --> 00:50:18,410
Because if the first character in s is h, then star s will go to that address
因为如果 s 中的第一个字符是 h，那么星号表示的 s 将会指向该地址

1022
00:50:18,410 --> 00:50:20,090
and show me what's actually there.
并向我展示那里实际上的内容。

1023
00:50:20,090 --> 00:50:21,930
And let me go ahead and do this again.
让我继续这样做。

1024
00:50:21,930 --> 00:50:25,530
Let me copy paste twice and then tweak this a little bit.
让我复制粘贴两次，然后稍微调整一下。

1025
00:50:25,530 --> 00:50:27,920
I want to go to the next byte over.
我想去下一个字节。

1026
00:50:27,920 --> 00:50:29,780
Well, I could do s bracket one.
好吧，我可以使用 s 中括号 1。

1027
00:50:29,780 --> 00:50:34,760
All right, but I could instead go to s plus one.
好的，但我可以用 s 加 1 来代替。

1028
00:50:34,760 --> 00:50:38,600
And I could instead go to s plus two, thereby
我还可以使用 s 加 2 来代替，从而

1029
00:50:38,600 --> 00:50:41,960
doing what we're calling pointer arithmetic, math on addresses.
执行我们称之为指针算术的操作，对地址进行数学运算。

1030
00:50:41,960 --> 00:50:47,000
And now, if I go ahead and rerun make addresses, dot slash addresses, voila.
现在，如果我继续运行创建地址，点斜杠地址，瞧！

1031
00:50:47,000 --> 00:50:48,710
Whoops, I forgot my backslash n.
哎呀，我忘记了反斜杠 n。

1032
00:50:48,710 --> 00:50:51,080
Let's fix that just to be tidy.
让我们修正一下，使其整洁。

1033
00:50:51,080 --> 00:50:53,690
Dot slash addresses, voila.
点斜杠地址，瞧！

1034
00:50:53,690 --> 00:50:55,670
There is our "HI".
这就是我们的“HI”。

1035
00:50:55,670 --> 00:50:58,400
Now, this is not how a normal person would print out a string,
现在，这并不是普通人打印字符串的方式，

1036
00:50:58,400 --> 00:51:02,210
but it does go to show you that there's not really been any magic.
但这确实表明，这里并没有什么魔法。

1037
00:51:02,210 --> 00:51:05,390
Like, these characters are just where we predicted they would be.
就像，这些字符正好在我们预测的地方。

1038
00:51:05,390 --> 00:51:08,700
And now that you have this star notation, the dereference operator,
现在你有了这个星号符号，解除引用运算符，

1039
00:51:08,700 --> 00:51:12,120
which means go there, you have the ability to access individual values.
这意味着去那里，你可以访问单个值。

1040
00:51:12,120 --> 00:51:15,750
You even have the ability to ask where those things are by using ampersands,
你甚至可以使用取地址符来询问这些东西在哪里，

1041
00:51:15,750 --> 00:51:16,480
as well.
也是。

1042
00:51:16,480 --> 00:51:20,820
But it turns out that the reason that we introduced the array syntax first
但事实证明，我们首先引入数组语法的原因是

1043
00:51:20,820 --> 00:51:22,860
is that the array syntax is what the world would
因为数组语法是世界

1044
00:51:22,860 --> 00:51:26,040
call syntactic sugar for exactly this.
称之为对这种语法糖的语法糖。

1045
00:51:26,040 --> 00:51:31,950
When you say s bracket zero, the compiler is essentially doing star s
当你使用 s 中括号零时，编译器本质上是在执行星号表示的 s

1046
00:51:31,950 --> 00:51:33,300
and saving you the trouble.
并为你节省麻烦。

1047
00:51:33,300 --> 00:51:37,170
When you do s bracket one, the compiler is essentially
当你使用 s 中括号 1 时，编译器本质上是

1048
00:51:37,170 --> 00:51:41,100
saving you the trouble of doing star, in parentheses, s plus one,
为你节省使用星号、括号、s 加 1 的麻烦，

1049
00:51:41,100 --> 00:51:43,750
and same for the third char, as well.
第三个字符也是一样的。

1050
00:51:43,750 --> 00:51:47,850
So all this time, pointers have been there underneath the hood.
所以一直以来，指针都隐藏在幕后。

1051
00:51:47,850 --> 00:51:50,760
They are what allow us to go to very specific memory locations.
它们使我们能够访问非常具体的内存位置。

1052
00:51:50,760 --> 00:51:54,400
They are going to be what allow us soon to start manipulating files,
它们将很快使我们能够开始操作文件，

1053
00:51:54,400 --> 00:51:57,908
whether it's photographs of stress balls, or CSI style content.
无论是压力球的照片，还是 CSI 风格的内容。

1054
00:51:57,908 --> 00:52:01,200
But for now, I think we should take our 10 minute break where whoopie pies will
但现在，我认为我们应该休息 10 分钟，谁派将在

1055
00:52:01,200 --> 00:52:02,640
now be served in the transept.
现在在过道里供应。

1056
00:52:02,640 --> 00:52:04,530
See you in 10.
10 分钟后见。

1057
00:52:04,530 --> 00:52:05,270
All right.
好的。

1058
00:52:05,270 --> 00:52:08,520
So we are back, and we've clearly drawn too much attention to the stress balls
所以我们回来了，我们显然对减压球给予了太多关注

1059
00:52:08,520 --> 00:52:10,937
today because now we're all out of these and whoopie pies.
今天，因为现在我们这些和谁派都没有了。

1060
00:52:10,937 --> 00:52:12,297
But more next week.
但下周会有更多。

1061
00:52:12,297 --> 00:52:14,130
In the meantime, though, we thought we'd now
与此同时，我们认为我们现在应该

1062
00:52:14,130 --> 00:52:17,940
use some of these new building blocks, this idea of being able to manipulate
使用一些新的构建块，这个想法能够操纵

1063
00:52:17,940 --> 00:52:20,610
underlying addresses, to revisit a couple of problems
底层地址，重新审视几个问题

1064
00:52:20,610 --> 00:52:23,580
that we kind of swept under the rug previously
我们之前把它暂时搁置了

1065
00:52:23,580 --> 00:52:26,120
by avoiding these problems altogether.
通过完全避免这些问题。

1066
00:52:26,120 --> 00:52:27,120
So by that, I mean this.
所以，我的意思是这个。

1067
00:52:27,120 --> 00:52:29,160
Let me go over to VS Code.
让我去 VS Code。

1068
00:52:29,160 --> 00:52:31,690
And let me create another example called compare.c,
让我创建一个名为 compare.c 的另一个示例，

1069
00:52:31,690 --> 00:52:34,440
whose purpose in life in a moment is going to be to compare values
它存在的目的，在接下来的一刻，将会是比较值

1070
00:52:34,440 --> 00:52:36,600
in kind of a very weak one way, too.
以一种非常薄弱的单向方式。

1071
00:52:36,600 --> 00:52:39,660
So let me go ahead and include CS50.h.
所以让我继续包含 CS50.h。

1072
00:52:39,660 --> 00:52:42,270
Let me go ahead and include standard io.h.
让我继续包含 standard io.h。

1073
00:52:42,270 --> 00:52:44,820
Let me do int main void, no command line arguments.
让我做 int main void，没有命令行参数。

1074
00:52:44,820 --> 00:52:49,000
And in here, let me just get two integers using getint as follows.
在这里，让我使用 getint 获取两个整数，如下所示。

1075
00:52:49,000 --> 00:52:51,300
So getint, and we'll ask for i.
所以 getint，我们将请求 i。

1076
00:52:51,300 --> 00:52:54,420
Let's go ahead and get int and ask for j,
让我们继续获取 int 并请求 j，

1077
00:52:54,420 --> 00:52:57,190
just so that we have two things to compare.
这样我们就有两件事可以比较了。

1078
00:52:57,190 --> 00:52:59,200
And then I'm going to do something super simple.
然后我要做一些超级简单的事情。

1079
00:52:59,200 --> 00:53:03,630
So if i equals, equals j, then let's print out,
所以如果 i 等于等于 j，那么让我们打印出来，

1080
00:53:03,630 --> 00:53:07,020
as we actually did in the past, same backslash n.
就像我们过去所做的那样，相同的反斜杠 n。

1081
00:53:07,020 --> 00:53:10,430
Else, if they're not the same, let's of course, print out, for instance,
否则，如果它们不一样，让我们当然，打印出来，例如，

1082
00:53:10,430 --> 00:53:10,930
different.
不同。

1083
00:53:10,930 --> 00:53:13,890
So super simple program that we used the first time around, really,
这是一个超级简单的程序，我们在第一次使用时，真的

1084
00:53:13,890 --> 00:53:15,430
just to demonstrate conditionals.
只是为了演示条件语句。

1085
00:53:15,430 --> 00:53:18,550
But now, we'll use it to tease apart some subtleties.
但是现在，我们将用它来揭示一些细微之处。

1086
00:53:18,550 --> 00:53:21,990
So let me go ahead and compile this with make compare.
所以让我继续使用 make compare 来编译它。

1087
00:53:21,990 --> 00:53:23,730
Dot slash compare.
点斜杠 compare。

1088
00:53:23,730 --> 00:53:27,330
And we'll compare one and one for i and j respectively.
我们将分别比较 i 和 j 的 1 和 1。

1089
00:53:27,330 --> 00:53:28,650
Those are, of course, the same.
它们当然是一样的。

1090
00:53:28,650 --> 00:53:30,357
Let's compare one and two.
让我们比较 1 和 2。

1091
00:53:30,357 --> 00:53:31,690
Those are, of course, different.
它们当然是不一样的。

1092
00:53:31,690 --> 00:53:34,560
So long story short, this program seems to work,
所以长话短说，这个程序似乎可以工作，

1093
00:53:34,560 --> 00:53:36,630
and we won't dwell much further on it.
我们不会进一步深入讨论它。

1094
00:53:36,630 --> 00:53:39,630
But let's consider for a moment what's going on inside of the computer's
但让我们花一点时间考虑一下计算机内部发生的事情

1095
00:53:39,630 --> 00:53:42,250
memory when that code is executed.
内存，当该代码被执行时。

1096
00:53:42,250 --> 00:53:43,920
So here's my canvas of memory.
所以这是我的内存画布。

1097
00:53:43,920 --> 00:53:45,660
Maybe i ends up over here.
也许 i 最终在这里。

1098
00:53:45,660 --> 00:53:47,350
Maybe j ends up over here.
也许 j 最终在这里。

1099
00:53:47,350 --> 00:53:51,480
Each of them I've drawn as four squares because integers are typically
我将它们中的每一个都画成了四个方块，因为整数通常

1100
00:53:51,480 --> 00:53:53,260
four bytes, or 32 bits.
四个字节，或 32 位。

1101
00:53:53,260 --> 00:53:56,520
So i has the value 50 here. i has the value 50.
所以 i 这里的值是 50。 i 的值是 50。

1102
00:53:56,520 --> 00:53:59,220
So I accidentally typed one and one, but assume
所以我不小心输入了 1 和 1，但假设

1103
00:53:59,220 --> 00:54:00,940
that I had typed 50 in both cases.
我在这两种情况下都输入了 50。

1104
00:54:00,940 --> 00:54:03,340
They both live at these two separate locations.
它们都住在这两个不同的位置。

1105
00:54:03,340 --> 00:54:03,840
All right.
好的。

1106
00:54:03,840 --> 00:54:05,800
So that's all fine and good.
所以这一切都很好。

1107
00:54:05,800 --> 00:54:09,960
And when we compare them, of course, 50 and 50, or one and one
当然，当我们比较它们时，50 和 50，或者 1 和 1

1108
00:54:09,960 --> 00:54:12,120
are, in fact, the exact same.
实际上是完全相同的。

1109
00:54:12,120 --> 00:54:16,290
But what if we actually compare different types of values?
但如果我们比较不同类型的值呢？

1110
00:54:16,290 --> 00:54:18,210
Let me go back into VS Code here.
让我回到这里的 VS Code 中。

1111
00:54:18,210 --> 00:54:22,050
And instead of integers, let's still, using the CS50 library,
我们仍然使用 CS50 库，而不是整数，

1112
00:54:22,050 --> 00:54:24,490
maybe use some strings instead.
也许使用一些字符串。

1113
00:54:24,490 --> 00:54:29,380
So let me go ahead and change my i and j to maybe s and t, respectively.
所以，让我继续将我的 i 和 j 分别改为 s 和 t。

1114
00:54:29,380 --> 00:54:31,710
So string s equals getstring.
所以字符串 s 等于 getstring。

1115
00:54:31,710 --> 00:54:34,440
And I'll ask for s, quote unquote.
我会要求 s，引号，引号。

1116
00:54:34,440 --> 00:54:37,260
And then string t equals getstring.
然后字符串 t 等于 getstring。

1117
00:54:37,260 --> 00:54:39,900
And then I'll ask for t, quote unquote.
然后我会要求 t，引号，引号。

1118
00:54:39,900 --> 00:54:44,700
And then down here, I'll compare s equals, equals t.
然后在下面，我会比较 s 等于，等于 t。

1119
00:54:44,700 --> 00:54:46,980
So here's the code, almost the same logically.
所以这是代码，逻辑上几乎相同。

1120
00:54:46,980 --> 00:54:50,760
I'm just getting different data types instead, still using the CS50 library.
我只是获得不同的数据类型，仍然使用 CS50 库。

1121
00:54:50,760 --> 00:54:54,930
So let's do make compare again, dot slash compare.
所以让我们再次执行 make compare，点斜杠 compare。

1122
00:54:54,930 --> 00:54:58,140
And let's type in something like "HI" exclamation point,
让我们输入类似于“HI”感叹号的东西，

1123
00:54:58,140 --> 00:54:59,760
"HI" exclamation point.
“HI”感叹号。

1124
00:54:59,760 --> 00:55:02,580
And that's interesting.
这很有趣。

1125
00:55:02,580 --> 00:55:05,320
All right, let's maybe try it again.
好吧，让我们再试一次。

1126
00:55:05,320 --> 00:55:08,040
So maybe lowercase "hi", "hi".
所以可能是小写“hi”，“hi”。

1127
00:55:08,040 --> 00:55:09,280
No, those are different.
不，这些是不同的。

1128
00:55:09,280 --> 00:55:12,190
Let's do it one more time, like "hi", "bye".
让我们再做一次，比如“hi”，“bye”。

1129
00:55:12,190 --> 00:55:13,810
OK, so it half works.
好的，所以它有一半有效。

1130
00:55:13,810 --> 00:55:17,210
But it seems to be saying different no matter what.
但无论如何，它似乎都在说不同。

1131
00:55:17,210 --> 00:55:18,420
Well, why might that be?
为什么是这样呢？

1132
00:55:18,420 --> 00:55:20,170
Well, let me first just peel back a layer.
好吧，让我先剥开一层。

1133
00:55:20,170 --> 00:55:22,850
We already know that strings don't technically exist.
我们已经知道字符串在技术上并不存在。

1134
00:55:22,850 --> 00:55:24,850
They're really char star.
它们实际上是 char star。

1135
00:55:24,850 --> 00:55:28,120
And string here is char star.
而这里的字符串是 char star。

1136
00:55:28,120 --> 00:55:32,590
So does this reveal, perhaps implicitly, why
那么，这是否隐含地揭示了为什么

1137
00:55:32,590 --> 00:55:35,860
s and t are being thought to be different, even though I literally
s 和 t 被认为是不同的，即使我确实是

1138
00:55:35,860 --> 00:55:37,105
typed "hi" twice?
两次输入“hi”？

1139
00:55:40,290 --> 00:55:43,830
Yeah, on line nine here, I'm really just comparing
是的，在这第 9 行，我只是在比较

1140
00:55:43,830 --> 00:55:48,300
the addresses that are in s and t, and that's why I changed it to char star,
s 和 t 中的地址，这就是我将其更改为 char star 的原因，

1141
00:55:48,300 --> 00:55:51,330
just not to change anything, but to make it even clearer
只是为了不改变任何东西，而是让它更加清楚

1142
00:55:51,330 --> 00:55:53,520
that s and t are, in fact, addresses.
s 和 t 实际上是地址。

1143
00:55:53,520 --> 00:55:55,300
They're not strings, per se.
它们不是字符串本身。

1144
00:55:55,300 --> 00:55:57,870
They're the address of the first character in those strings.
它们是这些字符串中第一个字符的地址。

1145
00:55:57,870 --> 00:56:00,810
And even though they happen to be the same words that I typed in,
即使它们碰巧是我输入的相同词语，

1146
00:56:00,810 --> 00:56:03,790
it would seem to imply that they're ending up in different places.
似乎意味着它们最终会出现在不同的位置。

1147
00:56:03,790 --> 00:56:06,360
So here's another canvas of memory for this program.
所以这是该程序的另一个内存画布。

1148
00:56:06,360 --> 00:56:08,850
And here, for instance, might be s with enough room
例如，这里可能会有足够的空间容纳 s

1149
00:56:08,850 --> 00:56:11,550
for eight bytes up here as a pointer.
作为指针，这里有 8 个字节。

1150
00:56:11,550 --> 00:56:14,790
Here maybe is where "hi" ended up for this particular story.
这里可能是“hi”在这个特定故事中最终出现的地方。

1151
00:56:14,790 --> 00:56:16,455
Well, what's actually going in s?
那么，s 里面实际上是什么？

1152
00:56:16,455 --> 00:56:21,930
Well, if h is at OX123, i is at OX124, and so forth, what's going in
那么，如果 h 在 OX123，i 在 OX124，等等，那么 s 里面有什么

1153
00:56:21,930 --> 00:56:24,180
s is OX123.
s 是 OX123。

1154
00:56:24,180 --> 00:56:29,520
But when I use get string a second time and type in "hi"
但是当我第二次使用 get string 并输入 "hi"

1155
00:56:29,520 --> 00:56:33,090
exclamation point, even the exact same way, uppercase or lowercase,
感叹号，即使使用完全相同的方式，大写或小写，

1156
00:56:33,090 --> 00:56:35,710
t is ending up, presumably, somewhere else in memory.
t 很可能最终存储在内存中的其他地方。

1157
00:56:35,710 --> 00:56:37,830
So it's maybe using these eight bytes over here.
所以它可能正在使用这些八个字节。

1158
00:56:37,830 --> 00:56:41,430
The same letters, coincidentally, by nature of how getstring works,
巧合的是，由于 getstring 的工作原理，相同的字母

1159
00:56:41,430 --> 00:56:44,580
are ending up in the computer's memory, maybe down there, bottom right
最终存储在计算机的内存中，可能在下方，右下角

1160
00:56:44,580 --> 00:56:45,270
hand corner.
角落。

1161
00:56:45,270 --> 00:56:50,370
Those are presumably different addresses, OX456, 457, 458, 459.
这些很可能是不同的地址，OX456，457，458，459。

1162
00:56:50,370 --> 00:56:54,720
So what's going to go in t as its value?
那么，t 的值将是什么？

1163
00:56:54,720 --> 00:56:57,370
OX456, according to this example.
根据这个例子，是 OX456。

1164
00:56:57,370 --> 00:57:00,750
And so when you literally compare s equals,
所以当你直接比较 s 等于

1165
00:57:00,750 --> 00:57:04,660
equals t, no, they're not the same.
等于 t 时，不，它们并不相同。

1166
00:57:04,660 --> 00:57:07,770
They are, in fact, different, even if what they're pointing at
事实上，它们是不同的，即使它们指向的是

1167
00:57:07,770 --> 00:57:08,887
happens to be the same.
相同的内容。

1168
00:57:08,887 --> 00:57:10,470
So the computer's taking us literally.
所以计算机是按照字面意思来理解我们的。

1169
00:57:10,470 --> 00:57:12,790
If you compare s and t respectively, it's
如果你分别比较 s 和 t，它

1170
00:57:12,790 --> 00:57:14,790
going to compare what their values actually are.
将比较它们的实际值。

1171
00:57:14,790 --> 00:57:17,490
And their values are the addresses of the first letter
而它们的值是第一个字母的地址

1172
00:57:17,490 --> 00:57:20,860
of this string, and the first letter of this string, respectively.
这个字符串，以及这个字符串的第一个字母。

1173
00:57:20,860 --> 00:57:23,640
And if those addresses differ, which they clearly do,
如果这些地址不同，很明显它们确实不同，

1174
00:57:23,640 --> 00:57:25,600
they're going to be deemed different.
它们将被认为是不同的。

1175
00:57:25,600 --> 00:57:28,350
Now, you might wonder, well, this just seems stupidly inefficient.
现在，你可能会想，好吧，这看起来真的很低效。

1176
00:57:28,350 --> 00:57:31,930
Why put the same string in two different places?
为什么要把相同的字符串放在两个不同的位置？

1177
00:57:31,930 --> 00:57:34,415
Well, maybe the string needs to be changed later on,
好吧，也许该字符串需要稍后更改，

1178
00:57:34,415 --> 00:57:36,790
and we might want to have two different versions thereof.
我们可能想要拥有两个不同的版本。

1179
00:57:36,790 --> 00:57:40,683
And frankly, the first time you call getstring, it does its thing.
坦率地说，你第一次调用 getstring 时，它会执行它的操作。

1180
00:57:40,683 --> 00:57:43,100
The second time you call getstring, it does its own thing.
你第二次调用 getstring 时，它会执行它自己的操作。

1181
00:57:43,100 --> 00:57:46,433
It doesn't necessarily know how many times it's been called in the past.
它不一定知道它过去被调用了多少次。

1182
00:57:46,433 --> 00:57:48,850
And so maybe there's no communication between those calls.
所以可能这些调用之间没有通信。

1183
00:57:48,850 --> 00:57:50,860
And so surely, it's going to do the simple thing
所以当然，它会做简单的事情

1184
00:57:50,860 --> 00:57:54,160
and just create more memory, create more memory for each of those strings,
并为每个字符串创建更多内存，创建更多内存，

1185
00:57:54,160 --> 00:57:56,350
duplicates though they may seem to be.
即使它们看起来像是重复的。

1186
00:57:56,350 --> 00:57:58,150
So what does this imply?
那么这意味着什么？

1187
00:57:58,150 --> 00:58:01,540
Well, you might recall that we avoided this problem altogether
好吧，你可能还记得，我们完全避免了这个问题

1188
00:58:01,540 --> 00:58:06,850
just a week ago by using what solution on line nine?
就在一周前，通过在第九行使用什么解决方案？

1189
00:58:06,850 --> 00:58:10,240
I did not compare two strings using equals, equals last time.
上次我没有使用 equals，equals 比较两个字符串。

1190
00:58:12,940 --> 00:58:13,780
Exactly.
没错。

1191
00:58:13,780 --> 00:58:18,250
We used the strcompare function, which is in string.h very deliberately
我们使用了 strcompare 函数，它在 string.h 中，当时我非常谨慎地使用了它

1192
00:58:18,250 --> 00:58:21,280
at the time, because I didn't want to trip over this mistake at the time
因为我当时不想在这个错误上犯错

1193
00:58:21,280 --> 00:58:24,010
until we were sort of ready and had the vocabulary to discuss it.
直到我们准备好并且拥有讨论它的词汇。

1194
00:58:24,010 --> 00:58:28,090
But I did not do s equals, equals t, even though, logically, that's
但我没有使用 s 等于，等于 t，即使从逻辑上来说，那就是

1195
00:58:28,090 --> 00:58:30,330
what you're trying to do, compare for equality.
你想要做的，比较是否相等。

1196
00:58:30,330 --> 00:58:32,080
But if you know now what a string is, it's
但是，如果你现在知道字符串是什么，它

1197
00:58:32,080 --> 00:58:34,480
an array of characters starting at some address.
是一个从某个地址开始的字符数组。

1198
00:58:34,480 --> 00:58:37,630
You really need someone something to do the heavy lifting
你真的需要有人或某事来完成繁重的工作

1199
00:58:37,630 --> 00:58:40,900
of comparing every one of those chars from left to right.
比较所有这些字符，从左到右。

1200
00:58:40,900 --> 00:58:45,700
We did it ourselves last time by just implementing it in code two weeks ago.
我们上次在两周前通过代码实现来完成的。

1201
00:58:45,700 --> 00:58:48,350
But strcompare compare does it for us.
但 strcompare compare 可以帮我们完成。

1202
00:58:48,350 --> 00:58:55,030
So strcompare, s comma t actually weirdly returns three possible values,
所以，strcompare，s 逗号 t 实际上奇怪地返回了三个可能的值，

1203
00:58:55,030 --> 00:58:59,140
zero if they're the same, a positive number if one comes before the other,
如果它们相同则返回零，如果一个在另一个前面则返回一个正数，

1204
00:58:59,140 --> 00:59:01,370
or a negative number if the opposite is true.
或者如果相反则返回一个负数。

1205
00:59:01,370 --> 00:59:04,420
So strcomp, remember, can be used for alphabetizing
所以 strcomp，记住，可以用来进行字母排序

1206
00:59:04,420 --> 00:59:08,780
things, or ascii-betizing things, based on those Ascii values.
事物，或者根据这些 ASCII 值进行 ASCII 排序。

1207
00:59:08,780 --> 00:59:12,910
So this version, if I open my terminal window now and do make compare,
所以这个版本，如果我现在打开我的终端窗口并执行 make compare，

1208
00:59:12,910 --> 00:59:17,337
dot slash compare, and type in "hi" and "hi", now, in fact,
点斜杠 compare，然后输入“hi”和“hi”，现在实际上，

1209
00:59:17,337 --> 00:59:19,420
they're the same because strcomp is doing the work
它们是相同的，因为 strcomp 正在进行工作

1210
00:59:19,420 --> 00:59:20,920
of comparing them char by char.
逐字符地比较它们。

1211
00:59:20,920 --> 00:59:25,280
And if I do "hi" and "bye", those are now, in fact, different.
如果我执行“hi”和“bye”，它们实际上现在不同了。

1212
00:59:25,280 --> 00:59:28,990
So we avoided the problem last time for this very reason that simply using
所以我们上次避免了这个问题，正是因为这个原因，简单地使用

1213
00:59:28,990 --> 00:59:30,790
equals, equals would not have worked.
等于，等于将不起作用。

1214
00:59:30,790 --> 00:59:31,290
Yes.
是的。

1215
00:59:38,432 --> 00:59:40,384
AUDIENCE: Using those values?
听众：使用这些值？

1216
00:59:40,384 --> 00:59:43,312
Is it like one minus one, or one, two, three,
就像一减一，还是一、二、三，

1217
00:59:43,312 --> 00:59:44,992
depending how different they are?
取决于它们有多不同？

1218
00:59:44,992 --> 00:59:46,200
SPEAKER 1: Oh, good question.
演讲者 1：哦，好问题。

1219
00:59:46,200 --> 00:59:49,590
So when using strcompare, the documentation
所以在使用 strcompare 时，文档

1220
00:59:49,590 --> 00:59:53,807
says that it will return zero, or a positive number, or a negative number.
说它将返回零，或一个正数，或一个负数。

1221
00:59:53,807 --> 00:59:55,390
It doesn't tell you a specific number.
它没有告诉你一个具体的数字。

1222
00:59:55,390 --> 00:59:59,110
So the magnitude of the integer that comes back actually has no meaning.
所以返回的整数的量级实际上没有意义。

1223
00:59:59,110 --> 01:00:03,010
It might very well be one, zero, and negative one, but there's no guarantee.
它很可能是 1、0 和 -1，但没有保证。

1224
01:00:03,010 --> 01:00:06,510
And so you can check for equality equals, equals,
所以你可以检查是否等于，等于，

1225
01:00:06,510 --> 01:00:10,050
or you should check for greater than or less
或者你应该检查是否大于或小于

1226
01:00:10,050 --> 01:00:12,340
than, but not specific to a certain number.
于，但不是针对特定数字。

1227
01:00:12,340 --> 01:00:14,010
So it just gives you relative ordering.
所以它只是给你相对排序。

1228
01:00:14,010 --> 01:00:17,190
It doesn't give you any more detail than that.
它没有给你更多细节。

1229
01:00:17,190 --> 01:00:17,710
All right.
好的。

1230
01:00:17,710 --> 01:00:21,990
So if we were to now take this lesson a step further,
所以，如果我们现在要进一步学习，

1231
01:00:21,990 --> 01:00:26,927
just to hammer home this point, whereby these strings s and t must clearly
只是为了强调这一点，即这些字符串 s 和 t 必须明确地

1232
01:00:26,927 --> 01:00:29,760
live at different addresses, let's actually try to see this in code.
存在于不同的地址，让我们实际尝试在代码中查看这一点。

1233
01:00:29,760 --> 01:00:31,990
So let me go back to VS Code here.
所以让我回到 VS Code 这里。

1234
01:00:31,990 --> 01:00:34,590
Let me go ahead and just remove all of the conditional code,
让我继续并将所有条件代码删除，

1235
01:00:34,590 --> 01:00:38,910
and instead do something old school, like print out %s backslash n and print
而是做一些老方法，比如打印输出 %s 反斜杠 n 并打印

1236
01:00:38,910 --> 01:00:39,525
out s.
输出 s。

1237
01:00:39,525 --> 01:00:43,390
Then Let's go ahead and print out %s again, but print out t,
然后让我们继续打印输出 %s，但打印输出 t，

1238
01:00:43,390 --> 01:00:46,040
just to see the two strings as being duplicative.
只是为了看到这两个字符串是重复的。

1239
01:00:46,040 --> 01:00:46,720
So here I go.
所以我开始做。

1240
01:00:46,720 --> 01:00:50,652
Make compare dot slash compare, "hi" exclamation point,
执行 make compare 点斜杠 compare，“hi”感叹号，

1241
01:00:50,652 --> 01:00:51,610
"hi" exclamation point.
“hi”感叹号。

1242
01:00:51,610 --> 01:00:53,510
And of course, they're actually the same.
当然，它们实际上是一样的。

1243
01:00:53,510 --> 01:00:56,830
But if I actually want to see where s and t are,
但如果我实际上想看看 s 和 t 在哪里，

1244
01:00:56,830 --> 01:00:59,650
I can change the % s to what?
我可以将 %s 更改为？

1245
01:00:59,650 --> 01:01:02,200
%p, %p here.
%p，%p 在这里。

1246
01:01:02,200 --> 01:01:05,020
And I don't need to use an ampersand before the s or the t
并且我不需要在 s 或 t 之前使用一个与号

1247
01:01:05,020 --> 01:01:06,700
because they are already addresses.
因为它们已经是地址了。

1248
01:01:06,700 --> 01:01:08,480
That was today's big reveal.
这就是今天的重大揭示。

1249
01:01:08,480 --> 01:01:12,050
And it turns out that printf is smart enough when you use s,
事实证明，当你使用 s 时，printf 足够智能，

1250
01:01:12,050 --> 01:01:18,280
and you give it an address of s, or the address in t, to just go there for you.
并且你给它一个 s 的地址，或者 t 中的地址，它就会直接为你转到那里。

1251
01:01:18,280 --> 01:01:21,025
So printf has been doing all of that for us with %s.
所以 printf 一直在用 %s 为我们做这一切。

1252
01:01:21,025 --> 01:01:24,070
But %p is actually going to print out those raw addresses.
但是 %p 实际上会打印出这些原始地址。

1253
01:01:24,070 --> 01:01:28,330
So let me do make compare, dot slash compare, "hi" once, "hi" twice.
所以让我做一下 make compare，点斜杠 compare，"hi" 一次，"hi" 两次。

1254
01:01:28,330 --> 01:01:34,120
And here now, we should see the addresses at which "hi" lives.
现在我们应该可以看到 "hi" 所在的地址。

1255
01:01:34,120 --> 01:01:37,870
And it's not going to be as simplistic as OX123 and OX456.
并且它不会像 OX123 和 OX456 那样简单。

1256
01:01:37,870 --> 01:01:40,540
But if I go back to my terminal and hit enter,
但是如果我回到我的终端并按下回车键，

1257
01:01:40,540 --> 01:01:43,480
indeed, I get two different hexadecimal values
实际上，我得到两个不同的十六进制值

1258
01:01:43,480 --> 01:01:46,870
that makes clear that, if I were to naively compare them with equals,
这清楚地表明，如果我天真地用等于号比较它们，

1259
01:01:46,870 --> 01:01:49,450
equals, they're always going to be different,
等于号，它们总是会不同，

1260
01:01:49,450 --> 01:01:51,740
even if I typed in the same words.
即使我输入了相同的单词。

1261
01:01:51,740 --> 01:01:54,850
So there's implications now of this, especially if we want
因此，这现在有了一些影响，特别是如果我们想要

1262
01:01:54,850 --> 01:01:56,960
to start changing things in memory.
开始更改内存中的内容。

1263
01:01:56,960 --> 01:02:00,490
So for instance, let me create a new program called copy.c.
例如，让我创建一个名为 copy.c 的新程序。

1264
01:02:00,490 --> 01:02:04,240
And in here, we'll start somewhat similarly with CS5o.h.
这里，我们将以与 CS5o.h 相似的方式开始。

1265
01:02:04,240 --> 01:02:09,070
We'll start with standard io.h.
我们将从 standard io.h 开始。

1266
01:02:09,070 --> 01:02:13,730
And preemptively, I'm going to go ahead and include string.h, as well.
并且，我将提前包含 string.h。

1267
01:02:13,730 --> 01:02:16,750
I'm going to declare main as not taking any command line arguments.
我将声明 main 不接受任何命令行参数。

1268
01:02:16,750 --> 01:02:20,050
And this time, I'm just going to get one string s with getstring,
这一次，我将只使用 getstring 获取一个字符串 s，

1269
01:02:20,050 --> 01:02:22,540
and I'll prompt the user for s.
然后我将提示用户输入 s。

1270
01:02:22,540 --> 01:02:24,730
And now, let me go ahead and naively say this.
现在，让我天真地说一下。

1271
01:02:24,730 --> 01:02:28,660
Let me give myself a new string called t and just set it equal to s,
让我给自己一个名为 t 的新字符串，并将其设置为等于 s，

1272
01:02:28,660 --> 01:02:31,672
my instinct being this is how I've copied integers before.
我的直觉是，这是我以前复制整数的方式。

1273
01:02:31,672 --> 01:02:33,880
This is how I've copied floating point values before.
这是我以前复制浮点数的方式。

1274
01:02:33,880 --> 01:02:38,800
This surely is how I copy strings, using the assignment operator as usual.
这肯定是我复制字符串的方式，使用通常的赋值运算符。

1275
01:02:38,800 --> 01:02:40,810
Let me now for the sake of discussion propose
现在，为了讨论起见，让我提议

1276
01:02:40,810 --> 01:02:43,480
that I want to capitalize the first letter in t,
我想将 t 中的第一个字母大写，

1277
01:02:43,480 --> 01:02:45,330
but not the first letter in s.
但不要将 s 中的第一个字母大写。

1278
01:02:45,330 --> 01:02:50,590
So logically, based on week two syntax, I'm going to go into the t string,
所以，从逻辑上讲，根据第二周的语法，我将进入 t 字符串，

1279
01:02:50,590 --> 01:02:58,180
go to location zero, and set it equal to upper of t bracket zero.
转到位置 0，并将其设置为 t 方括号 0 的 upper。

1280
01:02:58,180 --> 01:02:59,980
So recall, we introduced two upper.
所以，回想一下，我们引入了两个 upper。

1281
01:02:59,980 --> 01:03:02,140
It's just a handy function for capitalizing things.
它只是一个用于将事物大写的便捷函数。

1282
01:03:02,140 --> 01:03:04,510
There's two lower, and there's a bunch of others, as well.
还有两个 lower，以及一堆其他的。

1283
01:03:04,510 --> 01:03:07,385
I didn't include the header file yet, though, so I'm going to go back
不过，我还没有包含头文件，所以我将返回

1284
01:03:07,385 --> 01:03:08,050
and include--
并包含 --

1285
01:03:08,050 --> 01:03:10,120
anyone remember where these are?
有人记得这些在哪里吗？

1286
01:03:10,120 --> 01:03:11,860
Yeah, ctype.h.
是的，ctype.h。

1287
01:03:11,860 --> 01:03:14,600
And it's fine to look that up in the menu if you ever need it.
如果你需要的话，在菜单中查找它就可以了。

1288
01:03:14,600 --> 01:03:19,150
So here, I am, a little naively, capitalizing the first letter in t.
所以在这里，我天真地将 t 中的第一个字母大写。

1289
01:03:19,150 --> 01:03:21,850
Technically speaking, I should check what the length of t
从技术上讲，我应该检查 t 的长度

1290
01:03:21,850 --> 01:03:25,772
is first, because if there's no characters there, if it has zero chars,
是第一个，因为如果那里没有字符，如果它有 0 个字符，

1291
01:03:25,772 --> 01:03:26,980
there's nothing to uppercase.
就没有东西需要大写。

1292
01:03:26,980 --> 01:03:30,190
But for now, I'm going to keep it simple and just blindly do that there.
但现在，我会保持简单，并盲目地在那里做。

1293
01:03:30,190 --> 01:03:34,510
Now, let me go ahead and print out with %s the value of s.
现在，让我们继续使用 %s 打印 s 的值。

1294
01:03:34,510 --> 01:03:38,080
Now, let me go ahead and print out with %s value of t.
现在，让我们继续使用 %s 打印 t 的值。

1295
01:03:38,080 --> 01:03:43,930
And I should see one lowercase s and one capitalized T. All right, here we go.
我应该看到一个是小写的 s，另一个是大写的 T。好了，我们开始吧。

1296
01:03:43,930 --> 01:03:46,875
Make copy, dot slash copy.
运行 copy 文件，在 copy 目录下。

1297
01:03:46,875 --> 01:03:49,000
And I'm going to deliberately type it in lowercase.
我将故意用小写字母输入。

1298
01:03:49,000 --> 01:03:55,810
"hi" exclamation point, and we should see now they're both capitalized,
“hi” 加一个感叹号，现在我们应该看到它们都变成了大写，

1299
01:03:55,810 --> 01:03:57,340
it would seem.
看起来是这样的。

1300
01:03:57,340 --> 01:04:00,295
Intuitively, why might that be?
直观上，为什么会出现这种情况呢？

1301
01:04:02,950 --> 01:04:05,090
Exactly, the addresses are the same.
没错，地址是相同的。

1302
01:04:05,090 --> 01:04:10,030
So if I do use the assignment operator and just do t equals s semicolon,
所以如果我使用赋值运算符，并且执行 t 等于 s，并以分号结尾，

1303
01:04:10,030 --> 01:04:14,950
it's going to take me literally and copy the address in s over to t,
它将直接把 s 中的地址复制到 t 中，

1304
01:04:14,950 --> 01:04:17,330
so that effectively, they're pointing at the same thing.
这样，实际上它们指向的是同一个东西。

1305
01:04:17,330 --> 01:04:21,000
So if we draw another picture here, for instance, here maybe is s,
所以如果我们在这里画另外一张图，比如，这里可能是 s，

1306
01:04:21,000 --> 01:04:23,800
and here maybe is the lowercase "hi" that I first type
这里可能是第一次输入的小写字母“hi”

1307
01:04:23,800 --> 01:04:25,270
in down here in memory.
在内存中的下方。

1308
01:04:25,270 --> 01:04:28,660
Maybe that's at OX123 again, and therefore that's what's in s.
也许它位于 OX123，因此这就是 s 中的内容。

1309
01:04:28,660 --> 01:04:33,340
When I then create the variable t by declaring it to be a string,
然后我通过声明 t 是一个字符串来创建变量 t，

1310
01:04:33,340 --> 01:04:36,160
as well, that gives me another variable here called t.
同样，这给了我另一个叫做 t 的变量。

1311
01:04:36,160 --> 01:04:38,665
But I'm just setting it equal to s.
但我只是把它设置为等于 s。

1312
01:04:38,665 --> 01:04:41,710
I'm not calling getstring again in this version of copy.
在这个版本的 copy 中，我没有再次调用 getstring。

1313
01:04:41,710 --> 01:04:43,030
That was in compare.
那是 compare 中的代码。

1314
01:04:43,030 --> 01:04:46,290
In copy, I'm just literally copying s into t.
在 copy 中，我只是直接把 s 复制到 t 中。

1315
01:04:46,290 --> 01:04:50,370
So that literally just changes the value to OX123, also.
所以这直接将值也更改为 OX123。

1316
01:04:50,370 --> 01:04:52,440
And if we abstract away all of these addresses,
如果我们将所有这些地址抽象出来，

1317
01:04:52,440 --> 01:04:56,920
that's essentially like s and t both pointing to the same place.
这实际上就像 s 和 t 都指向同一个地方。

1318
01:04:56,920 --> 01:05:02,560
So if I use s bracket zero, or t bracket zero, they are one and the same.
所以，如果我使用 s 方括号零，或者 t 方括号零，它们就是同一个。

1319
01:05:02,560 --> 01:05:05,220
So when I use t bracket zero to use uppercase,
所以，当我使用 t 方括号零来使用大写字母时，

1320
01:05:05,220 --> 01:05:08,070
it's changing that lowercase h to capital H.
它将小写字母 h 更改为大写字母 H。

1321
01:05:08,070 --> 01:05:13,980
But again, both strings, both pointers are pointing at the same value.
但同样地，两个字符串，两个指针都指向同一个值。

1322
01:05:13,980 --> 01:05:17,130
And again, this should be even clearer as of today.
同样地，从今天开始，这一点应该更加清楚。

1323
01:05:17,130 --> 01:05:21,060
If I go back into VS Code and, indeed, take these training wheels off,
如果我回到 VS Code 中，并且确实摘掉了这些辅助轮，

1324
01:05:21,060 --> 01:05:25,950
and treat string as what it is, char star, which indicates that both s and t
并且将字符串视为它本身，即字符星，这表明 s 和 t 都是

1325
01:05:25,950 --> 01:05:29,700
are just addresses, which makes even clearer, syntactically,
地址，这在语法上更加清晰地表明，

1326
01:05:29,700 --> 01:05:33,640
that this is probably the picture that's going on underneath the hood.
这可能是引擎盖下正在发生的事情。

1327
01:05:33,640 --> 01:05:35,640
Now, just to make the code a little more robust,
现在，为了使代码更健壮，

1328
01:05:35,640 --> 01:05:38,190
let me at least be a little careful here.
至少让我在这里小心一点。

1329
01:05:38,190 --> 01:05:44,530
If the string length of t is greater than zero, then and only then,
如果 t 的字符串长度大于零，当且仅当，

1330
01:05:44,530 --> 01:05:48,880
should I really blindly index into the string and go to location zero.
我才应该真正地盲目地索引到字符串中并转到位置零。

1331
01:05:48,880 --> 01:05:51,310
That doesn't really solve the fundamental problem,
但这并没有真正解决根本问题，

1332
01:05:51,310 --> 01:05:54,640
but it at least avoids a situation where maybe the user just hits enter,
但至少它避免了一种情况，即用户可能只是按下了回车键，

1333
01:05:54,640 --> 01:05:56,800
gives me no characters, and I try to blindly
没有输入任何字符，而我试图盲目地

1334
01:05:56,800 --> 01:05:59,180
uppercase something that's not there.
将不存在的东西转换为大写。

1335
01:05:59,180 --> 01:06:00,377
But there's still a bug.
但仍然存在错误。

1336
01:06:00,377 --> 01:06:01,210
There's still a bug.
仍然存在错误。

1337
01:06:01,210 --> 01:06:03,290
So how do I actually solve this?
那么，我该如何真正地解决这个问题呢？

1338
01:06:03,290 --> 01:06:05,260
Well, it turns out we need two other functions
事实证明，我们需要另外两个函数。

1339
01:06:05,260 --> 01:06:06,873
that we haven't had occasion to use.
我们还没有机会使用。

1340
01:06:06,873 --> 01:06:09,040
But these are perhaps the most powerful, and they're
但这些可能是最强大的，而且它们是

1341
01:06:09,040 --> 01:06:11,860
going to allow us to solve even grander problems next week when
将会让我们在下周解决更宏大的问题，当

1342
01:06:11,860 --> 01:06:14,540
we discuss all the more, things called data structures.
我们讨论更多被称为数据结构的东西时。

1343
01:06:14,540 --> 01:06:19,160
But for now, let's very simply solve this idea of copying a string.
但现在，让我们简单地解决这个复制字符串的想法。

1344
01:06:19,160 --> 01:06:24,100
Let me go back into VS Code here, and let me give myself one more header file
让我回到 VS Code，再给自己添加一个头文件

1345
01:06:24,100 --> 01:06:26,810
that's called standard lib for standard library.
它叫做 standard lib，代表标准库。

1346
01:06:26,810 --> 01:06:31,420
So include standard lib dot h, in which both of these functions,
所以包含 standard lib 点 h，其中这两个函数

1347
01:06:31,420 --> 01:06:33,670
malloc and free, are declared for me.
malloc 和 free，都已为我声明。

1348
01:06:33,670 --> 01:06:37,300
And now, in my code, I'm going to behave a little bit differently here.
现在，在我的代码中，我将采取一些不同的行为。

1349
01:06:37,300 --> 01:06:40,900
Clearly, I got into trouble by just blindly copying the addresses.
很明显，我只是盲目地复制地址，导致了麻烦。

1350
01:06:40,900 --> 01:06:43,960
What I really want to do when I copy strings, presumably, and then
我真正想做的是，当我复制字符串，假设，然后

1351
01:06:43,960 --> 01:06:47,530
uppercase one of them, is I want to create
将其中一个字符串大写，我想创建一个

1352
01:06:47,530 --> 01:06:51,160
a duplicate string, a second array that is identical,
一个重复的字符串，一个完全相同的第二个数组，

1353
01:06:51,160 --> 01:06:52,970
but is elsewhere in memory.
但它位于内存中的其他位置。

1354
01:06:52,970 --> 01:06:55,520
So the way to do this might be as follows.
所以，这样做的方法可能是这样。

1355
01:06:55,520 --> 01:06:59,470
Instead of just setting t equal to s, I should really
而不是简单地将 t 设置为 s，我应该真正

1356
01:06:59,470 --> 01:07:02,050
call this brand new function called malloc,
调用这个全新的函数叫做 malloc，

1357
01:07:02,050 --> 01:07:06,020
which stands for memory allocate, and it takes a single argument,
它代表内存分配，它需要一个参数，

1358
01:07:06,020 --> 01:07:09,010
which is just the number of bytes you would like the operating system
它只是你想让操作系统分配给你的字节数。

1359
01:07:09,010 --> 01:07:10,400
to allocate for you.
分配给你。

1360
01:07:10,400 --> 01:07:13,700
So whether you're using this on Windows, Mac OS, or Linux in our case,
所以无论你是把它用在 Windows、Mac OS 还是 Linux 上，就我们而言，

1361
01:07:13,700 --> 01:07:16,060
this is a way I can literally ask the operating system,
这是一种方法，我可以直接问操作系统，

1362
01:07:16,060 --> 01:07:19,330
please find for me some number of bytes in the computer's memory
请为我在计算机的内存中找到一些字节

1363
01:07:19,330 --> 01:07:21,740
that I can now use for my own purposes.
现在可以用来满足我自己的需求。

1364
01:07:21,740 --> 01:07:24,978
So malloc here, I technically need at least three bytes,
所以这里的 malloc，我技术上至少需要三个字节，

1365
01:07:24,978 --> 01:07:26,770
but that's not going to be enough because I
但这还不够，因为我

1366
01:07:26,770 --> 01:07:28,490
need a fourth for the null character.
还需要一个字节来存放空字符。

1367
01:07:28,490 --> 01:07:29,560
So I could put four here.
所以我可以在此处放四个字节。

1368
01:07:29,560 --> 01:07:30,340
But that's stupid.
但这很愚蠢。

1369
01:07:30,340 --> 01:07:33,070
I shouldn't just hardcode a number like this we've seen.
我应该避免像这样直接硬编码数字，我们已经看到过。

1370
01:07:33,070 --> 01:07:38,392
So I could probably do strlen of s to dynamically figure out
所以，我可能可以使用 strlen 函数动态计算

1371
01:07:38,392 --> 01:07:39,850
how many bytes I want for the copy.
我想要复制多少字节。

1372
01:07:39,850 --> 01:07:42,160
But that, too, is not enough because string length
但这也不够，因为字符串长度

1373
01:07:42,160 --> 01:07:46,630
returns the human readable length, so H-I exclamation point.
返回的是人类可读的长度，所以是 H-I 感叹号。

1374
01:07:46,630 --> 01:07:48,480
So I think I want a plus one in there, too.
所以，我想在这里加一。

1375
01:07:48,480 --> 01:07:51,188
So that just means get the length of whatever the human typed in,
所以，这意味着获取人类输入的长度，

1376
01:07:51,188 --> 01:07:54,810
add one for the null character to make sure that we're not undercounting.
加上一个字节来存放空字符，以确保我们没有少算。

1377
01:07:54,810 --> 01:07:56,520
Now, what can I then do?
现在，我还能做什么呢？

1378
01:07:56,520 --> 01:07:59,050
Unfortunately, I need to do a bit of work here.
不幸的是，我需要在这里做一些工作。

1379
01:07:59,050 --> 01:08:02,310
So let me actually go ahead now and do something like this.
所以，让我现在继续做这样的事情。

1380
01:08:02,310 --> 01:08:10,740
For int i equals zero, I is less than the string length of s, i plus, plus.
对于 int i 等于零，i 小于 s 的字符串长度，i 加加。

1381
01:08:10,740 --> 01:08:15,540
And then inside of this loop, I could copy into the ith location of t,
然后在这个循环中，我可以将 s 的第 i 个位置的内容复制到 t 的第 i 个位置。

1382
01:08:15,540 --> 01:08:17,970
whatever is in the ith location of s.
无论 s 的第 i 个位置是什么。

1383
01:08:17,970 --> 01:08:20,609
Now, this is a little buggy.
现在，这有点小问题。

1384
01:08:20,609 --> 01:08:23,763
One, this is inefficient to keep asking this question.
首先，不断地问这个问题效率低下。

1385
01:08:23,763 --> 01:08:25,680
We talked about this in the context of design.
我们之前在设计方面讨论过这个问题。

1386
01:08:25,680 --> 01:08:29,580
I should probably improve this by giving myself a variable like n,
我应该通过给自己一个像 n 这样的变量来改进它，

1387
01:08:29,580 --> 01:08:33,450
set that equal to the string length, and then do i is less than n
将它设置为字符串长度，然后做 i 小于 n

1388
01:08:33,450 --> 01:08:35,520
again, and again, just so I'm not stupidly
一遍又一遍，这样我就不会愚蠢地

1389
01:08:35,520 --> 01:08:38,580
calling string length four different times, or three different times.
四次或三次调用字符串长度。

1390
01:08:38,580 --> 01:08:42,359
But this, too, is slightly buggy, and this one's very subtle.
但这也有点错误，而且这个错误非常微妙。

1391
01:08:42,359 --> 01:08:47,740
This does not fully copy s into t.
这并没有完全将 s 复制到 t 中。

1392
01:08:47,740 --> 01:08:54,069
Does anyone see the very subtle bug that I've introduced?
有人看到我引入的非常微妙的错误吗？

1393
01:08:54,069 --> 01:08:55,660
Sorry?
什么？

1394
01:08:55,660 --> 01:08:58,120
Yeah, I'm forgetting the backslash zero.
是的，我忘记了反斜杠零。

1395
01:08:58,120 --> 01:09:00,340
So even though I'm copying H-I exclamation point,
所以即使我复制了 H-I 感叹号，

1396
01:09:00,340 --> 01:09:04,240
or whatever the human typed in, I need to go one step further deliberately
或者人类输入的任何内容，我需要故意再走一步

1397
01:09:04,240 --> 01:09:07,180
to make sure I also copy the backslash zero,
以确保我也复制了反斜杠零，

1398
01:09:07,180 --> 01:09:09,250
or at least manually put it in myself.
或者至少手动把它自己放进去。

1399
01:09:09,250 --> 01:09:14,215
So I could solve this by, either doing this up to and through n,
所以我可以通过以下方法解决这个问题，要么一直做到 n，

1400
01:09:14,215 --> 01:09:17,620
i is less than or equal to n, or I could plus one here.
i 小于等于 n，或者我可以在此处加 1。

1401
01:09:17,620 --> 01:09:18,859
That, too, would be fine.
那也行。

1402
01:09:18,859 --> 01:09:25,510
Or if I really want, I could do this, like t bracket
或者如果我真的想要，我可以这样做，比如 t 方括号

1403
01:09:25,510 --> 01:09:27,673
three equals, quote unquote, backslash zero.
三个等于号，引号引号，反斜杠零。

1404
01:09:27,673 --> 01:09:30,340
But again, I shouldn't get into the habit of hard coding things.
但同样，我不应该养成硬编码的习惯。

1405
01:09:30,340 --> 01:09:37,029
I could do string length of s, and that would give me the last location in s,
我可以做 s 的字符串长度，这将给我 s 中的最后一个位置，

1406
01:09:37,029 --> 01:09:38,200
which would also work.
这也能奏效。

1407
01:09:38,200 --> 01:09:39,620
But that, too, is stupid.
但那也是愚蠢的。

1408
01:09:39,620 --> 01:09:40,540
I might as well--
我也可以——

1409
01:09:40,540 --> 01:09:42,250
or just unnecessarily complex.
或者只是不必要地复杂。

1410
01:09:42,250 --> 01:09:44,460
Let's just do this, change one symbol, and boom.
让我们就这样做，改变一个符号，砰的一声。

1411
01:09:44,460 --> 01:09:49,800
Now we're copying all three, and the fourth character, as well.
现在我们正在复制所有三个，以及第四个字符。

1412
01:09:49,800 --> 01:09:52,380
All right, so with this said, let's go ahead now
好了，话说到此，现在让我们继续

1413
01:09:52,380 --> 01:09:56,310
and make sure that t is indeed of length at least greater than zero.
并确保 t 的长度至少大于零。

1414
01:09:56,310 --> 01:09:59,830
Then let's go ahead and capitalize t as before and print out the results.
然后，让我们继续像以前一样将 t 大写，并打印出结果。

1415
01:09:59,830 --> 01:10:04,212
So let me go ahead and open my terminal window, make copy, dot slash copy,
所以，让我打开我的终端窗口，制作副本，点斜杠副本，

1416
01:10:04,212 --> 01:10:06,420
and I'm going to deliberately type "hi" in lowercase.
我将故意用小写输入“hi”。

1417
01:10:06,420 --> 01:10:10,380
And now we should see disparate s and t.
现在我们应该看到不同的 s 和 t。

1418
01:10:10,380 --> 01:10:14,760
s is now still lowercase, and T is now capitalized.
s 现在仍然是小写，而 T 现在是大写的。

1419
01:10:14,760 --> 01:10:16,980
But why is that exactly?
但为什么正是这样呢？

1420
01:10:16,980 --> 01:10:21,060
Well, let me actually go into, say, my computer's memory
好吧，让我实际进入，比如说，我的计算机的内存

1421
01:10:21,060 --> 01:10:24,210
again and propose that, if what I had before
再次提出，如果我之前有

1422
01:10:24,210 --> 01:10:27,090
was this situation, where s is pointing at this chunk of memory,
是这种情况，s 指向这块内存，

1423
01:10:27,090 --> 01:10:30,660
and t was accidentally pointing in that same chunk of memory, what we really
而 t 意外地指向同一块内存，我们真正

1424
01:10:30,660 --> 01:10:33,750
want to do is have t point at a new chunk of memory.
想要做的是让 t 指向一块新的内存。

1425
01:10:33,750 --> 01:10:36,660
And malloc is what gives us this chunk of memory.
而 malloc 就是给我们这块内存的。

1426
01:10:36,660 --> 01:10:41,490
And then using that for loop, can I copy the H, the I, the exclamation point,
然后使用那个 for 循环，我可以复制 H、I、感叹号，

1427
01:10:41,490 --> 01:10:44,020
and even the backslash zero.
甚至反斜杠零。

1428
01:10:44,020 --> 01:10:48,280
So now, this is a little subtle, but malloc is what gives me
所以现在，这有点微妙，但 malloc 就是给我

1429
01:10:48,280 --> 01:10:50,620
access to this new chunk of memory.
访问这块新的内存。

1430
01:10:50,620 --> 01:10:55,060
Malloc takes one argument, the number of bytes that you want it to find for you.
Malloc 接受一个参数，即你希望它为你找到的字节数。

1431
01:10:55,060 --> 01:10:56,020
Take a guess.
猜猜看。

1432
01:10:56,020 --> 01:11:00,970
What value is malloc returning?
malloc 函数返回什么值？

1433
01:11:00,970 --> 01:11:06,220
Conceptually, it's returning a chunk of memory, but that's kind of handwavy.
从概念上来说，它返回的是一块内存，但这有点笼统。

1434
01:11:06,220 --> 01:11:08,200
What might malloc actually be returning?
malloc 函数实际上可能返回什么？

1435
01:11:08,200 --> 01:11:10,675
AUDIENCE: Maybe the pointer to the first character?
观众：可能是指向第一个字符的指针？

1436
01:11:10,675 --> 01:11:11,710
SPEAKER 1: Perfect.
演讲者 1：完美。

1437
01:11:11,710 --> 01:11:17,050
malloc is returning the address of that chunk of memory, not the last address.
malloc 函数返回的是那块内存的地址，而不是最后一个地址。

1438
01:11:17,050 --> 01:11:18,220
The first address.
第一个地址。

1439
01:11:18,220 --> 01:11:20,050
And here's a difference with strings.
这里与字符串不同。

1440
01:11:20,050 --> 01:11:23,710
This chunk of memory is not magically terminated with null for you.
这块内存不会自动为你以空字符结尾。

1441
01:11:23,710 --> 01:11:27,580
I had to do that with for loop. malloc, and in turn, your operating system,
我必须用循环来做。malloc 函数，以及你的操作系统，

1442
01:11:27,580 --> 01:11:30,560
does keep track of how big these chunks of memory are.
会跟踪这些内存块的大小。

1443
01:11:30,560 --> 01:11:32,770
So even though it's only returning the address
所以即使它只返回

1444
01:11:32,770 --> 01:11:35,860
of the first byte of that memory, the operating system
该内存第一个字节的地址，操作系统

1445
01:11:35,860 --> 01:11:39,582
is going to know that it used up four bytes here, four bytes here.
会知道它在这里使用了四个字节，这里也使用了四个字节。

1446
01:11:39,582 --> 01:11:41,290
And it will keep track of that so that it
它会跟踪这些信息，以便它

1447
01:11:41,290 --> 01:11:43,570
doesn't give you an overlapping address in the future
将来不会给你一个重叠的地址

1448
01:11:43,570 --> 01:11:44,380
because that would be bad.
因为那会很糟糕。

1449
01:11:44,380 --> 01:11:45,670
Your data would get corrupted.
你的数据会损坏。

1450
01:11:45,670 --> 01:11:50,500
But you, similarly, have to remember or figure out how many bytes are available
但你，同样，必须记住或计算出有多少字节可用

1451
01:11:50,500 --> 01:11:51,070
thereafter.
以后。

1452
01:11:51,070 --> 01:11:54,970
It's up to you to manage it, as by putting a null character there
这取决于你来管理，就像在那里添加一个空字符一样

1453
01:11:54,970 --> 01:11:55,970
yourself.
你自己。

1454
01:11:55,970 --> 01:11:58,480
So if I go back to my code now, let me actually
所以现在我回到我的代码，让我实际

1455
01:11:58,480 --> 01:12:02,090
harden this code just a little bit more as follows,
增强一下这段代码，如下所示，

1456
01:12:02,090 --> 01:12:05,450
whereby I can do this a little better.
这样我就可以做得更好一点。

1457
01:12:05,450 --> 01:12:10,010
If I go back to VS Code here, it turns out, if something goes wrong
如果我回到这里的 VS Code，事实证明，如果出现错误

1458
01:12:10,010 --> 01:12:12,470
and I'm out of memory, maybe I've got an old computer,
而且我内存不足，也许我的电脑太旧了，

1459
01:12:12,470 --> 01:12:15,732
or maybe I'm typing something way bigger than three characters in,
或者我输入的内容远不止三个字符，

1460
01:12:15,732 --> 01:12:17,690
like three billion characters, and the computer
比如三十亿个字符，而电脑

1461
01:12:17,690 --> 01:12:19,310
might genuinely run out of memory.
可能真的内存不足。

1462
01:12:19,310 --> 01:12:21,410
I actually should be in the habit of doing this.
实际上我应该养成这样的习惯。

1463
01:12:21,410 --> 01:12:27,320
If t equals, equals a special symbol called null with two Ls,
如果 t 等于一个特殊的符号，叫做 null，有两个 L，

1464
01:12:27,320 --> 01:12:29,330
and I promised this would eventually exist,
我承诺这个符号最终会存在，

1465
01:12:29,330 --> 01:12:32,750
I should just return one now, or return two, return negative one,
我现在应该返回 1，或者返回 2，返回负 1，

1466
01:12:32,750 --> 01:12:37,340
return any value other than zero, and just abort the program early.
返回任何非零值，然后立即中止程序。

1467
01:12:37,340 --> 01:12:42,230
That means, if malloc returns null, there's not enough memory available.
也就是说，如果 malloc 返回 null，说明没有足够的可用内存。

1468
01:12:42,230 --> 01:12:45,260
And it turns out, all this time, I'm going to do one other crazy thing,
而且事实证明，一直以来，我还要做一件疯狂的事情，

1469
01:12:45,260 --> 01:12:47,660
even though we've not expected you to do this thus far.
即使我们之前并没有要求你这么做。

1470
01:12:47,660 --> 01:12:50,180
Technically, when using getstring, getstring,
严格来说，使用 getstring 函数时，

1471
01:12:50,180 --> 01:12:53,960
if you read the documentation, the manual, it too can return null.
如果你阅读文档，手册，它也可以返回 null。

1472
01:12:53,960 --> 01:12:56,300
Because if you type in a crazy long string,
因为如果你输入一个超长的字符串，

1473
01:12:56,300 --> 01:12:58,340
and the computer can't fit it in its memory,
而电脑无法将其放入内存，

1474
01:12:58,340 --> 01:13:00,440
getstring needs to signal that to you somehow.
getstring 函数需要以某种方式通知你这一点。

1475
01:13:00,440 --> 01:13:05,940
And the documentation actually says that, if getstring returns null,
文档中实际上说明，如果 getstring 返回 null，

1476
01:13:05,940 --> 01:13:08,750
then you too should not trust what's in it.
那么你也不能相信其中的内容。

1477
01:13:08,750 --> 01:13:12,710
You should just exit the program immediately, in this case.
在这种情况下，你应该立即退出程序。

1478
01:13:12,710 --> 01:13:15,648
But there's one other improvement we can make here.
但是，这里还有另外一项改进。

1479
01:13:15,648 --> 01:13:18,440
And even though this is making the code seem way longer than it is,
尽管这使得代码看起来比实际长很多，

1480
01:13:18,440 --> 01:13:20,750
most of this I've just added is just error checking,
但我添加的大部分内容只是错误检查，

1481
01:13:20,750 --> 01:13:24,680
just mindless error checking to make sure that I don't treat s as being
只是无脑的错误检查，以确保我不将 s 视为

1482
01:13:24,680 --> 01:13:27,020
valid, or t as being valid when it isn't.
有效的，或者将 t 视为有效的，而实际上它不是。

1483
01:13:27,020 --> 01:13:28,290
It turns out this is stupid.
事实证明，这很蠢。

1484
01:13:28,290 --> 01:13:29,790
I don't need to reinvent this wheel.
我不需要重新发明轮子。

1485
01:13:29,790 --> 01:13:32,900
Certainly, for decades, people have been copying strings, even in C.
当然，几十年来，人们一直在复制字符串，即使在 C 语言中也是如此。

1486
01:13:32,900 --> 01:13:36,350
So it turns out there's another fun function called strcopy, wonderfully
事实证明，还有一个有趣的函数叫做 strcopy，非常棒地

1487
01:13:36,350 --> 01:13:39,440
enough, that takes the destination as its first argument,
足以，它将目标作为它的第一个参数，

1488
01:13:39,440 --> 01:13:41,610
the source as its second argument.
将源作为它的第二个参数。

1489
01:13:41,610 --> 01:13:46,500
And that will for me copy s into t, respectively.
它将分别为我将 s 复制到 t 中。

1490
01:13:46,500 --> 01:13:51,380
So that does the equivalent of that for loop, including the backslash zero.
因此，它相当于那个 for 循环，包括反斜杠零。

1491
01:13:51,380 --> 01:13:55,310
However, there's one other function recall that was on our cheat sheet
然而，还有一点要记住，在我们的备忘单上

1492
01:13:55,310 --> 01:13:58,100
a moment ago, whereby malloc is accompanied
刚才，malloc 伴随着

1493
01:13:58,100 --> 01:14:00,110
by one other function called Free.
另一个名为 Free 的函数。

1494
01:14:00,110 --> 01:14:02,090
So Free is the opposite of malloc.
所以 Free 是 malloc 的反义词。

1495
01:14:02,090 --> 01:14:04,040
When you're done with your computer's memory,
当你使用完计算机的内存后，

1496
01:14:04,040 --> 01:14:07,070
you're supposed to give it back to Windows, to Mac OS, to Linux
你应该将它归还给 Windows，Mac OS 或 Linux，

1497
01:14:07,070 --> 01:14:09,320
so it can reuse it for something else.
以便它可以将其用于其他用途。

1498
01:14:09,320 --> 01:14:12,350
And frankly, if you've ever been using your computer for hours
坦率地说，如果你曾经连续使用你的计算机几个小时

1499
01:14:12,350 --> 01:14:15,720
on end, days on end, and maybe it's getting slower, and slower,
甚至连续几天，也许它变得越来越慢，

1500
01:14:15,720 --> 01:14:18,470
maybe it's Photoshop, maybe it's a really big document, generally,
可能是 Photoshop，可能是非常大的文档，一般来说，

1501
01:14:18,470 --> 01:14:20,840
really big files consume lots and lots of memory.
非常大的文件会消耗大量的内存。

1502
01:14:20,840 --> 01:14:24,320
If the humans who wrote that software, be it Photoshop or something else,
如果编写该软件的人类，无论是 Photoshop 还是其他软件，

1503
01:14:24,320 --> 01:14:29,150
wrote buggy code and kept using malloc, malloc, malloc, malloc, asking
编写了有错误的代码，并不断使用 malloc，malloc，malloc，malloc，要求

1504
01:14:29,150 --> 01:14:32,780
for more and more memory, but they never call the opposite function, Free,
获取越来越多的内存，但他们从未调用相反的函数 Free，

1505
01:14:32,780 --> 01:14:34,820
your computer might actually run out of memory.
你的计算机可能真的会内存不足。

1506
01:14:34,820 --> 01:14:37,130
And typically, the symptom is that it gets so darn
通常，症状是它变得非常糟糕

1507
01:14:37,130 --> 01:14:38,720
slow it becomes annoying to use.
缓慢，以至于变得令人讨厌使用。

1508
01:14:38,720 --> 01:14:42,230
And frankly, the mouse starts moving very slowly, maybe the thing freezes
坦率地说，鼠标开始移动非常缓慢，也许它会完全冻结

1509
01:14:42,230 --> 01:14:43,880
altogether, the computer crashes.
在一起，计算机崩溃。

1510
01:14:43,880 --> 01:14:46,080
Bad things happen when you run out of memory.
内存不足时会发生不好的事情。

1511
01:14:46,080 --> 01:14:48,800
So in my case here, if I go back to VS Code,
所以在我的例子中，如果我回到 VS Code，

1512
01:14:48,800 --> 01:14:53,300
it's actually on me in this language called C to actually manage
实际上，在这门名为 C 的语言中，由我来管理

1513
01:14:53,300 --> 01:14:57,530
the memory myself so that, when I have called malloc,
我自己使用的内存，这样，当我调用 malloc 时，

1514
01:14:57,530 --> 01:15:00,753
thereafter, I had better free that same memory.
之后，我最好释放相同的内存。

1515
01:15:00,753 --> 01:15:02,420
Now, I don't want to free it right away.
现在，我不想立即释放它。

1516
01:15:02,420 --> 01:15:03,890
I want to free it when I'm done with it.
我想在完成使用后释放它。

1517
01:15:03,890 --> 01:15:06,590
So frankly, the very last thing I'm going to do in my program
所以，坦率地说，在我的程序中，我要做的最后一件事

1518
01:15:06,590 --> 01:15:12,720
here is called Free on t because t is what I malloced up here.
在这里是调用 Free 在 t 上，因为 t 是我在这里分配的。

1519
01:15:12,720 --> 01:15:15,950
So at the very bottom of my program, I should free t.
所以，在我的程序的底部，我应该释放 t。

1520
01:15:15,950 --> 01:15:18,920
And then just to be super nitpicky, let me return zero just
然后，为了过于挑剔，让我返回零，只是

1521
01:15:18,920 --> 01:15:21,710
to signify success at this point.
为了表示在此处成功。

1522
01:15:21,710 --> 01:15:25,460
Now, there's a slight asymmetry, which is a little inconsistent here.
现在，这里存在轻微的不对称，这有点不一致。

1523
01:15:25,460 --> 01:15:28,130
Even though getstring, I'm going to imply,
即使 getstring 会为我分配内存，它实际上确实使用了 malloc。

1524
01:15:28,130 --> 01:15:31,760
is still allocating memory for me, it actually does use malloc.
即使 getstring 会为我分配内存，它实际上确实使用了 malloc。

1525
01:15:31,760 --> 01:15:34,710
getstring and CS50's other functions are special.
getstring 和 CS50 的其他函数很特殊。

1526
01:15:34,710 --> 01:15:38,120
They manage memory for you, so you do not and should not free
它们会为你管理内存，所以你不应该也不需要释放

1527
01:15:38,120 --> 01:15:41,000
memory that getstring returns to you.
getstring 返回给你的内存。

1528
01:15:41,000 --> 01:15:42,350
We handle all of that for you.
我们会为你处理所有这些。

1529
01:15:42,350 --> 01:15:45,350
But that's a training wheel that's going to be taken off as of this week
但这只是一个辅助工具，本周起就要被拿掉了

1530
01:15:45,350 --> 01:15:46,558
anyway, so it's kind of moot.
所以它有点无关紧要。

1531
01:15:46,558 --> 01:15:47,540
So not to worry.
所以不用担心。

1532
01:15:47,540 --> 01:15:52,100
But I'm only freeing memory that malloced.
但我只释放 malloc 分配的内存。

1533
01:15:52,100 --> 01:15:52,820
All right.
好的。

1534
01:15:52,820 --> 01:15:56,516
Null, then, means the--
那么，null 表示——

1535
01:15:56,516 --> 01:15:57,690
what is null?
什么是 null？

1536
01:15:57,690 --> 01:16:01,000
It is just an address, and it's literally the address zero.
它只是一个地址，实际上就是地址零。

1537
01:16:01,000 --> 01:16:02,000
So there's this theme.
所以有一个主题。

1538
01:16:02,000 --> 01:16:03,827
N-U-L recall, was the terminating symbol,
N-U-L，还记得吗？是终止符，

1539
01:16:03,827 --> 01:16:05,410
which just means the string ends here.
这意味着字符串在这里结束。

1540
01:16:05,410 --> 01:16:09,370
N-U-L-L, which is not greatly named, but it's what humans went with years ago,
N-U-L-L，名字不太好，但这是人类几年前选择的，

1541
01:16:09,370 --> 01:16:11,603
just means that this is the address zero.
只是意味着这是地址零。

1542
01:16:11,603 --> 01:16:14,770
And what your computer does is, even though I've been playfully saying that,
而你的电脑所做的就是，尽管我一直戏谑地说，

1543
01:16:14,770 --> 01:16:18,580
oh, in the top left is address zero, and then one, and then two, and then three,
哦，左上角是地址零，然后是一，然后是二，然后是三，

1544
01:16:18,580 --> 01:16:20,333
the address zero is hands off.
地址零是不能使用的。

1545
01:16:20,333 --> 01:16:22,750
It's kind of a wasted byte that your computer should never
它是一个浪费的字节，你的电脑永远不应该

1546
01:16:22,750 --> 01:16:27,400
use because the computer uses zero as a special sentinel value, null,
使用，因为电脑使用零作为特殊的哨兵值，null，

1547
01:16:27,400 --> 01:16:28,880
to signify error.
来表示错误。

1548
01:16:28,880 --> 01:16:32,170
So we're spending one byte out of billions nowadays just to make sure
所以我们现在从数十亿字节中花费一个字节，只是为了确保

1549
01:16:32,170 --> 01:16:34,900
that there's a special symbol that's coming back that can
有一个特殊的符号会返回，它可以

1550
01:16:34,900 --> 01:16:37,600
indicate when something has gone wrong.
指示何时出现错误。

1551
01:16:37,600 --> 01:16:38,320
All right.
好的。

1552
01:16:38,320 --> 01:16:39,700
That was a mouthful.
这可真是一大口。

1553
01:16:39,700 --> 01:16:46,120
Any questions on this copying of strings, this malloc-ing,
关于字符串的复制、malloc 分配、

1554
01:16:46,120 --> 01:16:48,640
or this freeing?
或者释放，有什么问题吗？

1555
01:16:48,640 --> 01:16:49,570
Oh, all right.
哦，好的。

1556
01:16:49,570 --> 01:16:55,460
So let me give you a tool with which to make some of this stuff easier,
所以让我给你一个工具，让你更容易地完成一些这些工作，

1557
01:16:55,460 --> 01:16:58,690
so that when you make mistakes or have bugs, as you invariably will,
这样当你犯错误或出现 bug 时，因为你肯定会犯，

1558
01:16:58,690 --> 01:17:01,148
you can chase them down without having to raise your hand,
你可以追查它们，而不用举手，

1559
01:17:01,148 --> 01:17:02,440
without having to ask the duck.
不用去问鸭子。

1560
01:17:02,440 --> 01:17:04,482
You actually have more technical tools with which
你实际上拥有更多技术工具，可以

1561
01:17:04,482 --> 01:17:06,190
to diagnose the problem yourself.
自己诊断问题。

1562
01:17:06,190 --> 01:17:09,280
And there's this new tool that we'll introduce today called valgrind.
我们今天将介绍一个新工具，叫做 valgrind。

1563
01:17:09,280 --> 01:17:13,150
And valgrind's purpose in life is to check your usage of memory for you.
valgrind 的作用是为你检查你的内存使用情况。

1564
01:17:13,150 --> 01:17:14,890
Admittedly, it's an older program.
诚然，它是一个比较旧的程序。

1565
01:17:14,890 --> 01:17:16,800
It's pretty arcane in terms of its interface,
它的界面非常神秘，

1566
01:17:16,800 --> 01:17:19,300
and there's just going to be a mess of output on the screen.
屏幕上只会出现一大堆输出。

1567
01:17:19,300 --> 01:17:21,970
But there's going to be certain patterns of mistakes that you'll notice,
但你将会注意到某些错误模式，

1568
01:17:21,970 --> 01:17:24,137
and I'll demonstrate a couple of them now so you can
现在我会演示几个，这样你就可以

1569
01:17:24,137 --> 01:17:26,270
see where and how you might go wrong.
看看你在哪里以及如何犯错误。

1570
01:17:26,270 --> 01:17:28,030
So I'm going to go over to VS Code here.
所以我将转到 VS Code 这里。

1571
01:17:28,030 --> 01:17:32,020
I'm going to create a program called memory.c that is deliberately buggy,
我将创建一个名为 memory.c 的程序，它故意包含 bug，

1572
01:17:32,020 --> 01:17:34,780
but it's not going to be obviously buggy at first.
但它一开始不会明显地出现错误。

1573
01:17:34,780 --> 01:17:36,010
So by that I mean this.
我的意思是。

1574
01:17:36,010 --> 01:17:39,100
Let me do include standard io.h.
让我包含标准io.h。

1575
01:17:39,100 --> 01:17:44,320
Let me also include proactively standard lib.h so I can use malloc.
让我主动包含标准lib.h，这样我就可以使用malloc。

1576
01:17:44,320 --> 01:17:47,110
Let me declare main with no command line arguments,
让我声明一个没有命令行参数的main函数。

1577
01:17:47,110 --> 01:17:49,280
and let me do something very simple.
让我做一些非常简单的事情。

1578
01:17:49,280 --> 01:17:53,740
Instead of just declaring an int called X, let me be a little crazy
而不是仅仅声明一个名为X的int，让我有点疯狂

1579
01:17:53,740 --> 01:17:56,290
and manually allocate this memory myself.
并自己手动分配这块内存。

1580
01:17:56,290 --> 01:17:59,110
So int X just gives me an integer, and it has since week one.
所以 int X 只是给了我一个整数，从第一周开始就是这样。

1581
01:17:59,110 --> 01:18:02,990
But now that I have malloc, I can kind of take control over this process.
但现在我有malloc了，我可以控制这个过程。

1582
01:18:02,990 --> 01:18:07,420
So let me declare, not an int, but an int star called X. So
所以让我声明，不是一个int，而是一个叫做X的int指针。所以

1583
01:18:07,420 --> 01:18:10,120
give me the address of an integer, and let
给我一个整数的地址，并让我

1584
01:18:10,120 --> 01:18:15,970
me store there the return value of malloc by asking malloc for, let's say,
将malloc的返回值存储在那里，让malloc给我，比如，

1585
01:18:15,970 --> 01:18:17,300
four bytes.
四个字节。

1586
01:18:17,300 --> 01:18:19,150
So I know that ints are four bytes.
我知道int是四个字节。

1587
01:18:19,150 --> 01:18:21,740
If I want four bytes, I just tell malloc, give me four bytes.
如果我想要四个字节，我只需要告诉malloc，给我四个字节。

1588
01:18:21,740 --> 01:18:23,380
Now, frankly, this is a little stupid.
坦白说，这有点愚蠢。

1589
01:18:23,380 --> 01:18:26,080
I shouldn't just assume that the int is always
我不应该假设int总是

1590
01:18:26,080 --> 01:18:28,122
going to be four bytes on everyone's computer.
在每个人的计算机上都是四个字节。

1591
01:18:28,122 --> 01:18:31,330
So there's this function you can start using called sizeof, or this operator,
所以有一个你可以开始使用的函数叫做sizeof，或者说是一个运算符，

1592
01:18:31,330 --> 01:18:33,220
technically, where you can say sizeof int.
严格来说，你可以说sizeof int。

1593
01:18:33,220 --> 01:18:36,820
And even if you're on an older computer, for instance, really old at this point,
即使你使用的是一台老式电脑，比如，现在真的很老了，

1594
01:18:36,820 --> 01:18:40,047
sizeof int will return the correct value, no matter what.
sizeof int 无论如何都会返回正确的值。

1595
01:18:40,047 --> 01:18:42,130
You don't have to assume that it's, in fact, four.
你不必假设它实际上是四个。

1596
01:18:42,130 --> 01:18:42,880
But you know what?
但你知道吗？

1597
01:18:42,880 --> 01:18:44,920
I'd actually like more than this number of ints.
我实际上想要比这个数字更多的int。

1598
01:18:44,920 --> 01:18:48,200
Let me actually treat X as an array of integers.
让我实际上将X视为一个整数数组。

1599
01:18:48,200 --> 01:18:51,610
So actually, if I want an array of integers, I could do this.
所以实际上，如果我想要一个整数数组，我可以这样做。

1600
01:18:51,610 --> 01:18:53,320
Give me three integers.
给我三个整数。

1601
01:18:53,320 --> 01:18:54,200
But no, no.
但不行，不行。

1602
01:18:54,200 --> 01:18:55,750
Let me not do week two syntax.
让我不要使用第二周的语法。

1603
01:18:55,750 --> 01:18:57,710
Let me do this myself as follows.
让我自己这样做。

1604
01:18:57,710 --> 01:19:02,170
Let me treat this as three times the size of an int.
让我把它当作一个int大小的三倍。

1605
01:19:02,170 --> 01:19:04,270
So that's technically going to give me 12 bytes.
所以这在技术上会给我12个字节。

1606
01:19:04,270 --> 01:19:07,265
But this makes X effectively an array.
但这使得X实际上成为一个数组。

1607
01:19:07,265 --> 01:19:09,640
And this is kind of deliberate now because if an array is
现在这有点故意，因为如果一个数组是

1608
01:19:09,640 --> 01:19:12,550
just contiguous memory, and malloc returns to you
仅仅是连续的内存，而malloc会返回给你

1609
01:19:12,550 --> 01:19:16,300
a chunk of contiguous memory, you can treat what comes back from malloc
一块连续的内存，你可以将malloc返回的结果

1610
01:19:16,300 --> 01:19:16,802
as an array.
视为一个数组。

1611
01:19:16,802 --> 01:19:18,760
And indeed, that's what we're doing as strings.
实际上，我们就是这样处理字符串的。

1612
01:19:18,760 --> 01:19:22,277
We're treating chunks of memory as arrays of chars.
我们把内存块当作字符数组。

1613
01:19:22,277 --> 01:19:23,860
So let me do something arbitrary here.
所以让我在这里做一些任意的事情。

1614
01:19:23,860 --> 01:19:28,195
Let me go to X bracket one and set it equal to 72.
让我去X方括号1，并将它设置为72。

1615
01:19:28,195 --> 01:19:30,880
X bracket two, set it equal to 73.
X方括号2，设置为73。

1616
01:19:30,880 --> 01:19:34,030
X bracket three, set it equal to 33.
X方括号3，设置为33。

1617
01:19:34,030 --> 01:19:35,680
And we did this a couple of weeks ago.
我们几周前就做过了。

1618
01:19:35,680 --> 01:19:37,450
That's "hi" but in Ascii code.
这是“hi”，但使用的是ASCII码。

1619
01:19:37,450 --> 01:19:40,420
Let me go ahead and make memory, and it seems to work fine.
让我继续创建内存，看起来工作正常。

1620
01:19:40,420 --> 01:19:43,600
Let me do dot slash memory, and no problem.
让我执行点斜杠内存，没问题。

1621
01:19:43,600 --> 01:19:45,460
There's no error messages from the compiler.
编译器没有报错信息。

1622
01:19:45,460 --> 01:19:48,700
There's no runtime errors when I actually run the code.
当我实际运行代码时，没有运行时错误。

1623
01:19:48,700 --> 01:19:53,350
But does anyone see any of the bugs thus far?
但是有人看到目前为止的任何错误吗？

1624
01:19:53,350 --> 01:19:54,555
What did I do wrong?
我做错了什么？

1625
01:19:54,555 --> 01:19:55,930
Let me look a little in the back.
让我稍微往后看一看。

1626
01:19:55,930 --> 01:19:57,616
Yeah.
是的。

1627
01:19:57,616 --> 01:20:00,118
AUDIENCE: Does it not know when the array ends?
观众：它不知道数组什么时候结束吗？

1628
01:20:00,118 --> 01:20:02,410
SPEAKER 1: It doesn't seem to know when the array ends.
演讲者 1：它似乎不知道数组什么时候结束。

1629
01:20:02,410 --> 01:20:04,285
Or more specifically, I'm not respecting when
更具体地说，我没有遵守什么时候

1630
01:20:04,285 --> 01:20:06,520
the array ends because I'm sort of stupidly
数组结束，因为我有点愚蠢地

1631
01:20:06,520 --> 01:20:08,590
starting at one, then two then three.
从 1 开始，然后是 2，然后是 3。

1632
01:20:08,590 --> 01:20:11,380
But technically, if I asked for three of these things,
但从技术上讲，如果我要求这三样东西，

1633
01:20:11,380 --> 01:20:15,040
I should have done bracket zero, bracket one, bracket two.
我应该做方括号 0，方括号 1，方括号 2。

1634
01:20:15,040 --> 01:20:18,905
And there's a second more subtle bug that you would only know from today.
还有一个更微妙的错误，你只有今天才知道。

1635
01:20:18,905 --> 01:20:19,405
Yeah.
是的。

1636
01:20:23,290 --> 01:20:26,980
OK, I don't necessarily know when one integer ends and the next one begins.
好的，我不一定知道一个整数什么时候结束，下一个整数什么时候开始。

1637
01:20:26,980 --> 01:20:29,770
That's actually not a problem, because on a given system,
这实际上不是问题，因为在给定系统上，

1638
01:20:29,770 --> 01:20:31,810
integers are always the same size.
整数始终是相同的大小。

1639
01:20:31,810 --> 01:20:35,892
So the computer can be smart enough to go from here, four bytes this way,
所以计算机可以足够智能，从这里开始，四个字节这样，

1640
01:20:35,892 --> 01:20:37,600
four bytes this way, four bytes this way.
四个字节这样，四个字节这样。

1641
01:20:37,600 --> 01:20:38,410
That's OK.
这没问题。

1642
01:20:38,410 --> 01:20:41,560
Strings are problematic because who knows how big the sentence was
字符串存在问题，因为谁知道人类输入的句子有多大

1643
01:20:41,560 --> 01:20:43,070
that the human typed in.
人类输入的句子有多大。

1644
01:20:43,070 --> 01:20:44,320
But there's a more subtle bug.
但还有一个更微妙的错误。

1645
01:20:44,320 --> 01:20:45,850
What have I not done?
我还没有做什么？

1646
01:20:45,850 --> 01:20:46,990
I didn't call free.
我没有调用 free。

1647
01:20:46,990 --> 01:20:49,120
So I didn't practice what I just preached.
所以我没有实践我刚刚宣讲的内容。

1648
01:20:49,120 --> 01:20:50,770
Anytime I malloc, I call free.
每次我调用 malloc，我都会调用 free。

1649
01:20:50,770 --> 01:20:54,670
But again, per my terminal window, neither of these bugs seem obvious.
但是，根据我的终端窗口，这两个错误似乎都不明显。

1650
01:20:54,670 --> 01:20:57,460
You might submit this code, or deploy it to your software,
你可能会提交此代码，或将其部署到你的软件中，

1651
01:20:57,460 --> 01:20:58,760
and be none the wiser.
而且浑然不觉。

1652
01:20:58,760 --> 01:21:01,790
But a tool like valgrind can actually help you find these things.
但是像 valgrind 这样的工具实际上可以帮助你找到这些东西。

1653
01:21:01,790 --> 01:21:03,920
So let me increase the size of my terminal window.
所以让我增加我的终端窗口的大小。

1654
01:21:03,920 --> 01:21:07,030
Let me run this command valgrind on my program.
让我在我的程序上运行这个命令 valgrind。

1655
01:21:07,030 --> 01:21:09,640
So dot slash memory is how I ran it a moment ago.
所以点斜杠 memory 是我刚才运行它的方式。

1656
01:21:09,640 --> 01:21:12,825
Just like debug50, you type before the name of your program.
就像 debug50 一样，你在程序名称前面输入。

1657
01:21:12,825 --> 01:21:14,950
Valgrind, you type before the name of your program.
Valgrind，你在程序名称前面输入。

1658
01:21:14,950 --> 01:21:19,360
And the output is going to look crazy, but this is useful.
并且输出看起来会很疯狂，但这是有用的。

1659
01:21:19,360 --> 01:21:20,110
Why?
为什么？

1660
01:21:20,110 --> 01:21:24,140
So notice at the very top of this, we're just seeing what version of valgrind
所以注意这里的最上面，我们只是看到了 valgrind 的版本

1661
01:21:24,140 --> 01:21:26,180
we're using and what command we ran.
我们正在使用，以及我们运行了什么命令。

1662
01:21:26,180 --> 01:21:29,060
But this starts to get juicy, and I'll highlight this here.
但这里开始变得有趣，我将在这里突出显示。

1663
01:21:29,060 --> 01:21:33,180
Invalid write of size four invalid write.
大小为 4 的无效写入 无效写入。

1664
01:21:33,180 --> 01:21:37,040
So writing means changing information, like setting a value or assigning it a.
所以写入意味着更改信息，例如设置一个值或为其分配一个。

1665
01:21:37,040 --> 01:21:39,030
Value and this is useful here.
值，这里很有用。

1666
01:21:39,030 --> 01:21:42,080
The problem is in memory.c at line nine.
问题出在 memory.c 的第 9 行。

1667
01:21:42,080 --> 01:21:44,990
So colon nine means line nine.
所以冒号 9 表示第 9 行。

1668
01:21:44,990 --> 01:21:50,060
All right, so let me go back to my code, look at line nine, and oh, interesting.
好的，让我回到我的代码，看看第 9 行，哦，有意思。

1669
01:21:50,060 --> 01:21:53,060
So invalid write of size four.
所以大小为 4 的无效写入。

1670
01:21:53,060 --> 01:21:56,400
So it's cryptic, but size four I know is the size of an integer.
所以它很神秘，但我知道大小 4 是一个整数的大小。

1671
01:21:56,400 --> 01:21:59,420
So I'm probably doing something stupid on line nine involving
所以，我可能在第九行做了一些愚蠢的事情，涉及到

1672
01:21:59,420 --> 01:22:00,770
changing an integer.
更改一个整数。

1673
01:22:00,770 --> 01:22:04,190
And sure enough, even though it's not super obvious, X bracket three,
果然，尽管并不明显，X 方括号 3，

1674
01:22:04,190 --> 01:22:06,150
oh, obviously, this doesn't exist.
哦，显然，这不存在。

1675
01:22:06,150 --> 01:22:07,670
So I have to change the problem.
所以我必须改变问题。

1676
01:22:07,670 --> 01:22:10,940
One and two were OK, even though it's logically the wrong thing.
1 和 2 还可以，尽管逻辑上是错误的。

1677
01:22:10,940 --> 01:22:13,170
Now I think this will get rid of this error.
现在我认为这会消除这个错误。

1678
01:22:13,170 --> 01:22:16,710
So let me actually clear my terminal window and make it bigger again.
所以，让我实际清除我的终端窗口，并再次将其放大。

1679
01:22:16,710 --> 01:22:20,180
Let me recompile my code because I made a change.
让我重新编译我的代码，因为我做了一些更改。

1680
01:22:20,180 --> 01:22:24,080
Let me rerun valgrind of dot slash memory.
让我重新运行 valgrind 的点斜杠内存。

1681
01:22:24,080 --> 01:22:27,590
And now, that error went away.
现在，那个错误消失了。

1682
01:22:27,590 --> 01:22:30,170
There's a mess of output here, but that error went away.
这里有一堆输出，但那个错误消失了。

1683
01:22:30,170 --> 01:22:32,540
But this is interesting here now.
但现在这里很有趣。

1684
01:22:32,540 --> 01:22:37,610
12 bytes in one blocks are definitely lost in loss record one of one.
在一个块中的 12 个字节肯定在第一个损失记录中丢失了。

1685
01:22:37,610 --> 01:22:40,310
So unnecessarily verbose, but the hint here
所以，不必要的冗长，但这里的提示

1686
01:22:40,310 --> 01:22:45,000
is that I somehow lost some bytes, otherwise known as a memory leak.
是我不知何故丢失了一些字节，也就是所谓的内存泄漏。

1687
01:22:45,000 --> 01:22:48,202
So earlier, when I described an imaginary bad programmer
所以，早些时候，当我描述一个想象中的糟糕程序员时

1688
01:22:48,202 --> 01:22:50,660
who kept calling malloc, malloc, malloc, and never freeing,
他不断调用 malloc，malloc，malloc，但从未释放，

1689
01:22:50,660 --> 01:22:52,370
that's what's called a memory leak, where
这就是所谓的内存泄漏，在这种情况下，

1690
01:22:52,370 --> 01:22:55,370
you're sort of losing track of your memory and never freeing it again.
你有点失去了对内存的跟踪，并且再也没有释放它。

1691
01:22:55,370 --> 01:22:59,120
So I've definitely lost 12 bytes in one block, whatever a block is,
所以，我肯定在一个块中丢失了 12 个字节，无论一个块是什么，

1692
01:22:59,120 --> 01:22:59,960
in this case.
在这种情况下。

1693
01:22:59,960 --> 01:23:01,640
This is a little less obvious.
这不太明显。

1694
01:23:01,640 --> 01:23:05,960
It's up to us to notice that, OK, wait a minute, memory.c line six is somehow
我们要注意到这一点，好吧，等等，memory.c 的第六行不知何故

1695
01:23:05,960 --> 01:23:06,710
germane.
相关。

1696
01:23:06,710 --> 01:23:08,000
Let me go back to--
让我回到——

1697
01:23:08,000 --> 01:23:10,250
oh, this is where I called malloc.
哦，这是我调用 malloc 的地方。

1698
01:23:10,250 --> 01:23:13,640
And valgrind doesn't necessarily know when I should free the memory.
而 valgrind 并不一定知道我应该什么时候释放内存。

1699
01:23:13,640 --> 01:23:17,660
That's up to me, but I should probably free it at the end of my function
这取决于我，但我可能应该在我的函数结束时释放它，因为一旦你释放了内存，

1700
01:23:17,660 --> 01:23:20,660
when I'm definitely done with it, because once you free your memory,
当我真正完成时，因为一旦你释放了你的内存，

1701
01:23:20,660 --> 01:23:24,370
you should not touch that variable again, unless you actually
你就不要再触碰那个变量了，除非你真正地

1702
01:23:24,370 --> 01:23:26,110
change what its value is.
改变它的值。

1703
01:23:26,110 --> 01:23:28,480
So now, as I've done this, and this program to be clear
所以，现在，当我这样做时，这个程序明确地说

1704
01:23:28,480 --> 01:23:29,560
does nothing useful.
没有做任何有用的事情。

1705
01:23:29,560 --> 01:23:32,920
This is just an intellectual exercise, not anything productive.
这只是一个智力练习，不是任何有成效的事情。

1706
01:23:32,920 --> 01:23:36,160
Let me do make memory one last time.
让我最后一次运行 make memory。

1707
01:23:36,160 --> 01:23:39,050
Let's do valgrind, dot slash memory.
让我们运行 valgrind，点斜杠内存。

1708
01:23:39,050 --> 01:23:42,640
And let me grow my terminal window again and hit enter.
让我再次扩大我的终端窗口，然后按回车键。

1709
01:23:42,640 --> 01:23:44,710
And even though it's still kind of output,
尽管它仍然是某种输出，

1710
01:23:44,710 --> 01:23:48,702
it's still kind of cryptic, at least it says no leaks are possible.
它仍然有点神秘，至少它说没有泄漏的可能性。

1711
01:23:48,702 --> 01:23:51,160
So now this is my own sort of teaching assistant telling me
所以，现在，这是我自己的教学助手告诉我

1712
01:23:51,160 --> 01:23:53,440
before I submit the code, or before I deploy it
在我提交代码之前，或者在我部署它之前

1713
01:23:53,440 --> 01:23:55,930
to production in real software, that at least there
到真正的软件生产中，至少在那里

1714
01:23:55,930 --> 01:23:57,980
seem to be no memory related errors.
似乎没有与内存相关的错误。

1715
01:23:57,980 --> 01:23:59,710
So valgrind is not for logical bugs.
所以 valgrind 不是用于逻辑错误。

1716
01:23:59,710 --> 01:24:01,120
It's not for syntax errors.
它不是用于语法错误。

1717
01:24:01,120 --> 01:24:04,810
It's for memory related bugs, as of today.
它是用于与内存相关的错误，截至目前。

1718
01:24:04,810 --> 01:24:10,310
Questions on any of that?
对此有任何问题吗？

1719
01:24:10,310 --> 01:24:10,810
No?
不？

1720
01:24:10,810 --> 01:24:12,820
OK, so what else can go wrong?
好吧，还有什么可能出错？

1721
01:24:12,820 --> 01:24:14,320
We mentioned these in the past.
我们之前提到了这些。

1722
01:24:14,320 --> 01:24:16,780
It turns out that garbage values are a thing.
事实证明，垃圾值确实存在。

1723
01:24:16,780 --> 01:24:18,910
And recall that, if you declare a variable
请记住，如果你声明一个变量

1724
01:24:18,910 --> 01:24:20,890
but don't give it a value with an equal sign,
但没有用等号赋予它一个值，

1725
01:24:20,890 --> 01:24:23,960
and you just blindly start using it, like printing it out, or doing math
你只是盲目地开始使用它，比如打印它或进行数学运算

1726
01:24:23,960 --> 01:24:26,660
on it, you might be manipulating a garbage value, which
你可能正在操作一个垃圾值，它

1727
01:24:26,660 --> 01:24:29,750
is some number that's essentially remnants of your computer
本质上是你的计算机剩余的一些数字

1728
01:24:29,750 --> 01:24:30,945
having been on for a while.
运行了一段时间。

1729
01:24:30,945 --> 01:24:33,320
Because if you're using this canvas and reusing it again,
因为如果你使用这个画布，并且再次使用它，

1730
01:24:33,320 --> 01:24:37,040
and again, surely there's going to be patterns of zeros and ones
一次又一次地，肯定会有零和一的模式

1731
01:24:37,040 --> 01:24:39,890
there that you didn't put there yourself, at least in the moment.
在那里，至少在那一刻，你不是自己放的。

1732
01:24:39,890 --> 01:24:41,420
They might be remnants of the past.
它们可能是过去的残留。

1733
01:24:41,420 --> 01:24:46,370
So garbage values are values of variables that you did not proactively
所以垃圾值是你没有主动设置的变量的值

1734
01:24:46,370 --> 01:24:48,810
set yourself as intended.
按预期设置。

1735
01:24:48,810 --> 01:24:50,030
So we can actually see this.
所以我们实际上可以看到这一点。

1736
01:24:50,030 --> 01:24:53,780
Let me actually go ahead and whip up a really quick program here
让我先快速编写一个程序

1737
01:24:53,780 --> 01:24:55,710
after shrinking my terminal window.
缩小我的终端窗口后。

1738
01:24:55,710 --> 01:24:58,310
Let me close memory.c.
让我关闭 memory.c。

1739
01:24:58,310 --> 01:25:01,820
Let me go ahead and open garbage.c.
让我打开 garbage.c。

1740
01:25:01,820 --> 01:25:04,340
And in here, I'll do include.
在这里，我将进行包含。

1741
01:25:04,340 --> 01:25:06,590
How about standard io.h?
标准输入输出呢？

1742
01:25:06,590 --> 01:25:09,638
Let's include standard lib.h
我们包含标准库。

1743
01:25:09,638 --> 01:25:12,341
Actually, we don't even need standard lib.h.
实际上，我们甚至不需要标准库。

1744
01:25:12,341 --> 01:25:16,790
Let's go ahead and include standard io.h and then int main void.
我们包含标准输入输出，然后是 int main void。

1745
01:25:16,790 --> 01:25:18,980
And then inside of the curly braces, let's
然后在大括号内，让我们

1746
01:25:18,980 --> 01:25:23,580
give me a really big array of scores, like 1,024 scores,
给我一个很大的分数数组，比如 1024 个分数，

1747
01:25:23,580 --> 01:25:25,920
like if it's a really busy semester.
就像一个非常繁忙的学期。

1748
01:25:25,920 --> 01:25:29,400
And then let me go ahead and just blindly iterate from i
然后让我继续盲目地从 i 开始迭代

1749
01:25:29,400 --> 01:25:32,138
equals zero on up to i is less than 1,024.
等于 0 直到 i 小于 1024。

1750
01:25:32,138 --> 01:25:33,930
And I'm not going to bother with constants.
我不会理会常量。

1751
01:25:33,930 --> 01:25:36,513
I'm just going to play around with these numbers for a moment.
我只是想玩玩这些数字。

1752
01:25:41,120 --> 01:25:43,460
And, oh, thank you.
哦，谢谢。

1753
01:25:43,460 --> 01:25:44,540
Oh, cookies for you.
哦，给你的饼干。

1754
01:25:44,540 --> 01:25:45,680
OK.
好的。

1755
01:25:45,680 --> 01:25:46,400
OK, here we go.
好的，我们开始吧。

1756
01:25:46,400 --> 01:25:47,130
OK, come on up.
好的，上来吧。

1757
01:25:47,130 --> 01:25:48,440
Thank you very much.
非常感谢。

1758
01:25:48,440 --> 01:25:49,580
Fair is fair.
公平就是公平。

1759
01:25:49,580 --> 01:25:50,780
OK.
好的。

1760
01:25:50,780 --> 01:25:52,940
Thank you.
谢谢。

1761
01:25:52,940 --> 01:25:54,440
OK.
好的。

1762
01:25:54,440 --> 01:25:56,280
OK, now everyone's really paying attention.
好的，现在每个人都非常认真地听着。

1763
01:25:56,280 --> 01:25:56,780
All right.
好的。

1764
01:25:56,780 --> 01:25:59,900
So in my loop here, I'm just going to do something stupid,
所以在我的循环中，我将做一些愚蠢的事情，

1765
01:25:59,900 --> 01:26:04,970
like print out all of the values in the scores array using percent i,
比如使用百分号 i 打印分数数组中的所有值，

1766
01:26:04,970 --> 01:26:08,820
even though I did not put anything in this array.
尽管我没有在这个数组中放任何东西。

1767
01:26:08,820 --> 01:26:11,570
So on line five, I'm obviously declaring an array
所以，在第 5 行，我显然声明了一个数组

1768
01:26:11,570 --> 01:26:15,230
of size 1,024 for that many ints, but I'm never
大小为 1024，用于存放这些整数，但我永远不会

1769
01:26:15,230 --> 01:26:19,890
actually putting values in there myself, or with getint, or any other function.
实际上，我本人在里面放入了值，或者使用 getint 或者其他函数。

1770
01:26:19,890 --> 01:26:21,560
So there's garbage values there.
所以这里面都是垃圾值。

1771
01:26:21,560 --> 01:26:24,440
There's presumably 1,024 garbage values there,
那里大概有 1024 个垃圾值，

1772
01:26:24,440 --> 01:26:26,060
and we can now actually see them.
现在我们可以看到它们了。

1773
01:26:26,060 --> 01:26:27,650
Let me make my terminal window bigger.
让我把我的终端窗口放大。

1774
01:26:27,650 --> 01:26:31,178
Let me make garbage, no pun intended, dot slash garbage.
让我创建垃圾，没有双关语的意思，点斜杠垃圾。

1775
01:26:31,178 --> 01:26:33,720
And there's going to be way more than even fit on the screen.
而且它们的数量远远超过屏幕能显示的。

1776
01:26:33,720 --> 01:26:34,303
But who cares?
但是谁在乎呢？

1777
01:26:34,303 --> 01:26:35,390
We just need to see a few.
我们只需要看到几个。

1778
01:26:35,390 --> 01:26:38,730
There are some of the garbage values in the array.
这些是数组中的部分垃圾值。

1779
01:26:38,730 --> 01:26:42,200
So make super clear that when you create variables of your own,
所以要非常清楚，当你创建自己的变量时，

1780
01:26:42,200 --> 01:26:44,780
you do not give them values of your own.
不要给他们赋予自己的值。

1781
01:26:44,780 --> 01:26:46,580
Who knows what may be there?
谁知道那里会有什么？

1782
01:26:46,580 --> 01:26:50,930
In some cases, it gets automatically initialized for you to all zeros,
在某些情况下，它会自动初始化为全零，

1783
01:26:50,930 --> 01:26:52,540
but that is not always the case.
但并非总是如此。

1784
01:26:52,540 --> 01:26:55,980
And in general, distrust the variable unless you yourself
一般来说，不要信任变量，除非你自己

1785
01:26:55,980 --> 01:26:57,580
have put a value there.
给它赋予了一个值。

1786
01:26:57,580 --> 01:27:03,090
So how now might we leverage this to--
那么，我们现在如何利用它来 -

1787
01:27:03,090 --> 01:27:05,670
how now might we think about potential problems?
我们现在如何思考潜在问题？

1788
01:27:05,670 --> 01:27:08,640
Well, consider this code here, which this program, too,
好吧，考虑一下这里面的代码，这个程序也是一样，

1789
01:27:08,640 --> 01:27:13,320
is more for discussion than actual utility, where at the top of it,
它更适合讨论，而不是实际应用，在代码的顶部，

1790
01:27:13,320 --> 01:27:15,870
I declare a variable called x and a variable called y,
我声明了一个名为 x 的变量和一个名为 y 的变量，

1791
01:27:15,870 --> 01:27:16,890
both of type pointer.
它们都是指针类型。

1792
01:27:16,890 --> 01:27:19,980
So x and y are supposed to be the addresses of two integers.
所以 x 和 y 应该分别是两个整数的地址。

1793
01:27:19,980 --> 01:27:22,950
malloc, the size of an int, and stored in x.
用 malloc 分配一个 int 的大小，然后存储到 x 中。

1794
01:27:22,950 --> 01:27:26,220
So I'm giving myself space for x, even though, obviously, I
所以我给自己分配了 x 的空间，虽然很明显，我

1795
01:27:26,220 --> 01:27:29,010
could have done this weeks ago by just not using the star,
几周前我就可以通过不使用星号来做到这一点，

1796
01:27:29,010 --> 01:27:30,360
and just say give me an int x.
直接说给我一个 int x。

1797
01:27:30,360 --> 01:27:35,640
Now I'm doing it the low level way, malloc-ing the x for myself.
现在我正在用低级方式来做，自己用 malloc 分配 x。

1798
01:27:35,640 --> 01:27:39,510
I'm then saying go to x, go to that address in memory,
然后我说去 x，去内存中的那个地址，

1799
01:27:39,510 --> 01:27:41,340
and put the number 42 there.
然后把数字 42 放到那里。

1800
01:27:41,340 --> 01:27:46,020
I'm then saying go to y and put the unlucky number 13 there.
然后我说去 y，把不吉利的数字 13 放到那里。

1801
01:27:46,020 --> 01:27:49,350
But what's worrisome about this line here?
但是这里这行代码有什么令人担忧的地方呢？

1802
01:27:49,350 --> 01:27:55,700
After this line, this line, this line, something's bad, I think.
在这行代码之后，这行代码之后，这行代码之后，我想有些地方不对劲。

1803
01:27:55,700 --> 01:27:57,830
Yeah, I never allocated memory for y.
是的，我从来都没有为 y 分配内存。

1804
01:27:57,830 --> 01:28:00,540
So specifically, I never assigned y a value,
所以具体来说，我从未给 y 赋值，

1805
01:28:00,540 --> 01:28:02,990
which means it's a garbage value, which is still a number.
这意味着它是一个垃圾值，它仍然是一个数字。

1806
01:28:02,990 --> 01:28:03,680
Maybe it's zero.
也许它是零。

1807
01:28:03,680 --> 01:28:04,680
Maybe it's a big number.
也许它是一个大数字。

1808
01:28:04,680 --> 01:28:06,290
Maybe it's a negative number.
也许它是一个负数。

1809
01:28:06,290 --> 01:28:10,100
And if it's a positive number, it could be an actual address
如果它是一个正数，它可能是一个真实的地址

1810
01:28:10,100 --> 01:28:11,670
somewhere in the computer's memory.
在计算机内存中的某个地方。

1811
01:28:11,670 --> 01:28:13,190
But star y means go there.
但是星号 y 意味着去那里。

1812
01:28:13,190 --> 01:28:15,050
Who knows what memory I'm touching?
谁知道我碰到了什么内存？

1813
01:28:15,050 --> 01:28:18,320
That's how computers crash if you touch memory that you're not supposed to.
这就是如果你触碰了不应该触碰的内存，计算机就会崩溃的原因。

1814
01:28:18,320 --> 01:28:21,740
So let me pretend that I didn't at least do this and let me just forge ahead
所以让我假装我至少没有这样做，让我继续前进

1815
01:28:21,740 --> 01:28:25,320
and set y equal to x so they're the same.
把 y 设置为等于 x，这样它们就一样了。

1816
01:28:25,320 --> 01:28:28,700
And I think what that would mean is now, if I do star y
我认为这意味着，现在，如果我使用星号 y

1817
01:28:28,700 --> 01:28:33,140
and go to the address, that's the same thing as going to the address in x.
然后去那个地址，这和去 x 中的地址是一样的。

1818
01:28:33,140 --> 01:28:37,640
And I think this will have the effect of changing the 42 to 13.
我认为这将改变42到13。

1819
01:28:37,640 --> 01:28:42,470
So this code is correct, so long as I don't blindly dereference y
所以这段代码是正确的，只要我不盲目地解除对y的引用

1820
01:28:42,470 --> 01:28:44,940
by using star y notation.
使用星号y表示法。

1821
01:28:44,940 --> 01:28:48,320
So this gets a little abstract, even though this is just an exercise here.
所以这有点抽象，尽管这只是一个练习。

1822
01:28:48,320 --> 01:28:51,200
And our friend Nick Parlante, a professor at Stanford,
我们的朋友Nick Parlante，斯坦福大学教授，

1823
01:28:51,200 --> 01:28:54,210
wonderfully put together a little claymation
非常棒地制作了一个小粘土动画

1824
01:28:54,210 --> 01:28:58,990
that's fun to take a look at, whereby if I go ahead and open up this file,
很有趣，如果我继续打开这个文件，

1825
01:28:58,990 --> 01:29:02,070
we'll be introduced to someone who's a little famous
我们会认识一个在计算机领域小有名气的人

1826
01:29:02,070 --> 01:29:05,250
in the world of computing named Binky, if we could dim the lights
名叫Binky，如果我们能调暗灯光

1827
01:29:05,250 --> 01:29:08,010
and take a look at what bad things can happen if you
看看如果你没有正确管理内存会发生什么坏事。

1828
01:29:08,010 --> 01:29:11,820
don't manage your memory properly.
不要正确地管理内存。

1829
01:29:11,820 --> 01:29:13,050
SPEAKER 5: Hey, Binky.
说话者5：嘿，Binky。

1830
01:29:13,050 --> 01:29:13,800
Wake up.
醒醒。

1831
01:29:13,800 --> 01:29:16,025
It's time for pointer fun.
现在是玩指针的时候了。

1832
01:29:16,025 --> 01:29:17,320
SPEAKER 6: What's that?
说话者6：什么？

1833
01:29:17,320 --> 01:29:19,150
Learn about pointers?
学习指针？

1834
01:29:19,150 --> 01:29:20,118
Oh, goody.
哦，太好了。

1835
01:29:20,118 --> 01:29:23,410
SPEAKER 5: Well, to get started, I guess we're going to need a couple pointers.
说话者5：好吧，要开始，我想我们需要几个指针。

1836
01:29:23,410 --> 01:29:24,610
SPEAKER 6: OK.
说话者6：好的。

1837
01:29:24,610 --> 01:29:28,060
This code allocates two pointers, which can point to integers.
这段代码分配了两个指针，它们可以指向整数。

1838
01:29:28,060 --> 01:29:28,810
SPEAKER 5: OK.
说话者5：好的。

1839
01:29:28,810 --> 01:29:32,220
Well, I see the two pointers, but they don't seem to be pointing to anything.
好吧，我看到这两个指针，但它们似乎没有指向任何东西。

1840
01:29:32,220 --> 01:29:33,220
SPEAKER 6: That's right.
说话者6：没错。

1841
01:29:33,220 --> 01:29:35,350
Initially, pointers don't point to anything.
最初，指针不指向任何东西。

1842
01:29:35,350 --> 01:29:38,410
The things they point to are called pointees, and setting them up
它们指向的东西叫做被指向物，设置它们

1843
01:29:38,410 --> 01:29:39,250
is a separate step.
是一个单独的步骤。

1844
01:29:39,250 --> 01:29:40,570
SPEAKER 5: Oh, right, right.
说话者5：哦，对，对。

1845
01:29:40,570 --> 01:29:41,230
I knew that.
我知道。

1846
01:29:41,230 --> 01:29:43,120
The pointees are separate.
被指向物是分开的。

1847
01:29:43,120 --> 01:29:45,190
So how do you allocate a pointee?
那么如何分配一个被指向物呢？

1848
01:29:45,190 --> 01:29:46,150
SPEAKER 6: OK.
说话者6：好的。

1849
01:29:46,150 --> 01:29:49,150
Well, this code allocates a new integer pointee,
好吧，这段代码分配了一个新的整数被指向物，

1850
01:29:49,150 --> 01:29:51,870
and this part sets x to point to it.
这部分将x设置为指向它。

1851
01:29:51,870 --> 01:29:53,480
SPEAKER 5: Hey, that looks better.
说话者5：嘿，看起来好多了。

1852
01:29:53,480 --> 01:29:54,740
So make it do something.
所以让它做点什么。

1853
01:29:54,740 --> 01:29:58,640
SPEAKER 6: OK, I'll dereference the pointer x to store the number
说话者6：好的，我将解除对指针x的引用以将数字

1854
01:29:58,640 --> 01:30:00,680
42 into its pointee.
42存储到它的被指向物中。

1855
01:30:00,680 --> 01:30:03,860
For this trick, I'll need my magic wand of dereferencing.
为了这个技巧，我需要我的解引用魔杖。

1856
01:30:03,860 --> 01:30:07,770
SPEAKER 5: Your magic wand of dereferencing?
说话者5：你的解引用魔杖？

1857
01:30:07,770 --> 01:30:09,195
That's great.
太棒了。

1858
01:30:09,195 --> 01:30:11,350
SPEAKER 6: This is what the code looks like.
说话者6：这就是代码的样子。

1859
01:30:11,350 --> 01:30:13,965
I'll just set up the number and--
我只要设置数字，然后——

1860
01:30:13,965 --> 01:30:15,020
SPEAKER 5: Hey, look.
说话者5：嘿，看。

1861
01:30:15,020 --> 01:30:16,220
There it goes.
它开始了。

1862
01:30:16,220 --> 01:30:19,910
So doing a dereference on x follows the arrow
所以对x进行解引用会沿着箭头

1863
01:30:19,910 --> 01:30:23,300
to access its pointee, in this case, to store 42 in there.
访问它的被指向物，在这种情况下，将42存储在那里。

1864
01:30:23,300 --> 01:30:27,560
Hey, try using it to store the number 13 through the other pointer, y.
嘿，试试用另一个指针y存储数字13。

1865
01:30:27,560 --> 01:30:28,860
SPEAKER 6: OK.
说话者6：好的。

1866
01:30:28,860 --> 01:30:33,380
I'll just go over here to y and get the number 13 set up,
我只要到y这里去，设置好数字13，

1867
01:30:33,380 --> 01:30:38,030
and then take the wand of dereferencing, and just--
然后拿起解引用魔杖，然后——

1868
01:30:38,030 --> 01:30:38,810
whoa.
哇。

1869
01:30:38,810 --> 01:30:41,150
SPEAKER 5: Oh, hey, that didn't work.
说话者 5：哦，嘿，那没起作用。

1870
01:30:41,150 --> 01:30:44,150
Say, Binky, I don't think dereferencing y
Binky，我认为对 y 进行解引用不是一个好主意

1871
01:30:44,150 --> 01:30:48,330
is a good idea because setting up the pointee is a separate step,
因为设置指针所指向的对象是一个单独的步骤，

1872
01:30:48,330 --> 01:30:50,405
and I don't think we ever did it.
而且我认为我们从未这样做过。

1873
01:30:50,405 --> 01:30:51,365
SPEAKER 6: Good point.
说话者 6：说得有道理。

1874
01:30:51,365 --> 01:30:54,230
SPEAKER 5: Yeah, we allocated the pointer y,
说话者 5：是的，我们分配了指针 y，

1875
01:30:54,230 --> 01:30:56,986
but we never set it to point to a pointee.
但我们从未将其设置为指向一个指针所指向的对象。

1876
01:30:56,986 --> 01:30:58,518
SPEAKER 6: Very observant.
说话者 6：观察力敏锐。

1877
01:30:58,518 --> 01:31:00,560
SPEAKER 5: Hey, you're looking good there, Binky.
说话者 5：嘿，Binky，你看起来很棒。

1878
01:31:00,560 --> 01:31:03,590
Can you fix it so that y points to the same pointee as x?
你能修复一下，让 y 指向与 x 相同的指针所指向的对象吗？

1879
01:31:03,590 --> 01:31:04,280
SPEAKER 6: Sure.
说话者 6：当然。

1880
01:31:04,280 --> 01:31:06,500
I'll use my magic wand of pointer assignment.
我会使用我的指针分配魔杖。

1881
01:31:06,500 --> 01:31:08,765
SPEAKER 5: Is that going to be a problem like before?
说话者 5：会像之前一样出现问题吗？

1882
01:31:08,765 --> 01:31:11,000
SPEAKER 6: No, this doesn't touch the pointees.
说话者 6：不，这不会影响指针所指向的对象。

1883
01:31:11,000 --> 01:31:14,470
It just changes one pointer to point to the same thing as another.
它只是改变了一个指针，使其指向与另一个指针相同的内容。

1884
01:31:14,470 --> 01:31:15,840
SPEAKER 5: Oh, I see.
说话者 5：哦，我明白了。

1885
01:31:15,840 --> 01:31:18,390
Now y points to the same place as x.
现在 y 指向与 x 相同的位置。

1886
01:31:18,390 --> 01:31:19,350
So wait.
所以等等。

1887
01:31:19,350 --> 01:31:20,370
Now y is fixed.
现在 y 被修复了。

1888
01:31:20,370 --> 01:31:23,430
It has a pointee, so you can try the wand of dereferencing again
它有一个指针所指向的对象，所以你可以再次尝试解引用魔杖

1889
01:31:23,430 --> 01:31:25,630
to send the 13 over.
将 13 传递过去。

1890
01:31:25,630 --> 01:31:26,640
SPEAKER 6: OK.
说话者 6：好的。

1891
01:31:26,640 --> 01:31:28,085
Here it goes.
开始了。

1892
01:31:28,085 --> 01:31:29,500
SPEAKER 5: Hey, look at that.
说话者 5：嘿，看看吧。

1893
01:31:29,500 --> 01:31:31,300
Now dereferencing works on y.
现在对 y 进行解引用起作用了。

1894
01:31:31,300 --> 01:31:34,795
And because the pointers are sharing that one pointee, they both see the 13.
由于指针共享一个指针所指向的对象，因此它们都看到了 13。

1895
01:31:34,795 --> 01:31:36,550
SPEAKER 6: Yeah, sharing.
说话者 6：是的，共享。

1896
01:31:36,550 --> 01:31:37,060
Whatever.
随便啦。

1897
01:31:37,060 --> 01:31:38,860
So are we going to switch places now?
所以我们现在要交换位置了吗？

1898
01:31:38,860 --> 01:31:39,790
SPEAKER 5: Oh, look.
说话者 5：哦，看。

1899
01:31:39,790 --> 01:31:40,675
We're out of time.
时间到了。

1900
01:31:40,675 --> 01:31:41,950
SPEAKER 6: But--
说话者 6：但是--

1901
01:31:41,950 --> 01:31:43,090
SPEAKER 1: All right.
说话者 1：好的。

1902
01:31:43,090 --> 01:31:44,320
So our thanks to Nick.
所以感谢尼克。

1903
01:31:44,320 --> 01:31:47,290
I can only imagine how many hours he spent making that happen.
我只能想象他花了多少时间才让这一切发生。

1904
01:31:47,290 --> 01:31:50,290
But hopefully, it gives you more of a visual as to what's happening when
但希望这能让你对以下情况有一个更直观的了解

1905
01:31:50,290 --> 01:31:54,160
we're dereferencing these addresses, and going to them, and assigning values,
我们正在对这些地址进行解引用，然后访问它们，并为其赋值，

1906
01:31:54,160 --> 01:31:58,720
and as per Binky's explosion there, what happens when you dereference values you
以及正如 Binky 那里的爆炸所示，当你对不应该解引用的值进行解引用时会发生什么，

1907
01:31:58,720 --> 01:31:59,380
shouldn't.
不应该。

1908
01:31:59,380 --> 01:32:01,730
So related thereto, let me do this.
所以与之相关的是，让我来做这个。

1909
01:32:01,730 --> 01:32:05,050
Let me go over to VS Code and open up now a program
让我去 VS Code 并打开一个程序

1910
01:32:05,050 --> 01:32:07,390
I wrote in advance called swap.c.
我提前编写了一个名为 swap.c 的程序。

1911
01:32:07,390 --> 01:32:11,990
And the purpose of this program is just to swap the value of two variables.
该程序的目的是交换两个变量的值。

1912
01:32:11,990 --> 01:32:16,660
So let me walk over to the code here and point out that, in main, I've got
所以让我走到这里的代码并指出，在 main 中，我有

1913
01:32:16,660 --> 01:32:17,890
two variables, x and y.
两个变量，x 和 y。

1914
01:32:17,890 --> 01:32:19,300
No pointers, no magic there.
没有指针，没有魔法。

1915
01:32:19,300 --> 01:32:21,670
Just x and y are one and two respectively.
只有 x 和 y 分别是 1 和 2。

1916
01:32:21,670 --> 01:32:27,520
I've got a couple of printfs here saying x is %i, y is %i, passing in x and y,
我在这里有几个 printf 语句，分别输出 x 是 %i，y 是 %i，并将 x 和 y 传递进去，

1917
01:32:27,520 --> 01:32:30,290
just so we can see that x and y are indeed one and two.
这样我们就能看到 x 和 y 确实是 1 和 2。

1918
01:32:30,290 --> 01:32:32,810
I'm then calling a function called swap, which
我随后调用了一个叫做 swap 的函数，它

1919
01:32:32,810 --> 01:32:34,950
presumably, should swap the two values.
应该可以交换这两个值。

1920
01:32:34,950 --> 01:32:37,340
And then I'm just printing the exact same thing again,
然后我又打印了完全相同的内容，

1921
01:32:37,340 --> 01:32:39,680
my hoping that it's first going to say one, two,
希望它会先说一，二，

1922
01:32:39,680 --> 01:32:43,460
then it's going to say two, one, thus achieving the idea of swapping here.
然后会说二，一，从而实现这里的交换想法。

1923
01:32:43,460 --> 01:32:44,480
And here's swap.
这就是 swap 函数。

1924
01:32:44,480 --> 01:32:46,755
Swap takes in two integers, a and b, though I
swap 函数接收两个整数，a 和 b，尽管我

1925
01:32:46,755 --> 01:32:48,380
could have called them whatever I want.
可以随心所欲地命名它们。

1926
01:32:48,380 --> 01:32:52,040
It temporarily puts a in temp.
它暂时将 a 存储到 temp 中。

1927
01:32:52,040 --> 01:32:54,290
It then changes a to b.
然后它将 a 更改为 b。

1928
01:32:54,290 --> 01:32:57,050
It then changes b to temp, and then that's it.
然后它将 b 更改为 temp，然后就完成了。

1929
01:32:57,050 --> 01:32:59,220
It's a void function, so it doesn't return anything,
它是一个 void 函数，所以它不返回任何值，

1930
01:32:59,220 --> 01:33:02,190
but it does all of the mathematical work in here.
但它在这里完成了所有的数学运算。

1931
01:33:02,190 --> 01:33:07,610
So this is curious, though, because when it runs,
所以这很有趣，因为当它运行时，

1932
01:33:07,610 --> 01:33:09,260
let me open up my terminal window here.
让我打开我的终端窗口。

1933
01:33:09,260 --> 01:33:14,150
Make swap, dot slash swap, I should see one, two, and then two, one.
执行 make swap，然后 ./swap，我应该看到一，二，然后二，一。

1934
01:33:14,150 --> 01:33:17,750
But no, even though I do think this is logically correct.
但是没有，虽然我认为这是逻辑上正确的。

1935
01:33:17,750 --> 01:33:21,020
And actually, we're almost out of stock, but we do have another box of cookies
实际上，我们的库存快没了，但我们还有一盒饼干

1936
01:33:21,020 --> 01:33:21,520
here.
在这里。

1937
01:33:21,520 --> 01:33:24,260
Can we get one volunteer to come on up here maybe?
我们可以找一个志愿者上来吗？

1938
01:33:24,260 --> 01:33:25,760
OK, how about you?
好吧，你怎么样？

1939
01:33:25,760 --> 01:33:28,010
Yes, in the pink, come on up.
是的，穿粉衣服的，上来吧。

1940
01:33:28,010 --> 01:33:31,470
A round of applause, though, really, it's about the cookies now, I know.
来点掌声吧，不过，说实话，现在主要是关于饼干，我知道。

1941
01:33:35,420 --> 01:33:38,180
OK.
好的。

1942
01:33:38,180 --> 01:33:40,706
And what is your name?
你叫什么名字？

1943
01:33:40,706 --> 01:33:43,437
SPEAKER 7: My name is Caleb, and I'm a first year concentrating
发言者 7：我叫 Caleb，我是一年级学生，主修

1944
01:33:43,437 --> 01:33:44,270
in computer science.
计算机科学。

1945
01:33:44,270 --> 01:33:45,520
SPEAKER 1: All right, welcome.
发言者 1：好的，欢迎。

1946
01:33:45,520 --> 01:33:48,290
Please stand behind the desk here.
请站在桌子后面。

1947
01:33:48,290 --> 01:33:49,040
No, you can stand.
不用，你可以站着。

1948
01:33:49,040 --> 01:33:49,550
It's fine.
没关系。

1949
01:33:49,550 --> 01:33:50,133
SPEAKER 7: OK.
发言者 7：好的。

1950
01:33:50,133 --> 01:33:52,438
SPEAKER 1: We have two glasses of water, colored, blue,
发言者 1：我们有两杯水，分别是蓝色的

1951
01:33:52,438 --> 01:33:53,480
and orange, respectively.
和橙色的。

1952
01:33:53,480 --> 01:33:57,870
And I would like you to swap the values of these two variables
我希望你交换这两个变量的值

1953
01:33:57,870 --> 01:34:00,035
so that the orange liquid goes in the blue glass,
这样橙色的液体就可以倒入蓝色的杯子中，

1954
01:34:00,035 --> 01:34:01,910
and the blue liquid goes in the orange glass.
蓝色的液体就倒入橙色的杯子中。

1955
01:34:05,864 --> 01:34:08,000
SPEAKER 7: Seems like a bad idea.
发言者 7：这似乎不是一个好主意。

1956
01:34:08,000 --> 01:34:09,695
SPEAKER 1: Why is that?
发言者 1：为什么？

1957
01:34:09,695 --> 01:34:14,930
SPEAKER 7: Because I can't get one out to put the other one in because there's
发言者 7：因为我无法把一种液体倒出来，然后把另一种液体倒进去，因为没有

1958
01:34:14,930 --> 01:34:15,800
no third glass.
第三个杯子。

1959
01:34:15,800 --> 01:34:20,210
SPEAKER 1: OK correct because we do have what we generally
发言者 1：好的，你说得对，因为我们通常

1960
01:34:20,210 --> 01:34:21,660
call a temporary variable here.
称之为临时变量。

1961
01:34:21,660 --> 01:34:23,660
So here, let me give you a variable called temp.
所以，这里，我给你一个叫做 temp 的变量。

1962
01:34:23,660 --> 01:34:26,090
And if I give you this, how does that change things?
如果你有了它，会改变什么？

1963
01:34:26,090 --> 01:34:27,695
SPEAKER 7: Well, now, I can take one.
发言者 7：好吧，现在我可以拿一个。

1964
01:34:27,695 --> 01:34:28,520
SPEAKER 1: OK.
发言者 1：好的。

1965
01:34:28,520 --> 01:34:29,720
SPEAKER 7: Very carefully.
发言者 7：要非常小心。

1966
01:34:32,278 --> 01:34:32,945
SPEAKER 1: Nice.
发言者 1：不错。

1967
01:34:32,945 --> 01:34:34,100
SPEAKER 7: I'm trying.
发言者 7：我正在尝试。

1968
01:34:34,100 --> 01:34:34,850
SPEAKER 1: OK.
说话者 1：好的。

1969
01:34:34,850 --> 01:34:35,810
SPEAKER 7: There we go.
说话者 7：好了。

1970
01:34:35,810 --> 01:34:42,620
SPEAKER 1: And now you can put b into a, if you will.
说话者 1：现在你可以把 b 放进 a 中，如果你愿意的话。

1971
01:34:42,620 --> 01:34:44,350
Nice.
不错。

1972
01:34:44,350 --> 01:34:49,900
And now temp goes back into that one.
现在 temp 回到那个里面了。

1973
01:34:49,900 --> 01:34:50,470
All right.
好的。

1974
01:34:50,470 --> 01:34:51,490
That was very well done.
做得很好。

1975
01:34:51,490 --> 01:34:53,270
Maybe round of applause.
也许可以鼓掌。

1976
01:34:53,270 --> 01:34:56,450
Thank you.
谢谢。

1977
01:34:56,450 --> 01:35:00,950
So this was just a cookie based way of making clear
所以这只是一个基于饼干的方式来澄清

1978
01:35:00,950 --> 01:35:04,040
that the code on the screen seems to work.
屏幕上的代码似乎可以工作。

1979
01:35:04,040 --> 01:35:07,130
If I scroll back down to the swap function,
如果我向下滚动到交换函数，

1980
01:35:07,130 --> 01:35:12,230
it seems to do exactly what you just did there, whereby the temporary glass is
它似乎做了你刚才在那里做的事情，即临时玻璃是

1981
01:35:12,230 --> 01:35:15,650
where we put a, then we changed a to contain b,
我们把 a 放的地方，然后我们把 a 改成包含 b，

1982
01:35:15,650 --> 01:35:18,770
then we changed b to contain what was originally an a,
然后我们把 b 改成包含最初的 a，

1983
01:35:18,770 --> 01:35:20,708
but is now in the temporary glass.
但现在在临时玻璃里。

1984
01:35:20,708 --> 01:35:21,500
And now we're done.
现在我们完成了。

1985
01:35:21,500 --> 01:35:25,130
So it did achieve the stated goal, and yet when I ran this code a moment ago,
所以它确实实现了既定的目标，然而当我刚才运行这段代码时，

1986
01:35:25,130 --> 01:35:27,950
it was one, two, and then one, two again.
它是 1，2，然后又是 1，2。

1987
01:35:27,950 --> 01:35:30,140
So why might that actually be?
那么，为什么实际上会这样呢？

1988
01:35:30,140 --> 01:35:33,860
Well, here we can go back to some of today's fundamentals
好吧，我们可以回到今天的一些基本原理

1989
01:35:33,860 --> 01:35:36,030
to consider what it is that's going wrong.
来考虑一下哪里出了问题。

1990
01:35:36,030 --> 01:35:39,830
And in this case, it's actually related to a concept
在这种情况下，它实际上与一个概念有关

1991
01:35:39,830 --> 01:35:44,780
we introduced some time ago, whereby there seems to be an issue of scope,
我们之前介绍过，即似乎存在一个范围问题，

1992
01:35:44,780 --> 01:35:48,350
whereby sometimes when you're manipulating variables inside
即有时当你在花括号内操作变量时，

1993
01:35:48,350 --> 01:35:53,240
of curly braces, thus defining their scope, it has no effect on values
从而定义它们的范围，它对其他地方的值没有影响

1994
01:35:53,240 --> 01:35:53,870
elsewhere.
其他地方。

1995
01:35:53,870 --> 01:35:57,640
The variables might not even exist elsewhere, as we saw in the past.
正如我们过去所见，这些变量可能甚至不存在于其他地方。

1996
01:35:57,640 --> 01:35:58,900
So what do I mean by this?
那么，我这是什么意思呢？

1997
01:35:58,900 --> 01:36:03,798
Well, with matters of scope, it turns out that in this case, the way
好吧，就范围问题而言，事实证明，在这种情况下，我的做法

1998
01:36:03,798 --> 01:36:06,090
I've implemented the swap function, I'm doing something
实现交换函数的方式，我在做一些

1999
01:36:06,090 --> 01:36:08,640
a programmer would call passing by value.
程序员所说的按值传递。

2000
01:36:08,640 --> 01:36:12,990
I'm literally passing in x and y by their values, one and two.
我实际上是按值传递 x 和 y，分别是 1 和 2。

2001
01:36:12,990 --> 01:36:15,750
Another way of putting this is passing by copy.
另一种说法是按副本传递。

2002
01:36:15,750 --> 01:36:18,900
So when I pass x and y into the swap function,
所以当我把 x 和 y 传递给交换函数时，

2003
01:36:18,900 --> 01:36:23,340
it turns out swap is actually getting copies thereof.
事实证明，交换函数实际上得到了它们的副本。

2004
01:36:23,340 --> 01:36:24,580
Now, what do I mean by this?
现在，我这是什么意思呢？

2005
01:36:24,580 --> 01:36:26,288
Well, let's go back again to this picture
好吧，让我们再回到这张图片

2006
01:36:26,288 --> 01:36:29,290
of memory representative of what's in your Mac, your PC, or your phone.
内存代表你 Mac、PC 或手机中的东西。

2007
01:36:29,290 --> 01:36:31,650
And if we zoom in on this chip and we treat
如果我们放大这个芯片，并把它看作

2008
01:36:31,650 --> 01:36:34,980
it more abstractly as this canvas, get rid of the actual hardware,
更抽象地作为画布，去掉实际的硬件，

2009
01:36:34,980 --> 01:36:37,780
and consider what's going on inside of the computer,
并考虑计算机内部发生的事情，

2010
01:36:37,780 --> 01:36:41,940
it turns out that there are conventions of how computers use this memory.
事实证明，计算机使用内存的方式存在一些约定。

2011
01:36:41,940 --> 01:36:44,740
And it's worth having a general sense of what goes where.
了解一下哪些东西放在哪里是值得的。

2012
01:36:44,740 --> 01:36:48,300
So generally speaking, if this is a big rectangular region of memory,
一般来说，如果这是一个大的矩形内存区域，

2013
01:36:48,300 --> 01:36:50,700
even though this is just an artist's depiction thereof,
即使这只是一个艺术家的描述，

2014
01:36:50,700 --> 01:36:53,250
it turns out that the top of your memory, so to speak,
事实证明，你的内存顶部，可以这么说，

2015
01:36:53,250 --> 01:36:54,750
is where machine code goes.
是机器码所在的地方。

2016
01:36:54,750 --> 01:36:59,470
The zeros and ones that you compile get loaded into here.
你编译的 0 和 1 会被加载到这里。

2017
01:36:59,470 --> 01:37:03,270
So when you do dot slash something, or on a Mac or PC, when you double click,
当您执行点斜杠某个东西，或在 Mac 或 PC 上双击时，

2018
01:37:03,270 --> 01:37:07,950
or on a phone, when you single tap, that loads your program's machine code,
或者在手机上，当您单击时，会加载您的程序的机器码，

2019
01:37:07,950 --> 01:37:10,528
the app's machine code to the top of your computer's memory.
将应用程序的机器码加载到计算机内存的顶部。

2020
01:37:10,528 --> 01:37:12,570
Strictly speaking, it doesn't have to be the top.
严格地说，它不必位于顶部。

2021
01:37:12,570 --> 01:37:14,730
But for our sake, it's in this region here.
但为了我们的方便，它位于该区域。

2022
01:37:14,730 --> 01:37:17,970
That's how the computer can access all of those zeros and ones quickly.
这就是计算机可以快速访问所有这些零和一的方式。

2023
01:37:17,970 --> 01:37:21,000
Below that, so to speak, are where global variables go.
在它下面，可以这么说，是全局变量所在的地方。

2024
01:37:21,000 --> 01:37:22,870
We haven't had many occasions to use these.
我们还没有很多机会使用它们。

2025
01:37:22,870 --> 01:37:25,410
But if you define a variable outside of main,
但是，如果您在 main 函数之外定义一个变量，

2026
01:37:25,410 --> 01:37:27,420
and outside of every other function in C,
并且在 C 中的任何其他函数之外，

2027
01:37:27,420 --> 01:37:29,140
it's what's called a global variable.
它被称为全局变量。

2028
01:37:29,140 --> 01:37:31,380
So those get tucked especially up at the top
因此，它们被特别放置在顶部

2029
01:37:31,380 --> 01:37:34,195
so that they're accessible everywhere else in your program.
以便它们可以在您的程序中的任何其他地方被访问。

2030
01:37:34,195 --> 01:37:35,820
Then there's something called the heap.
然后是堆。

2031
01:37:35,820 --> 01:37:37,180
More on that in a moment.
稍后会详细讲解。

2032
01:37:37,180 --> 01:37:40,860
And it grows downward, so you have a lot of memory available to you
它向下增长，因此您拥有大量可用的内存

2033
01:37:40,860 --> 01:37:43,380
here in the heap, and you can keep getting more, and more,
在堆中，并且您可以继续获得更多，更多，

2034
01:37:43,380 --> 01:37:44,700
and more available to you.
更多可供您使用。

2035
01:37:44,700 --> 01:37:47,820
But at the bottom of this memory is what's called the stack.
但是，在这段内存的底部是堆栈。

2036
01:37:47,820 --> 01:37:51,060
And the stack actually grows, curiously, in the other direction, up, and up,
有趣的是，堆栈实际上在另一个方向上增长，向上，向上，

2037
01:37:51,060 --> 01:37:51,570
and up.
向上。

2038
01:37:51,570 --> 01:37:55,320
And it turns out, when you use malloc and ask the computer for memory,
事实证明，当您使用 malloc 并向计算机请求内存时，

2039
01:37:55,320 --> 01:37:58,020
it comes from this heap region, specifically.
它来自这个堆区域，具体来说。

2040
01:37:58,020 --> 01:38:02,250
When you use functions with variables and arguments,
当您使用带有变量和参数的函数时，

2041
01:38:02,250 --> 01:38:04,170
you're using stack memory.
您使用的是堆栈内存。

2042
01:38:04,170 --> 01:38:07,405
Now, the astute viewer will notice that this does not seem like a good thing
现在，敏锐的观众会注意到，这似乎不是一件好事

2043
01:38:07,405 --> 01:38:09,030
if they're about to collide eventually.
如果它们最终会发生冲突。

2044
01:38:09,030 --> 01:38:12,657
And bad things can and will happen when one overflows the other, but more
当一方溢出另一方时，会发生不好的事情，但更多

2045
01:38:12,657 --> 01:38:13,740
on that, too, in a moment.
稍后会详细讲解。

2046
01:38:13,740 --> 01:38:15,630
But let's focus for the moment on a stack
但让我们暂时关注堆栈

2047
01:38:15,630 --> 01:38:17,770
when we do something like this swap function.
当我们执行这样的交换函数时。

2048
01:38:17,770 --> 01:38:21,150
So for instance, when we had code like this, which was bad,
例如，当我们有这样的代码，它是错误的，

2049
01:38:21,150 --> 01:38:26,130
it did not allow us to permanently change the values of x and y.
它不允许我们永久改变 x 和 y 的值。

2050
01:38:26,130 --> 01:38:27,060
Why?
为什么？

2051
01:38:27,060 --> 01:38:28,170
No pun intended.
不是有意玩弄文字。

2052
01:38:28,170 --> 01:38:31,710
Here on the stack is where the very first function
这里，在堆栈上是第一个函数所在的地方

2053
01:38:31,710 --> 01:38:33,640
goes in your computer's memory.
进入计算机内存。

2054
01:38:33,640 --> 01:38:36,030
So main, if you have any variables, they go
因此，main，如果您有任何变量，它们会

2055
01:38:36,030 --> 01:38:39,210
at the bottom of the computer's memory once you've loaded that program.
在您加载该程序后，位于计算机内存的底部。

2056
01:38:39,210 --> 01:38:40,660
So what do I mean by that?
那么，我的意思是什么？

2057
01:38:40,660 --> 01:38:44,400
Well, if you think back to the code a moment ago, it was things like x and y,
好吧，如果您回忆起刚才的代码，它就像 x 和 y 这样的东西，

2058
01:38:44,400 --> 01:38:45,450
and so forth.
等等。

2059
01:38:45,450 --> 01:38:50,790
When main calls swap, swap goes above it on the stack, so to speak.
当 main 调用 swap 时，swap 可以说是位于堆栈之上。

2060
01:38:50,790 --> 01:38:53,230
And each of these rectangles, the technical term is frame.
每个矩形，其技术术语为帧。

2061
01:38:53,230 --> 01:38:54,450
So this is a stack frame.
所以，这是一个堆栈帧。

2062
01:38:54,450 --> 01:38:55,620
This is a stack frame.
这是一个堆栈帧。

2063
01:38:55,620 --> 01:38:57,960
And if swap called another function, another frame
如果 swap 调用另一个函数，另一个帧

2064
01:38:57,960 --> 01:38:59,490
would go on the stack this way.
将以这种方式进入堆栈。

2065
01:38:59,490 --> 01:39:01,710
And then as soon as swap returns, though,
然后，一旦swap返回，

2066
01:39:01,710 --> 01:39:03,900
that memory essentially goes away, or the computer
该内存实际上就消失了，或者说计算机

2067
01:39:03,900 --> 01:39:06,608
forgets about it, even though the bits are obviously still there.
忘记了它，即使位显然还在那里。

2068
01:39:06,608 --> 01:39:08,610
You still have the hardware, but it's forgotten.
你仍然拥有硬件，但它被忘记了。

2069
01:39:08,610 --> 01:39:12,450
And main remains until main finishes and exits your program.
而main则一直存在，直到main完成并退出你的程序。

2070
01:39:12,450 --> 01:39:16,000
But let's consider what's going inside of these stack frames.
但让我们考虑一下这些栈帧内部发生了什么。

2071
01:39:16,000 --> 01:39:20,010
So here's main at the bottom, and it had two variables, x and y.
所以这里是底部的main，它有两个变量，x和y。

2072
01:39:20,010 --> 01:39:23,310
Those variables were one and two, respectively.
这些变量分别是1和2。

2073
01:39:23,310 --> 01:39:28,080
Main called swap, which had two arguments, a and b,
main调用了swap，它有两个参数，a和b，

2074
01:39:28,080 --> 01:39:30,965
also integers, which are effectively local variables, also,
也是整数，实际上也是局部变量，

2075
01:39:30,965 --> 01:39:33,090
even though you're declaring them in the signature,
即使你在函数签名中声明它们，

2076
01:39:33,090 --> 01:39:34,570
the prototype of the function.
函数的原型。

2077
01:39:34,570 --> 01:39:39,660
So when swap is called, swap is using its frame of memory as follows.
所以当调用swap时，swap使用其内存帧如下。

2078
01:39:39,660 --> 01:39:42,090
Room for a, room for b, room for temp.
为a留出空间，为b留出空间，为temp留出空间。

2079
01:39:42,090 --> 01:39:43,260
Not necessarily to scale.
不一定按比例。

2080
01:39:43,260 --> 01:39:45,630
I just wanted everything to be a pretty rectangle.
我只是想让一切都成为一个漂亮的矩形。

2081
01:39:45,630 --> 01:39:47,070
What's going where?
什么在什么地方？

2082
01:39:47,070 --> 01:39:56,820
Well, because functions in C pass by value, that is, copy, a is a copy of x,
因为C语言中的函数按值传递，也就是复制，a是x的副本，

2083
01:39:56,820 --> 01:39:58,890
and b is a copy of y.
而b是y的副本。

2084
01:39:58,890 --> 01:40:00,570
But they're separate bytes.
但它们是独立的字节。

2085
01:40:00,570 --> 01:40:02,823
This is a different memory location than this.
这个内存位置与这个不同。

2086
01:40:02,823 --> 01:40:04,740
This is a different memory location than this.
这个内存位置与这个不同。

2087
01:40:04,740 --> 01:40:07,960
So we're just copying the patterns of bits from one to the other.
所以我们只是将位模式从一个复制到另一个。

2088
01:40:07,960 --> 01:40:09,570
This is passing by value, a.k.a.
这就是按值传递，也称为

2089
01:40:09,570 --> 01:40:10,680
Passing by copy.
按副本传递。

2090
01:40:10,680 --> 01:40:11,730
So what then happens?
那么接下来会发生什么？

2091
01:40:11,730 --> 01:40:14,970
Just like our demonstration, we used temp cleverly,
就像我们的演示一样，我们巧妙地使用了temp，

2092
01:40:14,970 --> 01:40:19,290
whereby with this code here, we copied the value of a into temp.
通过这里的代码，我们将a的值复制到temp中。

2093
01:40:19,290 --> 01:40:21,540
So that puts the number one here, too.
这样这里也有数字1了。

2094
01:40:21,540 --> 01:40:23,820
We then changed a to equal b.
然后我们将a的值改为b。

2095
01:40:23,820 --> 01:40:25,770
So that's what happened here.
这就是这里发生的事情。

2096
01:40:25,770 --> 01:40:29,760
We then changed b to equal temp, so that changed the value there.
然后我们将b的值改为temp，从而改变了那里的值。

2097
01:40:29,760 --> 01:40:31,200
But then swap returned.
但随后swap返回了。

2098
01:40:31,200 --> 01:40:35,640
You went back to your seat, leaving a and b swapped, yes.
你回到了你的座位，留下了a和b交换了，是的。

2099
01:40:35,640 --> 01:40:40,050
But what was not swapped was x and y.
但没有交换的是x和y。

2100
01:40:40,050 --> 01:40:43,980
You did all of this work correctly, but in the wrong scope.
你做的一切都正确，但在错误的范围内。

2101
01:40:43,980 --> 01:40:46,150
You operated on copies thereof.
你对它们的副本进行了操作。

2102
01:40:46,150 --> 01:40:48,660
So this swap function, while logically correct,
因此，这个swap函数，虽然逻辑上是正确的，

2103
01:40:48,660 --> 01:40:51,540
will never solve this problem correctly as written
但按照目前的写法，永远无法正确地解决这个问题

2104
01:40:51,540 --> 01:40:54,160
because we've been passing by value.
因为我们一直是按值传递的。

2105
01:40:54,160 --> 01:40:56,250
So today, we introduce a technique, whereby
所以今天，我们介绍一种技术，通过这种技术，

2106
01:40:56,250 --> 01:41:00,750
you can pass by reference instead, pass by pointer instead,
你可以按引用传递，而不是按指针传递，

2107
01:41:00,750 --> 01:41:03,270
because instead of just passing in copies,
因为不是简单地传递副本，

2108
01:41:03,270 --> 01:41:08,410
what if we actually tell swap where x is and where y is, not what it is
如果我们实际上告诉swap x在哪里，y在哪里，而不是它们是什么

2109
01:41:08,410 --> 01:41:10,260
and what it is, but where each is?
以及它是什么，而是它们分别在哪里？

2110
01:41:10,260 --> 01:41:14,820
Then swap can follow the proverbial treasure map, go to those locations,
那么swap就可以遵循谚语中的藏宝图，去到那些地方，

2111
01:41:14,820 --> 01:41:16,630
and change them permanently.
并永久地改变它们。

2112
01:41:16,630 --> 01:41:19,290
So this was the bad code in red, and this
所以这是用红色标出的错误代码，而这个

2113
01:41:19,290 --> 01:41:20,940
is going to escalate quickly visually.
将很快在视觉上升级。

2114
01:41:20,940 --> 01:41:23,880
But it's just an application of today's ideas.
但这仅仅是今天理念的应用。

2115
01:41:23,880 --> 01:41:26,610
This is the correct solution now.
现在，这是正确的解决方案。

2116
01:41:26,610 --> 01:41:27,810
So let me do before.
所以，让我先做一下。

2117
01:41:27,810 --> 01:41:29,140
In red is bad.
红色代表错误。

2118
01:41:29,140 --> 01:41:31,380
Green, after, is correct.
绿色，之后，是正确的。

2119
01:41:31,380 --> 01:41:32,010
Why?
为什么？

2120
01:41:32,010 --> 01:41:34,860
The way you specify pass by reference or pointer
指定传递引用或指针的方式

2121
01:41:34,860 --> 01:41:37,710
instead is you change swap to take, not two integers, per se,
而是将swap修改为接收两个整数的地址，而不是两个整数本身，

2122
01:41:37,710 --> 01:41:39,660
but two addresses of integers.
而是两个整数的地址。

2123
01:41:39,660 --> 01:41:41,970
And the syntax for that today is just to add the star.
而今天的语法只是添加星号。

2124
01:41:41,970 --> 01:41:44,280
So int star, and int star.
所以int星号，和int星号。

2125
01:41:44,280 --> 01:41:46,650
Meanwhile, the code down here has to change.
同时，下面的代码需要改变。

2126
01:41:46,650 --> 01:41:47,910
Temp does not have to change.
Temp不需要改变。

2127
01:41:47,910 --> 01:41:53,670
Temp is still just a variable that's ready for some value.
Temp仍然只是一个准备接受值的变量。

2128
01:41:53,670 --> 01:41:58,660
But the a and the b, and the b need to be rewritten as follows.
但a和b需要按照如下方式重写。

2129
01:41:58,660 --> 01:42:03,720
So star a means go to the address a, and get its value,
所以星号a表示，去到地址a，获取其值，

2130
01:42:03,720 --> 01:42:06,570
and put it in temp, just like you reached for one of the glasses
并将其放入temp，就像你伸手去拿其中一个杯子

2131
01:42:06,570 --> 01:42:07,500
and poured it in.
并将其倒入。

2132
01:42:07,500 --> 01:42:11,400
Star b means, go to the value in b and grab it.
星号b表示，去到b中的值，并获取它。

2133
01:42:11,400 --> 01:42:16,710
And then go to the value at a and change it to be that at b.
然后去到a中的值，并将其修改为b中的值。

2134
01:42:16,710 --> 01:42:19,500
And then lastly, this is not now sweat.
最后，这不再是汗水。

2135
01:42:19,500 --> 01:42:21,240
This is now colored liquid.
现在是彩色的液体。

2136
01:42:21,240 --> 01:42:28,750
This last line is go to the address b, and put temp there instead.
最后一行表示，去到地址b，并将temp放到那里。

2137
01:42:28,750 --> 01:42:31,080
So the picture now is fundamentally different.
所以，现在的画面从根本上不同了。

2138
01:42:31,080 --> 01:42:32,430
Main looks the same still.
Main看起来仍然相同。

2139
01:42:32,430 --> 01:42:36,990
But when swap is called, effectively, and we won't bother with OX123 or 456.
但当swap被调用时，实际上，我们不会理会OX123或456。

2140
01:42:36,990 --> 01:42:39,540
Let's just do it with arrows pointing at things.
让我们用指向事物的箭头来做。

2141
01:42:39,540 --> 01:42:43,710
a is a pointer to x, b is a pointer to y.
a是指向x的指针，b是指向y的指针。

2142
01:42:43,710 --> 01:42:46,200
So what do those lines of code tell us to do?
那么，这些代码行告诉我们做什么？

2143
01:42:46,200 --> 01:42:46,972
Go to a.
去到a。

2144
01:42:46,972 --> 01:42:49,680
So that means this, kind of like the old chutes and ladders game,
这意味着，就像老式的滑梯和梯子游戏一样，

2145
01:42:49,680 --> 01:42:50,580
if you ever played.
如果你玩过的话。

2146
01:42:50,580 --> 01:42:54,900
Follow the arrow, and that leads you to the number one, and store it in temp.
沿着箭头走，它会带你到数字1，并将它存储在temp中。

2147
01:42:54,900 --> 01:42:56,970
So that one was straightforward.
所以，那个很简单。

2148
01:42:56,970 --> 01:42:58,500
Go to the value in b.
去到b中的值。

2149
01:42:58,500 --> 01:43:00,000
So follow the arrow.
所以，沿着箭头走。

2150
01:43:00,000 --> 01:43:02,970
That gives us two, and put it at the location
这给了我们2，并将它放在位置

2151
01:43:02,970 --> 01:43:05,880
in a, which means put the two there.
在a中，这意味着将2放到那里。

2152
01:43:05,880 --> 01:43:09,270
The very last line of code now means get temp, which is obviously there,
最后一行代码现在表示，获取temp，它显然在那里，

2153
01:43:09,270 --> 01:43:14,100
and go to the address b, and change it to one.
并去到地址b，将其修改为1。

2154
01:43:14,100 --> 01:43:17,640
So now, even though we've not changed a and b at all, per se,
所以现在，尽管我们并没有改变a和b本身，

2155
01:43:17,640 --> 01:43:20,100
we've used them as little breadcrumbs to lead us
我们使用它们作为面包屑来引导我们

2156
01:43:20,100 --> 01:43:22,180
to the right location in the computer's memory.
到计算机内存中的正确位置。

2157
01:43:22,180 --> 01:43:25,800
So when swap returns this time, even though it's a void function,
所以，当swap这次返回时，即使它是一个void函数，

2158
01:43:25,800 --> 01:43:27,630
it has made a difference.
它已经产生了影响。

2159
01:43:27,630 --> 01:43:32,910
And it's had this effect of swapping the actual original values of x and y.
而且它已经产生了交换x和y的原始值的效果。

2160
01:43:32,910 --> 01:43:35,160
The code, admittedly, is cryptic looking.
诚然，代码看起来很神秘。

2161
01:43:35,160 --> 01:43:38,220
It's not the most user friendly syntax, but this ability
它不是最友好的语法，但这种能力

2162
01:43:38,220 --> 01:43:41,490
now to go to locations in memory and change
现在可以去到内存中的位置并改变

2163
01:43:41,490 --> 01:43:44,220
what is actually there is what we've been given today
实际存在的东西，是我们今天得到的。

2164
01:43:44,220 --> 01:43:48,100
with this new syntax of the star operator, and occasionally as needed,
使用星号运算符的新语法，以及在必要时偶尔使用

2165
01:43:48,100 --> 01:43:51,520
the ampersand one, as well.
符号运算符。

2166
01:43:51,520 --> 01:43:55,590
Questions on this technique, which is, admittedly, the most sophisticated
对这种技术有什么问题吗？它确实是最复杂的

2167
01:43:55,590 --> 01:43:58,990
of the examples thus far, and we'll probably take time to get used to.
示例，我们可能需要花点时间来适应。

2168
01:43:58,990 --> 01:43:59,490
Yeah.
是的。

2169
01:44:02,805 --> 01:44:03,430
Say that again.
再说一遍。

2170
01:44:03,430 --> 01:44:04,252
Will this work if--
如果这样做可以吗？

2171
01:44:04,252 --> 01:44:06,460
AUDIENCE: Will this work if you're swapping the value
观众：如果交换两个字符串的值

2172
01:44:06,460 --> 01:44:07,755
of two strings instead of ints?
而不是两个整数，这样做可以吗？

2173
01:44:07,755 --> 01:44:08,590
SPEAKER 1: Ah, good question.
演讲者 1：啊，问得好。

2174
01:44:08,590 --> 01:44:10,423
Will this work if you're swapping the values
如果交换两个字符串的值

2175
01:44:10,423 --> 01:44:12,400
of two strings instead of two ints?
而不是两个整数，这样做可以吗？

2176
01:44:12,400 --> 01:44:18,610
Yes, if you go to the address that the string represents and change maybe
可以，如果你去字符串代表的地址，并且可能使用

2177
01:44:18,610 --> 01:44:21,350
with a loop all of the characters one at a time.
循环一个一个地更改所有字符。

2178
01:44:21,350 --> 01:44:24,335
So it's going to be more complicated than this in green because you're
所以它会比绿色部分更复杂，因为你需要

2179
01:44:24,335 --> 01:44:26,710
going to have to change all of the individual characters,
更改所有单个字符，

2180
01:44:26,710 --> 01:44:31,240
probably reusing a temporary char, instead of a temporary integer.
可能需要重用一个临时字符，而不是一个临时整数。

2181
01:44:31,240 --> 01:44:31,850
But you could.
但是可以这样做。

2182
01:44:31,850 --> 01:44:32,350
Yeah.
是的。

2183
01:44:32,350 --> 01:44:38,218
AUDIENCE: [INAUDIBLE]
观众： [听不清]

2184
01:44:38,218 --> 01:44:40,510
SPEAKER 1: Since integers have a fixed number of bits,
演讲者 1：由于整数具有固定数量的位，

2185
01:44:40,510 --> 01:44:43,093
can you ever run into a situation where you run out of memory?
你是否会遇到内存不足的情况？

2186
01:44:43,093 --> 01:44:43,900
Absolutely.
当然。

2187
01:44:43,900 --> 01:44:46,480
Your phone, your laptop, your desktop can only do so much,
你的手机、你的笔记本电脑、你的台式机只能做这么多，

2188
01:44:46,480 --> 01:44:49,300
can only count so high because of these physical limitations.
因为这些物理限制，只能计算到这么高的数字。

2189
01:44:49,300 --> 01:44:51,390
And hopefully, it's just never reach that limit.
希望它永远不会达到这个限制。

2190
01:44:51,390 --> 01:44:54,640
But we'll talk in a couple of weeks time when we transition to web programming
但我们将在几周后，当我们过渡到网页编程时

2191
01:44:54,640 --> 01:44:57,220
and databases, and the Metas, the Microsofts,
和数据库，以及 Meta、微软，

2192
01:44:57,220 --> 01:45:00,250
the Googles of the world that have crazy large amounts of data.
谷歌等拥有大量数据的公司。

2193
01:45:00,250 --> 01:45:02,163
The number of bits we use in those contexts
我们在这些情况下使用的位数

2194
01:45:02,163 --> 01:45:04,330
is actually going to matter for exactly that reason.
实际上会因为这个原因而变得重要。

2195
01:45:04,330 --> 01:45:05,590
If business is booming, and if you've got
如果生意兴隆，如果你有

2196
01:45:05,590 --> 01:45:07,690
lots and lots of data, lots and lots of users,
大量数据，大量用户，

2197
01:45:07,690 --> 01:45:09,760
you need to be able to count higher.
你需要能够计算更高的数字。

2198
01:45:09,760 --> 01:45:12,760
Just so that you've seen the code actually in operation,
为了让你看到代码的实际运行，

2199
01:45:12,760 --> 01:45:15,380
here is, of course, my swap function down below.
当然，我的交换函数就在下面。

2200
01:45:15,380 --> 01:45:17,350
And if I go ahead and change its prototype
如果我继续更改它的原型

2201
01:45:17,350 --> 01:45:21,950
to take in pointers to a and b, and similarly change the prototype up here.
使它接收指向 a 和 b 的指针，并且类似地更改上面的原型。

2202
01:45:21,950 --> 01:45:26,320
And if I go in and change a here to be star a to dereference it, star
如果我进入并更改这里的 a 使其成为星号 a 以取消引用它，星号

2203
01:45:26,320 --> 01:45:28,600
b to dereference it, star a to dereference it,
b 以取消引用它，星号 a 以取消引用它，

2204
01:45:28,600 --> 01:45:32,200
and star b to dereference it, I claim now that this version of the code
和星号 b 以取消引用它，我现在声称这个版本的代码

2205
01:45:32,200 --> 01:45:33,110
should now work.
现在应该可以工作了。

2206
01:45:33,110 --> 01:45:36,130
In fact, let me go ahead and do make swap.
实际上，让我继续做 make swap。

2207
01:45:36,130 --> 01:45:37,620
It didn't compile.
它没有编译。

2208
01:45:37,620 --> 01:45:38,520
So why might that be?
所以为什么会出现这种情况？

2209
01:45:38,520 --> 01:45:40,603
Well, let me scroll up to see what the message is.
好吧，让我向上滚动查看消息。

2210
01:45:40,603 --> 01:45:42,590
Incompatible integer to pointer conversion
整数到指针转换不兼容

2211
01:45:42,590 --> 01:45:45,230
passing in parameter of type int star.
传入类型为 int star 的参数。

2212
01:45:45,230 --> 01:45:46,580
That's a lot to absorb.
信息量很大。

2213
01:45:46,580 --> 01:45:49,670
But clearly, the issue is with how I'm calling swap.
但很明显，问题在于我调用 swap 的方式。

2214
01:45:49,670 --> 01:45:50,940
So why is this?
为什么呢？

2215
01:45:50,940 --> 01:45:55,640
Well, notice that now that my swap function expects as arguments pointers
好的，请注意，现在我的 swap 函数期望传入指针作为参数

2216
01:45:55,640 --> 01:46:00,140
to integers, I can't just blindly pass in x and y, which are integers.
给整数，我不能直接传入 x 和 y，它们都是整数。

2217
01:46:00,140 --> 01:46:04,100
Instead, I do need to use our friend, the new ampersand operator to pass
相反，我需要使用我们的老朋友取地址运算符来传入

2218
01:46:04,100 --> 01:46:06,410
in the address of x and the address of y.
x 和 y 的地址。

2219
01:46:06,410 --> 01:46:12,140
So now, if I reopen my terminal window, run make swap, and do dot slash swap,
所以现在，如果我重新打开我的终端窗口，运行 make swap，并执行点斜杠 swap，

2220
01:46:12,140 --> 01:46:15,290
now I see one, two, and then two, one.
现在我看到了 1，2，然后 2，1。

2221
01:46:15,290 --> 01:46:16,640
So the code changes in this way.
所以代码就这样改变了。

2222
01:46:16,640 --> 01:46:18,530
And maybe this example more so than others
也许这个例子比其他例子更能说明

2223
01:46:18,530 --> 01:46:21,950
makes clear why the star operator lets us go somewhere,
清楚地说明为什么星号运算符能让我们去某个地方，

2224
01:46:21,950 --> 01:46:24,980
but the ampersand effectively does the opposite and figures out
而取地址运算符实际上做了相反的事情，它计算出

2225
01:46:24,980 --> 01:46:27,390
what the address of something now is.
某个东西的地址是什么。

2226
01:46:27,390 --> 01:46:27,890
All right.
好的。

2227
01:46:27,890 --> 01:46:30,720
So what about these other locations in memory?
那么，内存中的其他位置呢？

2228
01:46:30,720 --> 01:46:34,700
Well, it turns out that, indeed, the stack, as we've described it,
事实证明，确实，正如我们所描述的那样，栈

2229
01:46:34,700 --> 01:46:35,750
grows up, and up, and up.
向上增长，向上增长，向上增长。

2230
01:46:35,750 --> 01:46:37,700
And recall that stack here in this sense is
回想一下，这里栈的概念

2231
01:46:37,700 --> 01:46:41,300
kind of like the stack of trays and the cafeteria or any of the dining halls.
就像自助餐厅或任何餐厅里的托盘堆一样。

2232
01:46:41,300 --> 01:46:43,820
There's one tray, another tray, another tray, another tray.
一个托盘，另一个托盘，另一个托盘，另一个托盘。

2233
01:46:43,820 --> 01:46:45,955
But then you start removing them from top down.
但随后，你开始从上往下移除它们。

2234
01:46:45,955 --> 01:46:48,830
So there's an ordering to them that we'll actually revisit next week.
因此它们是有序的，我们下周会重新讨论这一点。

2235
01:46:48,830 --> 01:46:51,230
But this is not a good design, in general.
但总的来说，这不是一个好的设计。

2236
01:46:51,230 --> 01:46:55,040
You shouldn't be doing things like two trains on the tracks barreling together
你不应该做像两列火车在轨道上迎面冲撞那样的事情

2237
01:46:55,040 --> 01:46:56,435
toward each other in this way.
相互迎面冲撞。

2238
01:46:56,435 --> 01:46:59,060
But honestly, it's kind of the only way, because if you've only
但说实话，这几乎是唯一的方法，因为如果你只有

2239
01:46:59,060 --> 01:47:01,310
got a finite amount of memory, OK, sure, you
有限的内存，好的，当然，你可以

2240
01:47:01,310 --> 01:47:02,750
can have them both grow in the same direction.
让它们都朝同一个方向增长。

2241
01:47:02,750 --> 01:47:04,940
But they're still going to hit some impasse eventually.
但最终它们仍然会遇到僵局。

2242
01:47:04,940 --> 01:47:06,565
You're still going to run out of space.
你仍然会耗尽空间。

2243
01:47:06,565 --> 01:47:10,590
So the way computers were designed years ago is they use memory in this way,
所以几年前计算机的设计方式就是用这种方式使用内存，

2244
01:47:10,590 --> 01:47:14,270
even though bad things can happen, if you use too much stack space,
即使会发生不好的事情，如果你使用了太多的栈空间，

2245
01:47:14,270 --> 01:47:15,510
or too much heap space.
或太多的堆空间。

2246
01:47:15,510 --> 01:47:16,740
So what do I mean by that?
那么我的意思是什么呢？

2247
01:47:16,740 --> 01:47:20,210
Our example a moment ago just had us call main and then swap
我们刚才的例子只是让我们调用 main 然后调用 swap

2248
01:47:20,210 --> 01:47:21,000
and that was it.
就这样。

2249
01:47:21,000 --> 01:47:22,950
So it's like two frames no big deal.
所以就像两帧，没什么大不了。

2250
01:47:22,950 --> 01:47:24,980
But if you call many functions again, and again,
但如果你一遍又一遍地调用很多函数，

2251
01:47:24,980 --> 01:47:27,980
and again, if you do something recursively, where you call yourself,
一遍又一遍地，如果你做了递归操作，你调用了自己，

2252
01:47:27,980 --> 01:47:31,070
you're going to pile, pile, pile stack frames potentially.
你可能会堆叠很多栈帧。

2253
01:47:31,070 --> 01:47:33,750
So you could start to hit the so-called heap area.
所以你可能开始触及所谓的堆区域。

2254
01:47:33,750 --> 01:47:36,427
Meanwhile, if you call malloc too many times,
与此同时，如果你多次调用 malloc，

2255
01:47:36,427 --> 01:47:38,510
you might be growing down, down, down, down, down,
你可能会向下增长，向下增长，向下增长，向下增长，向下增长，

2256
01:47:38,510 --> 01:47:41,400
and then overrun some of the stack memory, as well.
然后也可能会覆盖一些栈内存。

2257
01:47:41,400 --> 01:47:44,270
So bad things can happen when you overrun either of these.
所以当你覆盖其中任何一个的时候，都会发生不好的事情。

2258
01:47:44,270 --> 01:47:46,670
And those of you maybe with prior programming experience
也许你们中有一些人有之前的编程经验

2259
01:47:46,670 --> 01:47:50,180
might have heard at least one of these terms, heap overflow, or more
可能听说过至少一个术语，堆溢出，或者更多

2260
01:47:50,180 --> 01:47:51,890
popularly, stack overflow.
最受欢迎的是堆栈溢出。

2261
01:47:51,890 --> 01:47:55,100
Super popular website for questions and answers about programming.
一个超级受欢迎的网站，专门用来回答有关编程的问题。

2262
01:47:55,100 --> 01:47:59,990
The etymology thereof is exactly this idea of overflowing the stack
这个词的词源正是这个概念，即堆栈溢出

2263
01:47:59,990 --> 01:48:03,290
and touching memory that you should not, whether it's
并访问了你不应该访问的内存，无论是

2264
01:48:03,290 --> 01:48:06,200
memory down here, or even worse, memory over here,
下面的内存，或者更糟的是，这边的内存，

2265
01:48:06,200 --> 01:48:08,390
as by something called heap overflow.
就像由一种叫做堆溢出的东西所导致的。

2266
01:48:08,390 --> 01:48:12,530
And these are specific examples of what we'll start calling buffer overflows.
这些是我们将开始称为缓冲区溢出的特定例子。

2267
01:48:12,530 --> 01:48:14,540
Buffer is just a chunk of memory.
缓冲区只是一块内存。

2268
01:48:14,540 --> 01:48:18,860
And buffer overflows means overflowing, using too much of that memory.
缓冲区溢出意味着溢出，使用过多的内存。

2269
01:48:18,860 --> 01:48:20,190
And buffers are everywhere.
缓冲区无处不在。

2270
01:48:20,190 --> 01:48:22,130
In fact, if you've used YouTube recently,
事实上，如果你最近使用过 YouTube，

2271
01:48:22,130 --> 01:48:25,460
and maybe it's just kind of paused and spinning, and spinning, and spinning,
也许它只是暂停了，并且在旋转，旋转，旋转，

2272
01:48:25,460 --> 01:48:27,320
maybe you're on a really bad connection.
也许你的网络连接很糟糕。

2273
01:48:27,320 --> 01:48:29,690
There's no more bytes in your buffer.
你的缓冲区中没有更多字节了。

2274
01:48:29,690 --> 01:48:31,850
There's no more video footage in the buffer
缓冲区中没有更多视频片段了

2275
01:48:31,850 --> 01:48:33,890
because maybe you have such a bad connection.
因为也许你的网络连接很糟糕。

2276
01:48:33,890 --> 01:48:36,650
But if Google were to make mistakes and try
但如果谷歌犯了错误，并且试图

2277
01:48:36,650 --> 01:48:40,230
to download too many bytes at a time, they too could overflow a buffer.
一次下载太多字节，他们也会导致缓冲区溢出。

2278
01:48:40,230 --> 01:48:42,470
And if YouTube or similar apps have ever crashed,
如果 YouTube 或类似的应用程序曾经崩溃过，

2279
01:48:42,470 --> 01:48:47,090
it could be because they're trying to use more memory than they actually
这可能是因为它们试图使用比实际需要的更多的内存

2280
01:48:47,090 --> 01:48:47,610
should be.
应该使用的内存。

2281
01:48:47,610 --> 01:48:49,490
So these things are sort of everywhere.
所以这些事情无处不在。

2282
01:48:49,490 --> 01:48:53,270
Now, as for these training wheels, we sort of took away
现在，对于这些辅助轮，我们已经把

2283
01:48:53,270 --> 01:48:54,980
the mystery of what a string is.
字符串是什么的神秘面纱揭开了。

2284
01:48:54,980 --> 01:48:57,230
But what about all of these other functions we've been
但是，我们一直在使用的所有其他函数呢？

2285
01:48:57,230 --> 01:48:59,300
taking for granted now for a few weeks?
我们已经使用了几周了？

2286
01:48:59,300 --> 01:49:03,680
You can and should still use them to solve some problems because, frankly, C
你仍然可以并且应该使用它们来解决一些问题，因为坦白地说，C

2287
01:49:03,680 --> 01:49:09,350
does not make it easy to get user input safely, like, period, full stop.
并不容易安全地获取用户输入，就像，句号，句号。

2288
01:49:09,350 --> 01:49:13,640
It is very non-trivial to get user input without running
在不冒缓冲区溢出的风险的情况下获取用户输入非常不容易。

2289
01:49:13,640 --> 01:49:16,100
the risk of overflowing a buffer.
缓冲区溢出的风险。

2290
01:49:16,100 --> 01:49:16,610
Why?
为什么？

2291
01:49:16,610 --> 01:49:17,870
Well, you're the programmer.
嗯，你是程序员。

2292
01:49:17,870 --> 01:49:21,020
How do you possibly know in advance how big of a string
你怎么可能提前知道人类明天、下周或下天可能输入的字符串有多长？

2293
01:49:21,020 --> 01:49:24,170
a human might type in tomorrow, or the next week, or the next day?
有多长？

2294
01:49:24,170 --> 01:49:27,450
You could try to be safe and allocate a million bytes all at once.
你可以尝试安全地一次性分配一百万字节。

2295
01:49:27,450 --> 01:49:29,630
But what if they type in 1,000,001 characters,
但如果他们输入了 1,000,001 个字符，

2296
01:49:29,630 --> 01:49:32,870
or use copy paste so much that they similarly overflow?
或者使用复制粘贴太多以至于它们也溢出？

2297
01:49:32,870 --> 01:49:36,030
So getting user input is a hard problem.
所以获取用户输入是一个难题。

2298
01:49:36,030 --> 01:49:38,370
So let's introduce you to what the alternative would be
所以让我们来介绍一下替代方案是什么

2299
01:49:38,370 --> 01:49:43,050
and given an appreciation for what libraries like CS50's and others
并感谢像 CS50 这样的库和其他库

2300
01:49:43,050 --> 01:49:45,880
like it are actually doing for you.
像这样的库实际上为你做了什么。

2301
01:49:45,880 --> 01:49:49,680
Let me go ahead and create our own version of getint and getstring
让我继续创建我们自己的 getint 和 getstring 版本

2302
01:49:49,680 --> 01:49:52,770
without using the CS50 library, but using a standard C
不使用 CS50 库，而是使用标准的 C

2303
01:49:52,770 --> 01:49:54,360
function called scanf.
函数 scanf。

2304
01:49:54,360 --> 01:49:56,430
And to do that, let me go over to VS Code.
为了做到这一点，让我去 VS Code。

2305
01:49:56,430 --> 01:49:59,610
Let me create a new file called, for instance, get.c.
让我创建一个新的文件，比如 get.c。

2306
01:49:59,610 --> 01:50:02,220
And then in get.c, let's make a very simple program
然后在 get.c 中，让我们编写一个非常简单的程序。

2307
01:50:02,220 --> 01:50:06,600
first that just gets an integer, but again, without using the CS50 library.
首先，这将得到一个整数，但是再次说明，不使用CS50库。

2308
01:50:06,600 --> 01:50:09,780
So let me go ahead and include the standard io library.
所以让我继续包含标准io库。

2309
01:50:09,780 --> 01:50:13,140
Let me go ahead and declare main as int main void.
让我继续声明main为int main void。

2310
01:50:13,140 --> 01:50:17,017
And then inside of main, let me go ahead and declare an integer n
然后在main内部，让我继续声明一个整数n

2311
01:50:17,017 --> 01:50:19,350
so that we have some place to put the integer that we're
这样我们就可以把我们获取的整数放到某个地方。

2312
01:50:19,350 --> 01:50:20,490
getting from the user.
从用户那里获取。

2313
01:50:20,490 --> 01:50:23,040
Then let me go ahead and just prompt the user
然后让我继续提示用户

2314
01:50:23,040 --> 01:50:26,940
for a value for n, so n colon space, for instance.
输入n的值，例如，n冒号空格。

2315
01:50:26,940 --> 01:50:29,220
Because again, I'm not using getint, so I can't just
因为再次说明，我没有使用getint，所以我不能仅仅

2316
01:50:29,220 --> 01:50:31,300
call it to present the user with a prompt.
调用它来向用户展示一个提示。

2317
01:50:31,300 --> 01:50:33,550
So I'm going to use printf to create my own prompt.
所以我将使用printf来创建我自己的提示。

2318
01:50:33,550 --> 01:50:36,370
And now, let me use this function scanf as follows.
现在，让我使用这个函数scanf，如下所示。

2319
01:50:36,370 --> 01:50:39,880
I'm going to call scanf, and then I'm going to pass to scanf,
我将调用scanf，然后我将传递给scanf，

2320
01:50:39,880 --> 01:50:45,460
similar in spirit to printf, a format code, like %i,
类似于printf，一个格式代码，比如%i，

2321
01:50:45,460 --> 01:50:49,340
effectively telling scanf that what I want it to scan, so to speak,
实际上告诉scanf，我想要它扫描的东西，可以这么说，

2322
01:50:49,340 --> 01:50:52,715
from the user's keyboard is in fact a single integer.
来自用户的键盘实际上是一个单一的整数。

2323
01:50:52,715 --> 01:50:55,840
Now, I'm going to close quotes, and I don't need a new line because I'm not
现在，我将关闭引号，我不需要换行，因为我没有

2324
01:50:55,840 --> 01:50:56,882
trying to print anything.
试图打印任何东西。

2325
01:50:56,882 --> 01:50:59,530
I'm trying to get something from the user using scanf.
我试图使用scanf从用户那里获取一些东西。

2326
01:50:59,530 --> 01:51:03,680
But I do need to tell scanf where to put this integer.
但我确实需要告诉scanf把这个整数放在哪里。

2327
01:51:03,680 --> 01:51:06,040
Now, if I want to put this integer in the variable n,
现在，如果我想把这个整数放在变量n中，

2328
01:51:06,040 --> 01:51:08,470
it's not quite as simple as just passing n
它并不像直接传递n那样简单

2329
01:51:08,470 --> 01:51:11,080
in because recall how variables are passed.
因为回想一下变量是如何传递的。

2330
01:51:11,080 --> 01:51:13,690
This variable n is going to be passed by value.
这个变量n将通过值传递。

2331
01:51:13,690 --> 01:51:16,510
Effectively, a copy is going to go into scanf,
实际上，一个副本将进入scanf，

2332
01:51:16,510 --> 01:51:19,910
and so scanf is not going to have the ability to change that value.
因此，scanf将无法改变该值。

2333
01:51:19,910 --> 01:51:22,660
But if you think back to how we swapped two values
但是如果你回想一下我们是如何交换两个值的

2334
01:51:22,660 --> 01:51:27,550
and passed two values into that swap function in C,
并将两个值传递给C中的那个交换函数，

2335
01:51:27,550 --> 01:51:31,360
well, if we pass those two values in by their addresses,
那么，如果我们通过它们的地址传递这两个值，

2336
01:51:31,360 --> 01:51:34,690
so passing by reference, so to speak, then the function,
所以通过引用传递，可以这么说，然后这个函数，

2337
01:51:34,690 --> 01:51:39,130
swap in that case, scanf in this case, can actually go to that address
在本例中是交换，在本例中是scanf，实际上可以进入该地址

2338
01:51:39,130 --> 01:51:40,400
and change the value.
并改变值。

2339
01:51:40,400 --> 01:51:43,840
So to summarize, I'm going to pass the scanf one argument, which is a format
总之，我将传递给scanf一个参数，它是一个格式

2340
01:51:43,840 --> 01:51:47,830
code, and a second argument, which is the address of an integer into which
代码，第二个参数是整数的地址，我们将把

2341
01:51:47,830 --> 01:51:49,165
to put the user's value.
用户的值放入其中。

2342
01:51:49,165 --> 01:51:52,040
After that, I'm just going to go ahead and print out what's happened.
之后，我将继续打印出发生的事情。

2343
01:51:52,040 --> 01:51:55,490
So I'm going to go ahead and print out the value of n followed by a colon,
所以，我将继续打印出n的值，后面跟着一个冒号，

2344
01:51:55,490 --> 01:51:58,450
followed by an actual placeholder, %i backslash n.
后面跟着一个占位符，%i反斜杠n。

2345
01:51:58,450 --> 01:52:01,390
And I'm going to pass in now to printf the value n.
现在，我将传递给printf值n。

2346
01:52:01,390 --> 01:52:04,300
So to be clear, I'm still passing n into printf, just like we've
所以，明确地说，我仍然将n传递给printf，就像我们已经

2347
01:52:04,300 --> 01:52:08,650
been doing since week one, but I'm passing to scanf the address of n,
从第一周开始一直在做的那样，但我正在传递给scanf n的地址，

2348
01:52:08,650 --> 01:52:12,510
so that scanf can actually go to that address and change the value of n.
这样，scanf就可以实际进入该地址，并改变n的值。

2349
01:52:12,510 --> 01:52:14,260
So I think this is actually going to work,
所以，我认为这实际上会起作用，

2350
01:52:14,260 --> 01:52:17,710
even though I've not used getint or any of the CS50 library.
尽管我没有使用getint或任何CS50库。

2351
01:52:17,710 --> 01:52:20,860
Let me go into my terminal, run make get.
让我进入我的终端，运行 make get。

2352
01:52:20,860 --> 01:52:22,090
Seems to compile OK.
看起来编译正常。

2353
01:52:22,090 --> 01:52:26,470
Let me do dot shalsh get, and let me type in a value like 50 for n.
让我运行 dot shalsh get，并在其中输入一个像 50 这样的值给 n。

2354
01:52:26,470 --> 01:52:30,920
And indeed, I should see spit back at me that the value I got was 50.
实际上，我应该看到它反馈给我，我获得的值是 50。

2355
01:52:30,920 --> 01:52:33,730
So it turns out that getting an integer from users
因此，从用户那里获取一个整数

2356
01:52:33,730 --> 01:52:37,210
is relatively straightforward just using scanf.
使用 scanf 相对来说比较直接。

2357
01:52:37,210 --> 01:52:40,690
But of course, to use scanf, you need to know a little something about pointers
当然，要使用 scanf，你需要了解一点关于指针的知识

2358
01:52:40,690 --> 01:52:42,220
or addresses, more generally.
或者更一般地来说，地址。

2359
01:52:42,220 --> 01:52:43,970
That was not knowledge we had in week one.
这在第一周我们还没有学过。

2360
01:52:43,970 --> 01:52:45,928
And so we do, indeed, use those training wheels
所以我们确实使用了这些辅助工具

2361
01:52:45,928 --> 01:52:48,440
of the CS50 library for the past few weeks
在过去几周的 CS50 库中

2362
01:52:48,440 --> 01:52:50,350
so that we can get integers more easily.
这样我们就可以更容易地获取整数。

2363
01:52:50,350 --> 01:52:55,210
And it turns out, if the user types more than a simple integer,
事实证明，如果用户输入的不仅仅是一个简单的整数，

2364
01:52:55,210 --> 01:52:59,080
or doesn't even type in an integer, scanf isn't necessarily
或者甚至没有输入一个整数，scanf 不一定

2365
01:52:59,080 --> 01:53:02,560
going to behave as user friendly as getint might.
会像 getint 一样友好地工作。

2366
01:53:02,560 --> 01:53:06,642
So in the CS50 library, we do a bit more error handling for you, as well.
所以，在 CS50 库中，我们也会为你做更多的错误处理。

2367
01:53:06,642 --> 01:53:08,350
But let's consider now an implementation,
但现在让我们考虑一个实现，

2368
01:53:08,350 --> 01:53:11,170
not of getting an integer, but getting a string instead.
不是获取一个整数，而是获取一个字符串。

2369
01:53:11,170 --> 01:53:15,220
Let me clear my terminal window, and let me go ahead and erase all of this code,
让我清除我的终端窗口，然后让我继续删除所有这些代码，

2370
01:53:15,220 --> 01:53:17,740
and instead focus this time on getting a string.
这次改为关注获取一个字符串。

2371
01:53:17,740 --> 01:53:21,250
Well, we know we can't use string anymore, at least if we're not
好吧，我们知道我们不能再使用 string 了，至少如果我们没有

2372
01:53:21,250 --> 01:53:22,420
using the CS50 library.
使用 CS50 库。

2373
01:53:22,420 --> 01:53:25,880
But not a problem because we know that strings are now char stars.
但这不是问题，因为我们知道字符串现在是 char 星号。

2374
01:53:25,880 --> 01:53:28,600
So if I want to get a string from the user, that's like getting,
所以，如果我想从用户那里获取一个字符串，那就像获取，

2375
01:53:28,600 --> 01:53:29,860
I think, a char star.
我认为，一个 char 星号。

2376
01:53:29,860 --> 01:53:32,680
So let me just call this string s by default.
所以让我默认地称这个字符串为 s。

2377
01:53:32,680 --> 01:53:36,010
Let me go ahead therefore and declare a variable s that's
因此，让我继续声明一个变量 s，它

2378
01:53:36,010 --> 01:53:37,190
going to store my string.
将存储我的字符串。

2379
01:53:37,190 --> 01:53:40,000
Let me go ahead next, as before, and prompt the user
接下来，像之前一样，让我继续提示用户

2380
01:53:40,000 --> 01:53:43,330
for the value of that variable, just by prompting them with printf.
输入该变量的值，只需用 printf 提示他们即可。

2381
01:53:43,330 --> 01:53:44,620
So nothing fancy there.
所以这里没有什么花哨的东西。

2382
01:53:44,620 --> 01:53:47,650
And let me try again using scanf to scan this time
让我再试一次，这次使用 scanf 来扫描

2383
01:53:47,650 --> 01:53:49,630
a string from the user's keyboard.
用户键盘上的一个字符串。

2384
01:53:49,630 --> 01:53:51,160
I'm going to type scanf.
我要输入 scanf。

2385
01:53:51,160 --> 01:53:54,490
I'm going to do %s instead of %i because I, indeed,
我要使用 %s 而不是 %i，因为我实际上

2386
01:53:54,490 --> 01:53:56,900
want to scan a string in this case.
想要扫描一个字符串。

2387
01:53:56,900 --> 01:53:59,230
And then I'm going to go ahead and pass in just s.
然后我将继续传入 s。

2388
01:53:59,230 --> 01:54:02,680
And here, at first glance, seems to be an inconsistency because,
这里，乍一看，似乎存在一个不一致，因为

2389
01:54:02,680 --> 01:54:05,230
previously, I did ampersand n.
之前，我使用了取地址符 n。

2390
01:54:05,230 --> 01:54:09,820
But that's because n was an integer, not the address thereof.
但那是因为 n 是一个整数，而不是它的地址。

2391
01:54:09,820 --> 01:54:12,260
But in the world of strings as we now know,
但在我们现在了解的字符串世界中，

2392
01:54:12,260 --> 01:54:14,590
a string is just the address of its first byte.
字符串只是它第一个字节的地址。

2393
01:54:14,590 --> 01:54:18,250
And so if we declare s to be a char star, a.k.a.
所以，如果我们声明 s 为一个 char 星号，也就是

2394
01:54:18,250 --> 01:54:21,190
string, well, s is already in address.
字符串，那么 s 已经在地址中了。

2395
01:54:21,190 --> 01:54:24,070
So I can just pass in s in this case to scanf
所以，在这种情况下，我可以直接将 s 传递给 scanf

2396
01:54:24,070 --> 01:54:26,380
without actually using an ampersand.
而不需要使用取地址符。

2397
01:54:26,380 --> 01:54:29,800
After that, let's go ahead and print out the result. So let's just use printf.
之后，让我们继续打印结果。所以让我们直接使用 printf。

2398
01:54:29,800 --> 01:54:33,970
Let's print out a prefix, like s colon again, %s as my placeholder,
让我们打印一个前缀，比如再次使用 s 冒号，%s 作为我的占位符，

2399
01:54:33,970 --> 01:54:37,130
and now backslash n because I'm formatting it on the screen.
现在使用反斜杠 n，因为我在屏幕上进行格式化。

2400
01:54:37,130 --> 01:54:41,480
And then let's go ahead and pass in s as always to printf.
然后让我们继续像往常一样将 s 传递给 printf。

2401
01:54:41,480 --> 01:54:44,660
So s is just a string, so I just pass it into printf like that.
所以 s 只是一个字符串，所以我像这样直接将它传递给 printf。

2402
01:54:44,660 --> 01:54:49,220
Well, let me go ahead now, and I'm going to go ahead and compile
好了，我现在就来，我将继续编译

2403
01:54:49,220 --> 01:54:52,158
this an old fashioned way because we actually protect you
这种老式的方式，因为我们实际上保护你

2404
01:54:52,158 --> 01:54:53,450
from doing something like this.
免受此类操作的困扰。

2405
01:54:53,450 --> 01:54:56,390
But I'm going to go ahead and ignore the warnings you would otherwise
但我会忽略你本来会看到的警告

2406
01:54:56,390 --> 01:54:56,900
see us make.
我们所做的警告。

2407
01:54:56,900 --> 01:55:00,020
And I'm going to go ahead and compile this with clang directly.
我会直接使用 clang 编译它。

2408
01:55:00,020 --> 01:55:03,980
So clang-o get, because that's the name of the program I want to output.
所以 clang-o get，因为这是我想要输出的程序的名称。

2409
01:55:03,980 --> 01:55:09,740
But I'm also going to specify dash capital W, no, uninitialized, which
但是我也会指定一个大写 W 的破折号，不，未初始化，它

2410
01:55:09,740 --> 01:55:13,040
is simply another command line argument that's
只是一个命令行参数，

2411
01:55:13,040 --> 01:55:16,603
going to tell clang not to warn us about variables that are not initialized.
会告诉 clang 不要警告我们关于未初始化的变量。

2412
01:55:16,603 --> 01:55:19,520
Because case in point on line five, as some of you might have noticed,
因为第五行的例子，正如你们中的一些人可能已经注意到的，

2413
01:55:19,520 --> 01:55:22,610
I didn't actually initialize s to anything, even null.
我实际上没有将 s 初始化为任何东西，即使是空值。

2414
01:55:22,610 --> 01:55:26,090
But that's OK because I want to forge ahead blindly just to make a point as
但没关系，因为我想盲目地前进，只是为了说明这一点

2415
01:55:26,090 --> 01:55:27,530
to what's going on here.
这里发生了什么。

2416
01:55:27,530 --> 01:55:31,490
And in fact, let's go ahead and compile this code as follows.
事实上，让我们继续用以下方式编译这段代码。

2417
01:55:31,490 --> 01:55:33,530
It does seem to compile, even though make would
它确实似乎可以编译，即使 make 会

2418
01:55:33,530 --> 01:55:35,210
have warned us that something's awry.
警告我们有些不对劲。

2419
01:55:35,210 --> 01:55:39,350
Let me go ahead now and run dot slash get, and this time, not type in 50.
现在让我继续运行点斜杠 get，这次不要输入 50。

2420
01:55:39,350 --> 01:55:41,600
But let me type in something like our familiar "hi"
但我可以输入类似我们熟悉的“hi”

2421
01:55:41,600 --> 01:55:44,930
exclamation point, and hit enter.
感叹号，然后按回车键。

2422
01:55:44,930 --> 01:55:48,110
I immediately get a segmentation fault, which
我立即得到一个段错误，这

2423
01:55:48,110 --> 01:55:50,930
means something has gone wrong related to memory.
意味着内存出现了一些问题。

2424
01:55:50,930 --> 01:55:54,140
A segment of memory has been touched that I shouldn't have.
我碰到了不应该碰的内存段。

2425
01:55:54,140 --> 01:55:55,608
Well, why, in fact, is this?
好吧，这到底是怎么回事？

2426
01:55:55,608 --> 01:55:57,650
Well, let's consider what it is we've been doing.
好吧，让我们看看我们一直在做什么。

2427
01:55:57,650 --> 01:56:00,050
If this here is my computer's memory, and in the first case
如果这是我的电脑内存，在第一种情况下

2428
01:56:00,050 --> 01:56:01,700
I was just trying to get an integer, that
我只想得到一个整数，

2429
01:56:01,700 --> 01:56:04,400
was actually pretty straightforward, because even if this memory is filled
实际上非常简单，因为即使这段内存被填满了

2430
01:56:04,400 --> 01:56:07,130
with a whole bunch of garbage values, as personified here
充满了垃圾值，正如这里拟人化所表现的

2431
01:56:07,130 --> 01:56:11,270
by Oscar the Grouch, when I declared n to be an integer before,
由奥斯卡·葛鲁奇（垃圾桶怪），当我之前声明 n 为一个整数时，

2432
01:56:11,270 --> 01:56:14,210
I just needed, on this machine, four bytes, which
我只需要在这台机器上使用 4 个字节，这

2433
01:56:14,210 --> 01:56:15,570
is the typical size for an int.
是 int 的典型大小。

2434
01:56:15,570 --> 01:56:17,100
And I put the number 50 there.
然后我在那里放了数字 50。

2435
01:56:17,100 --> 01:56:19,517
So it doesn't matter that there were these garbage values.
所以，这些垃圾值并不重要。

2436
01:56:19,517 --> 01:56:22,190
I just went to those four bytes after declaring
在声明一个名为 n 的变量之后，我只访问了那 4 个字节

2437
01:56:22,190 --> 01:56:24,680
a variable called n and overwrote those bits,
并覆盖了那些位，

2438
01:56:24,680 --> 01:56:27,410
with some pattern of bits representing the number 50.
用一些代表数字 50 的位模式。

2439
01:56:27,410 --> 01:56:30,260
But strings we now know are sort of fundamentally different.
但我们现在知道字符串在本质上是不同的。

2440
01:56:30,260 --> 01:56:34,850
If I go back to that same memory space, and I declare s to be a pointer,
如果我回到相同的内存空间，并且我声明 s 为一个指针，

2441
01:56:34,850 --> 01:56:37,970
that is, a char star, well, recall that pointers are generally
也就是说，一个 char 星号，好吧，回忆一下，指针通常

2442
01:56:37,970 --> 01:56:40,100
eight bytes on modern systems.
在现代系统上是 8 个字节。

2443
01:56:40,100 --> 01:56:44,960
And so that's like taking eight of these bytes from memory and calling it s.
所以这就像从内存中取出这八个字节，并将其称为 s。

2444
01:56:44,960 --> 01:56:48,140
But the catch is, if I haven't initialized s to actually
但问题是，如果我没有初始化 s 使其成为一个有效的地址，

2445
01:56:48,140 --> 01:56:52,100
be a valid location, as via calling malloc,
比如通过调用 malloc，

2446
01:56:52,100 --> 01:56:54,088
there are still garbage values there.
那里仍然存在垃圾值。

2447
01:56:54,088 --> 01:56:55,880
That is to say, patterns of bits that maybe
也就是说，可能是之前

2448
01:56:55,880 --> 01:56:58,730
have been there always, but from some previous function that got
一直存在的位模式，但它们来自于某个之前被调用的函数，

2449
01:56:58,730 --> 01:57:01,880
called, or some other lines of code if this program were actually bigger.
或者如果该程序实际上更大，则来自其他代码行。

2450
01:57:01,880 --> 01:57:06,350
So it's just some garbage value is filling that variable s.
所以只是某些垃圾值填充了变量 s。

2451
01:57:06,350 --> 01:57:10,610
The problem, though, is that in my code now, when I call scanf
然而，问题在于，在我的代码中，现在当我调用 scanf 时，

2452
01:57:10,610 --> 01:57:14,855
and I tell scanf to scan a string from the user and to put it at that location
并告诉 scanf 从用户那里扫描一个字符串并将其放在该位置，

2453
01:57:14,855 --> 01:57:16,670
s, well, what is that location s?
s，那么，s 的位置是什么？

2454
01:57:16,670 --> 01:57:18,650
It's literally a garbage value.
它就是一个垃圾值。

2455
01:57:18,650 --> 01:57:21,630
It's the equivalent of a foam finger pointing there, there, there.
这相当于一个泡沫手指指向那里，那里，那里。

2456
01:57:21,630 --> 01:57:25,050
We just don't know because it's not a valid address.
我们只是不知道，因为它不是一个有效的地址。

2457
01:57:25,050 --> 01:57:28,190
And so I get that segmentation fault here in my terminal window
因此，我在终端窗口中得到了这个段错误，

2458
01:57:28,190 --> 01:57:31,490
because I've not initialized s to be some known value.
因为我没有将 s 初始化为某个已知值。

2459
01:57:31,490 --> 01:57:34,070
I get a segmentation fault because, effectively, I've
我得到了一个段错误，因为实际上我

2460
01:57:34,070 --> 01:57:38,690
accidentally touched memory that I should not, in fact, have done so.
意外地触碰了我不应该触碰的内存。

2461
01:57:38,690 --> 01:57:40,740
So how do we fix this?
那么我们如何解决这个问题呢？

2462
01:57:40,740 --> 01:57:43,645
Well clearly, I need s to point at some valid chunk of memory,
很明显，我需要让 s 指向某个有效的内存块，

2463
01:57:43,645 --> 01:57:45,020
and I could do that using malloc.
我可以使用 malloc 来实现。

2464
01:57:45,020 --> 01:57:47,395
But frankly, in this case, I could do it even more simply
但坦白地说，在这种情况下，我可以用更简单的方法来实现，

2465
01:57:47,395 --> 01:57:50,660
by just declaring s to be an array of characters,
只需将 s 声明为一个字符数组，

2466
01:57:50,660 --> 01:57:52,130
as we might have in week two.
就像我们在第二周做的那样。

2467
01:57:52,130 --> 01:57:54,510
So let me go ahead and clear my terminal window here.
所以，让我来清除一下这里的终端窗口。

2468
01:57:54,510 --> 01:57:59,360
Let me go into get.c, and let's simply change what's s is.
让我进入 get.c，让我们简单地更改 s 的内容。

2469
01:57:59,360 --> 01:58:02,720
Instead of a char star, which we know is what a string technically is,
而不是一个 char star，我们知道从技术上讲，字符串就是这个，

2470
01:58:02,720 --> 01:58:05,970
we can still implement strings as arrays of characters.
我们仍然可以将字符串实现为字符数组。

2471
01:58:05,970 --> 01:58:08,880
That's certainly still true.
这当然仍然是正确的。

2472
01:58:08,880 --> 01:58:11,300
So let me go ahead and do that, declare s to be
所以，让我来做这件事，将 s 声明为

2473
01:58:11,300 --> 01:58:12,772
an array of, say, four characters.
一个包含四个字符的数组。

2474
01:58:12,772 --> 01:58:15,980
And in this case, I should have enough room for the H, the I, the exclamation
在这种情况下，我应该有足够的空间容纳 H、I、感叹号

2475
01:58:15,980 --> 01:58:20,390
point, and even that null character, the trailing backslash zero.
和那个空字符，结尾的反斜杠零。

2476
01:58:20,390 --> 01:58:22,370
So now, let me go ahead and build this.
所以现在，让我来构建它。

2477
01:58:22,370 --> 01:58:23,360
Make get.
make get。

2478
01:58:23,360 --> 01:58:26,430
And because I'm not, not initializing something this time,
而且这次我没有初始化任何东西，

2479
01:58:26,430 --> 01:58:29,960
I can use make as usual without getting yelled at because I'm not yet
我可以像往常一样使用 make，而不会被骂，因为我还没有

2480
01:58:29,960 --> 01:58:31,160
doing anything wrong.
做错任何事。

2481
01:58:31,160 --> 01:58:34,250
Now let me go ahead and do dot slash get enter.
现在，让我来执行点斜杠 get 回车。

2482
01:58:34,250 --> 01:58:38,240
And in this case, it's ready to receive my H-I exclamation point enter,
在这种情况下，它准备接收我的 H-I 感叹号回车，

2483
01:58:38,240 --> 01:58:40,460
and all actually seems well.
一切都看起来很正常。

2484
01:58:40,460 --> 01:58:40,970
Why?
为什么？

2485
01:58:40,970 --> 01:58:44,240
Because in this case, I actually had enough space for s,
因为在这种情况下，我实际上有足够的空间容纳 s，

2486
01:58:44,240 --> 01:58:47,750
because if I go back to my memory here, because I've now redeclared s
因为如果我回到我的内存，因为我现在重新声明了 s，

2487
01:58:47,750 --> 01:58:50,090
as an actual array of four characters, that's
作为一个包含四个字符的实际数组，这就像

2488
01:58:50,090 --> 01:58:53,600
like asking the operating system, for instance, for these four chars here.
比如向操作系统请求这四个字符。

2489
01:58:53,600 --> 01:58:58,340
And certainly, I can fit H-I exclamation point and the null character
当然，我可以把 H-I 感叹号和空字符放进去

2490
01:58:58,340 --> 01:58:59,970
into those four bytes.
在这四个字节里。

2491
01:58:59,970 --> 01:59:01,430
So there's not a problem.
所以没有问题。

2492
01:59:01,430 --> 01:59:05,810
But there might be a problem if the I, or the user, more generally,
但是如果 I，或者更一般地说，用户，

2493
01:59:05,810 --> 01:59:07,520
types in too many characters.
输入了太多字符。

2494
01:59:07,520 --> 01:59:09,860
So let me go ahead and run dot slash get again.
所以让我继续运行点斜杠 get 再次。

2495
01:59:09,860 --> 01:59:12,330
Let me type H-I exclamation point.
让我输入 H-I 感叹号。

2496
01:59:12,330 --> 01:59:16,340
But just to get a little aggressive, let me highlight that and paste it again,
但为了变得更具侵略性，让我突出显示它并再次粘贴，

2497
01:59:16,340 --> 01:59:19,880
again, again, and again, and really type, very excitedly,
一遍又一遍，一遍又一遍，非常兴奋地输入，

2498
01:59:19,880 --> 01:59:23,460
a pretty long string that is surely longer than four bytes.
一个相当长的字符串，它肯定比四个字节长。

2499
01:59:23,460 --> 01:59:25,820
Well unfortunately, I've only asked the operating system
不幸的是，我只要求操作系统

2500
01:59:25,820 --> 01:59:27,540
for an array of four bytes.
一个四个字节的数组。

2501
01:59:27,540 --> 01:59:31,340
So what's going to happen with all of those extra hi's, hi's, hi's?
那么，所有这些额外的 hi，hi，hi 会怎样？

2502
01:59:31,340 --> 01:59:34,795
They're just going to, by default, remain contiguous from left to right,
它们默认情况下将从左到右保持连续，

2503
01:59:34,795 --> 01:59:36,420
top to bottom in the computer's memory.
从上到下在计算机的内存中。

2504
01:59:36,420 --> 01:59:38,930
But they're going to end up, some of those characters,
但是它们最终会，其中一些字符，

2505
01:59:38,930 --> 01:59:43,020
at locations I didn't ask the operating system for in this array.
在我的这个数组中，我没有向操作系统请求的位置。

2506
01:59:43,020 --> 01:59:47,450
So if I go back to VS Code here, I've typed in a very long string, certainly
所以如果我回到这里的 VS Code，我已经输入了一个非常长的字符串，当然

2507
01:59:47,450 --> 01:59:48,860
longer than four bytes in total.
总长度超过了四个字节。

2508
01:59:48,860 --> 01:59:49,880
Let me hit enter.
让我按回车键。

2509
01:59:49,880 --> 01:59:50,690
And darn it.
该死。

2510
01:59:50,690 --> 01:59:53,800
There is another segmentation fault. So in short, we,
又出现了段错误。简而言之，我们，

2511
01:59:53,800 --> 01:59:56,540
you are going to see these segmentation faults any time
你会在任何时候看到这些段错误

2512
01:59:56,540 --> 01:59:58,910
you touch segments of memory, so to speak,
你触摸到内存的片段，可以这么说，

2513
01:59:58,910 --> 02:00:02,870
that do not belong to you, that you didn't allocate space for, as
它们不属于你，你没有为它们分配空间，就像

2514
02:00:02,870 --> 02:00:05,220
via an array, or even via malloc.
通过数组，甚至通过 malloc。

2515
02:00:05,220 --> 02:00:07,970
And this is going to be a fundamental problem with getting strings
这将成为获取字符串的一个基本问题

2516
02:00:07,970 --> 02:00:11,210
because I don't in advance how long the string is going to be
因为我事先不知道字符串有多长

2517
02:00:11,210 --> 02:00:12,680
that the human's going to type in.
人类要输入。

2518
02:00:12,680 --> 02:00:13,670
Maybe it's four.
也许是四个。

2519
02:00:13,670 --> 02:00:14,840
Maybe it's fewer characters.
也许是更少的字符。

2520
02:00:14,840 --> 02:00:15,980
Maybe it's even more.
也许更多。

2521
02:00:15,980 --> 02:00:17,400
So what's the alternative?
那么，还有什么选择呢？

2522
02:00:17,400 --> 02:00:20,480
Well, I could go in here maybe and allocate, I don't know,
好吧，我可以在里面分配，我不知道，

2523
02:00:20,480 --> 02:00:22,970
4,000 characters for s.
为 s 分配 4,000 个字符。

2524
02:00:22,970 --> 02:00:27,770
But what if you type in an even longer string that's 4,001 characters or more?
但如果你输入一个更长的字符串，长度为 4,001 个字符或更多，会怎么样？

2525
02:00:27,770 --> 02:00:31,580
I might still have these memory related errors, these segmentation faults.
我可能仍然会遇到这些与内存相关的错误，这些段错误。

2526
02:00:31,580 --> 02:00:35,540
So one of the reasons then, too, that we provide you with the CS50 library,
因此，我们向你提供 CS50 库的一个原因是，

2527
02:00:35,540 --> 02:00:37,880
and in turn, functions like getstring, is
反过来，像 getstring 这样的函数，就是

2528
02:00:37,880 --> 02:00:43,250
that getstring very, very conservatively walks through these user's input
getstring 非常、非常保守地遍历这些用户的输入

2529
02:00:43,250 --> 02:00:46,410
byte, by byte, by byte, one character at a time.
一个字节一个字节一个字节，一次一个字符。

2530
02:00:46,410 --> 02:00:48,980
And what the CS50 library is doing underneath the hood
CS50 库在幕后所做的是

2531
02:00:48,980 --> 02:00:52,400
is, as soon as it realizes, oh, the user gave us another byte, another byte,
就是，一旦它意识到，哦，用户给了我们另一个字节，另一个字节，

2532
02:00:52,400 --> 02:00:56,270
we in the CS50 library are constantly allocating and re
我们在 CS50 库中不断地分配和重新分配

2533
02:00:56,270 --> 02:00:59,960
allocating more and more memory using malloc for you,
使用 malloc 为你分配越来越多的内存，

2534
02:00:59,960 --> 02:01:03,660
and effectively managing the memory required for that string.
并有效地管理该字符串所需的内存。

2535
02:01:03,660 --> 02:01:07,580
So even though scanf exists, it's dangerous to use with strings.
所以，即使 scanf 存在，用它处理字符串也很危险。

2536
02:01:07,580 --> 02:01:09,890
And even with integers, it turns out it lacks
即使使用整数，事实证明它也缺乏

2537
02:01:09,890 --> 02:01:13,940
some of the error handling that the CS50 library has thus far provided.
CS50 库迄今为止提供的一些错误处理功能。

2538
02:01:13,940 --> 02:01:16,010
How do we actually go about solving this?
我们实际上如何解决这个问题呢？

2539
02:01:16,010 --> 02:01:21,170
The way getstring actually works in the CS50 library is it kind of tiptoes.
getstring 在 CS50 库中的实际工作方式是它有点像踮着脚尖。

2540
02:01:21,170 --> 02:01:21,860
It waits.
它等待。

2541
02:01:21,860 --> 02:01:25,250
It gets one character from you and then checks if there's another one coming.
它从你那里获取一个字符，然后检查是否还有另一个字符要来。

2542
02:01:25,250 --> 02:01:27,027
Then it allocates more space for a second.
然后它为第二个字符分配更多空间。

2543
02:01:27,027 --> 02:01:30,110
If there's still a third, it allocates more space, more space, more space.
如果还有第三个字符，它会分配更多空间，更多空间，更多空间。

2544
02:01:30,110 --> 02:01:33,260
So essentially, what getstring does is it uses malloc again,
所以本质上，getstring 所做的是它再次使用 malloc，

2545
02:01:33,260 --> 02:01:36,290
and again, and again, and it kind of lays the tracks down
一次又一次，它像铺设轨道一样

2546
02:01:36,290 --> 02:01:38,690
as you're typing in the keystrokes and hitting enter,
当你输入键击并按下回车键时，

2547
02:01:38,690 --> 02:01:42,230
so that we never assume how many characters you're going to type in.
这样我们就永远不会假设你将输入多少个字符。

2548
02:01:42,230 --> 02:01:46,820
We dynamically allocate just enough bytes for you, plus one extra,
我们动态地为你分配刚好足够的字节，再加上一个额外的字节，

2549
02:01:46,820 --> 02:01:48,540
for the null character.
用于空字符。

2550
02:01:48,540 --> 02:01:50,358
And this is sort of a hoop that's just not
而这就像是一个圈，它只是不

2551
02:01:50,358 --> 02:01:53,150
fun to jump through when, at the end of the day, all you want to do
有趣，当最终你想要做的

2552
02:01:53,150 --> 02:01:55,230
is get input from the user.
是从用户那里获取输入。

2553
02:01:55,230 --> 02:01:58,100
So even with the training wheels officially off,
所以即使辅助轮正式卸下，

2554
02:01:58,100 --> 02:02:01,190
it's going to be annoying to get strings from users in C.
在 C 语言中从用户获取字符串将是一件很烦人的事。

2555
02:02:01,190 --> 02:02:04,247
But it is easy with ints, with floats, with other data types.
但是使用整数、浮点数和其他数据类型就很简单。

2556
02:02:04,247 --> 02:02:06,080
And frankly, we'll soon, in two weeks, pivot
坦率地说，我们很快，在两周内，将转向

2557
02:02:06,080 --> 02:02:09,380
to Python, which takes care of all of these problems for us
Python，它会为我们解决所有这些问题

2558
02:02:09,380 --> 02:02:10,700
and manages our memory.
并管理我们的内存。

2559
02:02:10,700 --> 02:02:13,820
But for now, we have one final to do beyond scanf,
但现在，除了 scanf 之外，我们还有最后一个要做的，

2560
02:02:13,820 --> 02:02:17,360
which is file IO, which is a fancy way of saying input and output.
那就是文件 I/O，它是一种更花哨的说法，指的是输入和输出。

2561
02:02:17,360 --> 02:02:19,760
Because now that we a little bit of hexadecimal,
因为现在我们了解了一些十六进制知识，

2562
02:02:19,760 --> 02:02:21,980
now that we know a little bit about pointers,
现在我们了解了一些关于指针的知识，

2563
02:02:21,980 --> 02:02:24,170
we actually have some more functions available to us
我们实际上可以使用更多函数

2564
02:02:24,170 --> 02:02:29,000
that will let us actually manipulate files on a computer's hard drive,
让我们实际上能够操作计算机硬盘上的文件，

2565
02:02:29,000 --> 02:02:33,020
like image files, or text files, or anything else we might want.
例如图像文件、文本文件或我们可能需要的任何其他文件。

2566
02:02:33,020 --> 02:02:38,510
Among the most common functions that are related to files are these here.
与文件相关的最常见函数包括这些。

2567
02:02:38,510 --> 02:02:42,770
fopen is going to be a function that lets you open a file, doing in code
fopen 将是一个让你打开文件的函数，在代码中执行

2568
02:02:42,770 --> 02:02:46,670
what you might otherwise do by going to File, Open in a graphical program.
你可能在图形程序中通过点击文件、打开来执行的操作。

2569
02:02:46,670 --> 02:02:48,000
Fclose does the opposite.
Fclose 做相反的操作。

2570
02:02:48,000 --> 02:02:51,347
It's the way you, in code, click on an X and close a file.
它是在代码中，点击 X 并关闭文件的方式。

2571
02:02:51,347 --> 02:02:53,180
Nothing's going to happen visually, but it's
视觉上不会发生任何变化，但它

2572
02:02:53,180 --> 02:02:57,410
how you give access to a program to the contents of a file.
是你让程序访问文件内容的方式。

2573
02:02:57,410 --> 02:03:01,550
fprintf, it allows you to print, not to the screen, but to a file.
fprintf 允许你打印，不是到屏幕上，而是到文件中。

2574
02:03:01,550 --> 02:03:05,672
fscanf lets you read data, not from the keyboard, but from a file. fread
fscanf 允许你读取数据，不是从键盘上读取，而是从文件中读取。 fread

2575
02:03:05,672 --> 02:03:08,630
and fwrite write are similarly used to read and write data from a file,
和 fwrite write 类似地用于从文件中读取和写入数据，

2576
02:03:08,630 --> 02:03:11,630
but generally binary data, like images, or something
但通常是二进制数据，比如图像，或者其他

2577
02:03:11,630 --> 02:03:13,820
that's not Ascii or Unicode text.
不是 ASCII 或 Unicode 文本的东西。

2578
02:03:13,820 --> 02:03:15,932
fseek is a function that lets you move around
fseek 是一个允许你在文件中左右移动的函数，有点像快进

2579
02:03:15,932 --> 02:03:18,140
in a file left to right, kind of like fast forwarding
在文件中从左到右移动，有点像快进

2580
02:03:18,140 --> 02:03:20,240
or rewinding through Netflix, or similar when
或者在 Netflix 上回放，或者在类似情况下

2581
02:03:20,240 --> 02:03:23,840
you want to jump to a different location in a video, or in this case, a file.
你想跳转到视频中的不同位置，或者在本例中，是文件中的不同位置。

2582
02:03:23,840 --> 02:03:25,620
And there's bunches of others, as well.
还有很多其他的。

2583
02:03:25,620 --> 02:03:28,370
So to give you a sense of what you can do with it when
所以，为了让你了解在

2584
02:03:28,370 --> 02:03:32,270
it comes to manipulating files, let's write just a couple of final programs,
谈到操作文件时，我们来编写几个最后的程序，

2585
02:03:32,270 --> 02:03:36,090
for instance, that let us manipulate some of this code for us.
例如，让我们可以为我们操作一些代码。

2586
02:03:36,090 --> 02:03:41,900
In fact, let me go ahead and open up here in VS Code a new file called,
事实上，让我在 VS Code 中打开一个名为

2587
02:03:41,900 --> 02:03:43,820
say, phonebook.c.
比如，phonebook.c 的新文件。

2588
02:03:43,820 --> 02:03:46,280
And in phonebook.c, we're going to implement now
在 phonebook.c 中，我们现在将实现

2589
02:03:46,280 --> 02:03:48,600
a version of the phonebook like we did in the past.
一个过去我们已经实现过的电话簿版本。

2590
02:03:48,600 --> 02:03:55,010
But in this case, we don't actually have a forgetful program that
但在这种情况下，我们实际上没有一个健忘的程序，该程序

2591
02:03:55,010 --> 02:03:57,827
prompts the user with getstring for a couple of names and numbers,
使用 getstring 提示用户输入几个姓名和电话号码，

2592
02:03:57,827 --> 02:03:59,660
and then just forgets about them altogether.
然后完全忘记它们。

2593
02:03:59,660 --> 02:04:01,610
This version of the phonebook is actually
这个版本的电话簿实际上

2594
02:04:01,610 --> 02:04:05,420
going to go ahead and save them persistently to a file for us.
将把它们持久地保存到一个文件中。

2595
02:04:05,420 --> 02:04:10,250
And for this, let me go ahead and open up just on my other screen here,
为此，让我在我的另一块屏幕上打开它，

2596
02:04:10,250 --> 02:04:14,420
without flipping over just yet, let me go ahead and open up--
暂时还没有翻页，让我打开一下——

2597
02:04:14,420 --> 02:04:17,220
give me just one moment.
请稍等一下。

2598
02:04:17,220 --> 02:04:19,680
So we have this ready to go.
所以我们已经准备好了。

2599
02:04:19,680 --> 02:04:23,230
Let me go ahead and create the file, this program as follows.
让我创建这个文件，程序如下。

2600
02:04:23,230 --> 02:04:26,400
I'm going to cheat and save time by using the CS50 library because I do not
我将使用 CS50 库来作弊并节省时间，因为我不

2601
02:04:26,400 --> 02:04:29,920
want to get into the nuances of getting strings character by character,
想深入探讨逐个字符获取字符串的细微差别，

2602
02:04:29,920 --> 02:04:31,590
which itself will escalate too quickly.
这本身会很快升级。

2603
02:04:31,590 --> 02:04:34,890
But let me go ahead and include the CS50 library, the standard IO library,
但让我先包含 CS50 库、标准 IO 库，

2604
02:04:34,890 --> 02:04:38,340
and lastly, the string library for this particular case.
最后，在本例中包含字符串库。

2605
02:04:38,340 --> 02:04:41,850
In my main function now, I'm going to go ahead and open up
在我的主函数中，我将打开

2606
02:04:41,850 --> 02:04:44,880
a file called maybe phonebook.csv.
一个名为 phonebook.csv 的文件。

2607
02:04:44,880 --> 02:04:48,210
If you've ever used a CSV file, it's like a lightweight spreadsheet
如果你曾经使用过 CSV 文件，它就像一个轻量级的电子表格

2608
02:04:48,210 --> 02:04:51,630
that you can open in Apple Numbers, Google Spreadsheets, Microsoft Excel.
它可以在 Apple Numbers、Google Spreadsheets、Microsoft Excel 中打开。

2609
02:04:51,630 --> 02:04:55,240
But CSV means that we're going to separate all of the values by commas.
但 CSV 意味着我们将用逗号分隔所有值。

2610
02:04:55,240 --> 02:04:57,960
So anywhere we want a new column, we actually use a comma,
所以，只要我们想要一个新列，我们实际上就使用逗号，

2611
02:04:57,960 --> 02:04:59,140
as we'll soon see.
我们很快就会看到。

2612
02:04:59,140 --> 02:05:00,510
So how do I actually do this?
那么我究竟该如何做呢？

2613
02:05:00,510 --> 02:05:07,980
I can open a file called phonebook.csv by literally using fopen phonebook.csv.
我可以通过使用 fopen phonebook.csv 来打开一个名为 phonebook.csv 的文件。

2614
02:05:07,980 --> 02:05:11,400
And I have to tell fopen how I want to open it.
而且我必须告诉 fopen 我想要如何打开它。

2615
02:05:11,400 --> 02:05:14,040
Do I want to open it for reading with R?
我想要使用 R 以只读方式打开它吗？

2616
02:05:14,040 --> 02:05:16,710
Do I want to open it for writing with W?
我想要使用 W 以只写方式打开它吗？

2617
02:05:16,710 --> 02:05:19,210
Or do I want to open it with appending, A?
或者我想要使用 A 以追加方式打开它吗？

2618
02:05:19,210 --> 02:05:22,990
And for something like a phone book, if I run this program again and again,
对于像电话簿这样的东西，如果我一遍又一遍地运行这个程序，

2619
02:05:22,990 --> 02:05:26,830
I'm going to actually do append so that new contacts get added to the file,
我实际上会使用追加方式，这样新的联系人就会被添加到文件中，

2620
02:05:26,830 --> 02:05:29,440
and we don't overwrite it with W.
而且我们不会使用 W 来覆盖它。

2621
02:05:29,440 --> 02:05:31,120
Now, what is fopen return?
现在，fopen 返回什么？

2622
02:05:31,120 --> 02:05:35,300
It technically returns a pointer to a file.
从技术上讲，它返回一个指向文件的指针。

2623
02:05:35,300 --> 02:05:36,550
But this one's a little weird.
但这个有点奇怪。

2624
02:05:36,550 --> 02:05:41,830
It's all capitalized, but it is a thing in C. File in all caps star file
它全部大写，但它是 C 中的一个东西。全部大写的 FILE 星号 file

2625
02:05:41,830 --> 02:05:44,660
is going to be a pointer to that file in memory.
将指向内存中该文件的指针。

2626
02:05:44,660 --> 02:05:48,700
So think of fopen as opening the file and returning the address thereof
因此，将 fopen 视为打开文件并返回其地址

2627
02:05:48,700 --> 02:05:50,060
in the computer's memory.
在计算机的内存中。

2628
02:05:50,060 --> 02:05:50,560
All right.
好的。

2629
02:05:50,560 --> 02:05:51,670
What do I want to next do?
接下来我想要做什么？

2630
02:05:51,670 --> 02:05:54,970
I want to go ahead and get two strings from the user, like maybe someone's
我想从用户那里获取两个字符串，例如可能是某人的

2631
02:05:54,970 --> 02:05:59,380
name, using getstring, again, to keep things simple for now.
姓名，再次使用 getstring，为了现在保持简单。

2632
02:05:59,380 --> 02:06:01,490
Let me then go ahead and get another one.
然后我再获取另一个。

2633
02:06:01,490 --> 02:06:02,620
How about their number?
他们的号码怎么样？

2634
02:06:02,620 --> 02:06:05,320
Using getstring, again, prompting for a number.
再次使用 getstring，提示输入一个数字。

2635
02:06:05,320 --> 02:06:07,480
And I don't strictly need these training wheels.
而且我并不严格需要这些辅助工具。

2636
02:06:07,480 --> 02:06:09,160
So even though it doesn't really make a difference,
所以尽管它并没有真正改变什么，

2637
02:06:09,160 --> 02:06:11,827
I'm going to at least change that to char star, even though I do
我至少要将它改为 char star，尽管我确实

2638
02:06:11,827 --> 02:06:14,560
want to keep using getstring conveniently.
想继续方便地使用 getstring。

2639
02:06:14,560 --> 02:06:18,590
And now I want to save this person's name and number to that CSV file.
现在我想将这个人的姓名和号码保存到该 CSV 文件中。

2640
02:06:18,590 --> 02:06:21,550
So I'm going to use, not printf, but fprintf,
所以我将使用，不是 printf，而是 fprintf，

2641
02:06:21,550 --> 02:06:26,380
printing to that file, variable, which is open in the computer's memory.
打印到该文件，变量，该变量在计算机的内存中打开。

2642
02:06:26,380 --> 02:06:31,360
Now I'm going to go ahead and print out two strings, %s comma, %s.
现在我要打印两个字符串，%s 逗号，%s。

2643
02:06:31,360 --> 02:06:34,870
Then I want to go ahead and print out the name for the first placeholder,
然后我想继续打印出第一个占位符的姓名，

2644
02:06:34,870 --> 02:06:37,150
and the number for the second placeholder.
第二个占位符的号码。

2645
02:06:37,150 --> 02:06:40,600
And for good measure, I want to move the cursor to the next line in the file,
为了保险起见，我想将光标移动到文件中的下一行，

2646
02:06:40,600 --> 02:06:43,600
so I am going to include a backslash n.
因此我将包含一个反斜杠 n。

2647
02:06:43,600 --> 02:06:48,820
Then I'm going to go ahead and fclose that same file with fclose.
然后我将继续使用 fclose 关闭同一个文件。

2648
02:06:48,820 --> 02:06:49,540
And that's it.
就是这样。

2649
02:06:49,540 --> 02:06:50,920
No more printing to the user.
不再向用户打印。

2650
02:06:50,920 --> 02:06:53,620
But I claim that I'm going to be changing the file again,
但我声称我将再次更改该文件，

2651
02:06:53,620 --> 02:06:54,628
and again, and again.
再次，再次。

2652
02:06:54,628 --> 02:06:55,420
So let me try this.
所以让我试试这个。

2653
02:06:55,420 --> 02:06:59,950
Make phone book, OK, dot slash phonebook, enter.
创建电话簿，好的，点斜杠 phonebook，回车。

2654
02:06:59,950 --> 02:07:01,480
And let's type in David.
让我们输入 David。

2655
02:07:01,480 --> 02:07:06,880
And how about +1 617-495-1000?
+1 617-495-1000 怎么样？

2656
02:07:06,880 --> 02:07:07,930
Enter.
回车。

2657
02:07:07,930 --> 02:07:09,310
OK, hopefully, it worked.
好的，希望它能用。

2658
02:07:09,310 --> 02:07:10,060
Let's do it again.
让我们再来一次。

2659
02:07:10,060 --> 02:07:10,990
Dot slash phonebook.
点斜杠 phonebook。

2660
02:07:10,990 --> 02:07:14,170
Carter, we'll give him the same number as last time.
Carter，我们给他上次的号码。

2661
02:07:14,170 --> 02:07:16,690
495-1000.
495-1000。

2662
02:07:16,690 --> 02:07:19,770
And let's do, how about just those two?
我们就这样做吧，就这两个怎么样？

2663
02:07:19,770 --> 02:07:23,880
So let me go ahead now and reveal that we do have
所以我现在就告诉你，我们确实有

2664
02:07:23,880 --> 02:07:27,510
a file in here called phonebook.csv.
一个名为 phonebook.csv 的文件。

2665
02:07:27,510 --> 02:07:29,290
So that does exist.
所以确实存在。

2666
02:07:29,290 --> 02:07:30,490
Let me go ahead and do this.
让我继续这样做。

2667
02:07:30,490 --> 02:07:33,838
Let me open up my file browser over here.
让我打开我这边文件浏览器。

2668
02:07:33,838 --> 02:07:35,380
I've got a lot of files I've created.
我已经创建了很多文件。

2669
02:07:35,380 --> 02:07:36,450
Here's phonebook.csv.
这是 phonebook.csv。

2670
02:07:36,450 --> 02:07:39,210
And if I click on it, there is the file that I just
如果我点击它，就会出现我刚刚创建的文件

2671
02:07:39,210 --> 02:07:40,780
created, separated by commas.
创建的，用逗号隔开。

2672
02:07:40,780 --> 02:07:44,430
But even more interestingly, let me actually right click or control click
但更有趣的是，让我实际右键单击或控制单击

2673
02:07:44,430 --> 02:07:47,620
on this, download it to my Mac's downloads folder.
它，将其下载到我的 Mac 的下载文件夹。

2674
02:07:47,620 --> 02:07:50,370
Let me go into my downloads folder just for fun,
为了好玩，让我进入我的下载文件夹，

2675
02:07:50,370 --> 02:07:52,740
and I've installed in advance Microsoft Excel.
我已经提前安装了 Microsoft Excel。

2676
02:07:52,740 --> 02:07:58,060
If I go into my downloads folder and open up phonebook.csv,
如果我进入我的下载文件夹并打开 phonebook.csv，

2677
02:07:58,060 --> 02:08:02,755
we're going to see, oh, Apple Numbers, not Excel, opening up.
我们会看到，哦，是 Apple Numbers 而不是 Excel 打开了。

2678
02:08:02,755 --> 02:08:03,630
View my spreadsheets.
查看我的电子表格。

2679
02:08:03,630 --> 02:08:05,172
All right, numbers is kind of stupid.
好吧，Numbers 有点蠢。

2680
02:08:05,172 --> 02:08:06,690
So there we go.
就是这样。

2681
02:08:06,690 --> 02:08:10,210
No, this isn't a Mac versus PC thing.
不，这不是 Mac 对 PC 的问题。

2682
02:08:10,210 --> 02:08:14,880
So now we have phonebook.csv rendered in this format here.
所以现在我们以这种格式呈现了 phonebook.csv。

2683
02:08:14,880 --> 02:08:18,190
Numbers presumes that the top row should be gray and not white, as well.
Numbers 还假设顶行应该是灰色的而不是白色的。

2684
02:08:18,190 --> 02:08:20,470
So the formatting looks a bit off.
所以格式看起来有点不对。

2685
02:08:20,470 --> 02:08:22,960
Anyhow, clearly, you could open this same file
无论如何，显然，你可以打开同一个文件

2686
02:08:22,960 --> 02:08:25,720
in a spreadsheet program like Microsoft Office, or Apple Numbers,
在像 Microsoft Office 或 Apple Numbers 这样的电子表格程序中，

2687
02:08:25,720 --> 02:08:28,330
or of course, something like Google Spreadsheets.
当然，也可以用像 Google Spreadsheets 这样的程序。

2688
02:08:28,330 --> 02:08:32,170
But let me do one other thing when it comes to copying files now,
但是，在复制文件方面，我想再做一件事，

2689
02:08:32,170 --> 02:08:37,180
whereby besides making a phone book, whereby I clearly have the ability now
除了创建电话簿，现在我显然有能力

2690
02:08:37,180 --> 02:08:40,120
to save strings in files.
将字符串保存在文件中。

2691
02:08:40,120 --> 02:08:43,270
And actually, just for good measure, let me hammer home the point
实际上，为了保险起见，让我强调一点

2692
02:08:43,270 --> 02:08:46,460
that anytime we're dealing with pointers now, something could go wrong.
现在，无论何时我们处理指针，都可能出现问题。

2693
02:08:46,460 --> 02:08:48,370
And if you read the documentation for fopen,
如果你阅读 fopen 的文档，

2694
02:08:48,370 --> 02:08:52,540
we should also check that file could be null.
我们还应该检查该文件是否为空。

2695
02:08:52,540 --> 02:08:55,940
Maybe the file is not found, or something's not working on the server.
也许文件未找到，或者服务器上某些东西无法正常工作。

2696
02:08:55,940 --> 02:08:58,610
And so just to be safe, we should return one there.
所以为了安全起见，我们应该在那里返回 1。

2697
02:08:58,610 --> 02:09:01,210
So even not just malloc, not just getstring.
所以，不仅仅是 malloc，不仅仅是 getstring。

2698
02:09:01,210 --> 02:09:03,700
Any time a function returns a pointer, you
任何时候函数返回一个指针，你

2699
02:09:03,700 --> 02:09:06,940
should check if it's null, because if it is, per the documentation,
应该检查它是否为空，因为根据文档，

2700
02:09:06,940 --> 02:09:08,990
almost always means something has gone wrong.
几乎总是意味着某些东西出错了。

2701
02:09:08,990 --> 02:09:12,520
So you should get out, lest you trust the return value therein.
所以你应该退出，以免你信任其中的返回值。

2702
02:09:12,520 --> 02:09:16,300
So let me go ahead and do one other program here.
所以，让我在这里再做另一个程序。

2703
02:09:16,300 --> 02:09:18,110
Let me create my own copy program.
让我创建我自己的复制程序。

2704
02:09:18,110 --> 02:09:22,610
So up until now, we've used commands like RM, and LS, and CP for copy.
到目前为止，我们一直使用 RM、LS 和 CP 等命令来复制。

2705
02:09:22,610 --> 02:09:26,360
I can actually create my own version of Linux's copy program,
我实际上可以创建我自己的 Linux 复制程序版本，

2706
02:09:26,360 --> 02:09:27,630
perhaps as follows.
也许如下所示。

2707
02:09:27,630 --> 02:09:31,730
Let me actually go into cp.c, in this case.
让我进入 cp.c，在这种情况下。

2708
02:09:31,730 --> 02:09:33,440
Let me include some familiar file.
让我包含一些熟悉的文件。

2709
02:09:33,440 --> 02:09:34,880
Standard io.h.
标准 io.h。

2710
02:09:34,880 --> 02:09:37,550
Let me include, how about one other?
让我再包含一个，怎么样？

2711
02:09:37,550 --> 02:09:40,940
Standard int.h for reasons we'll see now,
标准 int.h，原因我们现在就会看到，

2712
02:09:40,940 --> 02:09:46,010
because in standard int.h is that uint8_type that I mentioned
因为在标准 int.h 中是那个我提到的 uint8_type

2713
02:09:46,010 --> 02:09:51,530
earlier, which just means, give me an eight bit value that's unsigned,
之前，它只是意味着，给我一个无符号的 8 位值，

2714
02:09:51,530 --> 02:09:53,000
which means no negative numbers.
这意味着没有负数。

2715
02:09:53,000 --> 02:09:54,320
It's just raw data.
它只是原始数据。

2716
02:09:54,320 --> 02:09:57,210
It's not an integer in the positive or negative sense.
它不是正数或负数意义上的整数。

2717
02:09:57,210 --> 02:09:59,180
And let me just nickname that to byte, just
让我把它简称为 byte，只是

2718
02:09:59,180 --> 02:10:02,780
to make clear that I want to manipulate files byte at a time.
为了明确表示我想一次操纵一个字节的文件。

2719
02:10:02,780 --> 02:10:05,390
Let me now declare, for the first time today,
现在让我声明，今天第一次，

2720
02:10:05,390 --> 02:10:10,610
a version of main that takes in an ergc command, takes in argc,
一个 main 版本，它接受一个 ergc 命令，接受 argc，

2721
02:10:10,610 --> 02:10:15,938
and takes in argv, which is for command line arguments.
并接受 argv，它用于命令行参数。

2722
02:10:15,938 --> 02:10:18,730
Technically though, I'm not using the CS50 library in this version,
从技术上讲，在这个版本中，我没有使用CS50库，

2723
02:10:18,730 --> 02:10:20,590
so even that can now be changed.
因此，即使是这一点现在也可以改变。

2724
02:10:20,590 --> 02:10:23,730
And this is the canonical way in C to declare
在C语言中，这是一种标准的声明方式

2725
02:10:23,730 --> 02:10:25,980
main when you want to get command line arguments using
main函数，当您想要使用命令行参数时

2726
02:10:25,980 --> 02:10:28,240
char star instead of string.
使用字符指针而不是字符串。

2727
02:10:28,240 --> 02:10:30,210
So now, I'm going to do two things.
所以现在，我要做两件事。

2728
02:10:30,210 --> 02:10:31,470
Remember how copy works.
记住复制是如何工作的。

2729
02:10:31,470 --> 02:10:34,710
You specify two files, the file you want to copy,
您指定两个文件：要复制的文件，

2730
02:10:34,710 --> 02:10:36,840
and the new name that you want to give to the copy.
以及要给复制文件起的新的名字。

2731
02:10:36,840 --> 02:10:41,860
So it would be like CP, space, old name, space, new name at the command line.
所以它就像在命令行中输入：CP、空格、旧文件名、空格、新文件名。

2732
02:10:41,860 --> 02:10:43,500
So accordingly, I'm going to do this.
因此，相应地，我要这样做。

2733
02:10:43,500 --> 02:10:47,250
I'm going to create one file in memory called source, or SRC for short.
我将在内存中创建一个名为source的文件，简称SRC。

2734
02:10:47,250 --> 02:10:52,050
And I'm going to set that equal to whatever is in argv one in read mode.
我将把该文件设置为argv中的第一个参数，并以读模式打开它。

2735
02:10:52,050 --> 02:10:55,200
But just to be super specific, I'm going to use read binary mode.
为了更加精确，我将使用二进制读模式。

2736
02:10:55,200 --> 02:10:56,910
I don't want to be copying text files.
我不想复制文本文件。

2737
02:10:56,910 --> 02:10:59,770
I want binary data, zeros and ones, like images.
我想要二进制数据，零和一，比如图像。

2738
02:10:59,770 --> 02:11:02,850
So I'm going to tell fopen to expect binary data.
所以我要告诉fopen函数预期二进制数据。

2739
02:11:02,850 --> 02:11:05,610
I'm then going to go ahead and create a second variable
然后我将创建一个第二个变量

2740
02:11:05,610 --> 02:11:08,170
called destination, DST for short.
名为destination，简称DST。

2741
02:11:08,170 --> 02:11:10,620
And I'm going to open up whatever is in argv two,
我将打开argv中的第二个参数，

2742
02:11:10,620 --> 02:11:12,670
the second file name at the command line.
即命令行中的第二个文件名。

2743
02:11:12,670 --> 02:11:14,550
But I don't want to read this file.
但我不想读取该文件。

2744
02:11:14,550 --> 02:11:18,330
I want to write to it in binary using zeros and ones.
我想使用零和一以二进制形式写入它。

2745
02:11:18,330 --> 02:11:21,657
Now, let me do the copying one bite at a time.
现在，让我一次复制一个字节。

2746
02:11:21,657 --> 02:11:22,740
It's a little inefficient.
这有点低效。

2747
02:11:22,740 --> 02:11:25,200
I should really do bunches of bytes at a time for speed.
为了速度，我应该一次性复制多个字节。

2748
02:11:25,200 --> 02:11:28,650
But let me just give myself one byte in a variable called b.
但让我在一个名为b的变量中存储一个字节。

2749
02:11:28,650 --> 02:11:31,260
So byte is not a thing in C. It's literally
所以字节在C语言中并不存在，它实际上

2750
02:11:31,260 --> 02:11:34,080
a synonym I created just for the sake of discussion
是我为了讨论而创建的同义词

2751
02:11:34,080 --> 02:11:36,545
because we'll do this in the future, as well.
因为我们将来也会这样做。

2752
02:11:36,545 --> 02:11:37,920
Now, let me go ahead and do this.
现在，让我继续做这件事。

2753
02:11:37,920 --> 02:11:40,617
How do you copy a file from old to new?
如何将文件从旧文件复制到新文件？

2754
02:11:40,617 --> 02:11:42,450
Well, I think it would suffice to use a loop
我认为使用循环就足够了

2755
02:11:42,450 --> 02:11:44,190
and just start at the beginning of the file,
从文件的开头开始，

2756
02:11:44,190 --> 02:11:46,732
loop all the way to the end of the file, and within the loop,
循环到文件的末尾，在循环中，

2757
02:11:46,732 --> 02:11:48,720
copy one byte from old to new.
将一个字节从旧文件复制到新文件。

2758
02:11:48,720 --> 02:11:49,960
So how do I do that?
那么，我该怎么做呢？

2759
02:11:49,960 --> 02:11:52,860
I used fprintf last time to write text.
上次我用fprintf函数来写入文本。

2760
02:11:52,860 --> 02:11:55,740
This time, I'm going to use a different function as follows.
这次，我将使用以下不同的函数。

2761
02:11:55,740 --> 02:11:58,912
While there are bytes to read from the file,
当文件中还有字节可以读取时，

2762
02:11:58,912 --> 02:12:01,620
and this one's going to be a mouthful, so let me just type it out
而这行代码很长，所以让我直接打出来

2763
02:12:01,620 --> 02:12:02,880
and then I'll explain it.
然后我会解释它。

2764
02:12:05,770 --> 02:12:11,770
While that line is true, go ahead and write
当那行代码为真时，继续写入

2765
02:12:11,770 --> 02:12:15,370
this line, which is similarly a mouthful, so I'll type it first
这行代码，同样也很长，所以我会先打出来

2766
02:12:15,370 --> 02:12:17,410
and then explain what it does.
然后解释它做什么。

2767
02:12:17,410 --> 02:12:20,270
Then I'm going to close destination.
然后我将关闭destination。

2768
02:12:20,270 --> 02:12:20,770
Whoops.
哎呀。

2769
02:12:20,770 --> 02:12:25,150
Then I'm going to close source, and I claim, if I haven't messed anything up,
然后我将关闭source，我声称，如果我没搞错的话，

2770
02:12:25,150 --> 02:12:28,130
this will now copy files for me.
这将为我复制文件。

2771
02:12:28,130 --> 02:12:28,750
How?
怎么？

2772
02:12:28,750 --> 02:12:31,510
So this is indeed a mouthful, but there's a function called fread,
这确实很拗口，但有一个叫做 fread 的函数，

2773
02:12:31,510 --> 02:12:34,660
whose purpose in life is to read one or more bytes for you.
它的作用就是为你读取一个或多个字节。

2774
02:12:34,660 --> 02:12:35,930
How does it work?
它是怎么工作的？

2775
02:12:35,930 --> 02:12:40,210
Well, just like swap, just like scanf, you
嗯，就像 swap，就像 scanf 一样，你需要

2776
02:12:40,210 --> 02:12:43,040
have to tell it where to load those bytes in memory.
告诉它在内存中将这些字节加载到哪里。

2777
02:12:43,040 --> 02:12:45,250
So if I want to put them in the byte called b,
所以如果我想将它们放到名为 b 的字节中，

2778
02:12:45,250 --> 02:12:47,470
I can't just say b because that's passed by value.
我不能只说 b，因为它传递的是值。

2779
02:12:47,470 --> 02:12:48,800
I need to pass by reference.
我需要传递引用。

2780
02:12:48,800 --> 02:12:51,520
So I say the address of b is where I want you to put
所以我说 b 的地址是我想要你放置的地方

2781
02:12:51,520 --> 02:12:53,620
one byte from the file at a time.
每次从文件中读取一个字节。

2782
02:12:53,620 --> 02:12:54,910
How big is a byte?
一个字节有多大？

2783
02:12:54,910 --> 02:12:58,180
Technically, I could just say one because we all know how big a byte is.
技术上讲，我可以直接说 1，因为我们都知道一个字节有多大。

2784
02:12:58,180 --> 02:13:01,240
But I'm just going to be super proper and generalize this as size of b
但我还是想做得严谨一些，并将其概括为 size of b

2785
02:13:01,240 --> 02:13:03,740
so it just figures it out for me, just in case we ever
这样它会自动帮我计算，以防我们以后

2786
02:13:03,740 --> 02:13:05,390
do more than one bite at a time.
一次读取多个字节。

2787
02:13:05,390 --> 02:13:07,700
How many bytes do I want to copy at a time?
我一次想复制多少个字节？

2788
02:13:07,700 --> 02:13:09,530
One, just to keep it simple.
一个，为了简单起见。

2789
02:13:09,530 --> 02:13:12,650
And where do I want to read those bytes from?
我想从哪里读取这些字节？

2790
02:13:12,650 --> 02:13:14,450
The source file.
源文件。

2791
02:13:14,450 --> 02:13:17,450
fread, if you read the documentation, just tells you
fread，如果你读过它的文档，就会知道它会告诉你

2792
02:13:17,450 --> 02:13:20,090
how many bytes were successfully read.
成功读取了多少个字节。

2793
02:13:20,090 --> 02:13:22,460
Logically, it should either be one was read,
逻辑上讲，它应该要么读取了一个字节，

2794
02:13:22,460 --> 02:13:25,380
or zero were read, based on what I'm asking it to do.
要么读取了零个字节，这取决于我让它做什么。

2795
02:13:25,380 --> 02:13:28,800
I'm asking it to read one at a time, so it's either going to succeed or fail.
我让它一次读取一个字节，所以它要么成功，要么失败。

2796
02:13:28,800 --> 02:13:31,218
So I want to do this for as long as it succeeds
所以我想只要它成功，就一直执行

2797
02:13:31,218 --> 02:13:34,010
because it's going to succeed until it gets to the end of the file,
因为它会一直成功，直到它到达文件末尾，

2798
02:13:34,010 --> 02:13:38,210
and then there's no more bytes to read, at which point it will return zero.
那时就没有更多字节可以读取了，它会返回 0。

2799
02:13:38,210 --> 02:13:42,470
So now, I do the opposite with fwrite, and it's almost the same line.
现在，我对 fwrite 做相反的操作，这行代码几乎相同。

2800
02:13:42,470 --> 02:13:44,930
Where do I want to write that byte?
我想把那个字节写入哪里？

2801
02:13:44,930 --> 02:13:47,600
Well, first, I tell fwrite where to find the byte,
嗯，首先，我告诉 fwrite 到哪里找到那个字节，

2802
02:13:47,600 --> 02:13:49,700
go there, and get the byte that was copied.
到那里去，获取被复制的字节。

2803
02:13:49,700 --> 02:13:53,060
It's this size, which is going to be one, but I did it generally.
它的大小会是 1，但我用的是通用写法。

2804
02:13:53,060 --> 02:13:54,770
One bite at a time, please.
请一次写入一个字节。

2805
02:13:54,770 --> 02:13:57,540
And write it to the destination file.
把它写入目标文件。

2806
02:13:57,540 --> 02:14:00,860
So if I now open up my terminal window, let me first
所以如果我现在打开我的终端窗口，让我先

2807
02:14:00,860 --> 02:14:04,100
make CP to create my own copy program.
创建一个叫做 CP 的程序，用于复制文件。

2808
02:14:04,100 --> 02:14:06,470
Let me actually open an image I came with today.
让我打开一张我今天带来的图片。

2809
02:14:06,470 --> 02:14:08,840
Here's a happy cat from the internet.
这是一张来自互联网的快乐猫的图片。

2810
02:14:08,840 --> 02:14:10,760
And that's going to be my original image.
这将是我的原始图片。

2811
02:14:10,760 --> 02:14:12,890
Let me now go ahead and run this.
我现在开始运行它。

2812
02:14:12,890 --> 02:14:14,180
Dot slash CP.
./CP

2813
02:14:14,180 --> 02:14:16,528
I have to run dot slash because I want my version of CP,
我必须运行 ./CP，因为我想要使用我自己的 CP 版本，

2814
02:14:16,528 --> 02:14:17,945
not the one that comes with Linux.
而不是 Linux 自带的版本。

2815
02:14:17,945 --> 02:14:22,940
So dot slash CP, cat.jpeg, and let's call it maybe
所以 ./CP cat.jpeg，我们把它命名为

2816
02:14:22,940 --> 02:14:26,210
my backup cat, just in case I ever mess up the original.
my backup cat，以防万一我搞乱了原始文件。

2817
02:14:26,210 --> 02:14:27,290
Enter.
回车。

2818
02:14:27,290 --> 02:14:29,180
Seems to work OK.
看起来工作正常。

2819
02:14:29,180 --> 02:14:33,770
When I run now code of backup dot jpeg to open the copy,
我现在运行 backup.jpeg 的代码来打开副本，

2820
02:14:33,770 --> 02:14:36,230
there is that same happy cat.
里面是同一只快乐猫。

2821
02:14:36,230 --> 02:14:39,350
So it's very low level manipulation, but it all
所以，这是一种非常低级的操作，但这一切

2822
02:14:39,350 --> 02:14:42,230
results from my now having the power to express myself
都是因为我现在有了用指针在位置和内存中表达自己的能力，

2823
02:14:42,230 --> 02:14:46,070
in terms of locations and memory using pointers, understanding
理解了字符串和现在文件实际上只是这些低级细节之上的抽象概念。

2824
02:14:46,070 --> 02:14:50,090
that strings and now files are really just abstractions on top of these lower
从所有这些中，将产生一些非常强大的功能。

2825
02:14:50,090 --> 02:14:50,960
level details.
低级细节。

2826
02:14:50,960 --> 02:14:54,950
And from all of that is going to come some pretty powerful functionality.
实际上，正如你很快就会看到，你现在可以做的事情之一，

2827
02:14:54,950 --> 02:14:58,620
In fact, among the things that you can now do, as you'll soon see,
就是操纵至少简单的文件，被称为位图文件。

2828
02:14:58,620 --> 02:15:02,270
is manipulate at least simple files, known as bitmap files.
所以 BMP 是位图文件，它本质上实现了图像，就像我们今天开始的那样，

2829
02:15:02,270 --> 02:15:06,980
So BMP is bitmap file, and it essentially implements images exactly
只是一张位图，一个网格，网格的 xy 坐标，

2830
02:15:06,980 --> 02:15:13,220
as we began today, as just a map of bits, a grid, xy coordinates of grids,
每个都代表一个像素坐标。

2831
02:15:13,220 --> 02:15:15,950
each of which represents a pixel coordinate.
位图是一种文件类型，在计算机上具有点 BMP 文件扩展名

2832
02:15:15,950 --> 02:15:20,600
A bitmap is a type of file with a dot BMP file extension on a computer
用于存储图像，就像这样。

2833
02:15:20,600 --> 02:15:22,440
that stores images just like that.
现在，你不仅能够以这种方式思考图像，

2834
02:15:22,440 --> 02:15:25,730
And now that you have the ability to not only think about images in this way,
而且还能编写操作图像的代码，

2835
02:15:25,730 --> 02:15:27,860
but write code that manipulates images, you
你可以在 Instagram、TikTok 和 Snapchat 上做一些强大的事情，

2836
02:15:27,860 --> 02:15:31,130
can do powerful things all on Instagram, and TikTok, and Snapchat,
比如现在的滤镜。

2837
02:15:31,130 --> 02:15:32,330
like filters nowadays.
例如，这是一张桥的图片，

2838
02:15:32,330 --> 02:15:35,540
So for instance, here is an image of the bridge,
横跨河面的 Weeks 桥。

2839
02:15:35,540 --> 02:15:37,340
the Weeks Bridge across the river.
这是我们通过编写一些 C 代码应用的黑白滤镜，

2840
02:15:37,340 --> 02:15:41,840
Here is a black and white filter that we've applied by writing some C code,
就像你很快就会做到的那样，将它从彩色变成黑白。

2841
02:15:41,840 --> 02:15:45,380
as you soon will, to change it from colorful to black and white.
这是你可能每天都会看到的原始图片。

2842
02:15:45,380 --> 02:15:48,380
Here's the original that you might see every day.
同时，这是它的倒影。

2843
02:15:48,380 --> 02:15:50,330
Here, meanwhile, is a reflection thereof.
如果你曾经在 x 轴上翻转过一张图片，

2844
02:15:50,330 --> 02:15:52,550
If you've ever flipped an image around on the x-axis,
实际上它可以旋转图像，即使它是桥的另一侧。

2845
02:15:52,550 --> 02:15:55,467
this can actually rotate the image, even though this is the other side
同时，这是一个模糊的版本。

2846
02:15:55,467 --> 02:15:56,660
of the bridge over there.
如果看起来有点模糊，那是故意的，

2847
02:15:56,660 --> 02:15:58,970
Meanwhile, here is a blurred version.
因为我们基本上模糊了所有值，方法是查看每个像素，

2848
02:15:58,970 --> 02:16:01,490
If it looks a little blurry, that's deliberate
向上、向下、向左和向右看，然后模糊

2849
02:16:01,490 --> 02:16:05,390
because we've essentially smudged all of the values by looking at every pixel,
效果以获得这里的效果。

2850
02:16:05,390 --> 02:16:07,820
looking up, down, left, and right, and kind of blurring
这里称为边缘检测，即

2851
02:16:07,820 --> 02:16:09,590
the effect to give it this effect here.
如果你感觉更舒适，你可以

2852
02:16:09,590 --> 02:16:11,518
Here is what's called edge detection, whereby
编写查看这些单个像素的代码，

2853
02:16:11,518 --> 02:16:13,310
if you're feeling more comfortable, you can
尝试找出边缘在哪里，就像一台高级计算机一样，

2854
02:16:13,310 --> 02:16:16,070
write code that looks at these individual pixels,
然后以这种方式着色。

2855
02:16:16,070 --> 02:16:19,910
tries to figure out where the edges are, just like a fancy computer might,
你能够做到这一切，因为像这样的图像

2856
02:16:19,910 --> 02:16:21,797
and then colorize it in this way, as well.
只是一些具有大量像素的坐标网格。

2857
02:16:21,797 --> 02:16:24,380
And you'll be able to do all of that because images like these
所以，现在已经变得非常简单的事情，将成为你

2858
02:16:24,380 --> 02:16:27,555
are just grids with coordinates with lots and lots of pixels.
现在完全可以控制的东西，现在我们已经

2859
02:16:27,555 --> 02:16:29,930
So what started quite simply now is going to be something
摘掉了这些辅助轮。

2860
02:16:29,930 --> 02:16:32,180
you now have complete control over, now that we've
在计算机科学领域，

2861
02:16:32,180 --> 02:16:33,770
taken off these training wheels.
理解像这样的极客幽默是件很平常的事。

2862
02:16:33,770 --> 02:16:35,540
And it's cultural within computer science
所以，今天我们将做的最后一件事，就是给你

2863
02:16:35,540 --> 02:16:37,590
to understand geek humor like this.
留下这个笑话作为结束，无论好坏，现在都应该有意义了。

2864
02:16:37,590 --> 02:16:41,270
And so the last thing we'll do today is give you
.

2865
02:16:41,270 --> 02:16:45,680
this joke to end on, which for better or for worse, should now make sense.
.

2866
02:16:45,680 --> 02:16:48,799
And those chuckles will suffice.
这些笑声就足够了。

2867
02:16:48,799 --> 02:16:51,250
This was CS50.
这就是CS50。
