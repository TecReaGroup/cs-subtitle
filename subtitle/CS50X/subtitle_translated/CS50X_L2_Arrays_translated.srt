1
00:00:00,000 --> 00:00:03,486
[MUSIC PLAYING]
[音乐播放]

2
00:01:01,280 --> 00:01:02,510
DAVID MALAN: All right.
大卫·马兰：好的。

3
00:01:02,510 --> 00:01:04,580
This is CS50.
这是 CS50。

4
00:01:04,580 --> 00:01:08,390
This is week 2 wherein we will ultimately learn how to use memory,
这是第二周，我们将最终学习如何使用内存，

5
00:01:08,390 --> 00:01:11,900
but we thought we'd first begin with a bit of story time.
但我们认为应该先从讲故事开始。

6
00:01:11,900 --> 00:01:14,570
And in fact, allow me to walk over to our brave volunteers who
事实上，让我走到我们勇敢的志愿者那里，

7
00:01:14,570 --> 00:01:15,650
have joined us already.
他们已经加入了我们。

8
00:01:15,650 --> 00:01:18,080
First here on my left, we have who?
在我左边的第一个，是谁？

9
00:01:18,080 --> 00:01:19,730
AKSHAYA: Hi, I'm Akshaya.
阿克沙娅：嗨，我是阿克沙娅。

10
00:01:19,730 --> 00:01:22,520
I'm a first year in Mathews, and I'm planning
我是一年级生，在马修斯学习，我计划

11
00:01:22,520 --> 00:01:25,747
on concentrating in chemical and physical biology and CS.
专注于化学和物理生物学以及计算机科学。

12
00:01:25,747 --> 00:01:27,080
DAVID MALAN: Wonderful, welcome.
大卫·马兰：太棒了，欢迎。

13
00:01:27,080 --> 00:01:28,955
And let me have you hang on to the microphone
请你拿着麦克风

14
00:01:28,955 --> 00:01:31,437
first because we've asked Akshaya to tell us a short story.
首先，因为我们请阿克沙娅给我们讲个小故事。

15
00:01:31,437 --> 00:01:33,770
So in your envelope, you have the beginnings of a story.
所以，你的信封里有一个故事的开头。

16
00:01:33,770 --> 00:01:35,353
If you wouldn't mind reading it aloud.
如果你不介意的话，请大声读出来。

17
00:01:35,353 --> 00:01:38,630
And as she reads this, allow us to give some thought as to what
当她读的时候，让我们思考一下

18
00:01:38,630 --> 00:01:41,922
level Akshaya reads at, so to speak.
阿克沙娅的阅读水平，这么说吧。

19
00:01:41,922 --> 00:01:43,880
AKSHAYA: All right, it's a long one, get ready.
阿克沙娅：好吧，它很长，准备好。

20
00:01:43,880 --> 00:01:48,405
One fish, two fish, red fish, blue fish.
一条鱼，两条鱼，红鱼，蓝鱼。

21
00:01:48,405 --> 00:01:50,030
DAVID MALAN: All right, very well done.
大卫·马兰：好的，做得很好。

22
00:01:50,030 --> 00:01:53,302
What grade level would you say she reads at if you think back
如果你回忆起中学、小学，你会说她的阅读水平是几年级？

23
00:01:53,302 --> 00:01:55,010
to your middle school, grade school, when
当老师说你达到了这个水平或者那个水平，或者这个水平的时候？

24
00:01:55,010 --> 00:01:59,490
maybe teacher said you read at this level or maybe this level or this one
也许老师说你达到了这个水平，或者那个水平，或者这个水平。

25
00:01:59,490 --> 00:02:01,530
here?
在这里？

26
00:02:01,530 --> 00:02:03,817
So OK, no offense taken yet.
所以，好的，还没人被冒犯。

27
00:02:03,817 --> 00:02:05,010
AUDIENCE: 1st grade.
观众：一年级。

28
00:02:05,010 --> 00:02:05,550
DAVID MALAN: I'm sorry?
大卫·马兰：你说什么？

29
00:02:05,550 --> 00:02:06,060
AUDIENCE: 1st grade.
观众：一年级。

30
00:02:06,060 --> 00:02:07,018
DAVID MALAN: 1st grade.
大卫·马兰：一年级。

31
00:02:07,018 --> 00:02:08,850
OK, so first grade is just about right.
好的，所以一年级差不多是正确的。

32
00:02:08,850 --> 00:02:12,432
And in fact, according to one algorithm, this text here,
事实上，根据一种算法，这篇文章，

33
00:02:12,432 --> 00:02:14,640
one fish, two fish, red fish, blue fish, would indeed
一条鱼，两条鱼，红鱼，蓝鱼，的确

34
00:02:14,640 --> 00:02:17,830
be considered to actually be 1st grade or just before first grade.
被认为是实际上一年级或者刚上一年级之前。

35
00:02:17,830 --> 00:02:19,530
So let's-- and why is that, though?
所以，让我们——为什么是这样的呢？

36
00:02:19,530 --> 00:02:21,977
Why did you say 1st grade?
你为什么说是一年级？

37
00:02:21,977 --> 00:02:23,060
AUDIENCE: It's very basic.
观众：很简单。

38
00:02:23,060 --> 00:02:23,990
DAVID MALAN: It's very basic.
大卫·马兰：很简单。

39
00:02:23,990 --> 00:02:26,198
But what is it about these words that are very basic?
但是，这些词为什么很简单呢？

40
00:02:26,198 --> 00:02:27,687
Do you want to identify yourself?
你想自我介绍吗？

41
00:02:27,687 --> 00:02:28,270
AKSHAYA: Sure.
阿克沙娅：当然。

42
00:02:28,270 --> 00:02:31,570
They're all one syllable and they're very simple like colors and stuff
它们都是单音节的，而且很简单，就像颜色之类的东西

43
00:02:31,570 --> 00:02:32,070
like that.
那样。

44
00:02:32,070 --> 00:02:32,945
DAVID MALAN: Spot-on.
大卫·马兰：完全正确。

45
00:02:32,945 --> 00:02:35,620
So like they're very short words they're very short sentences.
所以，它们都是很短的词，很短的句子。

46
00:02:35,620 --> 00:02:38,050
And you would expect that of a younger person.
你会期望年轻人是这样。

47
00:02:38,050 --> 00:02:40,822
All right, let's go ahead and hand the mic to your next volunteer
好的，让我们把麦克风递给下一个志愿者

48
00:02:40,822 --> 00:02:42,530
here if you'd like to introduce yourself.
如果你想自我介绍的话。

49
00:02:42,530 --> 00:02:43,030
ETHAN: Yes.
伊森：好的。

50
00:02:43,030 --> 00:02:43,810
Hi, I'm Ethan.
嗨，我是伊森。

51
00:02:43,810 --> 00:02:46,752
I'm a first year in Canada, and I'll be concentrating in economics.
我是一名加拿大的一年级学生，我将专注于经济学。

52
00:02:46,752 --> 00:02:47,710
DAVID MALAN: Wonderful.
大卫·马兰：太棒了。

53
00:02:47,710 --> 00:02:50,860
And in your folder, we have another story to share.
在您的文件夹中，我们还有另一个故事要分享。

54
00:02:50,860 --> 00:02:52,480
ETHAN: Congratulations.
伊森：恭喜你。

55
00:02:52,480 --> 00:02:53,740
Today is your day.
今天是你的日子。

56
00:02:53,740 --> 00:02:55,480
You're off to great places.
你将前往伟大的地方。

57
00:02:55,480 --> 00:02:56,730
You're off and away.
你出发了。

58
00:02:56,730 --> 00:02:59,230
DAVID MALAN: So this text might sound familiar, particularly
大卫·马兰：所以这个文本可能听起来很熟悉，尤其是

59
00:02:59,230 --> 00:03:00,880
on the heels of high school, perhaps.
在高中之后，也许。

60
00:03:00,880 --> 00:03:05,310
What grade level might he be reading at?
他可能在哪个年级阅读？

61
00:03:05,310 --> 00:03:06,450
So maybe 5th grade.
所以可能是五年级。

62
00:03:06,450 --> 00:03:07,620
And why 5th grade?
为什么是五年级？

63
00:03:07,620 --> 00:03:09,740
AUDIENCE: [INAUDIBLE]
观众：[听不清]

64
00:03:09,740 --> 00:03:11,030
DAVID MALAN: OK.
大卫·马兰：好的。

65
00:03:11,030 --> 00:03:11,540
Yeah.
是的。

66
00:03:11,540 --> 00:03:13,040
So a little more complicated.
所以有点复杂。

67
00:03:13,040 --> 00:03:16,850
Like the words-- we've got some more punctuation, we have an apostrophe,
比如这些词——我们有更多标点符号，有一个撇号，

68
00:03:16,850 --> 00:03:17,892
we have longer sentences.
我们有更长的句子。

69
00:03:17,892 --> 00:03:20,392
And indeed, according to one algorithm, not quite 5th grade,
事实上，根据一种算法，还不完全是五年级，

70
00:03:20,392 --> 00:03:22,640
but we would adjudicate your reading level to be 3rd.
但我们会判定你的阅读水平是三年级。

71
00:03:22,640 --> 00:03:25,280
But let's see if we can't do one final flourish here
但让我们看看我们是否可以在这里做最后的润色

72
00:03:25,280 --> 00:03:28,190
if you'd like to introduce yourself and your story.
如果你想介绍你自己和你的故事。

73
00:03:28,190 --> 00:03:29,840
MIKE: Hi, I'm Mike.
迈克：你好，我是迈克。

74
00:03:29,840 --> 00:03:30,920
I'm also a first year.
我也是一年级。

75
00:03:30,920 --> 00:03:33,020
I'm in Weld, and I'm planning on concentrating
我在韦尔德，我计划专注于

76
00:03:33,020 --> 00:03:34,185
in biomedical engineering.
生物医学工程。

77
00:03:34,185 --> 00:03:35,060
DAVID MALAN: Welcome.
大卫·马兰：欢迎。

78
00:03:35,060 --> 00:03:36,980
And your tale?
你的故事？

79
00:03:36,980 --> 00:03:41,750
MIKE: It was a bright, cold day in April and the clocks were striking 13.
迈克：那是一个明媚寒冷的四月天，钟声敲响了13下。

80
00:03:41,750 --> 00:03:45,440
Winston Smith, his chin nuzzled into his breast in an effort
温斯顿·史密斯，他把下巴埋在胸前，试图

81
00:03:45,440 --> 00:03:49,130
to escape the vile wind, slipped quickly through the glass doors
躲避恶风，迅速地穿过玻璃门

82
00:03:49,130 --> 00:03:51,710
of victory mansions, though not quickly enough
胜利豪宅，尽管不够快

83
00:03:51,710 --> 00:03:55,445
to prevent a swirl of gritty dust from entering along with him.
以至于无法阻止一股沙尘随他一起进入。

84
00:03:55,445 --> 00:03:57,320
DAVID MALAN: All right, so escalated quickly.
大卫·马兰：好的，升级很快。

85
00:03:57,320 --> 00:03:59,960
And someone's guess at this reading level?
有人猜想这个阅读水平是多少？

86
00:03:59,960 --> 00:04:01,083
AUDIENCE: 1984.
观众：1984。

87
00:04:01,083 --> 00:04:02,125
DAVID MALAN: What's that?
大卫·马兰：什么？

88
00:04:02,125 --> 00:04:05,320
Oh, OK, 1984 is indeed the text in question, and in what
哦，好的，1984确实是所讨论的文本，你在什么

89
00:04:05,320 --> 00:04:08,050
grade did you perhaps read that book?
年级读过这本书？

90
00:04:08,050 --> 00:04:09,670
So I'm hearing 8th, I'm hearing 10th.
所以我听到的是八年级，我听到的是十年级。

91
00:04:09,670 --> 00:04:12,490
So indeed, 10th grade is what a certain algorithm would actually
所以事实上，十年级是某种算法实际上

92
00:04:12,490 --> 00:04:14,260
adjudicate that reading level to be at.
判定那个阅读水平应该是在。

93
00:04:14,260 --> 00:04:15,610
And consider now the heuristics.
现在考虑一下启发式方法。

94
00:04:15,610 --> 00:04:19,158
So we started with very small words, very small sentences, very easy words,
所以我们从非常小的词语、非常短的句子、非常简单的词语开始，

95
00:04:19,158 --> 00:04:21,700
and then things sort of escalated into more interesting, more
然后事情逐渐升级，变得更加有趣，更加

96
00:04:21,700 --> 00:04:25,460
sophisticated English, more interesting sentence construction and the like.
复杂的英语，更加有趣的句子结构等等。

97
00:04:25,460 --> 00:04:30,640
So I bet if we could somehow capture those characteristics of text,
所以，我敢说，如果我们能够以某种方式捕捉到这些文本的特征，

98
00:04:30,640 --> 00:04:33,250
the length of the words and the lengths of the sentences
词语的长度和句子的长度

99
00:04:33,250 --> 00:04:35,680
and the position of the punctuation, I daresay,
以及标点符号的位置，我敢说，

100
00:04:35,680 --> 00:04:38,878
even using week 1 material and, today, week 2 material,
即使使用第一周的材料，以及今天第二周的材料，

101
00:04:38,878 --> 00:04:41,920
we'll be able to actually write code and implement an algorithm like that
我们将能够实际编写代码并实现这样的算法

102
00:04:41,920 --> 00:04:44,380
can take these spoken words, put them to paper,
可以将这些口语词语写下来，

103
00:04:44,380 --> 00:04:47,590
and actually analyze roughly what that reading level might be.
并实际分析一下那个阅读水平可能是什么。

104
00:04:47,590 --> 00:04:49,390
So that's just a teaser of what lies ahead.
所以这只是对未来的一些预告。

105
00:04:49,390 --> 00:04:52,300
For now, allow us to thank our volunteers, each of whom
现在，让我们感谢我们的志愿者，每个人都

106
00:04:52,300 --> 00:04:55,930
gets a wonderful parting gift here to read at home.
在这里收到一份很棒的离别礼物，可以在家阅读。

107
00:04:55,930 --> 00:04:58,410
[APPLAUSE]
[掌声]

108
00:04:58,410 --> 00:04:58,910
All right.
好的。

109
00:04:58,910 --> 00:05:01,110
And Thank you all so much.
非常感谢大家。

110
00:05:01,110 --> 00:05:05,730
So with that said, there's another domain that we'll explore this week,
所以，我们这周将探索另一个领域，

111
00:05:05,730 --> 00:05:07,730
and indeed, what you'll find in the coming weeks
事实上，在接下来的几周内你会发现

112
00:05:07,730 --> 00:05:11,150
is that beyond just focusing on some of the fundamentals and the basics
除了专注于一些基础知识之外

113
00:05:11,150 --> 00:05:14,330
like we've really done in the past couple of weeks talking about loops
就像我们在过去几周谈论循环那样，我们确实做了

114
00:05:14,330 --> 00:05:16,340
and conditionals and Boolean expressions,
以及条件语句和布尔表达式，

115
00:05:16,340 --> 00:05:19,400
really building blocks or puzzle pieces that we can assemble together,
真正可以拼凑在一起的积木或拼图碎片，

116
00:05:19,400 --> 00:05:22,070
we're going to increasingly start talking about applications
我们将越来越多地开始讨论应用程序

117
00:05:22,070 --> 00:05:25,250
of these ideas which, after all, is why any field is perhaps
这些想法的应用，毕竟，这也是为什么任何领域也许

118
00:05:25,250 --> 00:05:26,460
important and applicable.
很重要且适用。

119
00:05:26,460 --> 00:05:29,510
So here, for instance, we'll consider not only reading levels today,
因此，例如，我们今天将不仅考虑阅读水平，

120
00:05:29,510 --> 00:05:33,630
and in turn, in problem set 2 this week, but also the world of cryptography,
反过来，在本周的习题集 2 中，还有密码学的世界，

121
00:05:33,630 --> 00:05:36,860
which is the art, the science of scrambling, encrypting
它是加密、混淆信息的艺术和科学

122
00:05:36,860 --> 00:05:39,230
information, and ciphering it in such a way
信息，并以这样的方式对其进行加密

123
00:05:39,230 --> 00:05:43,530
that you can send a message securely through the internet, through the air,
这样你就可以通过互联网、通过空中安全地发送消息，

124
00:05:43,530 --> 00:05:46,700
through any medium even though someone might intercept it.
通过任何媒介，即使有人可能会拦截它。

125
00:05:46,700 --> 00:05:49,100
Ideally, thanks to cryptography, they shouldn't
理想情况下，多亏了密码学，他们不应该

126
00:05:49,100 --> 00:05:53,240
be able to decrypt it or actually determine what it there says.
能够解密它或实际确定它上面写了什么。

127
00:05:53,240 --> 00:05:57,560
So for instance, if you were to receive a message like this, at first glance,
例如，如果你收到这样一条消息，乍一看，

128
00:05:57,560 --> 00:05:59,460
it's indeed a bit cryptic.
它确实有点神秘。

129
00:05:59,460 --> 00:06:02,400
Three words maybe, but by day's end, we'll
也许三个词，但到今天结束的时候，我们将

130
00:06:02,400 --> 00:06:04,830
have decrypted even this message for you.
为您解密这条消息。

131
00:06:04,830 --> 00:06:08,550
So up until now, though, we've had some sort of conceptual training wheels on.
然而，直到现在，我们一直在使用一些概念性的辅助轮。

132
00:06:08,550 --> 00:06:12,480
And I gave us this picture last week when we introduced the tool make via
上周我们在介绍工具 make 时给出了这张图片，

133
00:06:12,480 --> 00:06:15,870
which you can make programs out of your source code because you need to turn
你可以用源代码创建程序，因为你需要将

134
00:06:15,870 --> 00:06:18,450
that source code into machine code, the 0's and 1's.
该源代码转换为机器代码，即 0 和 1。

135
00:06:18,450 --> 00:06:20,970
And in the middle here was this thing called a compiler.
中间这个东西叫做编译器。

136
00:06:20,970 --> 00:06:23,790
But it really has been kind of an abstraction for us,
但它确实对我们来说是一种抽象，

137
00:06:23,790 --> 00:06:27,690
and we've sort of had these metaphorical and physical training
我们也有一些隐喻性和物理性的辅助轮

138
00:06:27,690 --> 00:06:30,450
wheels here in the sense that we haven't really
在这里，从某种意义上来说，我们没有真正地

139
00:06:30,450 --> 00:06:34,420
needed to care like what the compiler is doing, how it works and so forth.
需要关心编译器在做什么，它如何工作等等。

140
00:06:34,420 --> 00:06:38,400
But today, what we thought we'd do is peel back a bit of that layer so
但今天，我们想做的是剥离那层的一部分，以便

141
00:06:38,400 --> 00:06:40,410
that even though after today you'll continue
即使在今天之后，你也会继续

142
00:06:40,410 --> 00:06:43,380
to be able to use commands like make and sort of return
能够使用像 make 这样的命令并返回

143
00:06:43,380 --> 00:06:46,275
to the beautiful abstraction that is not caring about some
到那个美好的抽象状态，即不必关心一些

144
00:06:46,275 --> 00:06:48,150
of these lower-level details, we'll offer you
这些较低级别的细节，我们会向你提供

145
00:06:48,150 --> 00:06:49,980
a glimpse of how some of these things work.
一些关于这些东西是如何运作的见解。

146
00:06:49,980 --> 00:06:52,350
Because so that inevitably when something goes wrong,
因为这样，当不可避免地出现问题时，

147
00:06:52,350 --> 00:06:54,540
you've got some bug, you're having some problem,
你遇到了一个错误，你遇到了问题，

148
00:06:54,540 --> 00:06:58,620
you'll have a bottom-up understanding of what it could actually be.
你将对问题可能是什么有一个自下而上的理解。

149
00:06:58,620 --> 00:07:01,620
And indeed, these basics, you'll find, will very often
事实上，你会发现，这些基本知识经常

150
00:07:01,620 --> 00:07:05,230
help you troubleshoot problems and really solve problems more generally.
帮助你解决问题，并且更一般地解决问题。

151
00:07:05,230 --> 00:07:07,920
So here, for instance, is the code that we keep coming back to.
例如，这里就是我们一直反复使用的代码。

152
00:07:07,920 --> 00:07:12,750
And this code here is the simplest of C programs that just says "hello, world."
这里面的代码是最简单的C程序，它只是说“hello, world”。

153
00:07:12,750 --> 00:07:13,960
This is the source code.
这是源代码。

154
00:07:13,960 --> 00:07:16,260
This, we claimed, was the corresponding machine code.
我们声称，这是相应的机器代码。

155
00:07:16,260 --> 00:07:18,810
And it was that program called a compiler that
而且，正是那个被称为编译器的程序

156
00:07:18,810 --> 00:07:20,800
converted one into the other.
将一个转换为另一个。

157
00:07:20,800 --> 00:07:23,100
But let's dive a little more deeply this week
但是，让我们本周更深入地探讨一下

158
00:07:23,100 --> 00:07:25,920
into what we mean by compiling code.
我们所说的编译代码到底是什么意思。

159
00:07:25,920 --> 00:07:28,410
Like what is happening so that by day's end,
就像发生的事情，所以到了晚上，

160
00:07:28,410 --> 00:07:30,910
nothing really feels like magic anymore.
没有什么感觉像魔法了。

161
00:07:30,910 --> 00:07:33,540
It's not just that it goes from source code to machine code
不仅仅是它从源代码变为机器代码

162
00:07:33,540 --> 00:07:37,020
and that's that, you understand what's actually being done for you,
就是这样，你明白为你做了什么，

163
00:07:37,020 --> 00:07:40,694
and frankly, what other humans have done over the decades to make
而且坦白地说，几十年来，其他人做了什么来让

164
00:07:40,694 --> 00:07:45,597
make as beautifully abstract and as simple as it now might seem to be.
让它变得如此抽象，如此简单，以至于现在看起来可能就是如此。

165
00:07:45,597 --> 00:07:47,430
So here are a couple of commands that you've
所以这里有一些你已经

166
00:07:47,430 --> 00:07:50,305
been in the habit of running when you want to first compile your code
习惯运行的命令，当你想要第一次编译你的代码时

167
00:07:50,305 --> 00:07:51,930
and then execute your code.
然后执行你的代码。

168
00:07:51,930 --> 00:07:56,280
But it turns out that make is actually running another command for you.
但事实证明，make实际上为你运行了另一个命令。

169
00:07:56,280 --> 00:07:59,190
The first of several white lies we'll tell in the course
这是我们在这门课程中要讲的几个善意的谎言中的第一个

170
00:07:59,190 --> 00:08:02,040
is that make itself is not a compiler, per se.
就是说make本身并不是编译器。

171
00:08:02,040 --> 00:08:06,580
It's actually a program that automatically runs a compiler for you.
它实际上是一个自动为你运行编译器的程序。

172
00:08:06,580 --> 00:08:07,770
And by that, I mean this.
我的意思是这个。

173
00:08:07,770 --> 00:08:13,650
Let me go over to VS Code here and let me create our familiar hello.c program.
让我转到VS Code，让我创建我们熟悉的hello.c程序。

174
00:08:13,650 --> 00:08:20,310
And I'm going to go ahead and do include stdio.h, int main void, and inside
我将继续进行include stdio.h、int main void，以及在

175
00:08:20,310 --> 00:08:25,027
of the curly braces, printf "hello," comma, "world," backslash n semicolon.
花括号内，printf "hello," 逗号，"world," 反斜杠 n 分号。

176
00:08:25,027 --> 00:08:27,360
So that's the code that we keep writing again and again.
所以，这就是我们一直反复编写的代码。

177
00:08:27,360 --> 00:08:31,932
And up until now, if I wanted to compile that, I would do make hello
到目前为止，如果我想编译它，我会使用make hello

178
00:08:31,932 --> 00:08:35,820
dot slash hello, and voila, now my program is made
点斜杠hello，瞧，现在我的程序已经做好了

179
00:08:35,820 --> 00:08:37,980
and it actually executes.
它实际上是执行的。

180
00:08:37,980 --> 00:08:40,289
But what's actually going on underneath the hood
但是，实际上在幕后

181
00:08:40,289 --> 00:08:43,799
there is that make is running an actual compiler for you,
是make正在为你运行一个真正的编译器，

182
00:08:43,799 --> 00:08:46,980
and the reveal today is that the compiler we have been using
而今天要揭示的是，我们一直在使用的编译器

183
00:08:46,980 --> 00:08:49,170
is something called Clang for C language.
是名为Clang的C语言编译器。

184
00:08:49,170 --> 00:08:51,540
And this is just another program whose purpose in life
而这只是一个程序，它在生命中的目的是

185
00:08:51,540 --> 00:08:54,510
is actually to do the conversion of source code to machine code.
实际上是将源代码转换为机器代码。

186
00:08:54,510 --> 00:08:57,360
But it turns out that Clang by itself can
但事实证明，Clang本身可以

187
00:08:57,360 --> 00:09:00,770
be used very simply like you see here, clang hello.c,
像你在这里看到的一样，非常简单地使用，clang hello.c，

188
00:09:00,770 --> 00:09:04,563
but it doesn't behave nearly as user-friendly as you might like.
但是它不像你期望的那样友好。

189
00:09:04,563 --> 00:09:06,480
So in particular, let me go ahead and do this.
因此，特别是，让我继续做这个。

190
00:09:06,480 --> 00:09:08,960
I'm going to go ahead and remove my compiled program
我将继续删除我编译的程序

191
00:09:08,960 --> 00:09:12,830
by running rm for remove, which I alluded to briefly last time.
通过运行 rm 命令来删除，我上次简要提到了。

192
00:09:12,830 --> 00:09:16,260
And then I'm going to say y for yes, remove that regular file.
然后我会输入 y 表示 yes，删除那个普通文件。

193
00:09:16,260 --> 00:09:21,800
And if I go ahead now and run just clang of hello.c and hit Enter,
如果我现在继续运行 clang hello.c 并按回车键，

194
00:09:21,800 --> 00:09:25,140
it seems to be successful, at least insofar as there's no error messages.
看起来是成功的，至少没有错误信息。

195
00:09:25,140 --> 00:09:27,530
But if I try to do dot slash hello, Enter,
但如果我尝试执行 ./hello 并按回车键，

196
00:09:27,530 --> 00:09:31,070
there is no such file or directory called hello.
没有名为 hello 的文件或目录。

197
00:09:31,070 --> 00:09:34,940
That is because by default, Clang somewhat goofily like just
这是因为默认情况下，Clang 有点傻，就像

198
00:09:34,940 --> 00:09:37,670
outputs a file name called a dot out.
输出一个名为 a.out 的文件。

199
00:09:37,670 --> 00:09:38,480
Like why a?
为什么是 a？

200
00:09:38,480 --> 00:09:42,200
Well, it's sort of a simple name. a dot out, technically for assembler output,
嗯，它是一个简单名称。a.out，技术上用于汇编输出，

201
00:09:42,200 --> 00:09:44,270
but this just means this is the default file
但这只是意味着这是 Clang 将要给我们的默认文件名。

202
00:09:44,270 --> 00:09:45,770
name that Clang is going to give us.
Clang 将要给我们的默认文件名。

203
00:09:45,770 --> 00:09:49,790
So OK, it turns out I can do dot slash a dot out Enter, and voila,
所以，我发现我可以执行 ./a.out 并按回车键，然后，

204
00:09:49,790 --> 00:09:53,723
that now is my program, but that's just a stupid name for a program.
现在它就是我的程序，但这只是一个愚蠢的程序名称。

205
00:09:53,723 --> 00:09:54,890
It's not very user-friendly.
它不太人性化。

206
00:09:54,890 --> 00:09:56,598
It's certainly not an icon you would want
它肯定不是你想

207
00:09:56,598 --> 00:09:58,680
to put on people's desktops or phones.
放在人们的桌面或手机上。

208
00:09:58,680 --> 00:10:00,070
So how can we do better?
所以我们怎样才能做得更好？

209
00:10:00,070 --> 00:10:03,600
Well, it turns out, with Clang, we can configure it using
事实证明，在 Clang 中，我们可以使用

210
00:10:03,600 --> 00:10:05,983
what we'll call command line arguments.
我们称之为命令行参数。

211
00:10:05,983 --> 00:10:09,150
And command line arguments are actually something we've been using thus far,
命令行参数实际上是我们一直在使用的，

212
00:10:09,150 --> 00:10:12,390
we just didn't slap this word on it, but command line arguments
我们只是没有给它加上这个词，但命令行参数

213
00:10:12,390 --> 00:10:15,600
are additional words or shorthand notation
是在命令提示符处输入的额外单词或简写符号，它们以某种方式

214
00:10:15,600 --> 00:10:18,660
that you typed at your command prompt that somehow
以某种方式修改程序的行为。

215
00:10:18,660 --> 00:10:21,270
modify the behavior of a program.
修改程序的行为。

216
00:10:21,270 --> 00:10:23,310
And you can perhaps guess where this is going.
你可能已经猜到这将走向何方。

217
00:10:23,310 --> 00:10:28,140
It turns out that if I actually want to create a program called hello--
事实证明，如果我确实想创建一个名为 hello 的程序，

218
00:10:28,140 --> 00:10:31,200
not a.out, which is the default, I can actually
而不是 a.out，它是默认的，我可以实际

219
00:10:31,200 --> 00:10:36,420
do this-- clang, space, dash lowercase o, space, hello,
执行以下操作：clang，空格，-o，空格，hello，

220
00:10:36,420 --> 00:10:40,260
or whatever I want to call the thing, space, hello.c.
或者我想要给它起任何名字，空格，hello.c。

221
00:10:40,260 --> 00:10:42,630
And now if I hit Enter, nothing seems to happen,
现在如果我按回车键，似乎什么也没发生，

222
00:10:42,630 --> 00:10:48,490
but now if I do ./hello and Enter, now I've actually got that program.
但现在如果我执行 ./hello 并按回车键，我现在就得到了那个程序。

223
00:10:48,490 --> 00:10:49,737
So why is make useful?
那么，为什么 make 有用呢？

224
00:10:49,737 --> 00:10:51,570
Well, it just saves us the trouble of having
嗯，它只是让我们不必每次

225
00:10:51,570 --> 00:10:55,230
to type out this longer line of command any time
都输入这条较长的命令行

226
00:10:55,230 --> 00:10:56,940
we actually want to compile the code.
我们实际上想要编译代码时。

227
00:10:56,940 --> 00:10:59,430
But in fact, it gets even worse than that
但实际上，它比这更糟糕

228
00:10:59,430 --> 00:11:01,860
with commands like clang or compilers in general
对于像 clang 这样的命令或一般的编译器

229
00:11:01,860 --> 00:11:04,470
because consider this code here.
因为考虑一下这里代码。

230
00:11:04,470 --> 00:11:08,010
Not just the version of "hello, world," but maybe the second version wherein
不仅仅是 “hello, world” 的版本，还有可能是第二版，其中

231
00:11:08,010 --> 00:11:11,700
last week, I started to get user input by adding the CS50 Library using
上周，我开始通过使用 CS50 库来获取用户输入

232
00:11:11,700 --> 00:11:14,370
get_string and then saying, "hello," comma, "David."
使用 get_string，然后说：“hello，”逗号，“David”。

233
00:11:14,370 --> 00:11:18,210
Well, if I go back to VS Code and I modify this program
那么，如果我回到 VS Code 并修改这个程序

234
00:11:18,210 --> 00:11:19,810
to be that same one--
变成跟那个一样，

235
00:11:19,810 --> 00:11:23,490
so let me go ahead and include cs50.h at the top.
所以我先在顶部包含 cs50.h。

236
00:11:23,490 --> 00:11:27,000
Let me get rid of this simple print line and instead give myself
我删除这条简单的打印语句，而是给自己

237
00:11:27,000 --> 00:11:33,510
a string called name equals get_string, "What's your name?"
一个名为 name 的字符串，等于 get_string，"What's your name?"。

238
00:11:33,510 --> 00:11:35,610
Question mark, just like we did in Scratch.
问号，就像我们在 Scratch 中做的那样。

239
00:11:35,610 --> 00:11:39,510
Then I can do printf, quote-unquote, "hello," comma.
然后我可以执行 printf，引号-反引号，“hello”，逗号。

240
00:11:39,510 --> 00:11:41,532
And previously I typed "world."
之前我输入了“world”。

241
00:11:41,532 --> 00:11:44,490
I obviously don't want to type "David" because I want it to be dynamic.
我显然不想输入“David”，因为我希望它动态。

242
00:11:44,490 --> 00:11:47,430
What did I type last week for as a placeholder?
上周我输入了什么作为占位符？

243
00:11:47,430 --> 00:11:50,980
So yeah, just-- not Command-S, but %S. So %S in this case,
所以，是的，只是——不是 Command-S，而是 %S。在本例中，%S

244
00:11:50,980 --> 00:11:53,070
which is a placeholder for any such string.
是任何此类字符串的占位符。

245
00:11:53,070 --> 00:11:56,550
Then I can still do my new line, close, quote, comma, and then
然后我仍然可以进行我的新行，关闭、引号、逗号，然后

246
00:11:56,550 --> 00:12:00,630
I can substitute in something like the value of the name variable.
我可以替换成类似于名称变量的值。

247
00:12:00,630 --> 00:12:03,430
All right, so if I go ahead now and compile this,
好的，所以如果我现在继续编译它，

248
00:12:03,430 --> 00:12:06,300
now last week, I could just do make hello and I'm on my way,
上周，我可以直接执行 make hello，然后我就完成了，

249
00:12:06,300 --> 00:12:07,570
it worked just fine.
它运行良好。

250
00:12:07,570 --> 00:12:10,440
But if I instead do clang manually, it turns out
但是，如果我手动执行 clang，结果发现

251
00:12:10,440 --> 00:12:16,650
that this is not going to be sufficient now. clang -o hello, space, hello.c.
现在这样就不够用了。clang -o hello，空格，hello.c。

252
00:12:16,650 --> 00:12:19,200
Exact same thing I typed a moment ago, but I
我刚才输入的完全一样，但是我

253
00:12:19,200 --> 00:12:21,940
think I'm going to see some errors.
认为我将看到一些错误。

254
00:12:21,940 --> 00:12:24,580
So what's this error hinting at here?
那么这里这个错误暗示着什么？

255
00:12:24,580 --> 00:12:27,120
Well, at the very bottom, it's a bit arcane with its output,
好吧，在最底部，它的输出有点神秘，

256
00:12:27,120 --> 00:12:30,400
and much of this you can ignore, but there are some certain key words.
而且很多东西你可以忽略，但是有一些关键的词。

257
00:12:30,400 --> 00:12:33,240
What's the first maybe keyword you recognize in these three
在这些三行错误输出中，你第一个认出来的关键词是什么？

258
00:12:33,240 --> 00:12:36,130
lines of erroneous output?
错误的输出？

259
00:12:36,130 --> 00:12:37,273
So it mentions main.
它提到了 main。

260
00:12:37,273 --> 00:12:40,440
That's not that much of a clue because that's the only thing I wrote so far.
这不是什么线索，因为那是迄今为止我唯一写的。

261
00:12:40,440 --> 00:12:42,060
Second line, though, get_string.
第二行，get_string。

262
00:12:42,060 --> 00:12:46,050
There's some issue with an undefined reference to get_string.
存在对 get_string 的未定义引用问题。

263
00:12:46,050 --> 00:12:47,590
Now why might that be?
现在，为什么会出现这种情况？

264
00:12:47,590 --> 00:12:51,820
I did include cs50.h, but that's apparently not
我已经包含了 cs50.h，但这显然不够

265
00:12:51,820 --> 00:12:54,520
enough to teach the compiler about get_string.
让编译器了解 get_string。

266
00:12:54,520 --> 00:12:58,630
Well, it turns out that if you're using a third-party library, one
好吧，事实证明，如果你正在使用第三方库，也就是

267
00:12:58,630 --> 00:13:02,740
that doesn't necessarily come with C the language, something like CS50's, it
并不一定随 C 语言提供的库，像 CS50 的库，它

268
00:13:02,740 --> 00:13:05,860
turns out that you additionally have to tell the compiler that you
事实证明，你还要额外告诉编译器，你要

269
00:13:05,860 --> 00:13:07,060
want to use that library.
使用这个库。

270
00:13:07,060 --> 00:13:08,890
And not just by including the header file,
不仅仅是包含头文件，

271
00:13:08,890 --> 00:13:11,450
but by an additional command as well.
还需要额外的命令。

272
00:13:11,450 --> 00:13:15,010
So when you run Clang, you want to provide an additional
所以当你运行 Clang 时，你要提供额外的

273
00:13:15,010 --> 00:13:16,900
rather command line argument.
命令行参数。

274
00:13:16,900 --> 00:13:21,580
Literally -l for library, which is a term I used last week, cs50.
确切地说，是 -l，代表 library，这是我上周用过的术语，cs50。

275
00:13:21,580 --> 00:13:23,620
A library is just code that someone else wrote
库就是别人写的代码，

276
00:13:23,620 --> 00:13:25,640
that you want to use in your project.
你想要在你的项目中使用的代码。

277
00:13:25,640 --> 00:13:29,380
So if I really want to compile this version that uses the CS50 Library,
所以，如果我真的想要编译使用 CS50 库的版本，

278
00:13:29,380 --> 00:13:34,660
I can still do clang o hello hello.c, but before I finish my thought,
我仍然可以执行 clang o hello hello.c，但是在完成我的思路之前，

279
00:13:34,660 --> 00:13:40,450
I need to tell the compiler to link, so to speak, in the library CS50.
我需要告诉编译器，用通俗的话来说，链接进 CS50 库。

280
00:13:40,450 --> 00:13:44,350
And now I hit Enter, the error message goes away, I can do ./hello,
现在我按下回车键，错误信息消失了，我可以执行 ./hello，

281
00:13:44,350 --> 00:13:47,410
I can type in my name, and voila, we're back to week 1.
我可以输入我的名字，瞧，我们回到了第一周。

282
00:13:47,410 --> 00:13:49,987
And this is why, suffice it to say, we introduce make,
这就是为什么，简而言之，我们引入了 make，

283
00:13:49,987 --> 00:13:51,070
which is not a CS50 thing.
它不是 CS50 的东西。

284
00:13:51,070 --> 00:13:54,070
This is a popular tool that real people in the real world
这是一个流行的工具，现实世界中的人们

285
00:13:54,070 --> 00:13:56,480
use to automate these kinds of processes.
用来自动化这些流程。

286
00:13:56,480 --> 00:13:59,050
So unbeknownst to you, make has been using
所以，在你不知情的情况下，make一直在使用

287
00:13:59,050 --> 00:14:03,670
the -o for you. make, unbeknownst to you, has been using -l cs50 for you
-o 为你。make，在你不知情的情况下，一直在为你使用 -l cs50

288
00:14:03,670 --> 00:14:06,650
just because it makes our lives easier.
仅仅是因为它让我们的生活更轻松。

289
00:14:06,650 --> 00:14:08,560
But today, we thought we would deliberately
但今天，我们想故意

290
00:14:08,560 --> 00:14:11,440
peel back this layer so we at least understand
剥离这一层，这样我们至少能理解

291
00:14:11,440 --> 00:14:16,300
what's going on behind this abstraction that is make itself
make本身这种抽象背后的运作方式

292
00:14:16,300 --> 00:14:17,750
and compiling more generally.
以及更一般意义上的编译。

293
00:14:17,750 --> 00:14:21,880
So let me propose that compiling itself is not quite what
所以，我想说，编译本身并不完全是我们所描述的那样。

294
00:14:21,880 --> 00:14:22,960
we've described it to be.
我们所描述的那样。

295
00:14:22,960 --> 00:14:25,840
Compiling is like this catch-all phrase that apparently I claim
编译就像是一个包罗万象的词语，我似乎认为

296
00:14:25,840 --> 00:14:27,650
goes from source code to machine code.
它可以将源代码转换为机器码。

297
00:14:27,650 --> 00:14:30,710
But if we really want to get pedantic, which we'll do briefly,
但如果我们真的想要吹毛求疵，我们会简要地做到这一点，

298
00:14:30,710 --> 00:14:33,640
but this is not a sign of things to come because this, too,
但这并非将来会发生的事情的预兆，因为这件事也

299
00:14:33,640 --> 00:14:39,250
will be abstract away, compiling is just one of four steps that are involved
会被抽象掉，编译只是涉及的四个步骤之一

300
00:14:39,250 --> 00:14:43,010
in turning source code that you and I write into those 0's and 1's.
将你我编写的源代码转换为0和1。

301
00:14:43,010 --> 00:14:45,010
But through an understanding of these four steps
但通过理解这四个步骤

302
00:14:45,010 --> 00:14:46,780
today, you'll hopefully better understand
今天，你将有望更好地理解

303
00:14:46,780 --> 00:14:49,480
how to troubleshoot issues like that and just know
如何解决此类问题，并了解

304
00:14:49,480 --> 00:14:51,680
what's happening because it's not, in fact, magic.
发生了什么，因为它实际上不是魔法。

305
00:14:51,680 --> 00:14:55,850
It's just the result of years of humans developing these four steps here.
它只是人类多年来开发这四个步骤的结果。

306
00:14:55,850 --> 00:14:58,870
So when you run make, what's happening?
所以，当你运行 make 时，发生了什么？

307
00:14:58,870 --> 00:15:02,450
Or in turn, when you run clang, four different things are happening.
或者，当你运行 clang 时，会发生四种不同的情况。

308
00:15:02,450 --> 00:15:04,360
And the first one is called pre-processing.
第一个被称为预处理。

309
00:15:04,360 --> 00:15:05,720
So what is this all about?
这到底是怎么回事呢？

310
00:15:05,720 --> 00:15:07,270
Well, let's consider this code here.
那么，让我们看一下这里的代码。

311
00:15:07,270 --> 00:15:09,730
And this code is a little bit interesting
这段代码有点意思

312
00:15:09,730 --> 00:15:13,850
insofar as it's one of the more complicated examples from last week.
因为它是在上周比较复杂的例子之一。

313
00:15:13,850 --> 00:15:18,550
And you'll notice, for instance, that I had include stdio at the top
你会注意到，例如，我在顶部添加了 include stdio

314
00:15:18,550 --> 00:15:19,900
so I could use printf.
以便可以使用 printf。

315
00:15:19,900 --> 00:15:24,340
I had main down here, whose purpose in life was just to meow three times.
我在这里写了 main，它的作用就是喵叫三声。

316
00:15:24,340 --> 00:15:27,880
And then recall we made our own meow function just like we did in week 0
然后回想一下，我们就像在第 0 周使用 Scratch 一样，创建了自己的 meow 函数

317
00:15:27,880 --> 00:15:31,630
with Scratch that just printed out, quote-unquote, "meow."
它只是打印出“喵”这个词。

318
00:15:31,630 --> 00:15:37,210
But I also included this line here, which we called what?
但我还在此处添加了这一行，我们称它为什么？

319
00:15:37,210 --> 00:15:39,760
This was a prototype.
这是一个原型。

320
00:15:39,760 --> 00:15:41,470
And why did I have to include it there?
为什么我必须在那里添加它？

321
00:15:41,470 --> 00:15:45,070
Or equivalently, what would happen if I didn't include a prototype up
或者等同地，如果我不在上面添加原型，会发生什么？

322
00:15:45,070 --> 00:15:45,790
at the top there?
在顶部？

323
00:15:45,790 --> 00:15:46,693
Yeah?
对吧？

324
00:15:46,693 --> 00:15:51,255
AUDIENCE: [INAUDIBLE]
观众： [听不清]

325
00:15:51,255 --> 00:15:52,130
DAVID MALAN: Exactly.
大卫·马兰：没错。

326
00:15:52,130 --> 00:15:55,820
If I didn't include it up here, the program, when trying to compile main,
如果我不在这里添加它，程序在尝试编译 main 时，

327
00:15:55,820 --> 00:15:59,370
would not know what meow is because it's not defined until later.
将不知道 meow 是什么，因为它直到后面才会被定义。

328
00:15:59,370 --> 00:16:02,210
So this is kind of like a little hint of what is to come.
所以，这有点像对未来即将发生的事情的暗示。

329
00:16:02,210 --> 00:16:05,750
Alternatively, we could just move this whole thing up at the top of the file,
或者，我们可以直接将整个内容移到文件的顶部，

330
00:16:05,750 --> 00:16:08,120
but I claim that just devolves into a big mess
但我认为这最终会导致混乱

331
00:16:08,120 --> 00:16:10,250
eventually once you have many different functions.
最终，当你有很多不同的函数时。

332
00:16:10,250 --> 00:16:13,590
Like you can't realistically put them all at the top to solve this problem.
就像你不能现实地把它们都放在顶部来解决这个问题。

333
00:16:13,590 --> 00:16:15,870
So these prototypes solve that problem.
所以这些原型解决了这个问题。

334
00:16:15,870 --> 00:16:16,760
So nothing new here.
所以这里没有新东西。

335
00:16:16,760 --> 00:16:20,750
Just a reminder of what motivated this one line of prototype.
只是一个提醒，是什么促使了这行原型代码的出现。

336
00:16:20,750 --> 00:16:24,290
Now let's consider this simpler program, which
现在让我们考虑这个更简单的程序，它

337
00:16:24,290 --> 00:16:26,945
is just the one we wrote most recently in VS Code.
只是我们最近在 VS Code 中编写的那个程序。

338
00:16:26,945 --> 00:16:28,820
This program prompts the human for their name
这个程序提示用户输入他们的姓名

339
00:16:28,820 --> 00:16:30,590
and then says hello to that person.
然后跟那个人打招呼。

340
00:16:30,590 --> 00:16:33,710
But it has two includes at the top of the file.
但它在文件顶部有两个包含语句。

341
00:16:33,710 --> 00:16:37,070
And in fact, any line of C that starts with this hash symbol
事实上，任何以这个井号开头的 C 代码行

342
00:16:37,070 --> 00:16:40,220
is what we'll call now a preprocessor directive.
我们现在称之为预处理指令。

343
00:16:40,220 --> 00:16:42,950
It's not really a word you need to remember in your vocabulary,
这不是一个你需要记住的词汇，

344
00:16:42,950 --> 00:16:46,310
but it is a little bit different from most every other line
但它与大多数其他代码行略有不同，

345
00:16:46,310 --> 00:16:47,900
because it starts with that hash.
因为它以井号开头。

346
00:16:47,900 --> 00:16:50,420
That's a special symbol in C.
这是 C 语言中的一个特殊符号。

347
00:16:50,420 --> 00:16:52,750
And what this means is the following.
它的意思如下。

348
00:16:52,750 --> 00:16:57,570
This very first line, cs50.h, is indeed a file that I and CS50 staff
这第一行，cs50.h，实际上是一个文件，我和 CS50 员工

349
00:16:57,570 --> 00:17:02,400
wrote and we installed somewhere in VS Code for you, somewhere in the cloud.
编写了并在 VS Code 中的某个地方为你安装了，在云端的某个地方。

350
00:17:02,400 --> 00:17:07,859
And I've claimed you need to use this header file in order to use get_string.
我声称你需要使用这个头文件才能使用 get_string 函数。

351
00:17:07,859 --> 00:17:12,290
So just logically, what is probably inside of cs50.h?
所以从逻辑上讲，cs50.h 里面可能是什么？

352
00:17:15,089 --> 00:17:16,170
Yeah?
是吧？

353
00:17:16,170 --> 00:17:17,610
AUDIENCE: Function [INAUDIBLE].
观众：函数 [听不清]。

354
00:17:23,628 --> 00:17:24,670
DAVID MALAN: Super close.
大卫·马兰：非常接近。

355
00:17:24,670 --> 00:17:27,589
So the function called get_string that does the getting of a string,
所以名为 get_string 的函数负责获取字符串，

356
00:17:27,589 --> 00:17:30,038
but it's not quite as much as the function itself.
但它并不完全是函数本身。

357
00:17:30,038 --> 00:17:33,080
It's actually a little bit less than that, but you're on the right track.
它实际上比这少一点，但你走在正确的轨道上。

358
00:17:33,080 --> 00:17:37,940
What is inside of cs50.h, presumably?
cs50.h 里面可能是什么？

359
00:17:37,940 --> 00:17:40,560
Just a what?
只是一个什么？

360
00:17:40,560 --> 00:17:43,770
Just a prototype for?
只是一个原型？

361
00:17:43,770 --> 00:17:44,820
Which function?
哪个函数？

362
00:17:44,820 --> 00:17:45,750
get_string.
get_string 函数。

363
00:17:45,750 --> 00:17:48,390
So admittedly, there's some other stuff in there, too,
所以说，里面还有一些其他的东西，

364
00:17:48,390 --> 00:17:51,930
but the important line for today's discussion is that inside of cs50.h
但今天讨论中重要的是，在 cs50.h 里面

365
00:17:51,930 --> 00:17:55,740
is indeed one line of code that defines what the return value, what
确实有一行代码定义了返回值，

366
00:17:55,740 --> 00:17:59,610
the name is, and what the arguments, if any, are to get_string,
名称是什么，以及 get_string 函数的参数是什么，如果有的话，

367
00:17:59,610 --> 00:18:00,880
and some other stuff.
以及一些其他的东西。

368
00:18:00,880 --> 00:18:05,130
And so what happens effectively when you compile your code,
所以当你在编译你的代码时，实际上发生了什么，

369
00:18:05,130 --> 00:18:07,080
step 1 is this pre-processing line.
第一步是这一行预处理代码。

370
00:18:07,080 --> 00:18:09,960
And essentially, there is some code that someone else wrote inside
本质上，有一些代码是由其他人编写的，它们位于

371
00:18:09,960 --> 00:18:13,710
of the clang compiler that looks for a line that starts with hash include,
clang 编译器中，它们会查找以井号 include 开头的代码行，

372
00:18:13,710 --> 00:18:17,580
and when it sees that, it goes and finds this file and effectively copies
当它看到这个时，它会去找到这个文件，并有效地复制

373
00:18:17,580 --> 00:18:21,240
and pastes the contents of that file right there into your code
并将该文件的内容粘贴到你的代码中，

374
00:18:21,240 --> 00:18:23,130
so that you don't have to go find the file,
这样你就不用去找到这个文件，

375
00:18:23,130 --> 00:18:25,840
copy and paste it, and make a mess of your own code.
复制粘贴它，并把你的代码弄乱。

376
00:18:25,840 --> 00:18:29,550
So in particular, it's effectively as though you're copying and pasting
因此，实际上就像你在复制粘贴

377
00:18:29,550 --> 00:18:32,910
the prototype of get_string to the very top of your file,
get_string 函数的原型到你的文件顶部，

378
00:18:32,910 --> 00:18:35,550
thereby teaching the compiler that it exists.
从而告诉编译器它存在。

379
00:18:35,550 --> 00:18:38,550
By that same logic, what is probably in stdio.h?
按照同样的逻辑，stdio.h 里面可能是什么？

380
00:18:41,740 --> 00:18:43,690
The prototype for?
用于什么？

381
00:18:43,690 --> 00:18:44,710
For printf.
用于printf。

382
00:18:44,710 --> 00:18:46,280
And indeed, exactly that.
没错，正是它。

383
00:18:46,280 --> 00:18:49,450
So this line effectively gets replaced with the equivalent
因此，这行代码实际上被替换成了等效的

384
00:18:49,450 --> 00:18:52,150
of the prototype for printf, which, for today's purposes,
printf的原型，为了今天的目的，

385
00:18:52,150 --> 00:18:55,210
is a bit more complicated, so let me wave my hand at the dot-dot-dot
它有点复杂，所以让我用省略号来表示它

386
00:18:55,210 --> 00:18:57,850
just because it takes a variable number of arguments
因为它接受可变数量的参数

387
00:18:57,850 --> 00:19:00,760
depending on how many placeholders or format codes you have.
取决于你有多少个占位符或格式代码。

388
00:19:00,760 --> 00:19:03,290
But effectively, that, too, is what's happening.
但实际上，这也是正在发生的事情。

389
00:19:03,290 --> 00:19:06,190
So the preprocessor step, step 1 of 4, just
所以预处理步骤，4 个步骤中的第一个，只是

390
00:19:06,190 --> 00:19:08,097
does that find and replace, if you will.
进行查找和替换，如果你愿意的话。

391
00:19:08,097 --> 00:19:10,430
Now there's some-- again, some other stuff in that file,
现在文件里还有一些其他的东西，

392
00:19:10,430 --> 00:19:12,580
and this, too, is kind of a white lie. printf
这又是一个善意的谎言。printf

393
00:19:12,580 --> 00:19:15,790
probably has its own file because that's a really big library,
可能拥有它自己的文件，因为这是一个非常大的库，

394
00:19:15,790 --> 00:19:17,930
but the essence of it is exactly this.
但其本质就是这个。

395
00:19:17,930 --> 00:19:21,010
So preprocessing converts all of those hash
所以预处理会将所有这些哈希

396
00:19:21,010 --> 00:19:24,520
include lines to whatever the underlying prototypes are
include 行转换为底层原型

397
00:19:24,520 --> 00:19:26,650
within the file plus some other stuff.
在文件内部加上一些其他的东西。

398
00:19:26,650 --> 00:19:29,920
Now compiling we use it as this catch-all phrase, but it turns out,
现在，我们用它作为这个万能词语，但事实证明，

399
00:19:29,920 --> 00:19:32,100
it has a very specific meaning that's worth
它有一个非常具体的含义，值得

400
00:19:32,100 --> 00:19:33,850
knowing about even though after today, you
了解，即使在今天之后，你

401
00:19:33,850 --> 00:19:37,120
can go back to using compiling as the sort of catch-all phrase.
可以回到使用编译作为万能词语。

402
00:19:37,120 --> 00:19:41,390
So when you've got this same code here after the pre-processing step
所以，当你预处理步骤之后有了这段代码时，

403
00:19:41,390 --> 00:19:42,420
has happened.
已经完成。

404
00:19:42,420 --> 00:19:44,900
So this is essentially happening in the computer's memory.
所以，这实质上发生在计算机的内存中。

405
00:19:44,900 --> 00:19:49,400
It's not changing your hello.c file permanently or anything like that.
它不会永久改变你的 hello.c 文件，或者类似的操作。

406
00:19:49,400 --> 00:19:54,890
This code gets, quote-unquote, "compiled" into something
这段代码被“编译”成了

407
00:19:54,890 --> 00:19:57,120
that looks more like this.
看起来像这样。

408
00:19:57,120 --> 00:19:59,660
And this is a scarier language that we won't spend time
这是一种更可怕的语言，我们不会在这门课上花时间

409
00:19:59,660 --> 00:20:00,860
on in this particular class.
来学习它。

410
00:20:00,860 --> 00:20:02,690
This is what's known as assembly language.
这就是所谓的汇编语言。

411
00:20:02,690 --> 00:20:06,710
And back in the day, before there was C, humans
在 C 出现之前，人类

412
00:20:06,710 --> 00:20:09,110
wrote this to program their computers.
用它来编写程序。

413
00:20:09,110 --> 00:20:12,440
Similarly, before there was assembly code back in the day,
同样地，在汇编语言出现之前，

414
00:20:12,440 --> 00:20:15,163
humans very initially used what instead?
人类最开始使用什么来代替它？

415
00:20:15,163 --> 00:20:16,080
AUDIENCE: 0's and 1's.
观众：0 和 1。

416
00:20:16,080 --> 00:20:19,430
DAVID MALAN: So 0's and 1's-- like they actually wrote the machine code
戴维·马兰：所以 0 和 1 -- 他们实际上写了机器码

417
00:20:19,430 --> 00:20:23,360
painfully, be it in code or be it in punch cards like physical objects
非常痛苦，无论是代码还是像打孔卡这样的物理对象

418
00:20:23,360 --> 00:20:24,000
or the like.
或者类似的东西。

419
00:20:24,000 --> 00:20:25,730
So again, these are sort of abstractions,
所以，这些都是抽象的概念，

420
00:20:25,730 --> 00:20:27,660
but we're rewinding for today in time.
但我们今天要回顾一下。

421
00:20:27,660 --> 00:20:30,860
But what this compiler for C is doing is converting C
但 C 语言的编译器所做的是将 C 语言

422
00:20:30,860 --> 00:20:33,380
into this other language called assembly language.
转换为另一种叫做汇编语言的语言。

423
00:20:33,380 --> 00:20:35,630
And even though this looks very esoteric,
虽然这看起来很深奥，

424
00:20:35,630 --> 00:20:37,940
there's at least some juicy things in here.
这里至少有一些有趣的东西。

425
00:20:37,940 --> 00:20:40,580
If I highlight get_string, it's mentioned in this code.
如果我高亮显示 get_string，它在这段代码中被提及。

426
00:20:40,580 --> 00:20:42,560
printf is mentioned in this code.
printf 在这段代码中被提及。

427
00:20:42,560 --> 00:20:44,540
And even some of these keywords here that
甚至这里的一些关键字

428
00:20:44,540 --> 00:20:48,320
are spelled a bit weirdly, this relates to subtracting and moving
拼写有点奇怪，这与减法和移动有关。

429
00:20:48,320 --> 00:20:51,480
something in memory and calling a function, calling a function.
内存中的一些东西以及调用函数，调用函数。

430
00:20:51,480 --> 00:20:53,450
So there's some semantics that are probably
因此，有一些语义可能

431
00:20:53,450 --> 00:20:56,690
somewhat familiar even though this is not code we ourselves will write.
多少有些熟悉，即使这不是我们自己会写的代码。

432
00:20:56,690 --> 00:20:59,670
But unfortunately, this is not yet machine code,
但不幸的是，这还不是机器码，

433
00:20:59,670 --> 00:21:02,370
and that's where step 3 comes in.
这就是第 3 步发挥作用的地方。

434
00:21:02,370 --> 00:21:06,470
So step 3 of this four-step process is technically called assembling.
因此，这四个步骤中的第 3 步在技术上被称为汇编。

435
00:21:06,470 --> 00:21:12,320
And assembling just takes that assembly code and converts it, thankfully,
而汇编只是将汇编代码转换，谢天谢地，

436
00:21:12,320 --> 00:21:15,650
to the thing we do care about, the 0's and 1's.
转换成了我们关心的东西，0 和 1。

437
00:21:15,650 --> 00:21:18,830
So assembling takes assembly code converts it to 0's and 1's.
因此，汇编将汇编代码转换为 0 和 1。

438
00:21:18,830 --> 00:21:21,020
As an aside, and I alluded to this earlier,
顺便说一下，我之前提到了这一点，

439
00:21:21,020 --> 00:21:26,810
the reason that Clang names its files a.out by default, assembler output,
Clang 默认将它的文件命名为 a.out 的原因是，汇编器输出，

440
00:21:26,810 --> 00:21:30,740
is a side effect of that being one of the steps in this process,
这是该过程中的一个步骤的副作用，

441
00:21:30,740 --> 00:21:33,740
dealing with assembly language and its subsequent output.
处理汇编语言及其后续输出。

442
00:21:33,740 --> 00:21:36,680
All right, so here are some 0's and 1's, but unfortunately, there's
好的，所以这里有一些 0 和 1，但不幸的是，还有

443
00:21:36,680 --> 00:21:41,340
still that fourth and final step, which is a word that I also used earlier,
第四步也是最后一步，这也是我之前用过的词，

444
00:21:41,340 --> 00:21:42,620
namely linking.
就是链接。

445
00:21:42,620 --> 00:21:45,420
So let me take a step back and look at this code here.
所以让我退一步看看这里面的代码。

446
00:21:45,420 --> 00:21:50,090
And even though this code is exactly as I wrote in VS Code in hello.c--
即使这段代码与我在 VS Code 中 hello.c 中写的完全一样——

447
00:21:50,090 --> 00:21:52,310
so no copying and pasting, no prototypes have
所以没有复制粘贴，也没有原型

448
00:21:52,310 --> 00:21:55,610
been plugged in here, this is my code, technically, there's
被插入到这里，这是我的代码，从技术上讲，这里有

449
00:21:55,610 --> 00:21:59,270
three different files involved in compiling even something relatively
三个不同的文件参与编译，即使是像这样相对

450
00:21:59,270 --> 00:22:00,170
simple like this.
简单的东西。

451
00:22:00,170 --> 00:22:03,560
There's obviously this thing itself, hello.c, which I wrote.
很明显，这里有它自己，hello.c，是我写的。

452
00:22:03,560 --> 00:22:08,600
There's apparently cs50.h, and there's apparently stdio.h.
很明显有 cs50.h，还有 stdio.h。

453
00:22:08,600 --> 00:22:12,650
But technically-- and you don't have to know this file name, per se, somewhere
但从技术上讲——你不需要知道这个文件名，本身来说，在某个地方

454
00:22:12,650 --> 00:22:15,540
else on the computer's hard drive, so to speak,
在计算机的硬盘驱动器上，可以这么说，

455
00:22:15,540 --> 00:22:19,520
is a cs50.c file, which actually contains
有一个 cs50.c 文件，它实际上包含

456
00:22:19,520 --> 00:22:22,910
the staff's implementation of get_string and get_int and get_float
工作人员对 get_string、get_int 和 get_float 的实现

457
00:22:22,910 --> 00:22:24,320
and all of those other functions.
以及所有其他函数。

458
00:22:24,320 --> 00:22:28,460
Somewhere on the server's hard drive is stdio.c
服务器硬盘驱动器上的某个地方是 stdio.c

459
00:22:28,460 --> 00:22:31,890
that implements printf and all of these other functions as well.
它实现了 printf 以及所有其他函数。

460
00:22:31,890 --> 00:22:34,940
So the dot c is just inferred from the dot h here.
所以这里的 .c 是从 .h 推断出来的。

461
00:22:34,940 --> 00:22:38,450
You don't ever mention the dot c file, but someone else wrote those files,
你从未提到过 .c 文件，但其他人编写了这些文件，

462
00:22:38,450 --> 00:22:41,570
someone else stored them in the server for you--
其他人将它们存储在服务器上供你使用——

463
00:22:41,570 --> 00:22:43,220
CS50 staff in this case.
在本例中是 CS50 工作人员。

464
00:22:43,220 --> 00:22:47,270
So technically, even when compiling a relatively short program like this,
因此，从技术上讲，即使编译像这样相对较短的程序，

465
00:22:47,270 --> 00:22:51,920
you're really combining three files at least at the end of the day.
你最终实际上至少将三个文件组合在一起。

466
00:22:51,920 --> 00:22:54,020
And I'll write them from left to right. hello.c,
我会从左到右写它们。hello.c，

467
00:22:54,020 --> 00:23:01,920
which I wrote, cs50.c, which the staff wrote, and then stdio.c as well.
是我写的，cs50.c 是工作人员写的，还有 stdio.c。

468
00:23:01,920 --> 00:23:04,010
So somewhere there's these three files.
所以某个地方有这三个文件。

469
00:23:04,010 --> 00:23:08,540
And Clang, our compiler, needs to compile each of these
而 Clang，我们的编译器，需要将这些文件中的每一个

470
00:23:08,540 --> 00:23:12,500
into the corresponding 0's and 1's.
编译成相应的 0 和 1。

471
00:23:12,500 --> 00:23:17,300
Lastly, this is not yet sufficient because these 0's and 1's haven't
最后，这还不够，因为这些 0 和 1 还没有

472
00:23:17,300 --> 00:23:18,333
been linked together.
链接在一起。

473
00:23:18,333 --> 00:23:20,750
I mean, I deliberately left a gap here to imply that these
我的意思是，我故意在这里留出空隙来暗示这些

474
00:23:20,750 --> 00:23:22,880
are three separately-compiled files.
是三个单独编译的文件。

475
00:23:22,880 --> 00:23:25,760
So that fourth and final step called linking
所以第四个也是最后一个步骤叫做链接

476
00:23:25,760 --> 00:23:28,430
takes all of these 0's and 1's and an intelligent way
将所有这些 0 和 1 以一种智能的方式

477
00:23:28,430 --> 00:23:35,300
combines them into just one final file named hello, named a.out,
组合成一个最终文件，名为 hello，名为 a.out，

478
00:23:35,300 --> 00:23:37,680
whatever the file name is of choice.
无论你选择的文件名是什么。

479
00:23:37,680 --> 00:23:40,820
So what you and I for the past week have just been calling compiling--
所以过去一周我们一直所说的编译——

480
00:23:40,820 --> 00:23:43,550
and that's what a normal person will use henceforth
这就是普通人以后会用的

481
00:23:43,550 --> 00:23:46,490
to describe this whole process, technically, there's
来描述整个过程，从技术上来说，这里

482
00:23:46,490 --> 00:23:49,250
these four different steps underneath the hood, each of which
有四个不同的步骤，每一个步骤

483
00:23:49,250 --> 00:23:55,067
is sort of a representative of an evolution of technology over the years.
在某种程度上代表了多年来技术的演变。

484
00:23:55,067 --> 00:23:56,900
And nowadays, if we fast forward a few weeks
现在，如果我们快进几周

485
00:23:56,900 --> 00:23:59,780
in class, when we start talking about Python, which
在课堂上，当我们开始讨论 Python 时，它

486
00:23:59,780 --> 00:24:03,710
is another more modern language, that, too, is going to be conceptually even
是另一种更现代的语言，它在概念上也

487
00:24:03,710 --> 00:24:06,090
higher level, even though underneath the hood,
更高级，即使在幕后，

488
00:24:06,090 --> 00:24:09,330
there's going to be some lower-level principles at work.
也有一些底层原理在起作用。

489
00:24:09,330 --> 00:24:16,010
So any questions on just terminology or these processes known as compiling?
所以关于术语或这些被称为编译的过程，有什么问题吗？

490
00:24:16,010 --> 00:24:17,462
Yeah?
是吧？

491
00:24:17,462 --> 00:24:19,879
AUDIENCE: I didn't really understand what compiling means.
观众：我不太明白编译是什么意思。

492
00:24:19,879 --> 00:24:21,360
[INAUDIBLE]
[听不清]

493
00:24:21,360 --> 00:24:22,110
DAVID MALAN: Sure.
大卫·马兰：当然。

494
00:24:22,110 --> 00:24:29,400
Compiling, if I rewind, is the process of taking your source code, which
如果我倒回去，编译就是将你的源代码，它

495
00:24:29,400 --> 00:24:35,260
looks like this, recall-- whoops, this, and converting it into assembly code.
看起来像这样，回忆一下——哎哟，这个，然后把它转换成汇编代码。

496
00:24:35,260 --> 00:24:38,640
So preprocessing just converts all of those hash
所以预处理只是将所有这些哈希

497
00:24:38,640 --> 00:24:41,470
include lines and a few others to their equivalents.
include 行和一些其他的行转换为它们的等价物。

498
00:24:41,470 --> 00:24:42,210
So that's step 1.
所以这是第一步。

499
00:24:42,210 --> 00:24:46,920
Compiling converts the C code into the underlying assembly code.
编译将 C 代码转换为底层的汇编代码。

500
00:24:46,920 --> 00:24:51,750
The assembling step, step 3, converts the assembly code to 0's and 1's.
汇编步骤，第三步，将汇编代码转换为 0 和 1。

501
00:24:51,750 --> 00:24:54,480
And then the fourth step, linking, combines
然后第四步，链接，组合

502
00:24:54,480 --> 00:24:57,960
all of the 0's and 1's from the one, the two, the three or more files
所有来自一个、两个、三个或更多文件的 0 和 1

503
00:24:57,960 --> 00:25:00,510
that are involved in your project and links them
参与你项目的这些文件，并将它们链接

504
00:25:00,510 --> 00:25:02,310
all together for you magically.
全部链接在一起，就像变魔术一样。

505
00:25:02,310 --> 00:25:06,060
But at the end of the day, all of this is happening automatically for you.
但最终，所有这一切都是自动为你完成的。

506
00:25:06,060 --> 00:25:10,530
If I jump now to the end here, whereby just by running
如果我现在跳到最后，只需要运行

507
00:25:10,530 --> 00:25:14,310
make, which, in turn, runs clang for you, like all of this
make，它反过来又为你运行 clang，就像所有这一切

508
00:25:14,310 --> 00:25:15,900
is abstracted away.
被抽象化了。

509
00:25:15,900 --> 00:25:19,620
But the key here is that even with these commands that we've been running,
但这里的关键是，即使使用我们一直在运行的这些命令，

510
00:25:19,620 --> 00:25:22,510
be it the make command or the clang command,
无论是 make 命令还是 clang 命令，

511
00:25:22,510 --> 00:25:28,570
everything should be explainable what you are typing at the prompt
你最终在提示符下输入的任何内容都应该能够解释清楚

512
00:25:28,570 --> 00:25:29,410
ultimately.
最终。

513
00:25:29,410 --> 00:25:31,300
Each of those things has a purpose.
每一个都有其目的。

514
00:25:31,300 --> 00:25:33,850
So any questions, then, on what we've just
那么，关于我们刚刚

515
00:25:33,850 --> 00:25:38,018
now called compiling even though it's only when you take another CS
现在称之为编译，即使只有当你学习另一门计算机科学课程时

516
00:25:38,018 --> 00:25:40,060
course that you might spend more time on assembly
你才会花更多时间在汇编

517
00:25:40,060 --> 00:25:42,940
language or these lower-level details?
语言或这些底层细节上？

518
00:25:42,940 --> 00:25:43,480
Yeah?
是吧？

519
00:25:43,480 --> 00:25:47,264
AUDIENCE: [INAUDIBLE]
观众：[听不清]

520
00:25:49,092 --> 00:25:50,300
DAVID MALAN: A good question.
大卫·马兰：一个好问题。

521
00:25:50,300 --> 00:25:51,740
Are there other types of compilers?
还有其他类型的编译器吗？

522
00:25:51,740 --> 00:25:52,240
Yes.
是的。

523
00:25:52,240 --> 00:25:57,320
Back when I took CS50, I used a popular compiler called GCC, the GNU Compiler
当我学习 CS50 的时候，我使用了一个流行的编译器，叫做 GCC，GNU 编译器

524
00:25:57,320 --> 00:26:00,650
Collection, which still exists actually in the code space
集合，实际上它仍然存在于代码空间

525
00:26:00,650 --> 00:26:02,120
that you're using for CS50.
你用来学习 CS50 的。

526
00:26:02,120 --> 00:26:04,110
Clang is somewhat more recent.
Clang 相对来说比较新。

527
00:26:04,110 --> 00:26:05,153
It's gaining popularity.
它越来越流行。

528
00:26:05,153 --> 00:26:07,820
And frankly, we use it in large part because it's error messages
坦白说，我们使用它很大程度上是因为它的错误消息

529
00:26:07,820 --> 00:26:09,320
are slightly more user-friendly.
更加人性化。

530
00:26:09,320 --> 00:26:12,570
You might not believe us because if you encountered some errors with your code
你可能不信我们，因为如果你在你的代码中遇到了一些错误

531
00:26:12,570 --> 00:26:16,370
this past week, they were probably just as arcane as the error messages I saw,
在上周，他们可能就像我看到的错误消息一样难以理解，

532
00:26:16,370 --> 00:26:18,598
but it's better than it was some years ago.
但它比几年前好多了。

533
00:26:18,598 --> 00:26:20,390
And there's alternatives to compiling, too,
而且也有编译的替代方案，

534
00:26:20,390 --> 00:26:24,100
but more on that when we get to Python as well.
但当我们谈到 Python 的时候，我们会详细讨论它。

535
00:26:24,100 --> 00:26:26,080
Other questions?
还有其他问题吗？

536
00:26:26,080 --> 00:26:26,580
No?
没有？

537
00:26:26,580 --> 00:26:27,080
All right.
好的。

538
00:26:27,080 --> 00:26:31,020
Well, what are the implications of the fact that we're going from source code
那么，从源代码到机器代码，这意味着什么呢？

539
00:26:31,020 --> 00:26:32,190
to machine code?
到机器代码？

540
00:26:32,190 --> 00:26:35,010
Well, it stands to reason that if you can compile code,
很明显，如果你可以编译代码，

541
00:26:35,010 --> 00:26:38,970
maybe you can decompile it-- that is, go in the reverse direction.
也许你可以反编译它——也就是说，反过来操作。

542
00:26:38,970 --> 00:26:42,010
Go from 0's and 1's to actual source code.
从 0 和 1 到实际的源代码。

543
00:26:42,010 --> 00:26:45,477
Now that would be handy if you want to go in as a programmer and change
现在，如果你想作为程序员去修改

544
00:26:45,477 --> 00:26:48,060
something in a program that you or someone else already wrote.
你或其他人已经编写的程序中的某些内容。

545
00:26:48,060 --> 00:26:51,330
It's maybe not ideal for your intellectual property,
这可能对你的知识产权不利，

546
00:26:51,330 --> 00:26:54,780
though, if you are the person who wrote that program in the first place.
不过，如果你本来就是编写该程序的人。

547
00:26:54,780 --> 00:26:57,810
If you are Microsoft and you wrote Microsoft Word or Excel
如果你就是微软，而且你编写了 Microsoft Word 或 Excel

548
00:26:57,810 --> 00:27:01,290
that people with Macs and PCs and phones have installed on their devices,
这些软件被 Mac、PC 和手机用户安装在他们的设备上，

549
00:27:01,290 --> 00:27:04,440
it doesn't actually sound very appealing if any old customer
如果任何一个老客户

550
00:27:04,440 --> 00:27:08,830
can take those 0's and 1's and reverse them, reverse engineer them,
可以将这些 0 和 1 反转，逆向工程它们，

551
00:27:08,830 --> 00:27:11,157
so to speak, into the original source code
可以说，将它们转化为原始的源代码

552
00:27:11,157 --> 00:27:13,740
because then they can have their own version of Microsoft Word
因为这样他们就可以拥有他们自己的 Microsoft Word 版本

553
00:27:13,740 --> 00:27:17,100
and make changes to it without really having put in all of the R&D
并对其进行修改，而无需投入所有研发

554
00:27:17,100 --> 00:27:19,980
that it might have taken to build the first version thereof.
可能需要构建它的第一个版本。

555
00:27:19,980 --> 00:27:22,720
But it turns out that reverse engineering--
但事实证明，反向工程——

556
00:27:22,720 --> 00:27:26,050
so doing things in the opposite direction-- is easier
做相反的事情——说起来容易

557
00:27:26,050 --> 00:27:29,740
said than done because there are multiple ways, as you've seen already,
做起来难，因为正如你已经看到的，

558
00:27:29,740 --> 00:27:31,300
to implement programs.
有很多方法可以实现程序。

559
00:27:31,300 --> 00:27:35,440
Like loops alone, you can use for loops, while loops, even do-while loops.
比如循环本身，你可以使用 for 循环、while 循环，甚至 do-while 循环。

560
00:27:35,440 --> 00:27:37,540
And so there's other ways-- there's multiple ways
因此，还有其他方法——有几种方法

561
00:27:37,540 --> 00:27:38,960
to solve the same problem.
可以解决相同的问题。

562
00:27:38,960 --> 00:27:41,590
So even if you try to reverse engineer a program
因此，即使你尝试反向工程一个程序

563
00:27:41,590 --> 00:27:44,440
and convert machine code back to source code,
并将机器代码转换回源代码，

564
00:27:44,440 --> 00:27:48,170
there's not necessarily going to be an obvious way to do so.
也不一定有一个明显的方法可以做到这一点。

565
00:27:48,170 --> 00:27:50,620
And the reality is, that it ends up being such a mess
现实情况是，最终会变得一团糟

566
00:27:50,620 --> 00:27:53,350
because you lose the variable names typically,
因为你通常会丢失变量名，

567
00:27:53,350 --> 00:27:57,070
you lose the function names typically, that what you end up looking at
你通常会丢失函数名，最终你看到的是

568
00:27:57,070 --> 00:28:01,300
might very well be C code, but it's completely difficult for you,
可能确实是 C 代码，但这对你来说非常困难，

569
00:28:01,300 --> 00:28:03,040
even a good programmer, to read.
即使是一个优秀的程序员，也能读懂。

570
00:28:03,040 --> 00:28:06,520
And generally, the mindset is, if you're really good enough
一般来说，人们的想法是，如果你真的足够优秀

571
00:28:06,520 --> 00:28:09,782
to decompile code in that way and read it subsequently
以这种方式反编译代码并随后阅读它

572
00:28:09,782 --> 00:28:11,740
even without good variable names, good function
即使没有好的变量名、好的函数名

573
00:28:11,740 --> 00:28:14,950
names, good documentation and the like, could probably have just implemented
好的文档等等，你可能可以自己直接实现

574
00:28:14,950 --> 00:28:18,340
the program in the first place yourself without jumping through those hoops.
这个程序，而不需要经过这些繁琐的步骤。

575
00:28:18,340 --> 00:28:20,440
So there's some practicality pushing back
所以有一些实用性在回推

576
00:28:20,440 --> 00:28:25,420
on what are otherwise potential threats to, say, your intellectual property.
在其他情况下，可能会对你的知识产权构成威胁。

577
00:28:25,420 --> 00:28:28,150
But that's not going to be the case later on in the term when
但在学期后期，情况就不一样了

578
00:28:28,150 --> 00:28:31,270
we do get to languages like Python to some extent, other languages
我们确实会接触到像 Python 这样的语言，在某种程度上，其他语言

579
00:28:31,270 --> 00:28:32,200
like JavaScript.
像 JavaScript。

580
00:28:32,200 --> 00:28:34,870
Some of those are actually going to be readable by anyone.
其中一些实际上任何人都可以阅读。

581
00:28:34,870 --> 00:28:36,790
Any of your customers, any of your friends,
你的任何客户、任何朋友

582
00:28:36,790 --> 00:28:39,950
and your family that actually use your programs.
以及你家里的那些实际使用你程序的人。

583
00:28:39,950 --> 00:28:43,540
So with that said, let's introduce now another tool to our toolkit
因此，现在让我们向我们的工具箱中添加另一个工具

584
00:28:43,540 --> 00:28:45,580
that will hopefully make some of the pain
希望这能够减轻一些痛苦

585
00:28:45,580 --> 00:28:47,470
from this past week when you did encounter
在上周你遇到问题的时候

586
00:28:47,470 --> 00:28:49,210
bugs a little more manageable.
使调试 bug 变得更加容易。

587
00:28:49,210 --> 00:28:52,330
And indeed, part of the process of writing code to this day
事实上，如今编写代码的一部分过程

588
00:28:52,330 --> 00:28:53,680
is debugging it.
就是调试它。

589
00:28:53,680 --> 00:28:56,560
And it is a rare thing to write a program,
写一个程序，这是一件很罕见的事情

590
00:28:56,560 --> 00:29:01,450
be it in C or any other language, and get it 100% right the first time.
无论是在 C 语言还是其他任何语言中，都能在第一次就做到 100% 正确。

591
00:29:01,450 --> 00:29:05,360
I mean, to this day, I still, 20-plus years later, still write buggy code.
我的意思是，直到今天，我已经 20 多年了，仍然会写出有 bug 的代码。

592
00:29:05,360 --> 00:29:08,695
Hopefully a little bit less of it, but any time you're adding a new feature,
希望现在会少一些，但无论何时你添加一个新功能，

593
00:29:08,695 --> 00:29:10,820
any time you're doing something for the first time,
无论何时你第一次做某事，

594
00:29:10,820 --> 00:29:14,380
you're not necessarily going to see all of the possible mistakes.
你不会一定能看到所有可能出现的错误。

595
00:29:14,380 --> 00:29:18,910
So even in industry, bugs are omnipresent, which is really to say,
因此，即使在工业界，bug 也是无处不在的，这意味着

596
00:29:18,910 --> 00:29:22,360
having techniques to debug code-- that is, eliminate bugs,
拥有调试代码的技术——也就是说，消除 bug，

597
00:29:22,360 --> 00:29:23,740
is super compelling.
非常有说服力。

598
00:29:23,740 --> 00:29:26,920
Now just for a bit of history, here is Admiral Grace Hopper,
现在我们来谈谈历史，这是海军上将 Grace Hopper，

599
00:29:26,920 --> 00:29:30,230
who was actually in not only the military,
她不仅在军队服役，

600
00:29:30,230 --> 00:29:33,070
but also on the faculty of Harvard years ago
而且多年前也在哈佛大学任教

601
00:29:33,070 --> 00:29:35,860
and worked on a Harvard computer called the Harvard Mark
并且参与了哈佛大学的一台名为哈佛 Mark 的计算机

602
00:29:35,860 --> 00:29:39,250
I, which is actually on display at the School of Engineering and Applied
I，这台计算机现在实际展出在工程与应用科学学院

603
00:29:39,250 --> 00:29:41,260
Sciences if you take a tour over there sometime.
如果有一天你去参观那里的话。

604
00:29:41,260 --> 00:29:44,230
But also when working on the Harvard Mark II,
在参与哈佛 Mark II 项目时

605
00:29:44,230 --> 00:29:50,170
she is known for having at least popularized the phrase "bug" to mean
她以至少普及了“bug”这个词来表示

606
00:29:50,170 --> 00:29:53,350
a mistake in a computer's program--
计算机程序中的错误——

607
00:29:53,350 --> 00:29:55,240
a mistake in a computer's code.
计算机代码中的错误。

608
00:29:55,240 --> 00:29:58,510
And the etymology of this supposedly is this here logbook
据推测，这个词的词源来自于这本航海日志

609
00:29:58,510 --> 00:30:02,320
wherein she and her colleagues were documenting processes being computed
她在日志中和她的同事记录了计算机上正在执行的进程

610
00:30:02,320 --> 00:30:04,960
on computers, that a moth actually got stuck
在计算机上，一只飞蛾卡住了

611
00:30:04,960 --> 00:30:09,250
in one of the relays, one of the mechanical-- the electric relays inside
卡在了其中一个继电器中，一个机械继电器——这台非常古老的计算机里面的电继电器，然后有人非常聪明地

612
00:30:09,250 --> 00:30:13,450
of the very old now computer, and someone very cleverly
写下了，“第一个被发现的 bug 的实际案例”。

613
00:30:13,450 --> 00:30:16,657
wrote, "First actual case of bug being found."
所以并不是她真正发现了这个 bug，

614
00:30:16,657 --> 00:30:18,490
So it wasn't she who actually discovered it,
而是她的同事们记录了这件事，然后这件事就被流传下来了。

615
00:30:18,490 --> 00:30:22,450
but this was a story she was thereafter fond of telling as a famed computer
但是，这是一个她后来作为著名的计算机科学家喜欢讲述的故事。

616
00:30:22,450 --> 00:30:23,860
scientist thereafter.
科学家。

617
00:30:23,860 --> 00:30:28,210
We now know bugs to be all too familiar when it comes to writing our own code,
我们现在知道，在编写自己的代码时，bug 太常见了，

618
00:30:28,210 --> 00:30:31,060
and I thought I would deliberately write some buggy code based
我认为我会故意编写一些有bug的代码，这些代码基于

619
00:30:31,060 --> 00:30:34,400
on some of the programs with which we experimented last week.
我们上周做实验的一些程序。

620
00:30:34,400 --> 00:30:37,270
So let me go back over to VS Code here and let
所以，让我回到这里的 VS Code，并让我

621
00:30:37,270 --> 00:30:44,290
me propose that I do something somewhat simplistic just like this to print out
我建议我做一些像这样简单的事情来打印

622
00:30:44,290 --> 00:30:47,140
a column of bricks of height 3.
一列高为 3 的砖块。

623
00:30:47,140 --> 00:30:50,440
So I'm going into VS Code and I'm going to deliberately call this program
所以，我将进入 VS Code，并且我将故意将这个程序称为

624
00:30:50,440 --> 00:30:53,230
buggy.c because I intend to do this poorly.
buggy.c，因为我打算把它做得不好。

625
00:30:53,230 --> 00:30:58,760
I'm going to include stdio.h as before, int main void as before.
我将像以前一样包含 stdio.h，像以前一样包含 int main void。

626
00:30:58,760 --> 00:31:01,630
And in here, if I want to print a pyramid of height 3,
在里面，如果我想打印一个高为 3 的金字塔，

627
00:31:01,630 --> 00:31:04,720
I'm going to do 4 int i gets--
我要做 4 个 int i 获取--

628
00:31:04,720 --> 00:31:06,910
all right, I'm still new to programming in my mind
好吧，我仍然不熟悉我的编程思维

629
00:31:06,910 --> 00:31:09,820
here, so I know I'm supposed to start counting at 0, OK.
在这里，所以我知道我应该从 0 开始计数，好的。

630
00:31:09,820 --> 00:31:13,480
And I want to do this until I count up to 3, so I'm going to do that.
而且，我想一直这样做，直到我数到 3，所以我要这样做。

631
00:31:13,480 --> 00:31:16,700
And then i++ I remember from class in this way.
然后，我记得从课堂上以这种方式学到 i++。

632
00:31:16,700 --> 00:31:20,500
And now I might go ahead and print out just a hash mark, backslash n,
现在，我可能会继续打印一个井号，反斜杠 n，

633
00:31:20,500 --> 00:31:23,710
which I do want because I want to move this cursor to the next line
这是我想要的，因为我想将光标移动到下一行

634
00:31:23,710 --> 00:31:24,790
to make this vertical.
使其垂直。

635
00:31:24,790 --> 00:31:29,730
But of course, if you've noticed with your eye already, when I do make buggy,
但是，当然，如果你已经注意到，当我做 buggy 时，

636
00:31:29,730 --> 00:31:30,960
it compiles OK.
它编译良好。

637
00:31:30,960 --> 00:31:33,640
So no typos, no syntactical errors.
所以，没有错别字，没有语法错误。

638
00:31:33,640 --> 00:31:37,620
But when I run this, I'm going to see how many bricks.
但是，当我运行它时，我将看到有多少块砖。

639
00:31:37,620 --> 00:31:39,510
So four in this case.
在这种情况下是四块。

640
00:31:39,510 --> 00:31:41,650
Now this is meant to be a simplistic example
现在，这应该是一个简单的例子

641
00:31:41,650 --> 00:31:44,910
so that we don't spend time trying to figure out what the bug is, but rather,
这样我们就不用花时间去弄清楚错误是什么，而是

642
00:31:44,910 --> 00:31:48,210
focus on techniques for actually identifying the bug.
专注于识别错误的技巧。

643
00:31:48,210 --> 00:31:50,010
So-- finding, rather, the bug.
所以，就是找到错误。

644
00:31:50,010 --> 00:31:52,170
So what's one of the first tools in your toolkit?
那么，你工具箱里的第一个工具是什么？

645
00:31:52,170 --> 00:31:55,470
Literally one you have already. printf is your friend.
你已经有了它。printf 是你的朋友。

646
00:31:55,470 --> 00:31:59,730
And it is a very quick and dirty tool for just seeing
它是一个非常快速简便的工具，可以用来查看

647
00:31:59,730 --> 00:32:02,520
what's going on inside of the computer when
当你在计算机内部发生什么时，

648
00:32:02,520 --> 00:32:06,550
you don't have more sophisticated tools or even the time to use them.
你没有更复杂的工具，甚至没有时间使用它们。

649
00:32:06,550 --> 00:32:09,750
And so in this case, for instance, what I'd propose is that--
所以，在这种情况下，例如，我建议--

650
00:32:09,750 --> 00:32:11,610
all right, I'm obviously seeing four hashes.
好吧，我显然看到四个井号。

651
00:32:11,610 --> 00:32:13,710
And let me play a little slow here.
让我在这里放慢一点。

652
00:32:13,710 --> 00:32:18,090
It'd be helpful for me to understand why logically I'm ending up with four, even
对我来说，了解为什么从逻辑上来说我最终得到四个，即使

653
00:32:18,090 --> 00:32:21,360
though I'm starting at 0 like I remember from class and I'm going up to 3
尽管我记得从课堂上开始从 0 开始，我正在数到 3

654
00:32:21,360 --> 00:32:25,870
as we did in class, like I'm just not seeing it in this particular story.
就像我们在课堂上做的那样，我只是没有在这个特定的故事中看到它。

655
00:32:25,870 --> 00:32:30,180
So what I would commonly do is go into my code and just help me see
所以我通常会进入我的代码，帮助我查看

656
00:32:30,180 --> 00:32:35,400
what's going on, and I might literally write a printf line like, i is %i,
发生了什么，我可能会直接写一行 printf，比如，i 是 %i，

657
00:32:35,400 --> 00:32:39,490
backslash n, comma, and then just print out the value of i.
反斜杠 n，逗号，然后只打印出 i 的值。

658
00:32:39,490 --> 00:32:41,620
I just want to see on every iteration, what
我只是想在每次迭代时查看，什么是

659
00:32:41,620 --> 00:32:45,530
is i, what is i, what is i just to help me see what the computer already knows.
i 是什么，i 是什么，i 是什么，只是为了帮助我查看计算机已经知道的。

660
00:32:45,530 --> 00:32:49,900
So let me go ahead and recompile buggy, let me rerun buggy,
所以让我继续重新编译 buggy，让我重新运行 buggy，

661
00:32:49,900 --> 00:32:51,910
and then let me make my terminal window bigger
然后让我把我的终端窗口放大

662
00:32:51,910 --> 00:32:53,410
just to make clear what's going on.
只是为了让事情更清楚。

663
00:32:53,410 --> 00:32:56,080
And now it's a little more pedantic.
现在它有点儿更刻板了。

664
00:32:56,080 --> 00:33:01,150
Now i is 0, I get a hash. i is 1, I get a hash. i is 2, I get a hash.
现在 i 是 0，我得到一个井号。i 是 1，我得到一个井号。i 是 2，我得到一个井号。

665
00:33:01,150 --> 00:33:04,310
Wait a minute. i is 3, I get a hash.
等一下。i 是 3，我得到一个井号。

666
00:33:04,310 --> 00:33:07,250
So clearly now, it should be maybe more obvious to you,
所以很明显，现在对你来说应该更明显了，

667
00:33:07,250 --> 00:33:09,430
especially if the syntax itself is unfamiliar,
特别是如果语法本身不熟悉，

668
00:33:09,430 --> 00:33:11,680
I certainly don't want this last one printing,
我当然不希望最后一个打印，

669
00:33:11,680 --> 00:33:14,810
or maybe equivalently, I don't want the first one printing.
或者等效地，我不希望第一个打印。

670
00:33:14,810 --> 00:33:17,830
So I can fix this in a couple of ways, but the solution,
所以我可以通过几种方法来解决这个问题，但解决方案，

671
00:33:17,830 --> 00:33:22,810
the most canonical solution is probably to do what with my code?
最规范的解决方案可能是用我的代码做什么？

672
00:33:22,810 --> 00:33:24,430
To change to what to what?
改为什么？

673
00:33:24,430 --> 00:33:25,402
Yeah?
是吗？

674
00:33:25,402 --> 00:33:26,590
AUDIENCE: [INAUDIBLE]
观众： [听不清]

675
00:33:26,590 --> 00:33:27,340
DAVID MALAN: Yeah.
大卫·马兰： 是的。

676
00:33:27,340 --> 00:33:31,000
So change the less than or equal sign to just a less than sign.
所以把小于等于号改为小于号。

677
00:33:31,000 --> 00:33:36,580
So even though this is like counting from 0 to 3 instead of 1 through 3,
所以即使这是从 0 到 3 计数而不是从 1 到 3，

678
00:33:36,580 --> 00:33:39,890
it's the more typical programmatic way to write code like this.
这是编写这种代码更典型的编程方式。

679
00:33:39,890 --> 00:33:43,600
And now, of course, if I do make buggy--
现在，当然，如果我做 buggy--

680
00:33:43,600 --> 00:33:46,840
and I'll increase my terminal window again, ./buggy,
我会再次放大我的终端窗口，./buggy，

681
00:33:46,840 --> 00:33:49,360
now I see what's going on inside of the code.
现在我看到了代码内部发生的事情。

682
00:33:49,360 --> 00:33:53,080
Now it matches my expectations, and so now the bug is gone.
现在它符合我的预期，所以现在 bug 消失了。

683
00:33:53,080 --> 00:33:55,330
Now of course, if I'm submitting this or shipping it,
现在当然，如果我要提交或发布它，

684
00:33:55,330 --> 00:33:57,190
I should delete the temporary printf.
我应该删除临时 printf。

685
00:33:57,190 --> 00:34:00,610
And let me disclaim that using printf in this way just to help you
我声明以这种方式使用 printf 只是为了帮助你

686
00:34:00,610 --> 00:34:03,100
see what's going on is generally a good thing,
了解正在发生的事情通常是一件好事，

687
00:34:03,100 --> 00:34:06,370
but generally adding a printf and a printf and a printf and a printf--
但通常添加一个 printf、一个 printf、一个 printf 和一个 printf--

688
00:34:06,370 --> 00:34:10,665
like it starts to devolve into just trial and error and you
就像它开始退化为纯粹的试错，而你

689
00:34:10,665 --> 00:34:13,540
have no idea what's going on, so you're just printing out everything.
不知道发生了什么，所以你只是打印出所有内容。

690
00:34:13,540 --> 00:34:17,230
Let me propose that if you ever find yourself slipping down
我建议如果你发现自己滑下了

691
00:34:17,230 --> 00:34:20,260
that hill into just trying this, trying this, trying this,
那座山，仅仅尝试这个，尝试那个，尝试另一个，

692
00:34:20,260 --> 00:34:22,659
you need a better tool, not just doing printf.
你需要一个更好的工具，而不仅仅是使用 printf。

693
00:34:22,659 --> 00:34:26,199
And frankly, it's annoying to use printf because every time you add a printf,
坦白地说，使用 printf 很烦人，因为每次你添加一个 printf，

694
00:34:26,199 --> 00:34:28,699
you have to recompile the code, rerun the code.
你必须重新编译代码，重新运行代码。

695
00:34:28,699 --> 00:34:31,230
It's just adding to the number of steps.
这只是增加了步骤数量。

696
00:34:31,230 --> 00:34:34,550
So let me propose instead that we do this.
所以让我建议我们这样做。

697
00:34:34,550 --> 00:34:37,070
I'm going to go back into VS Code here and I'm
我将回到这里的 VS Code 中，并且我

698
00:34:37,070 --> 00:34:39,980
going to write a different program that actually
将要编写一个不同的程序，实际上

699
00:34:39,980 --> 00:34:42,110
has a helper function, so to speak.
有一个辅助函数，可以这么说。

700
00:34:42,110 --> 00:34:44,840
A second function whose purpose in life is maybe just
第二个函数，它的生命目标可能是仅仅

701
00:34:44,840 --> 00:34:46,940
to print that column for me.
为我打印那列。

702
00:34:46,940 --> 00:34:50,685
So I'm going to say this-- void print_column,
所以我会说这个——void print_column，

703
00:34:50,685 --> 00:34:53,060
though I could call it anything I want, and this function
虽然我可以随意命名，但这个函数

704
00:34:53,060 --> 00:34:56,570
is going to take a argument or a parameter called
将要接受一个参数，叫做

705
00:34:56,570 --> 00:34:59,300
height which will tell it how many bricks to print,
height，它将告诉函数要打印多少块砖，

706
00:34:59,300 --> 00:35:01,070
how many vertical bricks.
多少块竖着的砖。

707
00:35:01,070 --> 00:35:05,900
I'm going to do the same kind of logic. for int i equals 0.
我要做同样的逻辑。for int i 等于 0。

708
00:35:05,900 --> 00:35:06,830
i is less than--
i 小于 --

709
00:35:06,830 --> 00:35:09,830
I'm going to make the same mistake again-- less than or equal to height,
我会再次犯同样的错误 -- 小于或等于高度，

710
00:35:09,830 --> 00:35:10,850
i++.
i++。

711
00:35:10,850 --> 00:35:14,922
And then inside of this for loop, let me go ahead and print out the hash mark.
然后在这个 for 循环中，我先打印出井号。

712
00:35:14,922 --> 00:35:16,880
So I've made the same mistake, but I've made it
所以，我犯了同样的错误，但我把它

713
00:35:16,880 --> 00:35:20,900
in the context now of a helper function only because in main,
现在放在了一个辅助函数的上下文中，因为在主函数中，

714
00:35:20,900 --> 00:35:24,980
what I'd like to do now, just to be a little more sophisticated is get int
我现在想做的是，为了更精细一点，从用户那里获取整数

715
00:35:24,980 --> 00:35:27,300
from the user for the height.
作为高度。

716
00:35:27,300 --> 00:35:31,190
And when I do get that int, I want to store it in a variable called n,
当我获取到这个整数时，我想把它存储在一个叫做 n 的变量中，

717
00:35:31,190 --> 00:35:34,980
but I do need to give that variable a type like last week.
但是我需要给这个变量一个类型，就像上周一样。

718
00:35:34,980 --> 00:35:36,440
So I'll say that it's an integer.
所以，我会说它是一个整数。

719
00:35:36,440 --> 00:35:40,940
And now, lastly, I can print_column, passing in-- actually, I'll
现在，最后，我可以调用 print_column，传入 -- 实际上，我会

720
00:35:40,940 --> 00:35:43,100
call it h just because height is h.
把它叫做 h，因为高度是 h。

721
00:35:43,100 --> 00:35:46,730
Print column h, semicolon.
打印列 h，分号。

722
00:35:46,730 --> 00:35:49,790
OK, so it's the exact same program except I'm getting user input now.
好的，所以它和之前的程序完全一样，只是我现在在获取用户输入。

723
00:35:49,790 --> 00:35:53,030
So it's not just going to be 3, it's going to be a variable height,
所以它不再是固定的 3，而是会根据高度变量变化，

724
00:35:53,030 --> 00:35:55,108
but I've done something stupid.
但是，我做了一些蠢事。

725
00:35:55,108 --> 00:35:56,940
AUDIENCE: [INAUDIBLE]
观众：[听不见]

726
00:35:56,940 --> 00:35:58,690
DAVID MALAN: I've done two stupid things.
戴维·马兰：我犯了两个蠢错误。

727
00:35:58,690 --> 00:36:02,310
So this, of course, is not supposed to be there, so I'll fix that.
当然，这个是不应该出现在这里的，所以我会把它修复。

728
00:36:02,310 --> 00:36:03,390
And someone else.
还有其他人。

729
00:36:03,390 --> 00:36:05,265
What else have I done?
我还做了什么？

730
00:36:05,265 --> 00:36:08,990
AUDIENCE: [INAUDIBLE]
观众：[听不见]

731
00:36:08,990 --> 00:36:09,740
DAVID MALAN: Yeah.
戴维·马兰：是的。

732
00:36:09,740 --> 00:36:11,070
I'm missing the prototype.
我漏掉了原型。

733
00:36:11,070 --> 00:36:16,040
And this is, let me reiterate, probably the only time where copy-paste is OK.
并且，让我再次强调，这可能是唯一可以进行复制粘贴的情况。

734
00:36:16,040 --> 00:36:17,960
Once you've implemented the function, you
一旦你实现了函数，你

735
00:36:17,960 --> 00:36:21,690
can copy paste its first line at a semicolon
就可以复制粘贴它的第一行，并加上一个分号

736
00:36:21,690 --> 00:36:25,265
so that it teaches the compiler that this function will exist.
这样编译器就知道这个函数存在了。

737
00:36:25,265 --> 00:36:26,635
AUDIENCE: [INAUDIBLE]
观众：[听不见]

738
00:36:26,635 --> 00:36:28,010
DAVID MALAN: Three stupid things.
戴维·马兰：三个蠢错误。

739
00:36:28,010 --> 00:36:28,510
OK.
好的。

740
00:36:28,510 --> 00:36:29,150
Thank you.
谢谢。

741
00:36:29,150 --> 00:36:31,520
So, good.
所以，很好。

742
00:36:31,520 --> 00:36:33,620
Include cs50.h.
包含 cs50.h。

743
00:36:33,620 --> 00:36:36,860
And now, anyone want to go for four?
现在，有人想尝试第四个错误吗？

744
00:36:36,860 --> 00:36:38,040
No?
没有？

745
00:36:38,040 --> 00:36:38,540
All right.
好的。

746
00:36:38,540 --> 00:36:39,582
Slightly unintended here.
这里有点意外。

747
00:36:39,582 --> 00:36:42,020
So let's see. make buggy.
让我们看看。执行 make buggy。

748
00:36:42,020 --> 00:36:44,160
OK, no syntax errors thanks to you all.
好的，多亏了你们，没有语法错误。

749
00:36:44,160 --> 00:36:47,090
So the code compiles, but of course, when I run buggy
所以代码编译通过了，但当然，当我运行 buggy

750
00:36:47,090 --> 00:36:52,130
and I type in something like 3 manually, I'm still going to get 1, 2, 3 4 out.
并且我手动输入了 3，我还是会得到 1, 2, 3, 4 的输出。

751
00:36:52,130 --> 00:36:54,500
So let me now introduce a more powerful tool
现在，我将介绍一个更强大的工具

752
00:36:54,500 --> 00:36:56,450
that's generally known as a debugger.
它通常被称为调试器。

753
00:36:56,450 --> 00:36:58,927
And within the VS Code environment that you're using,
在你们使用的 VS Code 环境中，

754
00:36:58,927 --> 00:37:02,010
we actually have a command that makes it a little easier to use this tool,
我们实际上有一个命令可以让使用这个工具变得更简单，

755
00:37:02,010 --> 00:37:03,510
but we didn't write the tool itself.
但我们没有编写这个工具本身。

756
00:37:03,510 --> 00:37:07,040
You are about to see a very graphical, a very popular industry standard
你们即将看到一个非常图形化的、非常流行的行业标准

757
00:37:07,040 --> 00:37:11,510
tool called a debugger, but we'll start the debugger using a CS50-specific
工具，叫做调试器，但我们会使用 CS50 特定的命令来启动它

758
00:37:11,510 --> 00:37:15,080
command called debug50, which just makes it easier with a single command
名为 debug50 的命令，只需一个命令就能简化调试过程

759
00:37:15,080 --> 00:37:17,655
to start the debugger without having to configure a text
无需配置文本文件即可启动调试器

760
00:37:17,655 --> 00:37:20,030
file with all of your preferred settings and all of that.
文件包含所有你喜欢的设置等等。

761
00:37:20,030 --> 00:37:22,710
It's just an annoying hoop otherwise to jump through.
否则，这只是一个令人讨厌的障碍。

762
00:37:22,710 --> 00:37:25,100
So what I'm going to do is go back to my code here.
所以我要回到我的代码这里。

763
00:37:25,100 --> 00:37:27,900
I have already compiled it, but just for good measure,
我已经编译了它，但为了保险起见，

764
00:37:27,900 --> 00:37:31,140
I'll make buggy again because the debugger needs your code
我将再次使它出现错误，因为调试器需要你的代码

765
00:37:31,140 --> 00:37:31,862
to be compiled.
被编译。

766
00:37:31,862 --> 00:37:33,570
It's not going to help with syntax errors
它不会帮助解决语法错误

767
00:37:33,570 --> 00:37:36,270
like the stupid mistakes I just made unintentionally,
比如我刚才无意中犯的愚蠢错误，

768
00:37:36,270 --> 00:37:40,530
it will help you though with programmatic errors, logical errors
它将帮助你解决程序错误，逻辑错误

769
00:37:40,530 --> 00:37:42,870
in your code once your code is running.
在你的代码运行后。

770
00:37:42,870 --> 00:37:47,130
So to run debug50, I'm going to do this. debug50, space, and then
所以要运行 debug50，我会这样做。 debug50，空格，然后

771
00:37:47,130 --> 00:37:51,840
the exact same command I would normally run to just run the program itself.
与我通常运行程序本身的命令完全相同。

772
00:37:51,840 --> 00:37:53,190
So ./buggy.
所以 ./buggy。

773
00:37:53,190 --> 00:37:57,150
So exact same thing, ./buggy, but I prefix it now with debug50.
所以完全相同，./buggy，但现在我在它前面加上 debug50。

774
00:37:57,150 --> 00:37:59,172
When I hit Enter, a whole bunch of--
当我按下回车键时，一大堆——

775
00:37:59,172 --> 00:38:01,380
another error is going to pop up on the screen, which
另一个错误将在屏幕上弹出，这

776
00:38:01,380 --> 00:38:04,213
is a good reminder because this will happen to you, too, invariably.
是一个很好的提醒，因为这也会不可避免地发生在你身上。

777
00:38:04,213 --> 00:38:07,560
It's reminding me that I have to set what's called a breakpoint.
它提醒我必须设置一个所谓的断点。

778
00:38:07,560 --> 00:38:10,140
And as that word suggests, it is the point
正如这个词所暗示的那样，它是代码需要中断的点

779
00:38:10,140 --> 00:38:12,060
at which you want your code to break.
你想要让你的代码中断的地方。

780
00:38:12,060 --> 00:38:15,420
Not break in make the situation worse sense, but rather,
不是指让情况更糟，而是指

781
00:38:15,420 --> 00:38:16,920
where do you want to pause?
你想要暂停的地方？

782
00:38:16,920 --> 00:38:20,590
Execution, break, execution-- like hitting the brakes on a car
执行，中断，执行——就像踩汽车的刹车

783
00:38:20,590 --> 00:38:22,710
so the program doesn't run all at once.
这样程序就不会一下子全部运行。

784
00:38:22,710 --> 00:38:24,600
And you can put this any number of places,
你可以在任何地方放置它，

785
00:38:24,600 --> 00:38:26,308
and you might have done this accidentally
你可能无意中这样做过

786
00:38:26,308 --> 00:38:29,040
if you've ever hovered over the gutter of VS Code,
如果你曾经将鼠标悬停在 VS Code 的代码区，

787
00:38:29,040 --> 00:38:32,010
the left-hand side next to your line numbers.
行号旁边的左侧。

788
00:38:32,010 --> 00:38:34,180
See the little red dot that appears?
看到出现的小红点了吗？

789
00:38:34,180 --> 00:38:38,560
If I click on any of these lines, that's going to set a breakpoint, so to speak.
如果我点击这些行中的任何一行，就会设置一个断点，可以说是。

790
00:38:38,560 --> 00:38:41,310
And I want to break execution at main.
我想要在 main 函数处中断执行。

791
00:38:41,310 --> 00:38:44,040
So I'm just going to click to the left of line 6 in this case.
所以我要点击第 6 行左侧。

792
00:38:44,040 --> 00:38:47,430
That makes it a darker red circle, a stop sign
它变成了一个更深的红色圆圈，一个停止标志

793
00:38:47,430 --> 00:38:51,030
of sorts that tells the debugger to pause execution on that line,
告诉调试器在该行暂停执行，

794
00:38:51,030 --> 00:38:53,580
though I could put it elsewhere if I so choose.
虽然我也可以选择把它放在其他地方。

795
00:38:53,580 --> 00:38:57,990
Let me go ahead and rerun debug50 ./buggy, Enter,
让我重新运行 debug50 ./buggy，回车，

796
00:38:57,990 --> 00:39:00,652
and now a bunch of things are going to happen on the screen.
现在屏幕上将发生很多事情。

797
00:39:00,652 --> 00:39:03,360
It's going to look a little overwhelming perhaps at first glance,
它可能乍一看会让人觉得有点不知所措，

798
00:39:03,360 --> 00:39:05,950
but there's some useful stuff that just happened.
但刚刚发生了一些有用的事情。

799
00:39:05,950 --> 00:39:12,450
So one, my code is still here, but the line that I set the breakpoint on is--
所以，第一，我的代码还在，但我设置断点的行是——

800
00:39:12,450 --> 00:39:16,080
rather, the first line of actual executable
更确切地说，是设置断点之后的第一个可执行的

801
00:39:16,080 --> 00:39:20,970
code at or below the breakpoint I set is highlighted in this yellowish green
代码行，用这种黄绿色高亮显示，

802
00:39:20,970 --> 00:39:25,120
here, which says, this line of code has not yet been executed.
表示这行代码尚未执行。

803
00:39:25,120 --> 00:39:28,590
We broke at this point, but if I click a button, this line of code
我们在这里中断，但是如果我点击一个按钮，这行代码

804
00:39:28,590 --> 00:39:30,030
will be executed.
将被执行。

805
00:39:30,030 --> 00:39:33,750
Because up until now, every C program you write runs as fast as that.
因为到目前为止，你编写的每个 C 程序都以这种速度运行。

806
00:39:33,750 --> 00:39:36,550
I want to pump the brakes and pause here.
我想踩刹车，在这里暂停一下。

807
00:39:36,550 --> 00:39:39,190
But notice a few other aspects of the window here.
但是，请注意这里窗口的其他几个方面。

808
00:39:39,190 --> 00:39:41,310
So notice that up here some weirdness.
所以请注意，这里有一些奇怪的东西。

809
00:39:41,310 --> 00:39:43,890
There's mentions of variables and we're familiar with these.
这里提到了变量，我们对此很熟悉。

810
00:39:43,890 --> 00:39:45,990
Local is a term we'll use this week.
“局部”是我们本周将会使用的术语。

811
00:39:45,990 --> 00:39:48,210
But there's this variable h, which weirdly,
但这里有一个变量 h，奇怪的是，

812
00:39:48,210 --> 00:39:51,300
where did the value 21912 come from?
值 21912 是从哪里来的？

813
00:39:51,300 --> 00:39:57,750
So it turns out, in C, before you initialize a variable with a value
事实证明，在 C 语言中，在你用一个值初始化一个变量之前，

814
00:39:57,750 --> 00:40:01,890
by literally typing the number 3, or by using a function like get_int,
比如直接输入数字 3，或使用 get_int 这样的函数，

815
00:40:01,890 --> 00:40:04,662
it often contains what's called a garbage value.
它通常包含一个被称为“垃圾值”的东西。

816
00:40:04,662 --> 00:40:06,120
More on those in a couple of weeks.
我们将在几周后详细讲解这些。

817
00:40:06,120 --> 00:40:07,950
But a garbage value is you can think of it
但你可以把“垃圾值”理解为

818
00:40:07,950 --> 00:40:10,680
as like remnants of whatever was in the computer's memory
计算机内存中残留的，在你运行程序之前存在的任何东西。

819
00:40:10,680 --> 00:40:12,280
before you ran your program.
在你运行程序之前存在的任何东西。

820
00:40:12,280 --> 00:40:14,040
And that's a bit of a oversimplification,
这有点过于简化了，

821
00:40:14,040 --> 00:40:18,150
but you cannot trust that a variable will have a certain value in this case
但你不能相信一个变量在这种情况下会具有特定的值，

822
00:40:18,150 --> 00:40:21,490
if you did not put one there yourself.
如果你自己没有赋予它值。

823
00:40:21,490 --> 00:40:23,857
So for now, h is nonsensical.
所以现在，h 毫无意义。

824
00:40:23,857 --> 00:40:25,440
It's a garbage value it means nothing.
它是一个“垃圾值”，没有任何意义。

825
00:40:25,440 --> 00:40:29,230
But once I execute this line, it should contain whatever the human types in.
但一旦我执行这一行代码，它应该包含用户输入的任何内容。

826
00:40:29,230 --> 00:40:29,730
All right.
好的。

827
00:40:29,730 --> 00:40:32,990
Down here, there's a watch section, which is a more sophisticated feature.
这里有一个“监视”区域，这是一个更高级的功能。

828
00:40:32,990 --> 00:40:34,740
Down here is what's called the call stack.
这里被称为“调用栈”。

829
00:40:34,740 --> 00:40:35,890
More on that in the future.
我们将在将来详细讲解。

830
00:40:35,890 --> 00:40:39,240
But what this means for now is that I'm executing the main function, not,
但现在这意味着我正在执行 main 函数，而不是，

831
00:40:39,240 --> 00:40:40,870
for instance, print_column.
例如 print_column 函数。

832
00:40:40,870 --> 00:40:44,790
So notice up here, these are the most useful controls within the interface.
所以请注意，这里是在界面中最有用的控件。

833
00:40:44,790 --> 00:40:46,740
If I hit this Play button, it's just going
如果我点击这个“播放”按钮，它只会

834
00:40:46,740 --> 00:40:50,640
to actually run my program to the end of it without bothering me further.
实际运行我的程序，直到结束，不会再打扰我。

835
00:40:50,640 --> 00:40:54,990
However, I can actually step over this line of code and execute it,
然而，我实际上可以“单步跳过”这一行代码并执行它，

836
00:40:54,990 --> 00:40:57,870
or I can step into this line of code and actually
或者我可以“单步进入”这一行代码，并实际上

837
00:40:57,870 --> 00:41:01,480
poke around the contents of get_int if it's available on the system.
查看 get_int 函数的内容，如果它在系统上可用的话。

838
00:41:01,480 --> 00:41:03,870
So conceptually you can either execute this line
从概念上讲，你可以执行这一行代码，

839
00:41:03,870 --> 00:41:08,745
or you can dive down conceptually deeper and see what's inside of that function.
或者你可以从概念上更深入地潜入，看看这个函数内部的内容。

840
00:41:08,745 --> 00:41:10,620
Lastly, this will let you step out, this will
最后，这个按钮可以让你“单步跳出”，它将

841
00:41:10,620 --> 00:41:13,828
allow you to restart the whole process, and this will just stop the debugger.
允许你重新启动整个过程，而这个按钮只会停止调试器。

842
00:41:13,828 --> 00:41:15,960
So these buttons are going to be our friends.
所以这些按钮将会是我们的好朋友。

843
00:41:15,960 --> 00:41:19,840
And the one I'll click first is the first one I described,
而我将要点击的第一个按钮就是我描述的第一个按钮，

844
00:41:19,840 --> 00:41:21,690
which is step over.
那就是“单步跳过”。

845
00:41:21,690 --> 00:41:26,180
So step over doesn't mean, skip this step, it just means execute it,
所以“单步跳过”并不意味着跳过这一步，它只是意味着执行它，

846
00:41:26,180 --> 00:41:30,000
but don't bother me by going into the weeds of what is on the specific line,
但不要因为要深入到这一行代码中的具体细节而打扰我，

847
00:41:30,000 --> 00:41:30,740
namely get_int.
特别是 get_int 函数。

848
00:41:30,740 --> 00:41:32,990
So when I click this button in a moment, you'll
所以，当我过一会儿点击这个按钮时，你会

849
00:41:32,990 --> 00:41:36,830
see that my terminal, which is still at the bottom, prompts me for a height.
看到我的终端（还在底部）会提示我输入高度。

850
00:41:36,830 --> 00:41:38,600
I'm going to go ahead and type 3.
我将输入 3。

851
00:41:38,600 --> 00:41:41,240
As soon as I hit Enter, what part of the screen
我一按下回车键，屏幕的哪个部分

852
00:41:41,240 --> 00:41:44,285
probably will change based on what I've said?
可能会根据我所说内容而改变？

853
00:41:47,280 --> 00:41:50,760
So h, the variable h should hopefully take on the number 3.
所以，变量 h 希望可以取值为 3。

854
00:41:50,760 --> 00:41:53,340
And I'll probably see a different line of code
我可能还会看到不同的代码行

855
00:41:53,340 --> 00:41:57,990
highlighted, probably line 9 next once I'm done executing line 8.
高亮显示，可能在我执行完第 8 行后，接下来高亮显示的是第 9 行。

856
00:41:57,990 --> 00:42:01,170
So let me go ahead and hit Enter and watch the top-left of the screen.
所以我按下回车键，然后观察屏幕的左上角。

857
00:42:01,170 --> 00:42:08,580
And voila, h now has the value 3, and execution has now paused on line 9
瞧，h 现在取值为 3，执行现在暂停在第 9 行

858
00:42:08,580 --> 00:42:12,900
because the debugger is allowing me to step through my code line by line.
因为调试器允许我逐行调试我的代码。

859
00:42:12,900 --> 00:42:16,998
Now let me go ahead and print out-- let me go ahead and just say, all right,
现在我继续打印出来，我继续说，好吧，

860
00:42:16,998 --> 00:42:17,790
I'm done with this.
我完成了。

861
00:42:17,790 --> 00:42:19,950
Let's go ahead and run the rest of the program.
让我们继续运行程序的剩余部分。

862
00:42:19,950 --> 00:42:21,660
It clearly got the value 3.
它显然得到了值 3。

863
00:42:21,660 --> 00:42:22,658
But wait a minute--
但是等一下

864
00:42:22,658 --> 00:42:24,450
oh, and at this point, it closed the window
哦，在这一点上，它关闭了窗口

865
00:42:24,450 --> 00:42:28,530
in which I would have seen the output, I would have still seen four hashes.
我本来应该在那里看到输出，但我还是看到了四个井号。

866
00:42:28,530 --> 00:42:29,950
So let me actually do this again.
所以让我再来做一遍。

867
00:42:29,950 --> 00:42:34,392
Let me go back into debug50 by running the exact same command again.
让我再次运行相同的命令来回到 debug50。

868
00:42:34,392 --> 00:42:37,350
It's going to think for a moment, it's going to reconfigure the screen.
它会思考一下，它会重新配置屏幕。

869
00:42:37,350 --> 00:42:38,892
I'm going to do the exact same thing.
我要做完全相同的事情。

870
00:42:38,892 --> 00:42:41,100
I'm going to step over this line, but I'd
我将跳过这一行，但我

871
00:42:41,100 --> 00:42:45,490
like to actually see what's going on inside of my print_column function.
想真正看看我的 print_column 函数内部发生了什么。

872
00:42:45,490 --> 00:42:48,580
So this time, instead of just saying run to the end
所以这次，而不是说直接运行到最后

873
00:42:48,580 --> 00:42:51,100
and close all the windows on me, let me go ahead
然后关闭所有窗口，让我继续

874
00:42:51,100 --> 00:42:54,460
and step into my print_column function.
进入我的 print_column 函数。

875
00:42:54,460 --> 00:42:57,070
So don't step over, step into.
所以不要跳过，要进入。

876
00:42:57,070 --> 00:42:58,525
Because if I step over--
因为如果我跳过

877
00:42:58,525 --> 00:43:00,400
and now this is what I meant to show earlier,
现在，这就是我之前想展示的内容，

878
00:43:00,400 --> 00:43:02,710
you can see that it's still printing out 4.
你可以看到它仍然在打印 4。

879
00:43:02,710 --> 00:43:05,930
So in fact, let me undo this, let me just stop the whole thing.
事实上，让我撤销这个，让我停掉整个程序。

880
00:43:05,930 --> 00:43:08,320
Let me rerun the command a final time.
让我最后一次重新运行该命令。

881
00:43:08,320 --> 00:43:10,690
So it goes back to where we began before.
所以它回到了我们之前开始的地方。

882
00:43:10,690 --> 00:43:15,520
It's going to prompt me again once I step over line 8 for a number like 3.
当我跳过第 8 行时，它会再次提示我输入一个像 3 这样的数字。

883
00:43:15,520 --> 00:43:19,930
But this time, instead of stepping over line 9, let's poke around.
但这次，而不是跳过第 9 行，让我们四处看看。

884
00:43:19,930 --> 00:43:23,770
I wrote print_column, so let's look at print_column step by step,
我写了 print_column，所以让我们一步一步地看看 print_column，

885
00:43:23,770 --> 00:43:26,800
step into it, and watch what happens to the yellow highlight.
进入它，然后观察黄色高亮发生了什么。

886
00:43:26,800 --> 00:43:30,220
It now jumps logically to the inside of print_column,
它现在逻辑地跳转到 print_column 的内部，

887
00:43:30,220 --> 00:43:32,510
thereby letting me walk through this code.
从而让我逐步遍历这段代码。

888
00:43:32,510 --> 00:43:35,720
And now I can just step over each of these lines one at a time.
现在我可以逐行跳过这些代码行。

889
00:43:35,720 --> 00:43:37,180
So stepping over.
所以跳过。

890
00:43:37,180 --> 00:43:38,440
OK, so what did it do?
好的，它做了什么？

891
00:43:38,440 --> 00:43:41,200
It did that whole narrative that I did verbally last week
它做了上周我口头描述的整个过程

892
00:43:41,200 --> 00:43:43,720
where it compared i against height.
它将 i 与 height 进行了比较。

893
00:43:43,720 --> 00:43:45,520
It then went inside of the loop.
然后它进入了循环。

894
00:43:45,520 --> 00:43:48,940
When I click Step Over, watch what happens in my terminal-- one hash
当我点击 Step Over 时，观察我的终端发生了什么——一个井号

895
00:43:48,940 --> 00:43:49,660
prints out.
打印出来。

896
00:43:49,660 --> 00:43:51,460
Now line 14 is highlighted again.
现在第 14 行再次高亮显示。

897
00:43:51,460 --> 00:43:54,220
It's comparing per the Boolean expression, i,
它根据布尔表达式比较，i，

898
00:43:54,220 --> 00:43:55,900
is it less than or equal to height?
它是否小于或等于 height？

899
00:43:55,900 --> 00:43:59,770
If so, it's going to go ahead and print out the hash.
如果是这样，它将继续打印哈希值。

900
00:43:59,770 --> 00:44:02,080
It's going to do this again, print out the hash.
它将再次这样做，打印出哈希值。

901
00:44:02,080 --> 00:44:05,020
But notice at the top-left of the screen, height
但请注意屏幕左上角的高度

902
00:44:05,020 --> 00:44:10,180
is still the same, it's still 3, but what has been changing, apparently?
仍然是相同的，它仍然是3，但显然是什么一直在改变？

903
00:44:10,180 --> 00:44:11,960
i on each iteration.
每次迭代中的i。

904
00:44:11,960 --> 00:44:16,240
So the debugger is letting me see what's going on slowly inside of this loop
所以调试器让我慢慢地看到这个循环内部发生了什么

905
00:44:16,240 --> 00:44:18,070
because i keeps getting incremented.
因为i一直在增加。

906
00:44:18,070 --> 00:44:21,580
So if I step over this line now, notice that I've now printed 3.
所以，如果我现在跨过这一行，请注意，我现在已经打印了3。

907
00:44:21,580 --> 00:44:25,690
So ideally I want this loop to end, but if I click Step Over once more,
理想情况下，我希望这个循环结束，但是如果我再次点击“跨过”，

908
00:44:25,690 --> 00:44:29,710
notice that the value of i at top-left is 3,
请注意，左上角i的值是3，

909
00:44:29,710 --> 00:44:35,600
but 3 is less than or equal to height-- oh, now I get it, if I play along here.
但是3小于或等于高度——哦，我现在明白了，如果我在这里配合的话。

910
00:44:35,600 --> 00:44:40,540
Now I see why less than or equals to, mathematically, is clearly incorrect.
现在我明白了为什么从数学角度来看，小于或等于显然是错误的。

911
00:44:40,540 --> 00:44:43,090
And as soon as that light bulb goes off, you can just sort of
一旦灯泡亮起来，你就可以

912
00:44:43,090 --> 00:44:46,570
bail out, click the red Stop button to turn the debugger off,
退出，点击红色的停止按钮来关闭调试器，

913
00:44:46,570 --> 00:44:50,560
go back in, fix your code, and voila, recompile, run it,
回到里面，修复你的代码，瞧，重新编译，运行它，

914
00:44:50,560 --> 00:44:51,950
and you're back in business.
你就又恢复正常了。

915
00:44:51,950 --> 00:44:55,480
So the takeaways here really are just what tools now exist?
所以，这里真正的收获就是现在有哪些工具？

916
00:44:55,480 --> 00:44:59,590
Printf is your friend, but only for quick-and-dirty debugging techniques.
Printf是你的朋友，但它只适用于快速且简单的调试技术。

917
00:44:59,590 --> 00:45:04,930
Get into the habit now of using debug50, and in turn, VS Code's debugger.
现在养成使用debug50的习惯，进而使用VS Code的调试器。

918
00:45:04,930 --> 00:45:08,800
You will invariably not take this advice, say,
你总是不会采纳这个建议，比如，

919
00:45:08,800 --> 00:45:11,710
for problem set 2 as you first begin because it's
在问题集2中，当你第一次开始的时候，因为它是

920
00:45:11,710 --> 00:45:15,340
going to feel easier and quicker just to use printf, just to use printf,
感觉用printf更容易、更快捷，用printf就行了，用printf就行了，

921
00:45:15,340 --> 00:45:16,300
just to use printf.
用printf就行了。

922
00:45:16,300 --> 00:45:17,710
And the problem with that logic is that you
而这种逻辑的问题在于，你

923
00:45:17,710 --> 00:45:20,000
begin to build up like technical debt, so to speak,
开始积累技术债务，可以这么说，

924
00:45:20,000 --> 00:45:21,760
where you really should have learned it earlier,
你本应该早点学习的，

925
00:45:21,760 --> 00:45:23,510
you really should have learned it earlier,
你本应该早点学习的，

926
00:45:23,510 --> 00:45:26,000
you really should have learned it earlier, at which point,
你本应该早点学习的，那时，

927
00:45:26,000 --> 00:45:29,350
you end up spending more time wasted using printf
你最终会浪费更多的时间使用printf

928
00:45:29,350 --> 00:45:32,720
and doing things manually than if you had just spent 10 minutes,
手动操作比你花10分钟

929
00:45:32,720 --> 00:45:35,170
30 minutes just learning the user interface
30分钟学习用户界面

930
00:45:35,170 --> 00:45:37,510
and the buttons of a proper debugger.
和一个合适的调试器的按钮要快得多。

931
00:45:37,510 --> 00:45:40,390
So please take that advice because it will save you
所以请采纳这个建议，因为它可以为你节省

932
00:45:40,390 --> 00:45:45,480
significant amounts of time over time.
大量的时间。

933
00:45:45,480 --> 00:45:48,900
Questions on printf or debugging in this way?
关于printf或这种调试方式有什么问题吗？

934
00:45:52,260 --> 00:45:54,790
Any questions on this?
关于这个有什么问题吗？

935
00:45:54,790 --> 00:45:55,290
No?
没有？

936
00:45:55,290 --> 00:45:55,800
OK.
好的。

937
00:45:55,800 --> 00:45:59,880
So let me give you a third and final technique for debugging, which has been
所以，让我告诉你第三种也是最后一种调试技术，它一直

938
00:45:59,880 --> 00:46:01,840
looming over us here for some time.
萦绕在我们心头。

939
00:46:01,840 --> 00:46:05,400
So there is actually this technique known as rubber duck debugging.
实际上，有一种叫做“橡皮鸭调试”的技术。

940
00:46:05,400 --> 00:46:09,570
And in the absence of a roommate who is taking CS50 or who has taken CS50
如果没有一个正在学习CS50或者已经学过CS50的室友

941
00:46:09,570 --> 00:46:13,140
or knows how to program, in the absence of having a TF or TA or CA
或者知道如何编程，如果没有一个教学助理或助教或课程助理

942
00:46:13,140 --> 00:46:16,920
sitting next to you, in the absence of having a family member available to ask
坐在你旁边，如果没有一个可以问问题的家人

943
00:46:16,920 --> 00:46:22,020
questions of, if you have simply an inanimate object on your desk,
问题，如果你桌上只有一个无生命的物体，

944
00:46:22,020 --> 00:46:25,440
goes the tradition, just talk to that inanimate object.
传统上，就和这个无生命的物体说话。

945
00:46:25,440 --> 00:46:27,970
Better yet, if it's an adorable rubber duck in this way.
更好的是，如果是一个可爱的橡皮鸭，用这种方式。

946
00:46:27,970 --> 00:46:31,560
And the idea of rubber duck debugging is that simply
而橡皮鸭调试的想法是，简单地

947
00:46:31,560 --> 00:46:34,930
by verbalizing literally out loud to this inanimate object--
通过文字形式大声地对这个无生命的物体说出来——

948
00:46:34,930 --> 00:46:36,930
probably with the door closed and no one knowing
可能门是关着的，没有人知道

949
00:46:36,930 --> 00:46:39,930
that you're talking to this rubber duck, you invariably
你在和这只橡皮鸭说话，你总是

950
00:46:39,930 --> 00:46:44,070
end up hearing any illogic in your own thoughts, at which point
最终听到你自己的想法中任何不合理的地方，此时

951
00:46:44,070 --> 00:46:47,340
the proverbial light bulb tends to go off and you're like, oh, I'm an idiot.
俗话说灯泡亮了，你就像，哦，我真蠢。

952
00:46:47,340 --> 00:46:50,310
It's supposed to be less than, not less than or equal to.
应该是小于，而不是小于等于。

953
00:46:50,310 --> 00:46:54,670
So literally just explaining to a duck or any inanimate object what's
所以，文字上来说，就是向一只鸭子或任何无生命的物体解释发生了什么

954
00:46:54,670 --> 00:46:57,790
going on in your code will quite frequently just
在你代码中发生的事情，这经常会

955
00:46:57,790 --> 00:47:02,260
help you see in your mind's eye what it is you've been doing wrong.
帮助你在脑海中看到你一直在做错的地方。

956
00:47:02,260 --> 00:47:05,590
So rubber duck debugging is indeed a very effective technique
所以橡皮鸭调试确实是一种非常有效的技巧

957
00:47:05,590 --> 00:47:09,550
even if you don't happen to have a small or large rubber duck.
即使你碰巧没有一只小或大的橡皮鸭。

958
00:47:09,550 --> 00:47:12,370
Of course, you're also welcome to use the CS50 Duck who
当然，你也可以使用CS50 Duck，它

959
00:47:12,370 --> 00:47:17,710
lives at cs50.ai, and also within a pane in VS Code at cs50.dev.
居住在cs50.ai，以及VS Code的窗格中，在cs50.dev。

960
00:47:17,710 --> 00:47:20,830
You can ask the CS50 Duck about concepts you don't understand,
你可以向CS50 Duck询问你不理解的概念，

961
00:47:20,830 --> 00:47:23,170
or you can even copy paste certain lines of code
或者，你甚至可以复制粘贴某些代码行

962
00:47:23,170 --> 00:47:27,460
with which you might be having trouble and ask the duck for its own advice.
你可能遇到了一些麻烦，并向这只鸭子寻求它自己的建议。

963
00:47:27,460 --> 00:47:28,180
All right.
好吧。

964
00:47:28,180 --> 00:47:33,730
So, with those tools in our toolkit, let me propose now that we do--
所以，有了这些工具，现在我建议我们做——

965
00:47:33,730 --> 00:47:37,390
that we introduce now a few lower-level features of C
现在介绍一下C语言中的一些低级特性

966
00:47:37,390 --> 00:47:40,720
itself and better understand how we can start solving some of those problems
本身，并更好地理解如何开始解决其中的一些问题

967
00:47:40,720 --> 00:47:44,860
like the readability of text or the encryption of data.
比如文本的可读性或数据的加密。

968
00:47:44,860 --> 00:47:47,080
These were our so-called types last week when
这些是我们上周所说的类型，当

969
00:47:47,080 --> 00:47:51,490
we introduced at least a subset of them or used them just to store data
我们至少介绍了其中的一部分，或者只是用它们来存储数据

970
00:47:51,490 --> 00:47:53,328
in a certain format, so to speak.
以某种格式，可以说。

971
00:47:53,328 --> 00:47:55,870
Like in week 0, we said that everything at the end of the day
就像在第0周，我们说，最终来说，一切

972
00:47:55,870 --> 00:47:57,490
is just 0's and 1's, binary.
都是0和1，二进制。

973
00:47:57,490 --> 00:48:03,130
And I claimed conceptually that how a computer knows if a set of bits
我概念上声称，计算机如何知道一组比特

974
00:48:03,130 --> 00:48:08,230
is a number versus a letter versus a color or a sound or an image or a video
是一个数字还是一个字母，还是一个颜色，或者一个声音，或者一张图片，或者一个视频

975
00:48:08,230 --> 00:48:11,048
is just context-dependent, like you're using Photoshop
仅仅是依赖于上下文，就像你使用Photoshop

976
00:48:11,048 --> 00:48:13,090
or you're using Microsoft Word or something else.
或者你使用Microsoft Word或其他东西。

977
00:48:13,090 --> 00:48:16,420
But last week, we saw a little more precisely that it's
但上周，我们更精确地看到了，它是

978
00:48:16,420 --> 00:48:18,490
not quite as broad strokes as that.
不像那样宽泛。

979
00:48:18,490 --> 00:48:23,680
It's more about what the programmer has told the software is
更多的是关于程序员告诉软件的是

980
00:48:23,680 --> 00:48:25,690
being stored in a given variable.
存储在给定的变量中。

981
00:48:25,690 --> 00:48:26,590
Is it an integer?
它是一个整数吗？

982
00:48:26,590 --> 00:48:28,180
Is it a char, a character?
它是一个char，一个字符吗？

983
00:48:28,180 --> 00:48:29,350
Is it a whole string?
它是一个完整的字符串吗？

984
00:48:29,350 --> 00:48:31,610
Is it a longer integer or the like?
它是一个更长的整数还是类似的东西？

985
00:48:31,610 --> 00:48:33,460
So you now have this control.
所以你现在有这种控制权。

986
00:48:33,460 --> 00:48:36,340
The catch, though, recall, though, is that each of these types
不过，回想一下，是这些类型中的每一个

987
00:48:36,340 --> 00:48:39,710
has only a finite amount of space allocated to it.
都只分配了有限的空间。

988
00:48:39,710 --> 00:48:43,060
So for instance, an integer is typically 4 bytes,
例如，一个整数通常是4个字节，

989
00:48:43,060 --> 00:48:46,780
and 4 bytes is 32 bits because it's 8 times 4.
而4个字节是32位，因为它是8乘以4。

990
00:48:46,780 --> 00:48:49,390
32 bits, we claimed, is roughly 4 billion,
我们声称，32位大约是40亿，

991
00:48:49,390 --> 00:48:52,120
but if you want to represent negative and positive numbers,
但如果你想表示负数和正数，

992
00:48:52,120 --> 00:48:55,330
the biggest integer you can store is like 2 billion.
你能存储的最大整数大约是20亿。

993
00:48:55,330 --> 00:48:57,650
Now that's really big for a lot of applications,
这对很多应用来说已经很大了，

994
00:48:57,650 --> 00:48:59,950
but years ago, Facebook, for instance, was
但几年前，比如Facebook，

995
00:48:59,950 --> 00:49:04,100
rumored to be using integers when they had fewer users.
据说在用户数量较少的时候使用了整数。

996
00:49:04,100 --> 00:49:06,790
But now that they have billions of users--
但现在他们有数十亿用户——

997
00:49:06,790 --> 00:49:12,100
3-plus billion users, an integer is no longer big enough for the Facebooks,
超过30亿用户，整数对于Facebook、

998
00:49:12,100 --> 00:49:15,620
the Googles, the Microsofts and so forth of the world.
谷歌、微软等世界级公司来说已经不够大了。

999
00:49:15,620 --> 00:49:21,520
So we also have longs, which use twice as many bytes, but exponentially
所以我们还有long，它使用两倍的字节数，但指数级地

1000
00:49:21,520 --> 00:49:23,080
bigger range of values.
更大的值范围。

1001
00:49:23,080 --> 00:49:26,260
Meanwhile, a bool, interestingly, is a byte, which
与此同时，bool很有趣，它是一个字节，这

1002
00:49:26,260 --> 00:49:29,550
is kind of bad design in what sense?
在某种程度上算是一种糟糕的设计？

1003
00:49:29,550 --> 00:49:31,780
Why might that be bad design?
为什么那可能是糟糕的设计？

1004
00:49:31,780 --> 00:49:33,590
It's only-- it should only be 2--
它应该只有2——

1005
00:49:33,590 --> 00:49:36,170
1 bit, rather, because a 0 or 1 should suffice.
确切地说，应该是1位，因为0或1就足够了。

1006
00:49:36,170 --> 00:49:38,440
Turns out, it's just easier to use a whole byte
事实证明，使用一个完整的字节更容易

1007
00:49:38,440 --> 00:49:40,900
even though we're wasting seven of those bits,
即使我们浪费了其中七个位，

1008
00:49:40,900 --> 00:49:43,750
but bools are represented nonetheless with 1 byte.
但bool仍然用1个字节表示。

1009
00:49:43,750 --> 00:49:45,400
Chars are going to be 1 byte.
char将占用1个字节。

1010
00:49:45,400 --> 00:49:47,890
Floats tend to be 4 bytes.
float通常是4个字节。

1011
00:49:47,890 --> 00:49:49,390
Doubles tend to be 8 bytes.
double通常是8个字节。

1012
00:49:49,390 --> 00:49:52,510
Some of this is system-dependent, but nowadays on modern computers,
有些是系统相关的，但在现代计算机上，

1013
00:49:52,510 --> 00:49:54,250
this tends to be a useful rule of thumb.
这通常是一个有用的经验法则。

1014
00:49:54,250 --> 00:49:56,710
The only one I can't commit to here is a string
这里我唯一不能确定的就是字符串

1015
00:49:56,710 --> 00:49:58,900
because a string, recall, is a sequence of text.
因为字符串，回想一下，是文本的序列。

1016
00:49:58,900 --> 00:50:02,800
And maybe it has no characters, one character, two, 10, 100.
它可能没有字符，一个字符，两个，十个，一百个。

1017
00:50:02,800 --> 00:50:05,410
So it's a variable number of bytes presumably
所以它很可能是一个可变数量的字节

1018
00:50:05,410 --> 00:50:08,590
where each byte represents a given character.
其中每个字节代表一个给定的字符。

1019
00:50:08,590 --> 00:50:12,370
So with that said, how do we get from an actual computer
综上所述，我们如何从实际的计算机

1020
00:50:12,370 --> 00:50:16,060
to information being represented therein?
到其中表示的信息？

1021
00:50:16,060 --> 00:50:19,270
Well, let me remind us that this is what's inside of our Macs, PCs, phones.
好吧，让我提醒大家，这就是我们Mac、PC、手机里面的东西。

1022
00:50:19,270 --> 00:50:22,220
Even though this isn't a scale and it might not be the same shape,
即使这不是一个比例尺，它可能也不同形状，

1023
00:50:22,220 --> 00:50:24,520
this is memory, random access memory.
这就是内存，随机存取内存。

1024
00:50:24,520 --> 00:50:26,890
And on these black chips, on the circuit board
在这些黑色芯片上，在电路板上

1025
00:50:26,890 --> 00:50:29,360
here, are the bytes that we keep talking about.
这里，就是我们一直在谈论的字节。

1026
00:50:29,360 --> 00:50:31,940
In fact, let's go ahead and zoom in on one of these chips,
事实上，让我们放大其中一个芯片，

1027
00:50:31,940 --> 00:50:33,110
fill the screen here.
填充这里屏幕。

1028
00:50:33,110 --> 00:50:35,820
And just for an artist's depiction's sake,
为了艺术描绘的缘故，

1029
00:50:35,820 --> 00:50:38,480
let me propose that if you've got, I don't know,
我建议，如果你有，我不知道，

1030
00:50:38,480 --> 00:50:43,340
a megabyte, a gigabyte-- like a lot of bytes packed into this chip nowadays,
一个兆字节，一个吉字节——像现在许多字节被塞进这个芯片一样，

1031
00:50:43,340 --> 00:50:46,100
it stands to reason that no matter how many of them you have,
可以推测，无论你有多少个，

1032
00:50:46,100 --> 00:50:48,398
we could just number them from top to bottom
我们可以从上到下对它们进行编号

1033
00:50:48,398 --> 00:50:50,690
and we could say that this is byte 1, or you know what?
我们可以说，这是字节1，或者你知道吗？

1034
00:50:50,690 --> 00:50:55,950
This is byte 0, 1, 2, 3, and this is maybe byte 1 billion or whatever it is.
这是字节0、1、2、3，也许这是字节10亿或者其他什么东西。

1035
00:50:55,950 --> 00:50:58,370
So you can think of memory as having addresses
所以你可以认为内存有地址

1036
00:50:58,370 --> 00:51:03,020
or just locations, numeric indices that identify each of those bytes
或者位置，数值索引，用来识别每一个字节

1037
00:51:03,020 --> 00:51:03,710
individually.
分别。

1038
00:51:03,710 --> 00:51:04,550
Why a byte?
为什么是字节？

1039
00:51:04,550 --> 00:51:08,300
Individual bits are not that useful, so 8, again, 1 byte
单个比特没有太大用处，所以 8 个比特，也就是 1 字节

1040
00:51:08,300 --> 00:51:10,400
tends to be the de facto standard.
通常是事实上的标准。

1041
00:51:10,400 --> 00:51:14,360
Let me-- so, for instance, if you're storing just a single character,
比如说，如果你只是存储一个字符，

1042
00:51:14,360 --> 00:51:18,570
a char, it might be stored literally in this top-left corner, so to speak,
一个字符，它可能存储在内存芯片的左上角，打个比方，

1043
00:51:18,570 --> 00:51:20,600
of the chip of memory.
在内存芯片的左上角。

1044
00:51:20,600 --> 00:51:23,060
If you're storing maybe an integer, 4 bytes,
如果你要存储一个整数，4 个字节，

1045
00:51:23,060 --> 00:51:24,830
it might take up that many bytes.
它可能占用这么多字节。

1046
00:51:24,830 --> 00:51:28,760
If you're storing a long, it might take up that many bytes instead.
如果你要存储一个长整型，它可能会占用这么多字节。

1047
00:51:28,760 --> 00:51:31,520
Now we don't have to dwell on the particulars of the circuit board
现在我们不需要纠结电路板的细节

1048
00:51:31,520 --> 00:51:34,580
and these traces and all the connections, so let me just abstract
这些走线以及所有的连接，所以我简单抽象一下

1049
00:51:34,580 --> 00:51:37,550
this away and claim that what your computer's memory really
这个概念，并断言你的电脑内存实际上

1050
00:51:37,550 --> 00:51:41,060
is is just kind of this canvas, I mean kind of in the Photoshop sense.
就是一个画布，我指的是类似于 Photoshop 的画布。

1051
00:51:41,060 --> 00:51:43,040
If you've ever made pictures, it's just a grid
如果你曾经画过画，它就是一个网格

1052
00:51:43,040 --> 00:51:46,220
of pixels, up, down, left, right, that's really all your memory is.
像素网格，上下左右，这就是你的内存。

1053
00:51:46,220 --> 00:51:51,110
It's this canvas that you can manipulate the bits on to store numbers anywhere
它是一个画布，你可以在上面操控比特，在任何地方存储数字

1054
00:51:51,110 --> 00:51:53,190
you want in the computer's memory.
你想要在电脑的内存中存储数字。

1055
00:51:53,190 --> 00:51:55,400
So in fact, let's zoom in here and let's consider
实际上，让我们放大看看，并考虑一下

1056
00:51:55,400 --> 00:52:01,640
how your computer is actually storing information using just these bytes.
你的电脑如何使用这些字节来存储信息。

1057
00:52:01,640 --> 00:52:04,190
At the end of the day, no matter how sophisticated
归根结底，无论你的 Mac、PC 或者手机有多高端，

1058
00:52:04,190 --> 00:52:07,280
your Mac, your PC, your phone is, like this is all
这都是

1059
00:52:07,280 --> 00:52:10,310
it has access to for storing information.
它用来存储信息的东西。

1060
00:52:10,310 --> 00:52:13,010
It's a canvas of bytes, and what you do with this
它是一个字节的画布，你如何使用它

1061
00:52:13,010 --> 00:52:15,720
now really invites design decisions.
现在真的需要设计决策。

1062
00:52:15,720 --> 00:52:17,000
So let's consider this.
所以让我们考虑一下。

1063
00:52:17,000 --> 00:52:20,060
Here is an excerpt from a program wherein maybe I'm
这里有一个程序片段，我可能在

1064
00:52:20,060 --> 00:52:22,160
prompting the user for three scores.
提示用户输入三个分数。

1065
00:52:22,160 --> 00:52:24,950
Like three test, scores, exam scores, something like that.
比如三次考试的分数，类似这样。

1066
00:52:24,950 --> 00:52:27,035
And the purpose in life of this program is maybe
这个程序的目的是

1067
00:52:27,035 --> 00:52:28,910
to average those three scores together if you
把这三个分数加起来求平均数，如果你

1068
00:52:28,910 --> 00:52:31,118
want to get a sense of where you stand in some class.
想了解你在某门课上的成绩情况。

1069
00:52:31,118 --> 00:52:33,290
So we can certainly whip up some code like this.
所以我们可以写出这样的代码。

1070
00:52:33,290 --> 00:52:37,370
And in just a moment, let me go ahead and flip over to VS Code here.
过一会儿，我切换到 VS Code。

1071
00:52:37,370 --> 00:52:41,420
And I'll write up a new program called scores.c.
我将编写一个名为 scores.c 的新程序。

1072
00:52:41,420 --> 00:52:46,460
And in this, let me go ahead and first include stdio.h,
在这个程序中，首先包含 stdio.h 头文件，

1073
00:52:46,460 --> 00:52:48,710
int main void at the top.
在开头添加 int main 函数。

1074
00:52:48,710 --> 00:52:51,750
And in here, let me go ahead and assume that, eh,
在这里，我假设，

1075
00:52:51,750 --> 00:52:53,250
it's not been the greatest semester.
这学期不太顺利。

1076
00:52:53,250 --> 00:52:56,930
So my first score, which I'll call score1, was a 72,
我的第一个分数，我将它命名为 score1，是 72，

1077
00:52:56,930 --> 00:53:03,050
my second score was a 73, but my third score, score3, was like a 33.
我的第二个分数是 73，但我的第三个分数，score3，是 33。

1078
00:53:03,050 --> 00:53:05,832
Now you might remember these numbers in another context,
你可能在另一个情况下记得这些数字，

1079
00:53:05,832 --> 00:53:08,540
they might spell a message, but in this case, it's just integers.
它们可能拼出一个信息，但在这种情况下，它们仅仅是整数。

1080
00:53:08,540 --> 00:53:12,320
It's just numbers because I'm telling the computer to treat these as ints.
它们只是数字，因为我告诉电脑将它们视为整数。

1081
00:53:12,320 --> 00:53:15,750
Now if I want to figure out what my average is, I can do a bit of math.
现在，如果我想计算我的平均分，我可以做一些计算。

1082
00:53:15,750 --> 00:53:18,770
So let me just print out that my average is--
所以，我只需要打印出我的平均分是--

1083
00:53:18,770 --> 00:53:20,600
and I don't want to shortchange myself.
我不想低估自己。

1084
00:53:20,600 --> 00:53:23,910
I'm not going to use %i because I don't want to lose even anything after
我不会使用 %i，因为我不想在

1085
00:53:23,910 --> 00:53:24,660
the decimal point.
小数点后丢失任何东西。

1086
00:53:24,660 --> 00:53:26,540
So we're going to use a float instead.
所以我们将使用浮点数。

1087
00:53:26,540 --> 00:53:33,230
And my average i claim will be score1 plus score2 plus score3
我声称我的平均值将是 score1 加 score2 加 score3

1088
00:53:33,230 --> 00:53:36,200
divided by 3, semicolon.
除以 3，分号。

1089
00:53:36,200 --> 00:53:38,840
With parentheses, because just like grade school math,
用括号，因为就像小学数学一样，

1090
00:53:38,840 --> 00:53:41,580
like order of operations, I parenthesize the numerator,
就像运算顺序一样，我将分子括起来，

1091
00:53:41,580 --> 00:53:43,670
so I can divide the whole thing by 3.
这样我就可以用 3 除以整个表达式。

1092
00:53:43,670 --> 00:53:45,350
But I have screwed up already.
但我已经搞砸了。

1093
00:53:45,350 --> 00:53:49,370
I am going to shortchange myself and not give myself as high a grade
我要亏待自己，不给自己这么高的分数

1094
00:53:49,370 --> 00:53:51,977
as I deserve, but this one's subtle.
尽管我应得，但这有点微妙。

1095
00:53:51,977 --> 00:53:52,935
What have I done wrong?
我做错了什么？

1096
00:53:56,230 --> 00:53:59,740
Yeah, I might want to cast these scores to floats
是的，我可能想要将这些分数转换为浮点数

1097
00:53:59,740 --> 00:54:05,290
because if you do integral math, divide an integer or the sum of an integers--
因为如果你做的是整数运算，除以一个整数或者几个整数的和——

1098
00:54:05,290 --> 00:54:09,710
some integers by an integer, it's going to be an integer as the result,
用一个整数除以几个整数，结果也会是一个整数，

1099
00:54:09,710 --> 00:54:12,730
so it's going to throw away anything after the decimal point.
所以它会丢弃小数点后的任何东西。

1100
00:54:12,730 --> 00:54:15,970
Even if it's something-point-1, something-point-5, something-point-9,
即使是 something-point-1，something-point-5，something-point-9，

1101
00:54:15,970 --> 00:54:18,010
that fraction is going to be thrown away.
那个小数部分会被丢弃。

1102
00:54:18,010 --> 00:54:19,750
There's a bunch of ways to fix this.
有很多方法可以解决这个问题。

1103
00:54:19,750 --> 00:54:22,810
I could just use floats or doubles for all of these.
我可以简单地对所有这些使用浮点数或双精度数。

1104
00:54:22,810 --> 00:54:26,140
I could cast score1, score2, or score3 as you propose.
我可以像你建议的那样，将 score1，score2 或 score3 转换为浮点数。

1105
00:54:26,140 --> 00:54:28,780
Frankly, the simplest way is just change the denominator
坦白地说，最简单的方法就是改变分母

1106
00:54:28,780 --> 00:54:31,840
because so long as I've got one float involved in the math,
因为只要在运算中包含一个浮点数，

1107
00:54:31,840 --> 00:54:35,950
this will promote the whole arithmetic expression to being floating point
整个算术表达式就会提升为浮点运算

1108
00:54:35,950 --> 00:54:37,690
math instead of integer math.
而不是整数运算。

1109
00:54:37,690 --> 00:54:41,110
So let me go ahead now and do make scores, Enter.
所以我现在就开始做 make scores，回车。

1110
00:54:41,110 --> 00:54:45,100
So far, so good. ./scores, and my average seems to be not great,
到目前为止一切都好。 ./scores，我的平均分似乎不太好，

1111
00:54:45,100 --> 00:54:47,140
but 59.33333--
但 59.33333——

1112
00:54:47,140 --> 00:54:47,950
so in the third.
所以排在第三名。

1113
00:54:47,950 --> 00:54:50,200
But I would have lost that third if I hadn't
但我如果没

1114
00:54:50,200 --> 00:54:52,940
used a float in this particular way.
用这种方式使用浮点数，我就会失去第三名。

1115
00:54:52,940 --> 00:54:56,570
Well, let's consider now what's actually going on inside of the computer
好吧，现在让我们考虑一下计算机内部实际上发生了什么

1116
00:54:56,570 --> 00:54:58,650
when I store these three variables.
当我存储这三个变量时。

1117
00:54:58,650 --> 00:55:01,175
So, back to the grid here, just my canvas of memory.
所以，回到这里的网格，也就是我的内存画布。

1118
00:55:01,175 --> 00:55:03,050
It doesn't really matter where things end up.
它们最终出现在哪里并不重要。

1119
00:55:03,050 --> 00:55:04,820
I might put it here, I might put it there,
我可能把它放在这里，也可能放在那里，

1120
00:55:04,820 --> 00:55:06,510
the computer makes these decisions.
计算机会做出这些决定。

1121
00:55:06,510 --> 00:55:10,500
But for the artist's sake, I'm going to put it at the top left-hand corner
但为了艺术的缘故，我要把它放在左上角

1122
00:55:10,500 --> 00:55:11,000
here.
这里。

1123
00:55:11,000 --> 00:55:15,710
So, score1 is containing the integer 72.
所以，score1 包含整数 72。

1124
00:55:15,710 --> 00:55:20,580
Why is it taking up four squares, though?
为什么它占用了四个方格呢？

1125
00:55:20,580 --> 00:55:22,040
Because?
因为？

1126
00:55:22,040 --> 00:55:23,030
It's an integer.
它是一个整数。

1127
00:55:23,030 --> 00:55:25,500
And on this system, an integer is 4 bytes.
在这个系统上，一个整数是 4 字节。

1128
00:55:25,500 --> 00:55:30,170
So I've drawn it to scale, if you will. score2 is the number 73,
所以，如果你愿意，我把它画成了比例。 score2 是数字 73，

1129
00:55:30,170 --> 00:55:32,150
it also takes 4 bytes.
它也占用了 4 字节。

1130
00:55:32,150 --> 00:55:34,850
By coincidence, but also by convention, it
巧合的是，也是按照惯例，它

1131
00:55:34,850 --> 00:55:38,180
will likely end up next to the first integer
很可能最终会出现在第一个整数旁边

1132
00:55:38,180 --> 00:55:40,970
in memory because I've only got three variables going on anyway,
在内存中，因为我只有三个变量在运行。

1133
00:55:40,970 --> 00:55:44,360
so the computer quite likely will store them back to back to back.
所以计算机很可能将它们存储在一起。

1134
00:55:44,360 --> 00:55:48,110
And indeed, by that logic, score3, containing the number 33,
实际上，根据这种逻辑，score3包含数字33，

1135
00:55:48,110 --> 00:55:50,060
is going to fill in this space here.
将填充这里空间。

1136
00:55:50,060 --> 00:55:51,917
We'll consider down the road what happens
我们将在后面考虑发生什么

1137
00:55:51,917 --> 00:55:53,750
if things get fragmented-- something's here,
如果事情变得碎片化——这里有些东西，

1138
00:55:53,750 --> 00:55:55,875
something's here, something's here, but for now, we
这里有些东西，这里有些东西，但现在，我们

1139
00:55:55,875 --> 00:55:59,507
can assume that this is probably contiguous, though not necessarily so.
可以假设这可能是连续的，虽然不一定如此。

1140
00:55:59,507 --> 00:56:01,340
All right, so that's pretty straightforward,
好的，所以这很简单，

1141
00:56:01,340 --> 00:56:02,750
but what's really going on?
但实际上发生了什么？

1142
00:56:02,750 --> 00:56:04,940
Well, these are just bytes of memory--
嗯，这些只是内存字节——

1143
00:56:04,940 --> 00:56:07,850
that is, bits of memory times 8.
也就是说，内存位乘以8。

1144
00:56:07,850 --> 00:56:10,460
And so what's really going on is this pattern
因此，实际上正在发生的是这种模式

1145
00:56:10,460 --> 00:56:14,150
of 0's and 1's is being stored to represent 72.
0和1被存储起来表示72。

1146
00:56:14,150 --> 00:56:16,280
This pattern of 0's and 1's is being stored
这种0和1的模式被存储

1147
00:56:16,280 --> 00:56:19,220
to represent 73, and similarly, 33.
用来表示73，同样，33。

1148
00:56:19,220 --> 00:56:22,750
But that's a very low level detail that we don't really care about,
但这是一个非常底层的细节，我们并不关心，

1149
00:56:22,750 --> 00:56:27,550
so we'll generally just think about these as numbers like 72, 73, 33.
所以我们通常只把它们当作72、73、33这样的数字来考虑。

1150
00:56:27,550 --> 00:56:28,050
All right.
好的。

1151
00:56:28,050 --> 00:56:32,280
So if we go back to the actual code, though, here, I
所以如果我们回到实际代码，这里，我

1152
00:56:32,280 --> 00:56:35,250
wonder if this is the best idea.
想知道这是否是最好的主意。

1153
00:56:35,250 --> 00:56:38,280
These three lines of code are correct.
这三行代码是正确的。

1154
00:56:38,280 --> 00:56:41,670
I got my 59 and 1/3 for my average, which I claim
我得到了我的平均分59又1/3，我声称

1155
00:56:41,670 --> 00:56:46,740
is correct, but code-wise, this should maybe rub you the wrong way.
是正确的，但从代码的角度来说，这可能让你觉得不舒服。

1156
00:56:46,740 --> 00:56:49,890
Even if you hadn't programmed before CS50,
即使你在CS50之前没有编程过，

1157
00:56:49,890 --> 00:56:53,250
why might this not be the best approach to storing things
为什么这可能不是存储东西的最佳方法

1158
00:56:53,250 --> 00:56:57,170
like scores in a program?
比如程序中的分数？

1159
00:56:57,170 --> 00:56:58,670
How might this get us in trouble?
这可能会给我们带来什么麻烦？

1160
00:56:58,670 --> 00:56:59,240
Yeah?
是吗？

1161
00:56:59,240 --> 00:57:03,890
AUDIENCE: [INAUDIBLE]
观众：[听不见]

1162
00:57:03,890 --> 00:57:04,670
DAVID MALAN: Yeah.
大卫·马兰：是的。

1163
00:57:04,670 --> 00:57:06,410
It's not the best because you have to use a whole bunch
这不是最好的，因为你必须使用很多

1164
00:57:06,410 --> 00:57:08,180
of different variables for each score.
不同的变量来表示每个分数。

1165
00:57:08,180 --> 00:57:11,330
They're almost identically named, though, but just imagine
虽然它们的名字几乎完全相同，但请想象

1166
00:57:11,330 --> 00:57:15,620
in almost any question involving the design of your code, what happens is n,
在几乎任何涉及你代码设计的问题中，发生的事情是n，

1167
00:57:15,620 --> 00:57:18,170
the number of things involved, gets larger?
参与的事物数量变大？

1168
00:57:18,170 --> 00:57:21,950
Am I really going to start writing code that has score4, score5, score6,
我真的要开始写包含score4、score5、score6的代码吗？

1169
00:57:21,950 --> 00:57:23,270
score10, score20?
score10、score20？

1170
00:57:23,270 --> 00:57:27,560
I mean, your code is just going to look like this mess of mostly copy-paste
我的意思是，你的代码看起来就像这样一堆大部分是复制粘贴的东西

1171
00:57:27,560 --> 00:57:30,227
except that the number at the end of the variable is changing.
除了变量末尾的数字在改变。

1172
00:57:30,227 --> 00:57:32,810
Like that should make you cringe a little bit because it's not
这应该让你有点畏缩，因为这不是

1173
00:57:32,810 --> 00:57:34,610
going to end well eventually.
最终会得到好的结果。

1174
00:57:34,610 --> 00:57:37,280
And typographical errors are going to get in the way most likely
而且打字错误很可能会妨碍

1175
00:57:37,280 --> 00:57:38,447
because we'll make mistakes.
因为我们会犯错误。

1176
00:57:38,447 --> 00:57:41,240
So how can we do a little bit better than that?
那么我们如何做得比这更好一些呢？

1177
00:57:41,240 --> 00:57:45,750
Well, let me propose that we introduce what we're going to now call an array.
好吧，我建议我们引入一个现在叫做数组的东西。

1178
00:57:45,750 --> 00:57:52,950
An array is a sequence of values back to back to back in memory.
数组是内存中一系列紧挨着的数值。

1179
00:57:52,950 --> 00:57:57,870
So an array is just a chunk of memory storing values back to back to back.
所以数组只是一块存储紧挨着数值的内存。

1180
00:57:57,870 --> 00:57:59,810
So no gaps, no fragmentation.
所以没有间隙，没有碎片化。

1181
00:57:59,810 --> 00:58:02,870
From left to right, top to bottom, just as I already drew.
从左到右，从上到下，就像我之前画的那样。

1182
00:58:02,870 --> 00:58:05,550
But these arrays in C, at least, are going
但是，至少在 C 语言中，这些数组将

1183
00:58:05,550 --> 00:58:09,070
to give a slightly new syntax that addresses exactly your concern.
提供一种稍微新的语法，准确地解决你的问题。

1184
00:58:09,070 --> 00:58:14,580
So here instead is I would propose how you define a one variable--
所以，这里我建议你如何定义一个变量——

1185
00:58:14,580 --> 00:58:19,890
not three, one variable called scores, plural, each of whose values
不是三个，而是名为 scores（复数）的一个变量，其每个值

1186
00:58:19,890 --> 00:58:24,150
is going to be an int, and you want three integers tucked away
将是一个 int 类型，你想将三个整数存储

1187
00:58:24,150 --> 00:58:25,420
in that variable.
在这个变量中。

1188
00:58:25,420 --> 00:58:28,440
So now I can pluralize the name of my variable
所以现在我可以将我的变量名改为复数形式

1189
00:58:28,440 --> 00:58:32,010
because by using square brackets and the number 3, I'm telling the compiler,
因为使用方括号和数字 3，我告诉编译器，

1190
00:58:32,010 --> 00:58:36,510
give me enough room for not one, not two, but three integers in total.
给我足够的空间，不是一个，不是两个，而是总共三个整数。

1191
00:58:36,510 --> 00:58:39,240
And the computer is going to do me a favor by storing them back
而且计算机将帮我一个忙，将它们存储回去

1192
00:58:39,240 --> 00:58:41,790
to back to back in the computer's memory.
到计算机内存中，相邻存放。

1193
00:58:41,790 --> 00:58:45,810
Now assigning values to these variables is almost the same,
现在给这些变量赋值几乎是一样的，

1194
00:58:45,810 --> 00:58:47,460
but the syntax looks like this.
但是语法看起来是这样的。

1195
00:58:47,460 --> 00:58:53,370
To assign the first value, I do scores, bracket, 0 equals whatever, 72.
要分配第一个值，我使用 scores，方括号，0 等于任何值，72。

1196
00:58:53,370 --> 00:58:58,560
scores, bracket, 1 equals 73; scores, bracket, 2 equals 33.
scores，方括号，1 等于 73；scores，方括号，2 等于 33。

1197
00:58:58,560 --> 00:59:00,360
And it's square brackets consistently.
并且始终使用方括号。

1198
00:59:00,360 --> 00:59:02,220
And notice, this is a feature--
请注意，这是一项功能——

1199
00:59:02,220 --> 00:59:04,080
or a downside of C.
或者说 C 语言的缺点。

1200
00:59:04,080 --> 00:59:07,980
We very frequently use the same syntax for slightly different ideas.
我们经常使用相同的语法表达略微不同的含义。

1201
00:59:07,980 --> 00:59:12,180
This first line tells the computer, give me an array of size 3.
第一行告诉计算机，给我一个大小为 3 的数组。

1202
00:59:12,180 --> 00:59:16,830
These next three lines mean, go into this array at location 0
接下来的三行意味着，进入这个数组的第 0 个位置

1203
00:59:16,830 --> 00:59:18,060
and put this value there.
并将这个值放在那里。

1204
00:59:18,060 --> 00:59:21,280
Location 1, put this value there; location 2, put this value there.
第 1 个位置，将这个值放在那里；第 2 个位置，将这个值放在那里。

1205
00:59:21,280 --> 00:59:24,690
So same syntax, but different meaning depending on the context here.
所以，相同的语法，但根据上下文，含义不同。

1206
00:59:24,690 --> 00:59:28,470
But the equal sign indeed means that this is assignment from right
但是，等号确实意味着，这是从右

1207
00:59:28,470 --> 00:59:30,340
to left just like last week.
到左的赋值，就像上周一样。

1208
00:59:30,340 --> 00:59:33,750
So what does this mean in the computer's memory?
那么，在计算机内存中，这意味着什么呢？

1209
00:59:33,750 --> 00:59:38,192
Well, in this case here, we now have a slightly different way of doing this.
好吧，在这个例子中，我们现在有一种稍微不同的方法来做到这一点。

1210
00:59:38,192 --> 00:59:39,900
And actually, let me do it first in code.
实际上，让我先在代码中演示一下。

1211
00:59:39,900 --> 00:59:43,440
Let me go back to VS Code here, and let me
让我回到 VS Code 这里，然后让我

1212
00:59:43,440 --> 00:59:48,100
propose that instead of having these three separate variables,
建议，与其使用这三个独立的变量，

1213
00:59:48,100 --> 00:59:52,590
let me give myself an int, scores variable of size 3,
让我给自己一个大小为 3 的 int 型 scores 变量，

1214
00:59:52,590 --> 00:59:58,590
and then do scores, bracket, 0 equals 72; scores, bracket, 1 equals 73;
然后执行 scores，方括号，0 等于 72；scores，方括号，1 等于 73；

1215
00:59:58,590 --> 01:00:02,100
scores, bracket, 2 equals 33.
scores，方括号，2 等于 33。

1216
01:00:02,100 --> 01:00:05,730
And now I have to change this syntax slightly, but same idea.
现在我需要稍微改变一下语法，但想法是一样的。

1217
01:00:05,730 --> 01:00:12,660
scores, bracket, 0; scores, bracket, 1; and lastly, scores, bracket, 2.
scores，方括号，0；scores，方括号，1；最后，scores，方括号，2。

1218
01:00:12,660 --> 01:00:14,640
So a couple of key details.
所以，一些关键细节。

1219
01:00:14,640 --> 01:00:16,000
I started counting at 0.
我从 0 开始计数。

1220
01:00:16,000 --> 01:00:16,500
Why?
为什么？

1221
01:00:16,500 --> 01:00:18,210
That's just the way it is with arrays.
这就是数组的规则。

1222
01:00:18,210 --> 01:00:21,818
You must start counting at 0 unless you want to waste one of those spaces.
你必须从 0 开始计数，除非你想要浪费其中一个空间。

1223
01:00:21,818 --> 01:00:23,610
And what you definitely don't want to do is
你绝对不想做的是

1224
01:00:23,610 --> 01:00:27,030
go into scores, bracket, 3 because I only
访问 scores，方括号，3，因为我只有

1225
01:00:27,030 --> 01:00:29,190
ask the computer for three integers.
要求计算机提供三个整数。

1226
01:00:29,190 --> 01:00:32,190
If I blindly do something like this, you're going too far.
如果我盲目地这样做，你就超出了范围。

1227
01:00:32,190 --> 01:00:34,830
You're going beyond the end of the chunk of memory
你正在超出内存块的末尾

1228
01:00:34,830 --> 01:00:37,080
and bad things will often happen.
而且经常会发生不好的事情。

1229
01:00:37,080 --> 01:00:38,770
So we won't do that just yet.
所以我们现在还不会这样做。

1230
01:00:38,770 --> 01:00:43,030
But for now, 0, 1, and 2 are the first, second, and third locations.
但就目前而言，0、1 和 2 分别是第一个、第二个和第三个位置。

1231
01:00:43,030 --> 01:00:48,030
So if I recompile this code-- so make scores seems OK. ./scores,
所以，如果我重新编译此代码——让得分看起来没问题。./得分，

1232
01:00:48,030 --> 01:00:50,607
and I get the exact same answer there.
我在这里得到了完全相同的答案。

1233
01:00:50,607 --> 01:00:52,440
But let me make it more dynamic because this
但让我把它变得更动态，因为这

1234
01:00:52,440 --> 01:00:56,670
is a little stupid that I'm compiling a program with my scores hardcoded.
我用我的得分硬编码来编译一个程序，这有点愚蠢。

1235
01:00:56,670 --> 01:00:59,380
What if I have a fourth exam tomorrow or something like that?
如果我明天再考一次，或者类似的事情呢？

1236
01:00:59,380 --> 01:01:01,110
So let's make it more dynamic and I think
所以让我们把它变得更动态，我认为

1237
01:01:01,110 --> 01:01:03,460
the syntax will start to make a little more sense.
语法会开始变得更合理。

1238
01:01:03,460 --> 01:01:07,270
Let's go ahead and use get_int and ask the user for a score.
让我们继续使用 get_int，并询问用户一个分数。

1239
01:01:07,270 --> 01:01:10,270
Let's go ahead and get_int and ask the user for another score.
让我们继续使用 get_int，并询问用户另一个分数。

1240
01:01:10,270 --> 01:01:15,090
Let's go ahead and get_int and ask the user for a third score,
让我们继续使用 get_int，并询问用户一个第三个分数，

1241
01:01:15,090 --> 01:01:18,720
now storing the return values in each of those variables.
现在将返回值存储在这些变量中的每一个中。

1242
01:01:18,720 --> 01:01:20,970
If I now do make scores--
如果我现在做 make scores——

1243
01:01:20,970 --> 01:01:22,530
oh, darn it.
哦，糟糕。

1244
01:01:22,530 --> 01:01:24,830
a mistake.
一个错误。

1245
01:01:24,830 --> 01:01:28,130
Similar to one I've made before, but we didn't see the error message last time.
类似于我之前犯过的错误，但我们上次没有看到错误信息。

1246
01:01:28,130 --> 01:01:28,880
What'd I do wrong?
我做错了什么？

1247
01:01:28,880 --> 01:01:30,165
Yeah?
是吧？

1248
01:01:30,165 --> 01:01:31,040
AUDIENCE: [INAUDIBLE]
观众： [听不见]

1249
01:01:31,040 --> 01:01:31,770
DAVID MALAN: OK.
大卫·马兰： 好的。

1250
01:01:31,770 --> 01:01:33,915
What did I do wrong-- how about over here?
我做错了什么——这边怎么样？

1251
01:01:33,915 --> 01:01:34,790
AUDIENCE: [INAUDIBLE]
观众： [听不见]

1252
01:01:34,790 --> 01:01:35,210
DAVID MALAN: Yeah.
大卫·马兰： 是的。

1253
01:01:35,210 --> 01:01:36,900
So I'm missing the CS50 header file.
所以，我缺少 CS50 头文件。

1254
01:01:36,900 --> 01:01:38,060
So how do you know that?
所以你是怎么知道的？

1255
01:01:38,060 --> 01:01:40,550
Well, implicit declaration of function get_int.
嗯，get_int 函数的隐式声明。

1256
01:01:40,550 --> 01:01:42,350
So it just doesn't know what get_int is.
所以它只是不知道 get_int 是什么。

1257
01:01:42,350 --> 01:01:44,660
Well, who does know what get_int is?
那么，谁知道 get_int 是什么？

1258
01:01:44,660 --> 01:01:47,010
The CS50 Library, that should be your first instinct.
CS50 库，这应该是你的第一直觉。

1259
01:01:47,010 --> 01:01:47,510
All right.
好吧。

1260
01:01:47,510 --> 01:01:51,620
Let me go to the top here and let me go ahead and squeeze in the CS50 Library
让我到顶部，然后让 CS50 库挤进来。

1261
01:01:51,620 --> 01:01:52,460
like this.
像这样。

1262
01:01:52,460 --> 01:01:54,140
Now let me clear my terminal.
现在让我清除我的终端。

1263
01:01:54,140 --> 01:01:55,312
make scores again.
再次 make scores。

1264
01:01:55,312 --> 01:01:56,270
We're back in business.
我们又回来了。

1265
01:01:56,270 --> 01:02:00,320
And notice, I don't need to do -l cs50.
并且注意，我不需要做 -l cs50。

1266
01:02:00,320 --> 01:02:05,490
make is doing that for me for clang, but we don't even see clang being executed,
make 正在为我做 clang 的工作，但我们甚至没有看到 clang 被执行，

1267
01:02:05,490 --> 01:02:09,120
but it is being executed underneath the hood, so to speak.
但它正在幕后执行，可以这么说。

1268
01:02:09,120 --> 01:02:10,970
All right, so ./scores, here we go.
好吧，所以 ./scores，我们开始了。

1269
01:02:10,970 --> 01:02:13,340
72, 73, 33.
72、73、33。

1270
01:02:13,340 --> 01:02:17,630
Math is still the same, but now the program is more interactive.
数学仍然是一样的，但现在这个程序更具交互性。

1271
01:02:17,630 --> 01:02:20,520
Now this, too, hopefully should rub you the wrong way.
现在，这也会让你感到不舒服。

1272
01:02:20,520 --> 01:02:25,790
This is correct, I would claim, but bad design still.
我敢说，这是正确的，但设计仍然很糟糕。

1273
01:02:25,790 --> 01:02:28,460
Reeks of week 0 inefficiencies.
充满了第 0 周的低效率。

1274
01:02:28,460 --> 01:02:29,030
Yeah?
是吧？

1275
01:02:29,030 --> 01:02:33,793
AUDIENCE: [INAUDIBLE]
观众： [听不见]

1276
01:02:33,793 --> 01:02:34,460
DAVID MALAN: OK.
大卫·马兰： 好的。

1277
01:02:34,460 --> 01:02:37,160
So I could ask the human how many scores do you want to input?
所以我可以问人类你想输入多少个分数？

1278
01:02:37,160 --> 01:02:38,310
Let's come back to that.
我们稍后再讨论这个问题。

1279
01:02:38,310 --> 01:02:42,550
But I think even in this construct, what better could I do?
但我认为，即使在这个结构中，我还能做得更好吗？

1280
01:02:42,550 --> 01:02:43,510
Use a loop, right?
使用循环，对吧？

1281
01:02:43,510 --> 01:02:46,060
Because I'm literally doing the same thing again and again.
因为我实际上是在一遍又一遍地做同样的事情。

1282
01:02:46,060 --> 01:02:48,530
And notice, this number is just changing slightly.
请注意，这个数字只是稍微改变了一下。

1283
01:02:48,530 --> 01:02:51,490
I would think that a little plus-plus could help there. get_int Score,
我认为加加运算符可能会有帮助。 get_int Score，

1284
01:02:51,490 --> 01:02:53,960
get_int Score, get_int Score-- that's the exact same thing.
get_int Score， get_int Score - 这完全一样。

1285
01:02:53,960 --> 01:02:56,120
So a loop is a perfect solution here.
所以循环在这里是一个完美的解决方案。

1286
01:02:56,120 --> 01:02:59,980
So let me go over into this code here, and I can still for now
所以让我看一下这里的代码，我现在仍然可以

1287
01:02:59,980 --> 01:03:02,440
declare it to be of size 3, but I think I
声明它的大小为 3，但我认为我

1288
01:03:02,440 --> 01:03:07,340
could do something like this-- for int i get 0, i is less than 3,
可以做这样的事情 - 对于 int i 获取 0，i 小于 3，

1289
01:03:07,340 --> 01:03:10,090
so I'm not going to make the same buggy mistake as I made earlier.
所以我不打算再犯之前犯过的同样的错误。

1290
01:03:10,090 --> 01:03:11,260
I++.
我++。

1291
01:03:11,260 --> 01:03:15,850
Inside of the loop now, I can do scores, bracket, i, and now
现在在循环里面，我可以做分数，方括号，i，现在

1292
01:03:15,850 --> 01:03:18,010
arrays are getting really interesting because you
数组变得非常有趣，因为你可以

1293
01:03:18,010 --> 01:03:22,570
can use and reuse them, but dynamically go to a specific location.
使用和重用它们，但动态地转到一个特定位置。

1294
01:03:22,570 --> 01:03:25,510
Equals get_int, quote-unquote, "Score."
等于 get_int，引号中的“分数”。

1295
01:03:25,510 --> 01:03:29,110
Now I can type that phrase just once and this loop ultimately
现在，我可以只键入一次这句话，而这个循环最终

1296
01:03:29,110 --> 01:03:31,330
will do the same thing, but it's getting better.
会做同样的事情，但它正在变得更好。

1297
01:03:31,330 --> 01:03:34,720
The code is getting better designed because it's more compact
代码的设计变得更好，因为它更紧凑

1298
01:03:34,720 --> 01:03:36,250
and I'm not repeating myself.
而且我没有重复自己。

1299
01:03:36,250 --> 01:03:38,020
72, 73, 33.
72、73、33。

1300
01:03:38,020 --> 01:03:42,530
Still works the same, but we're iteratively improving the code here.
它仍然以相同的方式工作，但我们正在迭代地改进这里的代码。

1301
01:03:42,530 --> 01:03:48,500
Now how else-- there's one design flaw here that I still don't love
现在还有什么方法呢？- 这里有一个设计缺陷，我仍然不喜欢

1302
01:03:48,500 --> 01:03:49,710
it's a little more subtle.
它更微妙。

1303
01:03:49,710 --> 01:03:51,160
Any observations?
有什么发现吗？

1304
01:03:51,160 --> 01:03:57,462
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1305
01:03:57,462 --> 01:03:58,670
DAVID MALAN: Ah, interesting.
大卫·马兰：啊，有趣。

1306
01:03:58,670 --> 01:04:01,460
So instead of dividing by 3.0, maybe I should divide it
所以，与其除以 3.0，我或许应该除以

1307
01:04:01,460 --> 01:04:05,480
by the array size, which at the moment is technically still 3,
数组的大小，目前它在技术上仍然是 3，

1308
01:04:05,480 --> 01:04:10,670
but I do concur that that is worrisome because they could get out of sync.
但我同意，这是令人担忧的，因为它们可能会不同步。

1309
01:04:10,670 --> 01:04:13,550
But there's something else that still isn't quite right.
但是，还有其他一些事情不太对劲。

1310
01:04:13,550 --> 01:04:14,965
Yeah?
是吗？

1311
01:04:14,965 --> 01:04:19,090
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1312
01:04:19,090 --> 01:04:22,292
DAVID MALAN: I'm OK moving to this zero-indexed model.
大卫·马兰：我同意转向这种零索引模型。

1313
01:04:22,292 --> 01:04:23,500
So this is a new term of art.
所以这是一个新的术语。

1314
01:04:23,500 --> 01:04:27,470
To index into an array means to go to a specific location.
索引到数组中意味着转到一个特定位置。

1315
01:04:27,470 --> 01:04:31,120
So here, I'm indexing into location i, but i is going
所以在这里，我索引到位置 i，但 i 将

1316
01:04:31,120 --> 01:04:33,250
to start at 0 and then 1 and then 2.
从 0 开始，然后是 1，然后是 2。

1317
01:04:33,250 --> 01:04:34,390
I'm actually OK with that.
我实际上可以接受这一点。

1318
01:04:34,390 --> 01:04:37,600
Even though in common day life we would say score1, score2, score3,
即使在日常生活中我们会说 score1、score2、score3，

1319
01:04:37,600 --> 01:04:39,730
as a programmer, I just have to get into the habit
作为一个程序员，我必须养成

1320
01:04:39,730 --> 01:04:43,450
of saying score0, score1, score2 now.
现在说 score0、score1、score2 的习惯。

1321
01:04:43,450 --> 01:04:44,350
But something else.
但还有其他事情。

1322
01:04:44,350 --> 01:04:45,306
Yeah?
是吗？

1323
01:04:45,306 --> 01:04:47,540
AUDIENCE: I could compute the average.
观众：我可以计算平均值。

1324
01:04:47,540 --> 01:04:49,850
DAVID MALAN: I could also compute the average in a loop
大卫·马兰：我也可以在循环中计算平均值

1325
01:04:49,850 --> 01:04:54,290
because indeed, this is only going-- so solving the problem halfway.
因为实际上，这只是...所以只解决了问题的一半。

1326
01:04:54,290 --> 01:04:56,240
I'm gathering the information in the loop,
我在循环中收集信息，

1327
01:04:56,240 --> 01:04:58,200
but then I'm manually writing it all out.
但我随后又手动将所有内容都写出来。

1328
01:04:58,200 --> 01:05:01,730
So it does feel like there should be a better solution here.
所以这里应该存在更好的解决方案。

1329
01:05:01,730 --> 01:05:05,540
But let me also identify one other issue I really don't like,
但请允许我指出另一个我不喜欢的問題，

1330
01:05:05,540 --> 01:05:06,710
and this is, indeed, subtle.
它确实很微妙。

1331
01:05:06,710 --> 01:05:11,180
I've got 3 here, I've got 3 here, and I essentially have 3 here,
这里有 3，这里也有 3，本质上这里也有 3，

1332
01:05:11,180 --> 01:05:12,750
albeit a floating point version.
尽管它是浮点版本。

1333
01:05:12,750 --> 01:05:16,550
This is just ripe for me making a mistake eventually and changing one
这最终让我很容易犯错，并改变其中

1334
01:05:16,550 --> 01:05:18,840
of those values, but not the other two?
一个值，但没改另外两个？

1335
01:05:18,840 --> 01:05:20,090
So how might I fix this?
那么我该如何解决呢？

1336
01:05:20,090 --> 01:05:22,200
I might at least do something like this.
我可能至少可以做这样的事情。

1337
01:05:22,200 --> 01:05:28,010
I could say integer maybe n for scores, I'll set that equal to 3.
我可以说整数 n 代表分数，我将它设置为 3。

1338
01:05:28,010 --> 01:05:31,430
I could then use n here, I could use n here.
然后我可以在此处使用 n，也可以在此处使用 n。

1339
01:05:31,430 --> 01:05:33,742
I could use n here, but that's a step backwards
我可以在此处使用 n，但这是一种倒退

1340
01:05:33,742 --> 01:05:36,950
because I don't want an int because I'm going to run into the same math issue
因为我不想要一个整数，因为我将遇到相同数学问题

1341
01:05:36,950 --> 01:05:40,250
as before, but I could convert it-- that is, cast it to a float,
与之前一样，但我可以将其转换，即将其转换为浮点数，

1342
01:05:40,250 --> 01:05:42,920
and we did that briefly last week.
我们上周简要介绍了这一点。

1343
01:05:42,920 --> 01:05:47,730
But there's one other thing I could do here that we did introduced last week.
但这里还有一种上周介绍过的做法。

1344
01:05:47,730 --> 01:05:51,150
This is better because I don't have a magic number floating around
这更好，因为我没有一个到处乱飞的魔术数字

1345
01:05:51,150 --> 01:05:53,490
in multiple places.
在多个地方。

1346
01:05:53,490 --> 01:05:56,160
Yeah, if I really want to be proper, I should probably
是的，如果我真的想做到规范，我可能应该

1347
01:05:56,160 --> 01:05:58,440
say this should be a constant integer.
说这应该是一个常数整数。

1348
01:05:58,440 --> 01:05:58,950
Why?
为什么？

1349
01:05:58,950 --> 01:06:01,200
Because I don't want to accidentally change it myself.
因为我不希望自己不小心修改它。

1350
01:06:01,200 --> 01:06:03,242
I don't want to be collaborating with a colleague
我不想与同事合作

1351
01:06:03,242 --> 01:06:04,800
and they foolishly change it on me.
而他们愚蠢地修改了它。

1352
01:06:04,800 --> 01:06:09,060
This just sends a stronger signal to the compiler, do not let the humans change
这向编译器发送了一个更强的信号，不要让人类修改

1353
01:06:09,060 --> 01:06:10,000
this value.
这个值。

1354
01:06:10,000 --> 01:06:12,960
And now just to point out one other feature of C,
现在，只指出 C 语言的另一个特性，

1355
01:06:12,960 --> 01:06:16,650
if you have a number like this, like the number 3,
如果你有一个这样的数字，比如数字 3，

1356
01:06:16,650 --> 01:06:18,990
I've deliberately capitalized this variable name really
我特意将这个变量名首字母大写，实际上

1357
01:06:18,990 --> 01:06:19,915
for the first time.
是第一次这样做。

1358
01:06:19,915 --> 01:06:22,290
Any time you have a constant, it tends to be a convention
任何时候你有一个常数，这往往是一个约定

1359
01:06:22,290 --> 01:06:25,000
to capitalize it just to draw your attention to it.
将其首字母大写，只是为了吸引你的注意。

1360
01:06:25,000 --> 01:06:26,580
It doesn't mean anything technically.
在技术上这没有任何意义。

1361
01:06:26,580 --> 01:06:28,950
Capitalizing a variable does nothing to it,
将变量首字母大写不会对它产生任何影响，

1362
01:06:28,950 --> 01:06:31,660
but it draws attention visually to it to the human.
但它会视觉上地吸引人们对它的注意。

1363
01:06:31,660 --> 01:06:33,930
So if you declare something as a constant,
所以如果你将某物声明为常数，

1364
01:06:33,930 --> 01:06:37,050
it's commonplace to capitalize it just because.
将它首字母大写是很常见的，仅仅是因为如此。

1365
01:06:37,050 --> 01:06:41,790
Moreover, if you have a constant that you might want to occasionally modify--
此外，如果你有一个常数，你可能偶尔想修改它，

1366
01:06:41,790 --> 01:06:45,660
maybe next semester when there's four exams or five exams instead of three,
也许下学期会有四次考试或五次考试，而不是三次，

1367
01:06:45,660 --> 01:06:48,900
it actually is OK sometimes to define what
有时定义以下内容实际上是可以的，

1368
01:06:48,900 --> 01:06:52,080
might be called a global variable, a variable that is not
可能被称为全局变量，一个不在

1369
01:06:52,080 --> 01:06:57,280
inside of curly braces, it's literally at the top of the file outside of main,
花括号内的变量，它实际上位于文件顶部的 main 函数外部，

1370
01:06:57,280 --> 01:06:59,890
and despite what I said about scope last week,
尽管我上周谈到了作用域，

1371
01:06:59,890 --> 01:07:05,170
a global variable like this on line 4 will be in scope
像这样在第 4 行上的全局变量将位于作用域内

1372
01:07:05,170 --> 01:07:07,550
to every function in this file.
对该文件中每个函数而言。

1373
01:07:07,550 --> 01:07:09,880
So it's actually a way of sharing a variable
所以它实际上是一种共享变量的方式

1374
01:07:09,880 --> 01:07:13,090
across multiple functions, which is generally fine if you're
跨多个函数共享，如果你使用常量，通常是可以的。

1375
01:07:13,090 --> 01:07:14,230
using a constant.
使用常量。

1376
01:07:14,230 --> 01:07:18,010
If you intend to change it, there's probably a better way
如果你打算更改它，可能有一种更好的方法

1377
01:07:18,010 --> 01:07:21,310
than actually using a global variable, but this is just
而不是使用全局变量，但这仅仅是

1378
01:07:21,310 --> 01:07:23,620
in contrast to what I previously did, which I would
与我之前做的事情形成对比，我会

1379
01:07:23,620 --> 01:07:26,810
call, by contrast, a local variable.
称之为局部变量。

1380
01:07:26,810 --> 01:07:30,563
But again, I'm just trying to reduce the probability of making mistakes
但再次强调，我只是在尝试降低犯错的概率

1381
01:07:30,563 --> 01:07:31,480
somewhere in the code.
在代码的某个地方。

1382
01:07:31,480 --> 01:07:32,170
And I do agree.
我同意。

1383
01:07:32,170 --> 01:07:35,560
I don't like that I'm still adding all of these scores
我不喜欢我仍然手动添加所有这些分数

1384
01:07:35,560 --> 01:07:39,130
manually even though clearly I had a loop a moment ago.
手动添加，尽管我之前有循环。

1385
01:07:39,130 --> 01:07:40,990
But for now, let's at least consider what's
但现在，让我们至少考虑一下

1386
01:07:40,990 --> 01:07:43,130
been going on inside of the computer's memory.
计算机内存中发生了什么。

1387
01:07:43,130 --> 01:07:48,880
So with this array, I now have not three variables, score1, score2, score3.
有了这个数组，现在我只有三个变量，score1、score2、score3。

1388
01:07:48,880 --> 01:07:53,530
I have one variable, an array variable, called scores, plural.
我只有一个变量，一个数组变量，叫做scores，复数。

1389
01:07:53,530 --> 01:07:57,700
And if I want to access the first element, its scores, bracket, 0.
如果我想访问第一个元素，它是scores，方括号，0。

1390
01:07:57,700 --> 01:08:00,400
If I want to access the second element, its scores, bracket, 1.
如果我想访问第二个元素，它是scores，方括号，1。

1391
01:08:00,400 --> 01:08:03,100
If I want to access the third element, it's scores, bracket, 2.
如果我想访问第三个元素，它是scores，方括号，2。

1392
01:08:03,100 --> 01:08:07,480
If I were to make a mistake and do scores, bracket, 3,
如果我犯了错误，并做了scores，方括号，3，

1393
01:08:07,480 --> 01:08:11,380
which is the fourth element, I'd end up in no man's land here,
这是第四个元素，我会在无人区，

1394
01:08:11,380 --> 01:08:15,307
and worst case, your program could crash or something weird will happen,
最糟糕的情况下，你的程序可能会崩溃，或者发生一些奇怪的事情，

1395
01:08:15,307 --> 01:08:17,140
spinning beach balls, those kinds of things.
旋转沙滩球，那些东西。

1396
01:08:17,140 --> 01:08:18,910
Just don't make those mistakes.
不要犯这些错误。

1397
01:08:18,910 --> 01:08:21,310
And C makes it easy to make those mistakes,
C让犯这些错误变得容易，

1398
01:08:21,310 --> 01:08:25,300
so the onus is really on you programmatically.
所以，编程上的责任真的在你身上。

1399
01:08:25,300 --> 01:08:31,960
Questions on this use of arrays?
关于数组使用的问题？

1400
01:08:31,960 --> 01:08:33,580
Question on this use of arrays?
关于数组使用的问题？

1401
01:08:33,580 --> 01:08:34,359
Yeah, in back.
好的，在后面。

1402
01:08:34,359 --> 01:08:36,283
AUDIENCE: Is there any way [INAUDIBLE]?
观众：有没有什么方法[听不清]？

1403
01:08:43,870 --> 01:08:45,370
DAVID MALAN: A really good question.
大卫·马兰：一个很好的问题。

1404
01:08:45,370 --> 01:08:48,279
Is there any way to create an array just by using syntax alone
有没有什么方法，只使用语法

1405
01:08:48,279 --> 01:08:49,899
without prompting the human for it?
而不提示用户？

1406
01:08:49,899 --> 01:08:51,490
Short answer, yes.
简短回答，是的。

1407
01:08:51,490 --> 01:08:56,529
If you want to have an array of integers called, for instance, array,
如果你想要一个名为array的整数数组，

1408
01:08:56,529 --> 01:09:01,090
you could actually do like 13, 42, 50, something like this,
你可以实际做成像13, 42, 50这样的，

1409
01:09:01,090 --> 01:09:04,300
would give you an array if you use this syntax.
如果使用这种语法，会给你一个数组。

1410
01:09:04,300 --> 01:09:08,680
This would give you an array of size 3 where the three values by default
这会给你一个大小为3的数组，其中三个值默认情况下

1411
01:09:08,680 --> 01:09:10,600
are 13, 42 and 50.
是13、42和50。

1412
01:09:10,600 --> 01:09:13,370
It's not syntax we'll use for now, but there is syntax like that.
我们现在不会使用这种语法，但有这样的语法。

1413
01:09:13,370 --> 01:09:15,970
It's not quite as user-friendly, though, as other languages
不过，它不像其他语言那样用户友好

1414
01:09:15,970 --> 01:09:19,060
if you've indeed programmed before.
如果你之前确实编程过。

1415
01:09:19,060 --> 01:09:24,439
Other questions on this use of arrays?
关于数组使用其他问题？

1416
01:09:24,439 --> 01:09:26,550
Yeah, in front.
好的，前面。

1417
01:09:26,550 --> 01:09:29,050
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1418
01:09:29,050 --> 01:09:30,924
DAVID MALAN: Is there a way to copy what?
大卫·马兰：有没有办法复制什么？

1419
01:09:30,924 --> 01:09:33,399
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1420
01:09:33,399 --> 01:09:36,310
DAVID MALAN: Oh, is there a way to calculate the length of an array?
大卫·马兰：哦，有没有办法计算数组的长度？

1421
01:09:36,310 --> 01:09:39,910
Short answer, no, and I'm about to show you one demonstration of this.
简短回答，没有，我马上要向你展示一个演示。

1422
01:09:39,910 --> 01:09:43,899
Those of you who have programmed before in Java, in JavaScript,
对于那些之前用 Java、JavaScript 或其他语言编程过的人来说，

1423
01:09:43,899 --> 01:09:47,270
in certain other languages, it's very easy to get the length of an array.
在其他一些语言中，获取数组的长度非常容易。

1424
01:09:47,270 --> 01:09:49,720
You essentially just ask the array, what's its length?
你只需直接问数组：它的长度是多少？

1425
01:09:49,720 --> 01:09:51,880
C does not give you that capability.
C 语言没有提供这种功能。

1426
01:09:51,880 --> 01:09:56,560
The onus is entirely on you and me to remember, s as with another variable,
我们必须自己记住，就像其他变量一样，

1427
01:09:56,560 --> 01:09:59,300
like n, how long the array is.
例如变量 n，数组的长度是多少。

1428
01:09:59,300 --> 01:10:01,760
And so in fact, let me go ahead and do this.
事实上，让我来做这件事。

1429
01:10:01,760 --> 01:10:06,430
I'm going to go ahead and open up a baking style, a program
我将打开一个烘焙风格的程序，

1430
01:10:06,430 --> 01:10:09,940
that I wrote in advance here which kind of escalates quickly,
我之前写过这个程序，它会很快变得复杂，

1431
01:10:09,940 --> 01:10:13,990
but there's not really too many new ideas here except for the array
但除了数组之外，这里没有太多新的想法。

1432
01:10:13,990 --> 01:10:14,800
specifics.
具体细节。

1433
01:10:14,800 --> 01:10:19,450
So this is scores.c premade this time.
所以这次是预先制作的 scores.c。

1434
01:10:19,450 --> 01:10:20,650
And notice what I have.
注意我这里有什么。

1435
01:10:20,650 --> 01:10:25,750
One, I've included cs50.h and stdio.h at the top, so that's the same.
首先，我在顶部包含了 cs50.h 和 stdio.h，这和之前一样。

1436
01:10:25,750 --> 01:10:28,630
I have declared a constant called n, set it equal to 3.
我声明了一个名为 n 的常量，将其设置为 3。

1437
01:10:28,630 --> 01:10:31,270
That is now the same as of my most recent change.
这和我的最新更改保持一致。

1438
01:10:31,270 --> 01:10:36,380
I did introduce an average function, which was one of the remaining concerns
我引入了一个平均值函数，这是我之前剩下的一个问题。

1439
01:10:36,380 --> 01:10:40,220
that I could compute the average with some kind of loop, too.
我可以用某种循环来计算平均值。

1440
01:10:40,220 --> 01:10:42,980
That average function is going to return a float, which is what.
这个平均值函数将返回一个浮点数，也就是...

1441
01:10:42,980 --> 01:10:46,100
I want my average to be a float with the fraction.
我希望我的平均值是一个带有小数部分的浮点数。

1442
01:10:46,100 --> 01:10:47,180
But notice this.
但注意这个。

1443
01:10:47,180 --> 01:10:50,360
In answer to your question, if I want a function called
为了回答你的问题，如果我想要一个名为

1444
01:10:50,360 --> 01:10:55,100
average to do something iterate over an array step by step by step,
average 的函数来执行一些操作，循环遍历数组，一步一步地，

1445
01:10:55,100 --> 01:10:58,430
add up all the numbers, and divide by the total number of numbers,
将所有数字加起来，然后除以数字的总数，

1446
01:10:58,430 --> 01:11:03,350
I need to give it the array of numbers, and I need to tell it how many of those
我需要将数字数组传递给它，并且需要告诉它有多少个

1447
01:11:03,350 --> 01:11:03,950
numbers are.
数字。

1448
01:11:03,950 --> 01:11:06,230
So I literally have to pass in two values.
所以我必须传递两个值。

1449
01:11:06,230 --> 01:11:09,890
Meanwhile, this code is the same as before inside of main.
与此同时，这段代码在 main 函数内部与之前相同。

1450
01:11:09,890 --> 01:11:13,430
I'm declaring a variable called scores of size n.
我声明了一个名为 scores 的变量，大小为 n。

1451
01:11:13,430 --> 01:11:16,430
I'm iterating from i to n.
我从 i 迭代到 n。

1452
01:11:16,430 --> 01:11:17,990
And actually-- yep.
实际上，是的。

1453
01:11:17,990 --> 01:11:22,520
And then in this loop, I'm assigning each of the scores a return
然后在这个循环中，我为每个分数分配一个返回值

1454
01:11:22,520 --> 01:11:23,750
value of get_int.
get_int 的值。

1455
01:11:23,750 --> 01:11:27,350
The last line of main is this-- print out the average with f,
main 函数的最后一行是：用 f 打印出平均值，

1456
01:11:27,350 --> 01:11:31,280
but don't just do it manually by adding and dividing with parentheses.
但不要用括号手动进行加法和除法。

1457
01:11:31,280 --> 01:11:36,080
Call the average function, pass in the length of the array and the array
调用平均值函数，传入数组的长度和数组本身，

1458
01:11:36,080 --> 01:11:41,810
itself, and hope that it returns a float that then gets plugged into percent f
并希望它返回一个浮点数，然后被插入到百分号 f 中。

1459
01:11:41,810 --> 01:11:45,260
So I would claim that pretty much all of this, even though it's a lot,
我认为，尽管代码量很大，但所有这些

1460
01:11:45,260 --> 01:11:46,550
should be familiar.
应该都是熟悉的。

1461
01:11:46,550 --> 01:11:50,780
There's no real new ideas except for this use of the global variable now
除了现在使用全局变量和这个平均值函数之外，没有真正的新想法。

1462
01:11:50,780 --> 01:11:52,590
and this average function.
这个平均值函数。

1463
01:11:52,590 --> 01:11:54,740
So let me scroll down to the average function
所以让我滚动到平均值函数

1464
01:11:54,740 --> 01:11:57,530
because this is the takeaway from this final example.
因为这是这个最后一个例子的重点。

1465
01:11:57,530 --> 01:11:59,570
In this example here--
在这个例子中，

1466
01:11:59,570 --> 01:12:01,640
let me scroll up to the average function,
让我滚动到平均值函数，

1467
01:12:01,640 --> 01:12:04,790
copy-pasted the prototype for the very first line.
复制粘贴第一行的原型。

1468
01:12:04,790 --> 01:12:06,980
And here's how I'm computing the average.
这就是我计算平均值的方式。

1469
01:12:06,980 --> 01:12:11,240
There's different ways of doing this, but here's an accumulator way.
有很多种方法可以做到这一点，但这里有一个累加器的方式。

1470
01:12:11,240 --> 01:12:15,260
On line 28, I'm declaring a variable inside of the average function called
在第 28 行，我在平均值函数内部声明一个名为

1471
01:12:15,260 --> 01:12:17,540
sum, and I'm just initializing it to 0.
sum 的变量，并且我将其初始化为 0。

1472
01:12:17,540 --> 01:12:18,050
Why?
为什么？

1473
01:12:18,050 --> 01:12:20,630
Mentally I want to add up all of the person scores
在脑海中，我想把所有人的分数加起来

1474
01:12:20,630 --> 01:12:24,480
and then I want to divide by the total and that's my mathematical average.
然后，我想除以总数，这就是我的数学平均值。

1475
01:12:24,480 --> 01:12:28,970
So here's my loop where I'm iterating from 0 up to, but not
所以，这是我的循环，我从 0 开始迭代，但不会

1476
01:12:28,970 --> 01:12:32,060
through the length-- so that should be three times.
到达长度，所以应该执行三次。

1477
01:12:32,060 --> 01:12:37,950
I am adding to the sum variable whatever is at the i-th location, so to speak,
我将 i 位置的值，也就是数组的第 i 个元素，加到 sum 变量上。

1478
01:12:37,950 --> 01:12:38,850
of the array.
数组的第 i 个元素。

1479
01:12:38,850 --> 01:12:42,050
So this is array, bracket 0; array, bracket, 1; array, bracket,
所以这是数组 [0]，数组 [1]，数组 [

1480
01:12:42,050 --> 01:12:43,860
2 on each iteration.
2]，在每次迭代中。

1481
01:12:43,860 --> 01:12:46,670
And then the last thing I'm doing is a nice one-liner.
最后，我做了一行简洁的代码。

1482
01:12:46,670 --> 01:12:51,470
I'm dividing the sum, which is an int, which is the sum of 72, 73, 33,
我将 sum 除以 length，sum 是一个 int 类型的值，它等于 72 + 73 + 33，

1483
01:12:51,470 --> 01:12:56,550
divided by the length, which is 3, but 3 is not a float, so I cast it to a float
length 等于 3，但 3 不是一个 float 类型的值，所以将其强制转换为 float 类型

1484
01:12:56,550 --> 01:13:03,060
so that the end value, hopefully, is going to be 59.33333 and so forth.
以便最终的值，我希望会是 59.33333 等等。

1485
01:13:03,060 --> 01:13:06,380
So the only thing that's weird syntactically is this, though.
然而，语法上唯一奇怪的是这一点。

1486
01:13:06,380 --> 01:13:10,430
When you define a function in C that takes an argument that isn't just
在 C 语言中，当你定义一个函数，它接收一个参数，这个参数不是一个简单的

1487
01:13:10,430 --> 01:13:14,640
a simple char, isn't just a simple integer, it's actually an array,
字符，不是一个简单的整数，而是一个数组，

1488
01:13:14,640 --> 01:13:17,090
you don't have to know the array's length in advance.
你不需要预先知道数组的长度。

1489
01:13:17,090 --> 01:13:19,820
You can just put square brackets after the name you give it.
你可以在你给它起的名字后面加上方括号。

1490
01:13:19,820 --> 01:13:21,237
And I don't have to call it array.
而且我不必把它叫做 array。

1491
01:13:21,237 --> 01:13:23,930
I could call it x or y or z or anything else.
我可以把它叫做 x 或 y 或 z，或者任何其他东西。

1492
01:13:23,930 --> 01:13:26,390
I called it array just to make clear that it's an array,
我把它叫做 array 只是为了清楚地表明它是一个数组，

1493
01:13:26,390 --> 01:13:30,620
but you do need to know the length somehow.
但你确实需要以某种方式知道它的长度。

1494
01:13:30,620 --> 01:13:31,120
OK.
好的。

1495
01:13:31,120 --> 01:13:37,820
Questions on combining those ideas in that there way?
关于以这种方式将这些想法结合在一起，你们有什么问题吗？

1496
01:13:41,170 --> 01:13:42,980
Any questions?
还有其他问题吗？

1497
01:13:42,980 --> 01:13:43,850
No?
没有？

1498
01:13:43,850 --> 01:13:44,420
All right.
好的。

1499
01:13:44,420 --> 01:13:46,790
Well, we've only dealt with numbers thus far.
嗯，到目前为止，我们只处理了数字。

1500
01:13:46,790 --> 01:13:50,340
It would be nice to actually deal with letters and words and paragraphs
实际上，如果能处理字母、单词和段落，那会很不错，

1501
01:13:50,340 --> 01:13:52,340
and the like, much like our readability example,
就像我们的可读性示例一样，

1502
01:13:52,340 --> 01:13:56,150
but I think first, some snacks and some fruit are served in the transept.
但我想，首先，在中殿会供应一些小吃和水果。

1503
01:13:56,150 --> 01:13:57,140
So we'll see you in 10.
所以我们 10 分钟后再见。

1504
01:13:57,140 --> 01:13:59,480
See you in 10.
10 分钟后再见。

1505
01:13:59,480 --> 01:14:00,320
All right.
好的。

1506
01:14:00,320 --> 01:14:01,190
So we're back.
所以我们回来了。

1507
01:14:01,190 --> 01:14:02,960
And up until now, we've been representing
到目前为止，我们一直在表示

1508
01:14:02,960 --> 01:14:05,060
just numbers underneath the hood, but we've
只是数字，但在幕后，我们已经

1509
01:14:05,060 --> 01:14:07,760
introduced arrays, which gave us this ability, recall,
引入了数组，这给了我们这种能力，还记得吗？

1510
01:14:07,760 --> 01:14:10,260
to store numbers back to back to back.
将数字一个接一个地存储起来。

1511
01:14:10,260 --> 01:14:13,310
So it turns out, you actually had this capability for the past
所以事实证明，过去的一周你实际上就拥有了这种能力，

1512
01:14:13,310 --> 01:14:15,620
week even though you might not have realized it.
即使你可能没有意识到这一点。

1513
01:14:15,620 --> 01:14:19,100
And let me propose that we first consider very simple example of three
我建议我们首先考虑三个非常简单的例子

1514
01:14:19,100 --> 01:14:20,750
chars instead of three integers.
字符，而不是三个整数。

1515
01:14:20,750 --> 01:14:23,390
And for simplistically, I'm going to call them c1, c2,
为了简单起见，我将它们称为 c1、c2，

1516
01:14:23,390 --> 01:14:25,400
and c3 just for the sake of discussion.
以及 c3，仅仅为了讨论。

1517
01:14:25,400 --> 01:14:29,090
But I'm going to put our familiar characters, "HI!"
但我要用单引号将我们熟悉的字符“HI!”

1518
01:14:29,090 --> 01:14:32,330
in those variables using single quotes because again.
放入这些变量中，因为再次。

1519
01:14:32,330 --> 01:14:35,900
That's what you do when using individual chars
这就是你在使用单个字符时所做的

1520
01:14:35,900 --> 01:14:40,282
to make the point that I can store three chars in three separate variables.
为了说明我可以将三个字符存储在三个单独的变量中。

1521
01:14:40,282 --> 01:14:41,990
So let me go ahead and go over to VS Code
所以让我继续，到 VS Code

1522
01:14:41,990 --> 01:14:45,180
here and let me create something called hi.c.
这里，让我创建一个名为 hi.c 的文件。

1523
01:14:45,180 --> 01:14:50,970
And in this program, I'll first include stdio.h, int main void as before.
在这个程序中，我将首先像之前一样包含 stdio.h、int main void。

1524
01:14:50,970 --> 01:14:53,430
And then inside of main, let's just do exactly that.
然后在 main 内部，让我们做完全相同的操作。

1525
01:14:53,430 --> 01:14:57,540
Char c1 equals, quote-unquote, capital H. Char C2 equals,
char c1 等于，引号、引号，大写 H。char c2 等于，

1526
01:14:57,540 --> 01:15:00,420
quote-unquote, capital I. Char C3 equals,
引号、引号，大写 I。char c3 等于，

1527
01:15:00,420 --> 01:15:02,550
quote-unquote, exclamation point.
引号、引号，感叹号。

1528
01:15:02,550 --> 01:15:06,450
So clearly not the best approach, but just for demonstration's sake.
所以显然这不是最好的方法，但仅仅是为了演示。

1529
01:15:06,450 --> 01:15:09,780
And here now that you understand hopefully
现在，希望你能明白

1530
01:15:09,780 --> 01:15:12,780
from week 1 that really number-- and really, from week 0,
从第一周开始，数字实际上是——实际上，从第零周开始，

1531
01:15:12,780 --> 01:15:16,020
that numbers are just letters, which can be something more, too.
数字只是字母，它们也可以是更多的东西。

1532
01:15:16,020 --> 01:15:18,570
We can really just use our basic understanding of C
我们实际上只需要使用我们对 C 的基本理解

1533
01:15:18,570 --> 01:15:21,180
to tinker with these ideas now and see them such
现在来修改这些想法，并看到它们

1534
01:15:21,180 --> 01:15:24,900
that there is indeed going to be no magic happening for us ultimately.
最终，对于我们来说，确实不会发生任何神奇的事情。

1535
01:15:24,900 --> 01:15:31,800
So let me go ahead and print out three characters-- %c, %c, %c, backslash n.
所以让我继续，打印出三个字符——%c、%c、%c、反斜杠 n。

1536
01:15:31,800 --> 01:15:34,800
And then print out c1, c2, c3.
然后打印出 c1、c2、c3。

1537
01:15:34,800 --> 01:15:36,690
So I've got three separate placeholders.
所以我有三个独立的占位符。

1538
01:15:36,690 --> 01:15:40,560
And we haven't really had occasion to use %c, but it means put char here,
我们还没有机会使用 %c，但它的意思是将字符放在这里，

1539
01:15:40,560 --> 01:15:44,760
unlike %s, which is put a whole string here, or %i, put an integer.
与 %s 不同，%s 是将整个字符串放在这里，或者 %i 是将整数放在这里。

1540
01:15:44,760 --> 01:15:49,290
Let me go ahead and make hi, no syntax errors, ./hi,
让我继续，创建 hi，没有语法错误，./hi，

1541
01:15:49,290 --> 01:15:51,330
and it should print out "HI!"
它应该打印出“HI!”

1542
01:15:51,330 --> 01:15:53,400
in exclamation points because I'm printing out
用感叹号，因为我正在打印

1543
01:15:53,400 --> 01:15:54,870
just three simple characters.
只是三个简单的字符。

1544
01:15:54,870 --> 01:15:57,850
But per our discussion as far back as week 0,
但根据我们早在第零周的讨论，

1545
01:15:57,850 --> 01:16:01,440
letters are just numbers and numbers are just letters,
字母只是数字，数字也仅仅是字母，

1546
01:16:01,440 --> 01:16:03,840
it just depends on the context in which we use them.
这取决于我们使用它们的上下文。

1547
01:16:03,840 --> 01:16:05,792
So let me change this %c to an i.
所以让我将 %c 更改为 i。

1548
01:16:05,792 --> 01:16:08,250
And I'm going to add a space just so that you can obviously
我将添加一个空格，这样你就可以清楚地

1549
01:16:08,250 --> 01:16:10,050
separate one number from another.
将一个数字与另一个数字分开。

1550
01:16:10,050 --> 01:16:14,850
Change this to i, change this to i, but still print out c1, c2, c3.
将这个改为 i，将这个改为 i，但仍然打印出 c1、c2、c3。

1551
01:16:14,850 --> 01:16:16,650
So no integers, per se.
所以没有真正的整数。

1552
01:16:16,650 --> 01:16:19,500
Let me just print out those chars.
让我只打印出那些字符。

1553
01:16:19,500 --> 01:16:26,670
Let me do make hi, no errors, ./hi, and now I see 72, 73, 33.
让我创建 hi，没有错误，./hi，现在我看到了 72、73、33。

1554
01:16:26,670 --> 01:16:31,270
So in the case of chars and ints, you can actually treat one as the other
所以对于字符和整数来说，你实际上可以将其中一个视为另一个

1555
01:16:31,270 --> 01:16:33,850
so long as you have enough bits to fit one in the other.
只要你有足够的位来容纳其中一个。

1556
01:16:33,850 --> 01:16:36,450
You don't have to cast even or do anything explicitly.
你甚至不需要强制转换或显式地做任何事情。

1557
01:16:36,450 --> 01:16:38,340
You do have to cast one of--
你必须强制转换其中一个——

1558
01:16:38,340 --> 01:16:41,910
converting an integer to a float to make clear to the compiler
将整数转换为浮点数，以便让编译器清楚

1559
01:16:41,910 --> 01:16:44,160
that you really intend to do this because that
你真的想这样做，因为这

1560
01:16:44,160 --> 01:16:47,400
could be destructive if it can't quite represent the number as you intend.
如果它不能完全如你预期的那样表示数字，那么这可能是破坏性的。

1561
01:16:47,400 --> 01:16:50,880
But in this case here, I think we're OK just poking around and seeing
但在这里，我认为我们只需要四处查看，看看

1562
01:16:50,880 --> 01:16:52,750
what's going on underneath the hood.
引擎盖下发生了什么。

1563
01:16:52,750 --> 01:16:55,202
Well, what is going on underneath the hood memory-wise?
那么，从内存的角度来看，底层到底发生了什么呢？

1564
01:16:55,202 --> 01:16:56,410
Well, something very similar.
嗯，非常相似。

1565
01:16:56,410 --> 01:16:57,780
Here's that canvas of memory.
这是内存的画布。

1566
01:16:57,780 --> 01:17:00,570
And maybe we got lucky and it's in the top left-hand corner
也许我们很幸运，它在左上角

1567
01:17:00,570 --> 01:17:03,270
like this-- c1, c2, c3.
就像这样——c1、c2、c3。

1568
01:17:03,270 --> 01:17:05,790
But these are just three individual characters,
但这些仅仅是三个独立的字符，

1569
01:17:05,790 --> 01:17:08,970
but we're getting awfully close to what we last week called
但我们正在非常接近上周我们所说的

1570
01:17:08,970 --> 01:17:12,270
a string, which are just characters, a sequence of characters
一个字符串，它仅仅是字符，一个字符序列

1571
01:17:12,270 --> 01:17:13,500
from left to right.
从左到右。

1572
01:17:13,500 --> 01:17:19,530
And in fact, I think if we combine this revelation that these are just
事实上，我认为如果我们将这些只是

1573
01:17:19,530 --> 01:17:22,410
numbers underneath the hood back to back to back combined
数字的发现，在底层一个接一个地组合起来

1574
01:17:22,410 --> 01:17:25,620
with the idea of an array from earlier, we can
与之前数组的概念结合起来，我们就可以

1575
01:17:25,620 --> 01:17:27,690
start to see what's really going on.
开始看到真正发生的事情。

1576
01:17:27,690 --> 01:17:31,920
Because indeed, underneath the hood, this is just a number, 72, 73, 33.
因为实际上，在底层，这只是一个数字，72、73、33。

1577
01:17:31,920 --> 01:17:34,290
And really, if we go lower level than that,
实际上，如果我们更底层一点，

1578
01:17:34,290 --> 01:17:36,870
it's these three patterns of 0's and 1's.
它就是这三个0和1的模式。

1579
01:17:36,870 --> 01:17:39,270
That's all that's going on inside of the computer,
这就是计算机内部发生的一切，

1580
01:17:39,270 --> 01:17:43,380
but it's our use of int that shows it to us as an integer.
但我们使用int将其显示为一个整数。

1581
01:17:43,380 --> 01:17:47,250
It's our use of char that makes it clear that it's a char, or equivalently,
我们使用char使它很清楚这是一个char，或者等效地，

1582
01:17:47,250 --> 01:17:50,260
%i and %c respectively.
分别为%i和%c。

1583
01:17:50,260 --> 01:17:52,180
But what exactly is a string?
但到底什么是字符串呢？

1584
01:17:52,180 --> 01:17:54,540
Well, it's really just a sequence of characters,
嗯，它实际上只是一系列字符，

1585
01:17:54,540 --> 01:17:56,530
and so why don't we go there?
所以我们为什么不去那里呢？

1586
01:17:56,530 --> 01:17:59,400
Let me propose that we actually give ourselves an actual string,
我建议我们给自己一个真实的字符串，

1587
01:17:59,400 --> 01:18:02,260
call it s-- we'll use double quotes this time.
叫做s——这次我们将使用双引号。

1588
01:18:02,260 --> 01:18:05,760
So if I go back to VS Code here, let me shorten this program
所以如果我回到这里的VS Code，让我简化一下这个程序

1589
01:18:05,760 --> 01:18:10,440
and just give myself a single string s, set it equal to "HI!"
只给自己一个字符串s，将其设置为"HI！"

1590
01:18:10,440 --> 01:18:11,310
in double quotes.
用双引号。

1591
01:18:11,310 --> 01:18:16,740
And then below that, let's go ahead and print out %s, backslash n,
然后在下面，让我们继续打印出%s、反斜杠n，

1592
01:18:16,740 --> 01:18:18,180
and then s itself.
然后是s本身。

1593
01:18:18,180 --> 01:18:21,120
And then, turns out, for reasons we'll soon
然后，事实证明，由于我们很快就会

1594
01:18:21,120 --> 01:18:23,670
see, I do need to include the CS50 Library so as
看到，我需要包含CS50库，以便

1595
01:18:23,670 --> 01:18:27,750
to use the actual keyword string here even though I'm not using get_string,
在这里使用实际的关键字字符串，即使我没有使用get_string，

1596
01:18:27,750 --> 01:18:29,490
but more on that another time.
但我们下次再讨论这个。

1597
01:18:29,490 --> 01:18:34,950
But if I now do make hi, it does compile ./hi and it still prints out the exact
但如果我现在编译hi，它确实会编译./hi，并且它仍然打印出完全一样的

1598
01:18:34,950 --> 01:18:35,920
same thing.
东西。

1599
01:18:35,920 --> 01:18:38,370
But what's going on inside of the computer's memory
但是当我在计算机内存中使用一个叫做s的字符串而不是三个字符时，

1600
01:18:38,370 --> 01:18:42,550
when I use a string called s instead of three chars, well,
到底发生了什么呢？嗯，

1601
01:18:42,550 --> 01:18:46,300
you can think of the string as taking up at least three bytes, H,
你可以认为这个字符串至少占用了三个字节，H，

1602
01:18:46,300 --> 01:18:47,690
I, exclamation point.
I，感叹号。

1603
01:18:47,690 --> 01:18:50,440
But it's not three separate variables, it's one variable.
但它不是三个独立的变量，而是一个变量。

1604
01:18:50,440 --> 01:18:53,620
But what does this really look like now, especially
但现在它真正是什么样子，尤其是

1605
01:18:53,620 --> 01:18:56,020
if I add back the yellow lines?
如果我添加回黄线呢？

1606
01:18:56,020 --> 01:19:00,970
s is really just an array of characters.
s实际上只是一个字符数组。

1607
01:19:00,970 --> 01:19:04,170
So we called it a string last week, and I claim today
所以上周我们称它为字符串，而我今天声称

1608
01:19:04,170 --> 01:19:10,320
that this is an abstraction in the CS50 library that's giving us this string,
这是一个CS50库中的抽象，它给了我们这个字符串，

1609
01:19:10,320 --> 01:19:13,560
but it's really just an array of size at least 3
但它实际上只是一个至少有3个大小的数组

1610
01:19:13,560 --> 01:19:16,560
here where s, bracket, 0 presumably gives me the H, s, bracket,
这里s，方括号，0可能给了我H，s，方括号，

1611
01:19:16,560 --> 01:19:19,720
1 is the I, s, bracket, 2 is the exclamation point.
1 是 I，s，括号，2 是感叹号。

1612
01:19:19,720 --> 01:19:22,410
But just by saying string, all of that happens automatically.
但只要说字符串，所有这些都会自动发生。

1613
01:19:22,410 --> 01:19:25,320
I don't even need to tell the computer how many chars are
我甚至不需要告诉计算机有多少个字符

1614
01:19:25,320 --> 01:19:27,880
going to be in this string all at once.
将要在这个字符串中一次性出现。

1615
01:19:27,880 --> 01:19:31,680
So in fact, let me go over to maybe a variant of this program
实际上，让我看一下这个程序的变体

1616
01:19:31,680 --> 01:19:33,570
and we can see this syntactically.
我们可以从语法上看到这一点。

1617
01:19:33,570 --> 01:19:37,480
So instead of printing out the whole string with %s,
所以，与其用 %s 打印出整个字符串，

1618
01:19:37,480 --> 01:19:43,320
let me actually be a little curious and print out %c, %c, %c,
让我有点好奇，并打印出 %c，%c，%c，

1619
01:19:43,320 --> 01:19:47,490
and then change s to s, bracket, 0, s, bracket, 1, s, bracket, 2.
然后将 s 更改为 s，括号，0，s，括号，1，s，括号，2。

1620
01:19:47,490 --> 01:19:49,140
Which is not better in any sense.
从任何意义上说，这都不算好。

1621
01:19:49,140 --> 01:19:51,000
This is way more tedious now, but it does
现在这要繁琐得多，但它确实

1622
01:19:51,000 --> 01:19:54,840
demonstrate that I can treat here in week 2
证明了我可以在第 2 周中将它

1623
01:19:54,840 --> 01:19:57,870
as though it's an array, which means even in week 1 it was an array,
像数组一样对待，这意味着即使在第 1 周，它也是一个数组，

1624
01:19:57,870 --> 01:19:58,840
we just didn't know it.
我们只是不知道。

1625
01:19:58,840 --> 01:20:01,730
We didn't have the syntax with which to express that.
我们没有语法来表达这一点。

1626
01:20:01,730 --> 01:20:05,740
So if I now do make hi, still compiles ./hi.
所以，如果我现在制作 hi，它仍然会编译 ./hi。

1627
01:20:05,740 --> 01:20:09,370
Same exact output, but I'm now just kind of manipulating
输出完全相同，但我现在只是在操作

1628
01:20:09,370 --> 01:20:11,380
the string in these different ways because I
字符串，用不同的方式，因为我

1629
01:20:11,380 --> 01:20:13,720
a string is just an array of characters, so I can
一个字符串仅仅是字符数组，所以我可以

1630
01:20:13,720 --> 01:20:16,450
treat with the square bracket notation.
用方括号表示法来处理。

1631
01:20:16,450 --> 01:20:21,100
But how do I know-- how does the computer know where hi ends?
但我怎么知道，计算机怎么知道 hi 在哪里结束？

1632
01:20:21,100 --> 01:20:23,890
And this is where strings get a little dangerous.
而这就是字符串变得有点危险的地方。

1633
01:20:23,890 --> 01:20:26,050
Like a char is 1 byte no matter what.
就像一个字符无论如何都是 1 个字节。

1634
01:20:26,050 --> 01:20:28,480
1 char, 1 character, that's it.
1 个字符，就是它了。

1635
01:20:28,480 --> 01:20:31,180
But a string, recall my question mark from earlier,
但是字符串，还记得我之前问的那个问题吗？

1636
01:20:31,180 --> 01:20:33,415
could be null bytes if it's--
如果它可能为空字节，因为它

1637
01:20:33,415 --> 01:20:37,610
you would think could be 0 bytes if you have nothing in it inside the quotes.
你会认为，如果你在引号里面什么都没有，它可能就是 0 个字节。

1638
01:20:37,610 --> 01:20:40,930
It could be one character, two, 10, 100 like I claimed,
它可能是一个字符，两个字符，10 个字符，100 个字符，就像我说的，

1639
01:20:40,930 --> 01:20:44,140
but how does the computer know where strings end?
但计算机怎么知道字符串在哪里结束？

1640
01:20:44,140 --> 01:20:47,560
Like how does the computer not know that the string is not
比如，计算机怎么不知道字符串不是

1641
01:20:47,560 --> 01:20:49,510
the whole row of memory here?
这里整行内存？

1642
01:20:49,510 --> 01:20:51,350
How does it know that it ends here?
它怎么知道它在这里结束？

1643
01:20:51,350 --> 01:20:54,880
Well, it turns out, all this time, when we've been using, quote-unquote,
好吧，事实证明，一直以来，当我们使用，引号引起来的，

1644
01:20:54,880 --> 01:20:58,120
string and using get_string from the CS50 library,
字符串，并使用 CS50 库中的 get_string，

1645
01:20:58,120 --> 01:21:00,640
there's actually a special sentinel value
实际上在计算机内存中每个字符串的末尾

1646
01:21:00,640 --> 01:21:03,580
at the end of every string in a computer's memory
都有一个特殊的哨兵值

1647
01:21:03,580 --> 01:21:06,700
that tells the computer string, stops here.
它告诉计算机字符串，到此为止。

1648
01:21:06,700 --> 01:21:08,890
And the sentinel value-- and by sentinel, I
而这个哨兵值—— 我说哨兵，是指

1649
01:21:08,890 --> 01:21:13,820
just mean special value that the world decided on decades ago, is all 0 bits.
几十年前全世界都决定使用的一个特殊值，它就是全 0 位。

1650
01:21:13,820 --> 01:21:20,210
If you have a byte with all 0 bits in it, that means string ends here.
如果你有一个字节，它的所有位都是 0，那就意味着字符串在这里结束。

1651
01:21:20,210 --> 01:21:23,920
So the implication is that the computer now, using a loop or something,
所以，这意味着计算机现在，使用循环或者其他什么，

1652
01:21:23,920 --> 01:21:26,650
can print out char, char, char-- oh, done,
可以打印出字符，字符，字符—— 哦，完成了，

1653
01:21:26,650 --> 01:21:28,750
because it sees this special value.
因为它看到了这个特殊值。

1654
01:21:28,750 --> 01:21:32,800
If it didn't have that, it might blindly go char, char, char, char char--
如果没有它，它可能会盲目地打印出字符，字符，字符，字符，字符——

1655
01:21:32,800 --> 01:21:37,450
printing out values of memory that don't belong to that given string.
打印出不属于该字符串的内存值。

1656
01:21:37,450 --> 01:21:39,490
So I was correcting myself verbally a moment ago
所以我刚才在口头上纠正了自己。

1657
01:21:39,490 --> 01:21:44,140
because I said that this string is of length 3, it's 3 bytes, but it's not.
因为我说这个字符串的长度是3，它有3个字节，但事实并非如此。

1658
01:21:44,140 --> 01:21:47,290
Every string in the world, both last week and now, this
世界上所有的字符串，无论是上周还是现在，都是

1659
01:21:47,290 --> 01:21:51,430
is actually n plus 1 bytes where n is the actual human length
实际上是 n+1 个字节，其中 n 是人类实际看到的长度

1660
01:21:51,430 --> 01:21:54,220
that you care about, H-I, exclamation point, or 3,
比如你关心的 H-I，感叹号，或者 3，

1661
01:21:54,220 --> 01:21:59,110
but it's always going to use one extra byte for this so-called zero value
但它始终会为这个所谓的零值使用一个额外的字节

1662
01:21:59,110 --> 01:21:59,770
at the end.
在结尾。

1663
01:21:59,770 --> 01:22:03,220
And this 0 value is very tedious to write a 0--
而这个 0 值用 8 个 0 比特来表示非常麻烦。

1664
01:22:03,220 --> 01:22:04,630
as 8 0 bits.
作为 8 个 0 比特。

1665
01:22:04,630 --> 01:22:07,240
So we would actually typically just write it as a 0.
所以我们通常会直接写成一个 0。

1666
01:22:07,240 --> 01:22:10,420
But you don't want to confuse a 0 on the screen-- it's actually being
但你不想把屏幕上的 0 和键盘上的数字 0 混淆。

1667
01:22:10,420 --> 01:22:12,290
like the number 0 on the keyboard.
它实际上就像键盘上的数字 0。

1668
01:22:12,290 --> 01:22:16,000
And so we would actually typically write this symbol with a backslash 0.
所以我们通常会用反斜杠 0 来写这个符号。

1669
01:22:16,000 --> 01:22:19,960
So this is the char-based representation of 0.
所以这是 0 的字符表示形式。

1670
01:22:19,960 --> 01:22:21,970
So it means the exact same thing, this is just
所以它表示的意义完全相同，这仅仅是

1671
01:22:21,970 --> 01:22:26,470
C notation that indicates that this is 8 0 bits,
C 语言的符号表示，它表示这是 8 个 0 比特，

1672
01:22:26,470 --> 01:22:29,380
but just makes clear that it's not literally the number
但它明确表示这并非是你在屏幕上看到的数字

1673
01:22:29,380 --> 01:22:32,320
0 that you want to see on the screen, it's a sentinel value
0，而是一个哨兵值

1674
01:22:32,320 --> 01:22:34,880
that is terminating this here string.
用来终止这个字符串。

1675
01:22:34,880 --> 01:22:38,480
So now what can I do once I know this information?
那么现在，知道了这些信息之后，我该怎么做呢？

1676
01:22:38,480 --> 01:22:41,740
Well, I can actually even see this let me go back to this code
我可以看到，让我回到这个代码

1677
01:22:41,740 --> 01:22:42,790
here in VS Code.
在 VS Code 里。

1678
01:22:42,790 --> 01:22:46,190
Let me change these %c's to %i's just like before.
像之前一样，把这些 %c 改成 %i。

1679
01:22:46,190 --> 01:22:50,290
And now, we'll see again those same numbers, make hi ./hi,
现在我们又会看到相同的数字，make hi ./hi，

1680
01:22:50,290 --> 01:22:51,730
there are the three.
它们是 3 个。

1681
01:22:51,730 --> 01:22:56,410
I can technically poke around a little bit further, %i one more,
我可以在技术上再深入一点，再来一个 %i，

1682
01:22:56,410 --> 01:22:58,210
and let's look at s, bracket, 3.
然后让我们看看 s，方括号，3。

1683
01:22:58,210 --> 01:23:02,060
I was not exaggerating earlier when I said,
之前我说的时候没有夸张，

1684
01:23:02,060 --> 01:23:06,260
in general, if you go past the end of an array, bad things can happen.
通常情况下，如果你超出数组的末尾，就会出现问题。

1685
01:23:06,260 --> 01:23:10,030
But in this case, I know that there is one more thing at the end of this array
但在这种情况下，我知道在这个数组的末尾还有一个东西

1686
01:23:10,030 --> 01:23:13,210
because this is how strings are built. This is not a CS50 thing,
因为字符串就是这样构建的。这与 CS50 无关，

1687
01:23:13,210 --> 01:23:17,440
this is a thing in C. Every string in the world in double quotes
这是 C 语言中的特性。世界上所有用双引号括起来的字符串

1688
01:23:17,440 --> 01:23:20,780
ends with a backslash 0-- that is 8 0 bits.
都以反斜杠 0 结尾，也就是 8 个 0 比特。

1689
01:23:20,780 --> 01:23:24,400
So if I really want, I can see this by printing out s, bracket, 3,
所以如果我真想看到，我可以打印出 s，方括号，3，

1690
01:23:24,400 --> 01:23:26,290
which is the fourth and final location.
也就是第四个也是最后一个位置。

1691
01:23:26,290 --> 01:23:34,120
If I recompile my code now, make hi ./hi, I should see 72, 73, 33, and 0.
如果我现在重新编译我的代码，make hi ./hi，我应该会看到 72，73，33 和 0。

1692
01:23:34,120 --> 01:23:35,470
That's always been there.
这些一直都在。

1693
01:23:35,470 --> 01:23:40,900
So I'm always using 4 bytes, somewhat wastefully, but somewhat necessarily
所以我一直使用 4 个字节，有些浪费，但也有些必要

1694
01:23:40,900 --> 01:23:45,080
so that the computer actually knows where that string ends.
这样计算机才能知道字符串的结尾在哪里。

1695
01:23:45,080 --> 01:23:48,070
So if we go back to the memory representation of this here,
所以如果我们回到这里这个内存的表示形式，

1696
01:23:48,070 --> 01:23:52,990
it's just as though you have an array of integers being stored contiguously back
就好像你有一个整数数组被连续存储在后面

1697
01:23:52,990 --> 01:23:56,800
to back to back, the last one of which means this is the end of the array
一个接一个，最后一个表示数组的结尾

1698
01:23:56,800 --> 01:24:00,120
of characters, but because I'm using, quote-unquote, "string,"
的字符，但因为我使用了“字符串”，

1699
01:24:00,120 --> 01:24:04,080
because I'm using %s and %c, I'm not seeing these numbers by default,
因为我使用了 %s 和 %c，所以默认情况下我没有看到这些数字，

1700
01:24:04,080 --> 01:24:08,950
I'm seeing H-I, exclamation point unless I explicitly tell printf, no, no, no,
我看到的是 H-I，感叹号，除非我明确告诉 printf，不，不，不，

1701
01:24:08,950 --> 01:24:13,470
no, show me with %i these actual integers.
不，用 %i 显示这些实际的整数。

1702
01:24:13,470 --> 01:24:15,840
This, then, is how you can think about the string.
那么，这就是你如何思考字符串的方式。

1703
01:24:15,840 --> 01:24:17,100
Like you don't really need to think about
就好像你并不需要去思考

1704
01:24:17,100 --> 01:24:18,540
it as being individual characters.
它是单个字符。

1705
01:24:18,540 --> 01:24:21,600
This is just s, and it has some length here,
这只是一个 s，它在这里有一些长度，

1706
01:24:21,600 --> 01:24:26,760
but it does not necessarily an array that you yourself have to create,
但它不一定是你自己需要创建的数组，

1707
01:24:26,760 --> 01:24:30,820
you get it automatically just by using a string.
你只要使用字符串，就可以自动获得它。

1708
01:24:30,820 --> 01:24:32,910
Now there's just-- not to add on to the jargon.
现在只是-- 不想增加专业术语。

1709
01:24:32,910 --> 01:24:35,760
This backslash 0, these 8 0 bits, there's
这个反斜杠 0，这些 8 位 0，有

1710
01:24:35,760 --> 01:24:37,290
actually a technical term for them.
实际上有一个专门的术语来称呼它们。

1711
01:24:37,290 --> 01:24:38,430
You can call them NUL.
你可以称它们为 NUL。

1712
01:24:38,430 --> 01:24:41,430
It's typically written in all caps like this, confusingly.
它通常像这样全部大写，很令人困惑。

1713
01:24:41,430 --> 01:24:44,580
In a couple of weeks, we're going to see another word pronounced null,
几周后，我们会看到另一个发音为 null 的词，

1714
01:24:44,580 --> 01:24:48,720
but spelled N-U-L-L. Left hand wasn't talking to right hand years ago,
但拼写为 N-U-L-L。几年前，左手和右手没有沟通，

1715
01:24:48,720 --> 01:24:54,000
but N-U-L means this is the 0 byte that terminates strings,
但 N-U-L 表示这是终止字符串的 0 字节，

1716
01:24:54,000 --> 01:24:56,520
that indicate the end of a string.
它表示字符串的结尾。

1717
01:24:56,520 --> 01:25:00,070
And fun fact, you've actually seen this before even though we glossed over it.
有趣的是，你实际上以前见过这个，即使我们把它略过了。

1718
01:25:00,070 --> 01:25:02,490
Here's that ASCII chart from last time.
这是上次的 ASCII 表。

1719
01:25:02,490 --> 01:25:08,850
If I focus on the leftmost column, guess what is the 0 ASCII character?
如果我把注意力集中在最左边的列，猜猜 0 ASCII 字符是什么？

1720
01:25:08,850 --> 01:25:09,480
NUL.
NUL。

1721
01:25:09,480 --> 01:25:14,005
You never see null on the screen, it's just how you pronounce 8 0 bits.
你永远不会在屏幕上看到 null，它只是你如何读出 8 位 0 的方式。

1722
01:25:14,005 --> 01:25:14,810
Whew!
呼！

1723
01:25:14,810 --> 01:25:17,360
questions on this representation of strings?
关于这种字符串表示方式，有什么问题吗？

1724
01:25:17,360 --> 01:25:18,250
Yeah?
有吗？

1725
01:25:18,250 --> 01:25:20,090
AUDIENCE: Are strings [INAUDIBLE]?
观众：字符串是 [听不清] 吗？

1726
01:25:20,090 --> 01:25:22,380
DAVID MALAN: Are string structured differently in other languages?
大卫·马兰：在其他语言中，字符串的结构是否不同？

1727
01:25:22,380 --> 01:25:22,760
Yes.
是的。

1728
01:25:22,760 --> 01:25:24,590
They are more powerful in other languages.
它们在其他语言中更强大。

1729
01:25:24,590 --> 01:25:28,070
In C, you have to build them yourself in this way.
在 C 语言中，你必须以这种方式自己构建它们。

1730
01:25:28,070 --> 01:25:29,900
More on that when we get to Python.
我们讲到 Python 时会详细介绍。

1731
01:25:29,900 --> 01:25:30,710
Other questions.
还有其他问题吗？

1732
01:25:30,710 --> 01:25:31,593
Yeah?
有吗？

1733
01:25:31,593 --> 01:25:41,170
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1734
01:25:41,170 --> 01:25:42,670
DAVID MALAN: A really good question.
大卫·马兰：这个问题问得很好。

1735
01:25:42,670 --> 01:25:45,840
Does that mean we don't have a function to get the length of a string?
这意味着我们没有函数来获取字符串的长度吗？

1736
01:25:45,840 --> 01:25:47,700
Do we have to create it?
我们必须创建它吗？

1737
01:25:47,700 --> 01:25:51,360
Short answer, there is a function, but you have to-- someone
简短的回答，有一个函数，但你必须-- 有人

1738
01:25:51,360 --> 01:25:52,540
had to write code for it.
必须为它编写代码。

1739
01:25:52,540 --> 01:25:56,010
You can't just ask the string itself like you can in JavaScript or Java.
你不能像在 JavaScript 或 Java 中那样直接询问字符串本身。

1740
01:25:56,010 --> 01:25:57,150
What is the--
什么是--

1741
01:25:57,150 --> 01:25:59,355
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1742
01:25:59,355 --> 01:26:00,480
DAVID MALAN: Yeah, you can.
大卫·马兰：是的，你可以。

1743
01:26:00,480 --> 01:26:04,230
It's actually more similar to Python than it is to JavaScript or Java,
它实际上更类似于 Python，而不是 JavaScript 或 Java，

1744
01:26:04,230 --> 01:26:07,110
but we'll see that in just a few minutes, in fact.
但事实上，我们将在几分钟内看到这一点。

1745
01:26:07,110 --> 01:26:09,340
So let's introduce maybe a couple of strings.
所以让我们引入几个字符串。

1746
01:26:09,340 --> 01:26:12,360
So here's two strings in the abstract called s and t,
所以这里有两个抽象的字符串，分别称为 s 和 t，

1747
01:26:12,360 --> 01:26:15,210
and I've initialized them arbitrarily to "HI!" and "BYE!"
我随机地将它们初始化为“HI！”和“BYE！”

1748
01:26:15,210 --> 01:26:18,840
just so we can explore what's going to actually happen underneath the hood.
这样我们就可以探索幕后实际发生的事情。

1749
01:26:18,840 --> 01:26:20,640
So let me go back to VS Code.
所以让我回到 VS Code。

1750
01:26:20,640 --> 01:26:23,680
Let me just completely change this program to be that instead.
让我完全改变这个程序，让它变成那样。

1751
01:26:23,680 --> 01:26:26,280
So string equals, quote-unquote, "HI!"
所以字符串等于，引号，"HI!"

1752
01:26:26,280 --> 01:26:28,860
String t equals, quote-unquote, "BYE!"
字符串t 等于，引号，"BYE!"

1753
01:26:28,860 --> 01:26:29,860
in all caps.
全部大写。

1754
01:26:29,860 --> 01:26:34,620
And then let's print them both out very simply. %s backslash n, s.
然后让我们简单地将它们都打印出来。%s 反斜杠 n，s。

1755
01:26:34,620 --> 01:26:39,570
Print out %s backslash n, t just so we can see what's going on.
打印出 %s 反斜杠 n，t，这样我们就可以看到发生了什么。

1756
01:26:39,570 --> 01:26:44,183
If I do make hi ./hi, I should, of course, see these two strings.
如果我确实创建了 hi ./hi，我当然应该看到这两个字符串。

1757
01:26:44,183 --> 01:26:46,350
But what's going on inside of the computer's memory?
但是计算机内存里发生了什么呢？

1758
01:26:46,350 --> 01:26:48,868
Well, in this computer's memory, assuming
嗯，在这个计算机的内存中，假设

1759
01:26:48,868 --> 01:26:51,660
these are the only two variables involved and assuming the computer
这两个是唯一涉及的变量，并且假设计算机

1760
01:26:51,660 --> 01:26:55,170
is just doing things top to bottom, "HI!"
只是从上到下做事，"HI!"

1761
01:26:55,170 --> 01:26:58,260
is probably going to be stored somewhere like this on my canvas of memory,
可能将存储在我记忆画布上的某个地方，

1762
01:26:58,260 --> 01:26:58,950
"BYE!"
"BYE!"

1763
01:26:58,950 --> 01:27:00,290
is probably going to be stored there.
可能将存储在那里。

1764
01:27:00,290 --> 01:27:03,165
And it's wrapping around, but that's just an artist's representation.
它正在循环，但这只是一个艺术家的表示。

1765
01:27:03,165 --> 01:27:05,380
But notice that it is now really important
但请注意，现在非常重要

1766
01:27:05,380 --> 01:27:08,890
that there is this NUL byte at the end of each string
每个字符串的末尾都有这个 NUL 字节

1767
01:27:08,890 --> 01:27:11,650
because that's how the computer is going to know where "HI!"
因为这是计算机知道 "HI!" 的位置的方式

1768
01:27:11,650 --> 01:27:13,630
ends and where "BYE!"
结束，以及 "BYE!" 的位置

1769
01:27:13,630 --> 01:27:15,670
begins, otherwise you might see "HI!"
开始，否则你可能会看到 "HI!"

1770
01:27:15,670 --> 01:27:16,360
"BYE!"
"BYE!"

1771
01:27:16,360 --> 01:27:20,380
all on the screen at once if there weren't the sentinel value indicating
如果不存在指示哨兵值的，所有这些都会同时出现在屏幕上

1772
01:27:20,380 --> 01:27:23,860
to printf, stop at this character.
告诉 printf 在此字符处停止。

1773
01:27:23,860 --> 01:27:26,290
But that's all that's going on in your program
但这就是你的程序中发生的一切

1774
01:27:26,290 --> 01:27:29,080
when you have two variables in this way.
当你用这种方式有两个变量时。

1775
01:27:29,080 --> 01:27:32,290
And in fact, what's really going on and things get a little more interesting
实际上，真正发生的事情，并且事情变得更加有趣

1776
01:27:32,290 --> 01:27:37,310
here, if I were to want two of these things,
这里，如果我想得到两个这样的东西，

1777
01:27:37,310 --> 01:27:40,630
notice that I could refer to them two as arrays.
请注意，我可以将它们称为数组。

1778
01:27:40,630 --> 01:27:43,990
So s, bracket, 0, 1, 2, and even 3.
所以 s，方括号，0，1，2，甚至 3。

1779
01:27:43,990 --> 01:27:47,110
t, bracket, 0, 1, 2, and even 3 and 4.
t，方括号，0，1，2，甚至 3 和 4。

1780
01:27:47,110 --> 01:27:51,460
But if I want to actually really blend some ideas,
但如果我实际上想真正融合一些想法，

1781
01:27:51,460 --> 01:27:54,190
just playing around with these basic principles now,
现在只是玩玩这些基本原则，

1782
01:27:54,190 --> 01:27:56,140
notice what I can do in this version.
请注意在这个版本中我可以做什么。

1783
01:27:56,140 --> 01:27:59,200
If I know I've got two arrays in VS Code,
如果我知道我在 VS Code 中有两个数组，

1784
01:27:59,200 --> 01:28:02,950
I don't strictly need to do string s and t and u
我不需要严格地使用字符串 s 和 t 以及 u

1785
01:28:02,950 --> 01:28:08,260
and v. That's devolving back into the scores1, scores2, scores3 mantra where
和 v。这又变成了 scores1、scores2、scores3 咒语，在那里

1786
01:28:08,260 --> 01:28:10,277
I had multiple variables almost the same name
我有几个几乎同名的变量

1787
01:28:10,277 --> 01:28:12,610
even though I'm using different letters of the alphabet.
即使我使用的是不同的字母。

1788
01:28:12,610 --> 01:28:13,840
What if I want--
如果我想要 -

1789
01:28:13,840 --> 01:28:15,280
what if I do this?
如果我这样做？

1790
01:28:15,280 --> 01:28:19,660
string words, and if I want to store two words in the computer's memory, fine.
字符串 words，如果我想在计算机的内存中存储两个单词，没问题。

1791
01:28:19,660 --> 01:28:22,700
Create an array of two strings.
创建一个包含两个字符串的数组。

1792
01:28:22,700 --> 01:28:23,620
But what is a string?
但是什么是字符串？

1793
01:28:23,620 --> 01:28:28,870
A string is an array of characters, so it's getting a little bit trippy here,
字符串是字符数组，所以这里有点奇怪，

1794
01:28:28,870 --> 01:28:32,290
but the ideas are still going to be the same. words, bracket,
但想法仍然是一样的。 words，方括号，

1795
01:28:32,290 --> 01:28:34,540
0 could certainly equal "HI!"
0 当然可以等于 "HI!"

1796
01:28:34,540 --> 01:28:39,280
words, bracket, 1 can certainly equal "BYE!" just like the scores example.
words，方括号，1 当然可以等于 "BYE!"，就像 scores 示例一样。

1797
01:28:39,280 --> 01:28:42,910
And then if I want to print these things with %s, I can print out words,
然后，如果我想用 %s 打印这些内容，我可以打印出 words，

1798
01:28:42,910 --> 01:28:44,080
bracket, 0.
方括号，0。

1799
01:28:44,080 --> 01:28:48,820
And then I can print out %s backslash n words bracket 1.
然后我可以打印出 %s 反斜杠 n words 方括号 1。

1800
01:28:48,820 --> 01:28:52,520
And the example is not going to be any different in terms of its output,
这个例子在输出方面不会有任何不同，

1801
01:28:52,520 --> 01:28:58,240
but I've now avoided s and t, I now just have one variable called words
但我现在避免了 s 和 t，现在只有一个名为 words 的变量

1802
01:28:58,240 --> 01:29:00,710
containing both of these here things.
包含这两个东西。

1803
01:29:00,710 --> 01:29:02,800
And if I really want to poke around, here's
如果我真的想四处看看，这里有

1804
01:29:02,800 --> 01:29:06,490
where things get even more visually overwhelming,
让事情变得更加视觉上让人眼花缭乱的地方，

1805
01:29:06,490 --> 01:29:09,640
but just the logical extension of these same ideas.
但只是这些相同想法的逻辑扩展。

1806
01:29:09,640 --> 01:29:13,300
Right now is the previous version where I had two variables, s and t.
现在是之前版本，我在那里有两个变量，s 和 t。

1807
01:29:13,300 --> 01:29:17,290
If I now use this new version where I have one variable called words,
如果我现在使用这个新版本，我有一个名为 words 的变量，

1808
01:29:17,290 --> 01:29:22,060
just like this here, the picture should follow logically like this.
就像这样，图片应该逻辑上像这样。

1809
01:29:22,060 --> 01:29:26,320
words, bracket, 0 is this string; words, bracket, 1 is this string;
words，方括号，0 是这个字符串；words，方括号，1 是这个字符串；

1810
01:29:26,320 --> 01:29:27,940
but what is each string?
但是每个字符串是什么？

1811
01:29:27,940 --> 01:29:29,840
It's an array of characters.
它是一个字符数组。

1812
01:29:29,840 --> 01:29:36,520
And so you can also think of it like this, where this H is words, bracket,
所以你也可以这样想，这里这个 H 是 words，方括号，

1813
01:29:36,520 --> 01:29:37,930
0, bracket, 0.
0，方括号，0。

1814
01:29:37,930 --> 01:29:41,440
So the 0-th character of the 0-th word.
所以是第 0 个单词的第 0 个字符。

1815
01:29:41,440 --> 01:29:45,580
And this is words, bracket, 0, 1; words, bracket, 0, 2; words, bracket, 0, 3.
而这是 words，方括号，0，1；words，方括号，0，2；words，方括号，0，3。

1816
01:29:45,580 --> 01:29:49,180
And then words, bracket, 1, 0.
然后 words，方括号，1，0。

1817
01:29:49,180 --> 01:29:52,382
So it's kind of like a two-dimensional array, almost.
所以它有点像一个二维数组，几乎。

1818
01:29:52,382 --> 01:29:54,340
And you can think about it that way if helpful.
如果你觉得有帮助，你可以这样想。

1819
01:29:54,340 --> 01:29:58,400
But for now, it's just applying the same principles to the code.
但现在，它只是将相同的原则应用到代码中。

1820
01:29:58,400 --> 01:30:01,930
So if I go to my code here and I've got my "HI!" and my "BYE!"--
所以如果我在这里去我的代码，我有我的“HI！”和我的“BYE！”--

1821
01:30:01,930 --> 01:30:07,000
this is going to look a little stupid, but let me change this %s to %c, %c,
这看起来有点蠢，但让我把这个 %s 更改为 %c，%c，

1822
01:30:07,000 --> 01:30:09,640
%c, and print out words, bracket, 0.
%c，并打印出 words，方括号，0。

1823
01:30:09,640 --> 01:30:11,620
words, bracket, 0, bracket 1.
words，方括号，0，方括号 1。

1824
01:30:11,620 --> 01:30:16,900
words, bracket, 0, bracket, 2 to print out that three-letter word.
words，方括号，0，方括号，2 来打印出那个三个字母的单词。

1825
01:30:16,900 --> 01:30:21,550
And now down here, let me print out %c, %c, %c,
现在在这里，让我打印出 %c，%c，%c，

1826
01:30:21,550 --> 01:30:24,340
%c because it's four letters in BYE, exclamation point.
%c 因为它在 BYE 中有四个字母，感叹号。

1827
01:30:24,340 --> 01:30:28,570
This is words, bracket, 1, but the first character; words, bracket, 1,
这是 words，方括号，1，但第一个字符；words，方括号，1，

1828
01:30:28,570 --> 01:30:32,920
the second character; words, bracket, 1, the third character;
第二个字符；words，方括号，1，第三个字符；

1829
01:30:32,920 --> 01:30:34,948
and words, bracket, 1, the fourth character.
以及 words，方括号，1，第四个字符。

1830
01:30:34,948 --> 01:30:37,240
It's hard to say when you're typing a different number,
当你输入不同的数字时，很难说，

1831
01:30:37,240 --> 01:30:40,810
but that's what we get by using zero indexing, so to speak.
但这就是我们使用零索引获得的，可以这么说。

1832
01:30:40,810 --> 01:30:41,720
make hi.
制作 hi。

1833
01:30:41,720 --> 01:30:42,220
Whew!
呼！

1834
01:30:42,220 --> 01:30:42,940
No mistakes.
没有错误。

1835
01:30:42,940 --> 01:30:43,780
"HI!"
“HI！”

1836
01:30:43,780 --> 01:30:45,440
Says the same thing.
说的是同一件事。

1837
01:30:45,440 --> 01:30:46,840
So again, there's no magic.
所以再说一次，没有魔法。

1838
01:30:46,840 --> 01:30:49,630
Like you are fully in control over what's going
就像你完全控制着正在发生的事情

1839
01:30:49,630 --> 01:30:51,560
on inside of the computer's memory.
在计算机的内存中。

1840
01:30:51,560 --> 01:30:54,250
And now that we have this array syntax with square brackets,
现在我们有了这个带有方括号的数组语法，

1841
01:30:54,250 --> 01:30:58,740
you can both create these things and then manipulate them or access them
你可以创建这些东西，然后操纵它们或访问它们

1842
01:30:58,740 --> 01:31:01,310
however you so choose.
根据你的选择。

1843
01:31:01,310 --> 01:31:01,810
Whew!
呼！

1844
01:31:01,810 --> 01:31:08,540
Questions on arrays or strings in this way?
关于数组或字符串以这种方式的问题？

1845
01:31:08,540 --> 01:31:10,032
Yeah, over here.
是的，这边。

1846
01:31:10,032 --> 01:31:13,340
AUDIENCE: Can you have any array that has multiple data types in it?
观众：你能有一个包含多个数据类型的数组吗？

1847
01:31:13,340 --> 01:31:13,880
DAVID MALAN: Good question.
大卫·马兰：好问题。

1848
01:31:13,880 --> 01:31:16,255
Can you have an array with multiple different data types?
你能有一个包含多个不同数据类型的数组吗？

1849
01:31:16,255 --> 01:31:19,310
Short answer, no; longer answer, sort of,
简短的回答，不；更长的回答，有点像，

1850
01:31:19,310 --> 01:31:22,670
but not in nearly the same user-friendly way as with languages
但不像 Python 或 JavaScript 等语言那样用户友好。

1851
01:31:22,670 --> 01:31:25,220
like Python or JavaScript or others.
例如 Python 或 JavaScript 等。

1852
01:31:25,220 --> 01:31:30,580
So assume for now arrays should be the same type in C. Other questions?
所以现在假设在 C 语言中，数组应该具有相同类型。还有其他问题吗？

1853
01:31:30,580 --> 01:31:31,997
Yeah, over here.
是的，这边。

1854
01:31:31,997 --> 01:31:34,432
AUDIENCE: When you talk about [INAUDIBLE]??
观众：当你说到 [听不清] ??

1855
01:31:47,113 --> 01:31:48,780
DAVID MALAN: Oh, a really good question.
大卫·马兰：哦，一个很好的问题。

1856
01:31:48,780 --> 01:31:51,500
It will-- so for those who couldn't hear,
它会——对于那些没有听到的人，

1857
01:31:51,500 --> 01:31:54,425
if you were to look past the end of one array,
如果你要看一下一个数组的末尾，

1858
01:31:54,425 --> 01:31:56,550
would you start to see the beginning of the second?
你会开始看到第二个的开头吗？

1859
01:31:56,550 --> 01:31:58,008
In this case, maybe the word "BYE!"
在这种情况下，也许是“再见！”这个词。

1860
01:31:58,008 --> 01:32:01,070
Could depend on the particulars of your code in the computer.
这可能取决于你的代码在计算机中的具体细节。

1861
01:32:01,070 --> 01:32:02,250
Let's try this.
让我们试试这个。

1862
01:32:02,250 --> 01:32:07,310
So let's get a little greedy here and go one past H-I, exclamation point,
所以让我们稍微贪心一点，在 H-I 后面加一个感叹号，

1863
01:32:07,310 --> 01:32:11,450
null character by looking at words, bracket, 0, 3,
通过查看单词、括号、0、3 来查看空字符，

1864
01:32:11,450 --> 01:32:16,220
which should actually be our null character, so that's going to be there.
它实际上应该是我们的空字符，所以它将存在于那里。

1865
01:32:16,220 --> 01:32:18,350
And actually, let's see.
实际上，让我们看看。

1866
01:32:18,350 --> 01:32:19,490
Let's go ahead and do this.
让我们继续执行这个操作。

1867
01:32:19,490 --> 01:32:21,530
Make hi ./hi.
将 hi 设置为 ./hi。

1868
01:32:21,530 --> 01:32:25,310
Still works as expected, but let me change this to integer,
它按预期工作，但我把它改为整数，

1869
01:32:25,310 --> 01:32:27,770
integer so we can actually see what's going on.
整数，这样我们就能真正看到发生了什么。

1870
01:32:27,770 --> 01:32:28,610
Integer.
整数。

1871
01:32:28,610 --> 01:32:32,840
And now, if I recompile make hi, I should see the same thing,
现在，如果我重新编译 make hi，我应该看到相同的东西，

1872
01:32:32,840 --> 01:32:34,100
but numerically.
但以数字形式。

1873
01:32:34,100 --> 01:32:37,430
And now what I think you're proposing is let's get a little crazy
现在我认为你建议我们稍微疯狂一点

1874
01:32:37,430 --> 01:32:41,000
and go even past that to what could be location 4,
并且超过它，到达可能的位置 4，

1875
01:32:41,000 --> 01:32:45,740
but we know semantically doesn't exist, but maybe is bumping up against "BYE!"
但我们知道语义上不存在，但可能正在与“再见！”发生碰撞。

1876
01:32:45,740 --> 01:32:49,140
So make hi ./hi.
所以将 hi 设置为 ./hi。

1877
01:32:49,140 --> 01:32:52,440
And guess what 66 is.
猜猜 66 是什么。

1878
01:32:52,440 --> 01:32:54,360
Well, just the B, but yes.
嗯，只是 B，但没错。

1879
01:32:54,360 --> 01:32:59,600
66, recall, is capital B because in week 0, capital A was 65.
请记住，66 是大写 B，因为在第 0 周，大写 A 是 65。

1880
01:32:59,600 --> 01:33:01,350
So indeed, now we're really poking around.
所以的确，现在我们真的在四处探查。

1881
01:33:01,350 --> 01:33:02,267
And you can get crazy.
你可以变得疯狂。

1882
01:33:02,267 --> 01:33:05,520
Like, what's 400 characters away and see what's going on there.
比如，400 个字符以外是什么，看看那里发生了什么。

1883
01:33:05,520 --> 01:33:07,870
Eventually your program will probably crash,
最终你的程序可能会崩溃，

1884
01:33:07,870 --> 01:33:12,300
and so don't poke around too much, but more on that in the coming days, too.
所以不要过多地四处探查，但在接下来的几天里，我们会详细介绍这一点。

1885
01:33:12,300 --> 01:33:16,298
All right, well how about some other revelations and problem-solving?
好的，我们来谈谈其他一些启示和问题解决方法吧？

1886
01:33:16,298 --> 01:33:18,840
Now coming back to the question about strings length earlier,
现在回到之前关于字符串长度的问题，

1887
01:33:18,840 --> 01:33:21,465
and we'll see if we can then tie this all together to something
我们将看看是否可以将所有这些结合起来，

1888
01:33:21,465 --> 01:33:24,390
like cryptography in the end and manipulating strings
最终像密码学一样，操纵字符串

1889
01:33:24,390 --> 01:33:26,580
for the purpose of sending them securely.
目的是安全地发送它们。

1890
01:33:26,580 --> 01:33:30,430
So let me propose that we go into VS Code here again in a moment.
所以，我建议我们过一会儿再回到 VS Code 中。

1891
01:33:30,430 --> 01:33:32,430
And I'm going to create a program called length.
我将创建一个名为 length 的程序。

1892
01:33:32,430 --> 01:33:36,490
Let's actually figure out ourselves the length of a string initially.
让我们先自己弄清楚一个字符串的长度。

1893
01:33:36,490 --> 01:33:39,750
So I'm going to go ahead and code length.c.
所以我将继续编写 length.c 代码。

1894
01:33:39,750 --> 01:33:42,450
I'm going to go ahead and include cs50.h.
我将继续包含 cs50.h。

1895
01:33:42,450 --> 01:33:46,170
I'm going to include stdio.h, int main void.
我将包含 stdio.h，int main void。

1896
01:33:46,170 --> 01:33:49,620
And then inside of main, I'm going to prompt the user for their name.
然后在 main 内部，我将提示用户输入他们的姓名。

1897
01:33:49,620 --> 01:33:51,930
get_string, quote-unquote, "Name."
获取字符串，引号括起来，"姓名"。

1898
01:33:51,930 --> 01:33:55,152
And then I'm going to go ahead and I want
然后我要

1899
01:33:55,152 --> 01:33:56,610
to count the length of this string.
计算这个字符串的长度。

1900
01:33:56,610 --> 01:33:57,943
But I know what a string is now.
但我现在知道字符串是什么了。

1901
01:33:57,943 --> 01:34:01,720
It's char, char, char, char, and then eventually the null character.
它是一个字符，一个字符，一个字符，一个字符，然后最终是空字符。

1902
01:34:01,720 --> 01:34:02,685
So I can look for that.
所以我可以寻找它。

1903
01:34:02,685 --> 01:34:04,560
And I can write this in a few different ways.
我可以用几种不同的方法来写它。

1904
01:34:04,560 --> 01:34:06,518
I know a bunch of different types of loops now,
我现在知道很多不同类型的循环，

1905
01:34:06,518 --> 01:34:10,440
but I'm going to go with a while loop by first declaring a variable n,
但我要用一个 while 循环，首先声明一个变量 n，

1906
01:34:10,440 --> 01:34:12,618
for number of characters, set it equal to 0.
表示字符数，将其设置为 0。

1907
01:34:12,618 --> 01:34:14,910
It's like starting to count with your fingers all down,
就像开始用手指往下数一样，

1908
01:34:14,910 --> 01:34:17,910
and I want to do the equivalent of this, counting each of the letters
我想要做等效的事情，计算我输入的每个字母

1909
01:34:17,910 --> 01:34:18,810
that I type in.
的个数。

1910
01:34:18,810 --> 01:34:20,490
So I can do that as follows.
所以我可以用以下方法来做。

1911
01:34:20,490 --> 01:34:29,160
While the name variable at location n does not equal,
当位置 n 处的 name 变量不等于

1912
01:34:29,160 --> 01:34:32,910
quote-unquote, backslash 0, which looks weird,
引号括起来，反斜杠 0，看起来很奇怪，

1913
01:34:32,910 --> 01:34:35,850
but it's just asking the question, is the character
但它只是在问，这个字符

1914
01:34:35,850 --> 01:34:39,850
at that location equal to the so-called null character?
在这个位置等于所谓的空字符吗？

1915
01:34:39,850 --> 01:34:43,560
Which is written with single quotes and backslash 0 by convention.
按照惯例，它是用单引号和反斜杠 0 写成的。

1916
01:34:43,560 --> 01:34:48,300
And what I want to do, while that is true, is just add 1 to n.
而我想要做的，当这是真的时，就是将 n 加 1。

1917
01:34:48,300 --> 01:34:52,440
And then at the very bottom here, let's just go ahead and print out with %i
然后在最下面这里，让我们直接用 %i 打印出来

1918
01:34:52,440 --> 01:34:57,540
the value of n because presumably if I type in HI, exclamation point,
n 的值，因为如果我输入 HI，感叹号，

1919
01:34:57,540 --> 01:35:01,860
I'm starting at 0 and I'm going to have H, I, exclamation point,
我从 0 开始，我要有 H、I、感叹号，

1920
01:35:01,860 --> 01:35:05,800
null character so I don't increment n a fourth time.
空字符，所以我不会在第四次递增 n。

1921
01:35:05,800 --> 01:35:08,460
So let's go ahead and run down here.
所以让我们继续运行到这里。

1922
01:35:08,460 --> 01:35:12,735
make length ./length, Enter.
make length ./length，回车。

1923
01:35:12,735 --> 01:35:15,360
Well, I guess I'm asking for name, so I'll do my name for real.
好吧，我想我是在要名字，所以我会用我的真实名字。

1924
01:35:15,360 --> 01:35:18,840
David, five characters, and I indeed get 5.
David，五个字符，我确实得到了 5。

1925
01:35:18,840 --> 01:35:22,750
If I used a for loop, I could do something similar,
如果我使用 for 循环，我可以做类似的事情，

1926
01:35:22,750 --> 01:35:26,070
but I think this while loop approach, much like our counter from the past,
但我认为这种 while 循环方法，就像我们过去使用的计数器一样，

1927
01:35:26,070 --> 01:35:27,330
is fairly straightforward.
相当简单。

1928
01:35:27,330 --> 01:35:28,600
But what if I want to do this?
但如果我想要这样做呢？

1929
01:35:28,600 --> 01:35:30,780
What if I want to make another function for this?
如果我想要为此创建一个新的函数呢？

1930
01:35:30,780 --> 01:35:32,100
Well, I could do that.
好吧，我可以这样做。

1931
01:35:32,100 --> 01:35:32,888
Let me--
让我 -

1932
01:35:32,888 --> 01:35:33,930
All right, let's do this.
好吧，让我们来做这个。

1933
01:35:33,930 --> 01:35:36,840
Let's write a quick function called string_length.
让我们编写一个名为 string_length 的简短函数。

1934
01:35:36,840 --> 01:35:40,172
It's going to take a string called s or whatever as input.
它将以一个名为 s 或其他任何字符串作为输入。

1935
01:35:40,172 --> 01:35:41,130
And then you know what?
然后你知道吗？

1936
01:35:41,130 --> 01:35:43,590
Let's just do this in that function.
让我们直接在这个函数中执行这个操作。

1937
01:35:43,590 --> 01:35:45,810
I'm going to borrow my code from a moment ago.
我要借用我之前写过的代码。

1938
01:35:45,810 --> 01:35:47,720
I'm going to paste it into this function.
我要把它粘贴到这个函数中。

1939
01:35:47,720 --> 01:35:49,470
But I'm not going to print out the length,
但我不会打印出长度，

1940
01:35:49,470 --> 01:35:51,060
I'm going to return the length n.
我要返回长度 n。

1941
01:35:51,060 --> 01:35:53,280
So I have a helper function of sorts that's
所以，我有一个辅助函数，它

1942
01:35:53,280 --> 01:35:55,590
going to hand me back the length of the string,
将把字符串的长度返回给我，

1943
01:35:55,590 --> 01:36:00,780
and that's why this returns an int, but takes a string as its argument.
这就是为什么它返回一个 int，但接收一个字符串作为参数的原因。

1944
01:36:00,780 --> 01:36:01,860
How do I use this?
我该如何使用它？

1945
01:36:01,860 --> 01:36:04,120
Well, first, I do need to copy the prototype
好吧，首先，我需要复制原型。

1946
01:36:04,120 --> 01:36:06,090
so I don't get into trouble as before.
所以我不再像以前那样陷入麻烦。

1947
01:36:06,090 --> 01:36:07,020
Semicolon.
分号。

1948
01:36:07,020 --> 01:36:10,020
And then in my main function, what I think I can do now
然后在我的主函数中，我认为我现在可以做的事情是

1949
01:36:10,020 --> 01:36:11,380
is something like this.
像这样。

1950
01:36:11,380 --> 01:36:17,942
I can do int length equals the string length of the name variable
我可以做 int length 等于 name 变量的字符串长度

1951
01:36:17,942 --> 01:36:18,900
that was just typed in.
刚刚输入的。

1952
01:36:18,900 --> 01:36:23,940
And now using printf %i, print out length, semicolon.
现在使用 printf %i，打印出 length，分号。

1953
01:36:23,940 --> 01:36:25,440
So exact same logic.
所以逻辑完全一样。

1954
01:36:25,440 --> 01:36:28,050
The only thing I've done that's different this time is I've
这一次我做的不同的事情是

1955
01:36:28,050 --> 01:36:30,210
added a helper function just to demonstrate
添加了一个辅助函数来演示

1956
01:36:30,210 --> 01:36:32,610
how I can take some pretty basic functionality,
如何获取一些非常基本的功能，

1957
01:36:32,610 --> 01:36:35,010
find the length of a string, and modularize it
找到字符串的长度，并将其模块化

1958
01:36:35,010 --> 01:36:38,040
into a function abstract it away so I never again have
进入一个函数抽象它，这样我就不必再

1959
01:36:38,040 --> 01:36:39,270
to copy-paste that for loop.
复制粘贴那个 for 循环。

1960
01:36:39,270 --> 01:36:41,020
I now have a function called string_length
我现在有一个名为 string_length 的函数

1961
01:36:41,020 --> 01:36:43,695
that will solve this problem for me.
可以为我解决这个问题。

1962
01:36:43,695 --> 01:36:46,600
Whoops, wrong program. make length.
糟糕，程序错了。 make length。

1963
01:36:46,600 --> 01:36:47,100
Huh.
嗯。

1964
01:36:47,100 --> 01:36:51,590
Use of undeclared identifier 'name.'
使用未声明的标识符“name”。

1965
01:36:51,590 --> 01:36:53,090
What did I do wrong?
我做错什么了？

1966
01:36:53,090 --> 01:36:59,350
Apparently on line 16 of length.c, what did I do wrong here?
显然在 length.c 的第 16 行，我在这里做错了什么？

1967
01:36:59,350 --> 01:37:00,639
Yeah, in front.
是的，前面。

1968
01:37:00,639 --> 01:37:06,210
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1969
01:37:06,210 --> 01:37:06,960
DAVID MALAN: Good.
大卫·马兰：好。

1970
01:37:06,960 --> 01:37:09,190
AUDIENCE: [INAUDIBLE]
观众：[听不清]

1971
01:37:09,190 --> 01:37:09,940
DAVID MALAN: Good.
大卫·马兰：好。

1972
01:37:09,940 --> 01:37:10,840
Perfect terminology.
完美的术语。

1973
01:37:10,840 --> 01:37:12,850
So name is local to main.
所以 name 对于 main 来说是局部的。

1974
01:37:12,850 --> 01:37:16,930
The scope of name is main, though sounds similar, but different words.
name 的作用域是 main，尽管听起来很相似，但却是不同的词。

1975
01:37:16,930 --> 01:37:19,720
And so I'm actually should be calling this
所以实际上我应该把它叫做

1976
01:37:19,720 --> 01:37:24,970
s because s is the name of the local variable being passed in even though it
s，因为 s 是被传递进来的局部变量的名称，即使它

1977
01:37:24,970 --> 01:37:29,410
happens to be 1 and the same as name because on line 9,
碰巧与 name 相同，因为在第 9 行，

1978
01:37:29,410 --> 01:37:32,060
I'm indeed passing in name as the argument.
我确实将 name 作为参数传递进来。

1979
01:37:32,060 --> 01:37:32,560
All right.
好的。

1980
01:37:32,560 --> 01:37:35,450
So this is where, again, copy-paste can sometimes get you into trouble.
所以，这里再次说明了，复制粘贴有时会让你陷入困境。

1981
01:37:35,450 --> 01:37:36,760
Let's try to make length again.
让我们再试着 make length。

1982
01:37:36,760 --> 01:37:42,520
Now it works. ./length, D-A-V-I-D, and now we have a function that seems to be
现在它可以工作了。 ./length，D-A-V-I-D，现在我们有一个似乎可以工作的函数。

1983
01:37:42,520 --> 01:37:43,090
working.
工作。

1984
01:37:43,090 --> 01:37:45,490
But this is such like commodity functionality.
但这就像商品功能一样。

1985
01:37:45,490 --> 01:37:47,770
Like my God, like surely someone before us
我的天啊，肯定在我们之前

1986
01:37:47,770 --> 01:37:51,070
has written a function to get the length of a string before,
已经写过一个函数来获取字符串的长度，

1987
01:37:51,070 --> 01:37:53,080
and indeed, other people have.
事实上，其他人已经写过了。

1988
01:37:53,080 --> 01:37:56,560
So it turns out that in C, just as you have the stdio library,
事实证明，在 C 中，就像你拥有 stdio 库一样，

1989
01:37:56,560 --> 01:38:00,580
you also have a string library whose header file is called, appropriately,
你还有一个字符串库，它的头文件被称为，恰当地，

1990
01:38:00,580 --> 01:38:01,600
string.h.
string.h。

1991
01:38:01,600 --> 01:38:05,200
In fact CS50 has documentation, therefore, in its own manual pages,
事实上，CS50 在自己的手册页中拥有文档，

1992
01:38:05,200 --> 01:38:08,020
so to speak, along with some sample usage thereof.
可以说是，连同一些示例用法。

1993
01:38:08,020 --> 01:38:10,580
But it turns out, in the string library, there
但事实证明，在字符串库中，存在

1994
01:38:10,580 --> 01:38:13,850
is a very popular function analogous to the Python one
一个非常受欢迎的函数，类似于你之前询问的 Python 函数

1995
01:38:13,850 --> 01:38:16,370
that you asked about earlier called strlen
叫做 strlen。

1996
01:38:16,370 --> 01:38:19,250
where strlen, one word, no underscores, just
其中 strlen，一个单词，没有下划线，仅仅

1997
01:38:19,250 --> 01:38:20,875
figures out the length of a string.
计算出一个字符串的长度。

1998
01:38:20,875 --> 01:38:23,000
And honestly, I've never looked at its source code,
老实说，我从未看过它的源代码，

1999
01:38:23,000 --> 01:38:26,030
but it probably uses a while loop, maybe it uses a for loop,
但它可能使用 while 循环，也许它使用 for 循环，

2000
01:38:26,030 --> 01:38:30,320
but it certainly uses the same idea of just iterating-- that is,
但它肯定使用相同的迭代思想——也就是说，

2001
01:38:30,320 --> 01:38:33,380
walking from left to right over a variable
从左到右遍历一个变量

2002
01:38:33,380 --> 01:38:36,860
in order to figure out what the length of a given string is.
以便找出给定字符串的长度。

2003
01:38:36,860 --> 01:38:38,040
So how do we use this?
所以我们如何使用它？

2004
01:38:38,040 --> 01:38:42,410
Well if I go back to VS Code here, I can throw away
好吧，如果我回到 VS Code，我可以扔掉

2005
01:38:42,410 --> 01:38:44,810
the entirety of my string length function,
我的整个字符串长度函数，

2006
01:38:44,810 --> 01:38:47,870
I can throw away the prototype, therefore,
我也可以扔掉原型，因此，

2007
01:38:47,870 --> 01:38:52,640
and I can include a third header file, string.h, inside
我可以在里面包含第三个头文件 string.h，

2008
01:38:52,640 --> 01:38:55,460
of which I claim now is this function called strlen
我声称现在是这个名为 strlen 的函数

2009
01:38:55,460 --> 01:38:58,370
that I can just now use out of the box for free
我现在可以直接免费使用

2010
01:38:58,370 --> 01:39:00,560
because someone else wrote this function for me.
因为其他人为我写了这个函数。

2011
01:39:00,560 --> 01:39:03,870
And string.h will teach the compiler that it exists.
而 string.h 会告诉编译器它存在。

2012
01:39:03,870 --> 01:39:10,700
So if I now do make length and ./length, now I have a similarly working program
所以如果我现在执行 make length 以及 ./length，我现在就有了一个类似的工作程序

2013
01:39:10,700 --> 01:39:14,720
that doesn't bother having me write unnecessary code.
它不让我编写不必要的代码。

2014
01:39:14,720 --> 01:39:16,880
So this is another example of a library.
所以这是库的另一个例子。

2015
01:39:16,880 --> 01:39:22,060
The string library is just going to make our lives easier by not having to--
字符串库只是为了让我们的生活更轻松，而不必——

2016
01:39:22,060 --> 01:39:25,082
for us not having to reinvent some wheel.
为了让我们不必重新发明轮子。

2017
01:39:25,082 --> 01:39:27,290
All right, well where else does this get interesting?
好的，那么这个还有哪些有趣的地方呢？

2018
01:39:27,290 --> 01:39:29,730
How about something like this?
比如这样怎么样？

2019
01:39:29,730 --> 01:39:31,970
Let me go back into VS Code here.
让我回到 VS Code 中。

2020
01:39:31,970 --> 01:39:35,138
Let's create a program called string.c--
让我们创建一个名为 string.c 的程序——

2021
01:39:35,138 --> 01:39:38,180
we'll play around with our own strings-- that's going to start similarly.
我们将会使用我们自己的字符串——开始部分类似。

2022
01:39:38,180 --> 01:39:44,030
So let's include cs50.h, let's include stdio.h,
所以让我们包含 cs50.h，让我们包含 stdio.h，

2023
01:39:44,030 --> 01:39:48,230
let's include string.h so we can use that same strlen function.
让我们包含 string.h，这样我们就可以使用相同的 strlen 函数。

2024
01:39:48,230 --> 01:39:50,030
int main void.
int main void。

2025
01:39:50,030 --> 01:39:51,810
And inside of this, let's do this.
在里面，让我们做这个。

2026
01:39:51,810 --> 01:39:57,410
Let's get a string s and prompt the user for any old string as input.
让我们获取一个字符串 s，并提示用户输入任何字符串。

2027
01:39:57,410 --> 01:39:57,910
All right.
好的。

2028
01:39:57,910 --> 01:40:04,140
And then let's go ahead and maybe print out, quote-unquote, "Output."
然后让我们继续打印，带引号的，"Output"。

2029
01:40:04,140 --> 01:40:07,238
And I'm just going to line up my spaces just right because these words are
而且我只是一直把我的空格对齐，因为这些单词是

2030
01:40:07,238 --> 01:40:09,780
slightly different lengths, but we'll see why I'm doing this.
长度略有不同，但我们会看到我为什么这么做。

2031
01:40:09,780 --> 01:40:11,860
It's just for aesthetics' sake in a moment.
只是一会儿为了美观。

2032
01:40:11,860 --> 01:40:13,380
And let's go ahead now and do this.
现在让我们继续做这个。

2033
01:40:13,380 --> 01:40:17,348
If I want to print out every character in a string, how can I now do this?
如果我想打印出字符串中的每个字符，我现在该怎么做呢？

2034
01:40:17,348 --> 01:40:19,140
Well, this is actually a pretty common task
好吧，这实际上是一项很常见的任务

2035
01:40:19,140 --> 01:40:23,580
even though this version, thereof, will seem pointless. for int i gets 0,
尽管这个版本看起来毫无意义。 for int i gets 0，

2036
01:40:23,580 --> 01:40:26,460
i is less than the length of s.
i 小于 s 的长度。

2037
01:40:26,460 --> 01:40:31,800
i++ is just the conventional way to start a loop that iterates from left
i++ 只是从左开始迭代循环的常规方法

2038
01:40:31,800 --> 01:40:34,260
to right over a string of that length.
到该长度字符串的右侧。

2039
01:40:34,260 --> 01:40:38,190
And then let's go ahead and print out each character, %c,
然后让我们继续打印出每个字符，%c，

2040
01:40:38,190 --> 01:40:43,800
printing out the string at location i using our fancy new array syntax.
使用我们新奇的数组语法打印出位置 i 处的字符串。

2041
01:40:43,800 --> 01:40:45,780
And at the very end of this program, let's just
在这个程序的最后，让我们只是

2042
01:40:45,780 --> 01:40:48,870
print out a new line character just to move the cursor to the bottom
打印一个新的换行符，以将光标移到底部

2043
01:40:48,870 --> 01:40:50,200
like we've done in the past.
就像我们过去所做的那样。

2044
01:40:50,200 --> 01:40:54,030
So this is kind of a stupid program like I am reinventing the wheel that is
所以这有点像一个愚蠢的程序，就像我重新发明了轮子一样

2045
01:40:54,030 --> 01:40:56,130
the %s format code.
%s 格式代码。

2046
01:40:56,130 --> 01:40:58,600
I already know that printf can print out a whole string.
我已经知道 printf 可以打印出一个完整的字符串。

2047
01:40:58,600 --> 01:40:59,650
Suppose it didn't.
假设它没有。

2048
01:40:59,650 --> 01:41:03,100
Suppose I forgot about %s and I only knew about %c,
假设我忘记了 %s，我只知道 %c，

2049
01:41:03,100 --> 01:41:09,100
these lines of code here collectively will print out the entirety of a string
这里这些代码行将共同打印出字符串的全部内容

2050
01:41:09,100 --> 01:41:12,050
character by character based on its length.
逐个字符地基于它的长度。

2051
01:41:12,050 --> 01:41:17,770
So if I compile this program, make string ./string and type in my name--
所以如果我编译这个程序，使字符串 ./string 并输入我的名字 -

2052
01:41:17,770 --> 01:41:20,870
for instance, David, the output is D-A-V-I-D,
例如，大卫，输出是 D-A-V-I-D，

2053
01:41:20,870 --> 01:41:22,870
and here's why I hit the spacebar an extra time,
这就是我多按一次空格键的原因，

2054
01:41:22,870 --> 01:41:26,230
because I wanted input and output to line up nicely so we could see that
因为我希望输入和输出整齐地排列，这样我们就可以看到

2055
01:41:26,230 --> 01:41:27,680
they're, in fact, the same length.
它们实际上是相同的长度。

2056
01:41:27,680 --> 01:41:28,930
So let me just stipulate.
所以让我声明一下。

2057
01:41:28,930 --> 01:41:35,390
This code is correct, but there is an inefficiency with this line of code.
这段代码是正确的，但是这行代码存在效率低下。

2058
01:41:35,390 --> 01:41:38,020
Let's talk about design instinctively.
让我们本能地谈谈设计。

2059
01:41:38,020 --> 01:41:42,550
What is maybe bad about this line of code 9--
这行代码 9 有什么不好的地方 -

2060
01:41:42,550 --> 01:41:44,650
line 9 that I've highlighted?
我高亮显示的第 9 行？

2061
01:41:44,650 --> 01:41:47,020
This one is subtle.
这个很微妙。

2062
01:41:47,020 --> 01:41:47,950
Let's go over here.
让我们看看这里。

2063
01:41:47,950 --> 01:41:51,900
AUDIENCE: [INAUDIBLE]
观众：[听不清]

2064
01:41:51,900 --> 01:41:54,120
DAVID MALAN: Yeah.
大卫·马兰：是的。

2065
01:41:54,120 --> 01:41:58,930
I'm calling strlen inside of the loop again and again and again.
我在循环内部一遍又一遍地调用 strlen。

2066
01:41:58,930 --> 01:41:59,430
Why?
为什么？

2067
01:41:59,430 --> 01:42:00,847
Well, recall how for loops worked.
好吧，回忆一下 for 循环是如何工作的。

2068
01:42:00,847 --> 01:42:03,870
When we walked through it last week, that middle part of for loop
当我们上周遍历它时，for 循环的中间部分

2069
01:42:03,870 --> 01:42:07,230
in between the semicolons keeps getting checked, keeps getting checked,
在分号之间一直被检查，一直被检查，

2070
01:42:07,230 --> 01:42:08,320
keeps getting checked.
一直被检查。

2071
01:42:08,320 --> 01:42:12,030
And so if you put a function call there, which is totally fine syntactically,
所以如果你在那里放一个函数调用，在语法上是完全可以的，

2072
01:42:12,030 --> 01:42:14,970
you're asking the same damn question again and again and again.
你一遍又一遍地问同一个问题。

2073
01:42:14,970 --> 01:42:17,790
And the length of David, D-A-V-I-D, is never changing.
而大卫的长度，D-A-V-I-D，是永远不变的。

2074
01:42:17,790 --> 01:42:21,330
So strlen, implemented decades ago by some other human,
所以 strlen，几十年前由其他人实现，

2075
01:42:21,330 --> 01:42:23,700
has some kind of loop in it, and you're literally
它里面有一些循环，而你实际上

2076
01:42:23,700 --> 01:42:26,580
making that code run again and again and again just
一遍又一遍地运行那段代码，仅仅

2077
01:42:26,580 --> 01:42:29,123
to get the same answer 5 again and again.
为了再次得到相同的答案 5。

2078
01:42:29,123 --> 01:42:30,540
So I think your instinct is right.
所以我觉得你的直觉是对的。

2079
01:42:30,540 --> 01:42:33,928
I could come up with another variable outside of the loop.
我可以想出一个循环之外的另一个变量。

2080
01:42:33,928 --> 01:42:35,220
I could do something like this.
我可以做这样的事情。

2081
01:42:35,220 --> 01:42:40,830
int length equals strlen of s, and then I could just plug that in.
int length 等于 s 的 strlen，然后我就可以直接把它插进去。

2082
01:42:40,830 --> 01:42:42,658
But there's a slightly more elegant way.
但是有一个更优雅的方式。

2083
01:42:42,658 --> 01:42:44,700
If you like doing things with slightly less code,
如果你喜欢用更少的代码来做事情，

2084
01:42:44,700 --> 01:42:46,440
this is correct as I've now written it.
现在我写的这个是正确的。

2085
01:42:46,440 --> 01:42:50,400
It's less efficient-- it's more efficient because I'm only
它效率更低 - 它效率更高，因为我只

2086
01:42:50,400 --> 01:42:53,440
calling strlen once now on this new line 9,
现在在这条新的 9 行代码上调用一次 strlen，

2087
01:42:53,440 --> 01:42:56,560
but a more common way to write this would typically
但是更常见的写法通常

2088
01:42:56,560 --> 01:42:58,360
be to do something like this.
是这样的。

2089
01:42:58,360 --> 01:43:02,860
After initializing i, you can also initialize something else like length.
在初始化 i 之后，你也可以初始化其他东西，比如 length。

2090
01:43:02,860 --> 01:43:07,580
And you can set length equal to strlen of s, then your semicolon,
你可以将 length 设置为 s 的 strlen，然后你的分号，

2091
01:43:07,580 --> 01:43:10,755
and now you can say while i is less than that length.
现在你可以说当 i 小于那个长度时。

2092
01:43:10,755 --> 01:43:12,130
Or I can tighten this up further.
或者我可以进一步压缩它。

2093
01:43:12,130 --> 01:43:15,580
If it's just a number and it's a super short loop, might as well just call it
如果它只是一个数字，并且是一个超短循环，不妨直接把它叫做

2094
01:43:15,580 --> 01:43:16,120
n.
n。

2095
01:43:16,120 --> 01:43:20,920
So this now would be a canonical way of implementing the exact same idea,
所以这现在将是实现完全相同想法的规范方法，

2096
01:43:20,920 --> 01:43:23,770
but without the inefficiency because now you're
但没有效率低下，因为现在你正在

2097
01:43:23,770 --> 01:43:28,150
calling strlen in the initialization part of for loop,
在 for 循环的初始化部分调用 strlen，

2098
01:43:28,150 --> 01:43:32,650
not inside of the Boolean expression that gets checked and executed
而不是在被检查和执行的布尔表达式中

2099
01:43:32,650 --> 01:43:34,000
again and again.
一次又一次地执行。

2100
01:43:34,000 --> 01:43:34,510
Yeah?
是吧？

2101
01:43:34,510 --> 01:43:38,965
AUDIENCE: [INAUDIBLE]
观众：[听不见]

2102
01:43:38,965 --> 01:43:39,840
DAVID MALAN: Correct.
大卫·马兰：没错。

2103
01:43:39,840 --> 01:43:43,200
Well, I'm declaring i as an int, but by way of the comma,
好吧，我将 i 声明为一个 int，但通过逗号，

2104
01:43:43,200 --> 01:43:45,570
I am also declaring n as an int.
我也将 n 声明为一个 int。

2105
01:43:45,570 --> 01:43:49,110
So they've got to be the same type for this trick to work.
所以它们必须是相同类型，这个技巧才能起作用。

2106
01:43:49,110 --> 01:43:50,370
Good observation.
观察得很好。

2107
01:43:50,370 --> 01:43:54,470
Other questions on this one here?
还有其他问题吗？

2108
01:43:54,470 --> 01:43:54,970
No?
没有？

2109
01:43:54,970 --> 01:43:55,540
All right.
好的。

2110
01:43:55,540 --> 01:43:58,900
Well, let's play around further here.
好吧，让我们在这里再玩一玩。

2111
01:43:58,900 --> 01:44:01,862
Let me propose that there's other libraries and header files
让我提议一下，还有其他库和头文件

2112
01:44:01,862 --> 01:44:03,320
as well that you might find useful.
也可能对你很有用。

2113
01:44:03,320 --> 01:44:05,800
There's also something called ctype, which relates to types
还有一个叫做 ctype 的东西，它与类型有关

2114
01:44:05,800 --> 01:44:08,500
and c's that's got a bunch of useful functions
和 C 语言，它包含许多有用的函数

2115
01:44:08,500 --> 01:44:12,200
that we can actually see if we visit the documentation here.
我们可以在这里访问文档，就能看到。

2116
01:44:12,200 --> 01:44:14,200
But before we get there, let me actually whip up
但在此之前，让我实际写一个

2117
01:44:14,200 --> 01:44:17,680
a program that maybe does something a little bit fun, albeit low level,
程序，它可能做一些有趣的事情，尽管比较低级，

2118
01:44:17,680 --> 01:44:21,590
like forcing some string to uppercase if the human types it in lowercase.
比如强制某个字符串大写，如果人类输入的是小写。

2119
01:44:21,590 --> 01:44:25,120
So let me go ahead and write a program called uppercase.c.
所以，让我继续编写一个名为 uppercase.c 的程序。

2120
01:44:25,120 --> 01:44:27,940
Let me go ahead and give myself the same header files.
让我继续给自己相同的头文件。

2121
01:44:27,940 --> 01:44:31,840
Include cs50.h, include stdio.h.
包含 cs50.h，包含 stdio.h。

2122
01:44:31,840 --> 01:44:34,960
And for now, let's include string.h for the length.
现在，让我们包含 string.h 以获得长度。

2123
01:44:34,960 --> 01:44:38,570
And let's go ahead and have int main void as before.
然后让我们像以前一样，将 int main void 添加进来。

2124
01:44:38,570 --> 01:44:40,840
And inside of main, let's give myself a string
在 main 内部，让我们给自己一个字符串

2125
01:44:40,840 --> 01:44:46,780
s equaling get_string "Before," just so I know what the string is initially.
s 等于 get_string "Before"，这样我就知道字符串最初是什么。

2126
01:44:46,780 --> 01:44:50,560
Now I'm going to print out proactively "After" with two spaces
现在，我将主动打印 "After"，并带有两个空格

2127
01:44:50,560 --> 01:44:53,740
just so that things line up aesthetically on the screen
这样，屏幕上看起来就会美观一些

2128
01:44:53,740 --> 01:44:55,580
because "After" is one character shorter.
因为 "After" 少了一个字符。

2129
01:44:55,580 --> 01:44:57,920
And now I'm going to do the same technique as before.
现在，我将使用与之前相同的技术。

2130
01:44:57,920 --> 01:45:07,340
for int i equals 0, n equals the string length of s, i is less than n, i++.
对于 int i 等于 0，n 等于 s 的字符串长度，i 小于 n，i++。

2131
01:45:07,340 --> 01:45:10,940
And then inside of this loop, what do I want to do logically?
然后在这个循环内部，我从逻辑上想做什么？

2132
01:45:10,940 --> 01:45:15,710
I want to force these characters to uppercase if they are, in fact,
如果这些字符实际上是小写，我想将它们强制大写。

2133
01:45:15,710 --> 01:45:16,670
lowercase.
小写。

2134
01:45:16,670 --> 01:45:18,083
And so how might I do this?
那么我该怎么做呢？

2135
01:45:18,083 --> 01:45:20,000
Well, there's a bunch of ways to express this,
好吧，有很多方法可以表达这一点，

2136
01:45:20,000 --> 01:45:22,640
but I'm going to do it maybe the most straightforward way
但我会以最直接的方式来做

2137
01:45:22,640 --> 01:45:24,260
even if you've not seen this before.
即使你以前没见过。

2138
01:45:24,260 --> 01:45:28,760
If the current letter in the string at location i,
如果字符串中位置 i 处的当前字母，

2139
01:45:28,760 --> 01:45:31,970
because I'm in a loop starting from 0 all the way up to, but not
因为我是在一个从 0 开始一直到，但没有的循环中，

2140
01:45:31,970 --> 01:45:34,400
through the string length, is greater than
在字符串长度内，大于

2141
01:45:34,400 --> 01:45:42,110
or equal to a lowercase a, in single quotes, and that letter is less than
或等于单引号内的一个小写字母a，并且该字母小于

2142
01:45:42,110 --> 01:45:43,970
or equal to a lowercase z.
或等于一个小写字母z。

2143
01:45:43,970 --> 01:45:45,440
What does this mean in English?
用英语怎么说呢？

2144
01:45:45,440 --> 01:45:48,740
Well, this essentially means if lowercase--
本质上，如果小写——

2145
01:45:48,740 --> 01:45:52,280
logically, if it's greater than or equal to little a and less than
从逻辑上讲，如果它大于或等于一个小写字母a，并且小于

2146
01:45:52,280 --> 01:45:55,760
or equal to little z, it's somewhere between a and z in lowercase.
或等于一个小写字母z，那么它就在a和z之间。

2147
01:45:55,760 --> 01:45:57,060
What do I want to do?
我想做什么？

2148
01:45:57,060 --> 01:45:58,670
Well, I want to force it to uppercase.
我想把它强制转换成大写。

2149
01:45:58,670 --> 01:46:03,260
So I want to print out a character without a new line yet
所以我想打印一个字符，但还没有换行

2150
01:46:03,260 --> 01:46:07,880
that prints out the current character, but force it to uppercase.
它会打印出当前的字符，但将其强制转换成大写。

2151
01:46:07,880 --> 01:46:09,120
Well, how can I do this?
怎么做呢？

2152
01:46:09,120 --> 01:46:12,560
Well, this is where this gets into some low-level hacking,
这就是我们要进入一些低级黑客的领域，

2153
01:46:12,560 --> 01:46:14,480
but notice the same ASCII chart.
但请注意相同的ASCII表。

2154
01:46:14,480 --> 01:46:17,640
Here's our uppercase letters from last time.
这是我们上次的大写字母。

2155
01:46:17,640 --> 01:46:20,900
Here's our lowercase characters, and let me highlight those.
这是我们的所有小写字母，我将它们高亮显示。

2156
01:46:20,900 --> 01:46:25,370
Does anyone notice a relationship between capital A and lowercase a
有没有人注意到大写字母A和小写字母a之间的关系

2157
01:46:25,370 --> 01:46:29,540
that happens to be the same for capital B and lowercase b?
对于大写字母B和小写字母b来说，这种情况也一样？

2158
01:46:29,540 --> 01:46:33,000
AUDIENCE: Capital A [INAUDIBLE].
观众：大写字母A[听不清]。

2159
01:46:33,000 --> 01:46:33,750
DAVID MALAN: Yeah.
大卫·马兰：是的。

2160
01:46:33,750 --> 01:46:35,170
Like this pattern is true.
这种模式是正确的。

2161
01:46:35,170 --> 01:46:40,140
So 97 minus 65 is 32, and that's true for every lowercase and uppercase
所以97减去65等于32，这对所有的小写字母和大写字母来说都是正确的

2162
01:46:40,140 --> 01:46:41,170
letter respectively.
字母来说都是一样的。

2163
01:46:41,170 --> 01:46:42,420
So I can leverage that.
所以我可以利用这一点。

2164
01:46:42,420 --> 01:46:43,950
And this is not a CS50 thing.
这不是CS50专属的。

2165
01:46:43,950 --> 01:46:44,850
Like this is ASCII.
这是ASCII码。

2166
01:46:44,850 --> 01:46:45,990
This is, in turn, Unicode.
这也反过来，是Unicode。

2167
01:46:45,990 --> 01:46:47,533
This is how modern computers work.
这就是现代计算机的工作方式。

2168
01:46:47,533 --> 01:46:49,950
So if I go back to VS Code here, you know what I could do.
所以如果我回到VS Code，你应该知道我能做什么。

2169
01:46:49,950 --> 01:46:52,350
Let's just literally subtract 32.
让我们直接减去32。

2170
01:46:52,350 --> 01:46:55,440
But because I'm displaying this as a char, not as an int,
但因为我将它显示为char，而不是int，

2171
01:46:55,440 --> 01:47:01,080
I'm going to see the lowercase letter seemingly become an uppercase instead.
我将看到小写字母似乎变成了大写字母。

2172
01:47:01,080 --> 01:47:05,310
Else, if it's not lowercase-- maybe it's already uppercase,
否则，如果它不是小写字母——也许它已经是大写字母，

2173
01:47:05,310 --> 01:47:09,420
maybe it is punctuation, let's just go ahead and print out with %c
也许它是标点符号，让我们直接用%c打印出来

2174
01:47:09,420 --> 01:47:11,462
the original character unaltered.
原来的字符保持不变。

2175
01:47:11,462 --> 01:47:13,170
And then at the very end of this program,
然后在这个程序的最后，

2176
01:47:13,170 --> 01:47:17,670
let's print a new line just to move the cursor to the next line.
我们打印一个换行符，让光标移动到下一行。

2177
01:47:17,670 --> 01:47:19,950
All right, so let's do make uppercase.
好了，让我们来执行make uppercase。

2178
01:47:19,950 --> 01:47:22,500
And let me type ./uppercase.
我输入./uppercase。

2179
01:47:22,500 --> 01:47:26,100
And I'll type in D-A-V-I-D, all lowercase, and now,
我输入D-A-V-I-D，全都是小写字母，现在，

2180
01:47:26,100 --> 01:47:27,750
you'll see it's in all caps.
你会看到它变成了全大写。

2181
01:47:27,750 --> 01:47:31,920
If, though, I type in maybe my last name but capitalized M, that's OK,
但是，如果我输入我的姓，但M是大写的，没关系，

2182
01:47:31,920 --> 01:47:34,930
the rest of it will still be capitalized for me.
其余的字母仍然会自动变成大写。

2183
01:47:34,930 --> 01:47:36,710
Now I don't love this technique.
我对这种方法不太满意。

2184
01:47:36,710 --> 01:47:40,090
It's a little bit fragile because I had to do some math.
它有点脆弱，因为我需要做一些数学运算。

2185
01:47:40,090 --> 01:47:43,220
I had to check my reference sheet and then incorporate it into my program.
我不得不查看参考表，然后将其纳入到程序中。

2186
01:47:43,220 --> 01:47:45,940
Even though it will be correct, I could be a little more clever.
虽然它是正确的，但我可以更聪明一点。

2187
01:47:45,940 --> 01:47:47,607
I could actually do something like this.
我可以这样做。

2188
01:47:47,607 --> 01:47:49,720
Well, whatever the value of lowercase is--
无论小写的值是多少——

2189
01:47:49,720 --> 01:47:53,650
lowercase a is minus whatever the value of capital A is,
小写字母 a 是大写字母 A 的值减去某个值，

2190
01:47:53,650 --> 01:47:56,378
and I could actually do it arithmetically even though that, too,
我实际上可以进行算术运算来实现，尽管这种方式也

2191
01:47:56,378 --> 01:47:59,170
is somewhat inefficient in that it's asking the same question again
在一定程度上效率低下，因为它重复询问同一个问题

2192
01:47:59,170 --> 01:48:02,320
and again, but the compiler is probably smart enough to optimize that.
又一次，但编译器可能足够智能，可以优化它。

2193
01:48:02,320 --> 01:48:05,830
And frankly, for those more comfortable, a good compiler
坦率地说，对于那些更舒适的人来说，一个好的编译器

2194
01:48:05,830 --> 01:48:07,930
will also notice, no, no, no, no, you don't
也会注意到，不，不，不，不，你不会

2195
01:48:07,930 --> 01:48:09,910
want to call strlen again and again.
想一遍又一遍地调用 strlen。

2196
01:48:09,910 --> 01:48:13,330
The compiler can do some of these optimizations for you,
编译器可以为你做一些这些优化，

2197
01:48:13,330 --> 01:48:15,610
but it's still good practice to get into yourself.
但养成自己这样做的习惯仍然是好的。

2198
01:48:15,610 --> 01:48:17,080
But there's probably a better way.
但可能有一种更好的方法。

2199
01:48:17,080 --> 01:48:19,630
Instead of rolling this solution ourselves
而不是自己编写这个解决方案

2200
01:48:19,630 --> 01:48:22,810
and subtracting 32 or doing any arithmetic,
并减去 32 或进行任何算术运算，

2201
01:48:22,810 --> 01:48:24,730
let's use that ctype library.
让我们使用那个 ctype 库。

2202
01:48:24,730 --> 01:48:27,280
Let me go back up to my header files.
让我回到我的头文件。

2203
01:48:27,280 --> 01:48:29,890
Let's additionally include ctype.h.
让我们另外包含 ctype.h。

2204
01:48:29,890 --> 01:48:33,100
Let's pretend like I read the documentation in advance, which I did,
让我们假装我提前阅读了文档，事实上，我确实阅读了，

2205
01:48:33,100 --> 01:48:33,940
in fact.
确实。

2206
01:48:33,940 --> 01:48:37,570
And let's instead of doing any math here,
让我们不要在这里进行任何数学运算，

2207
01:48:37,570 --> 01:48:41,590
let's use a function that exists in that library called toupper
让我们使用该库中存在的名为 toupper 的函数

2208
01:48:41,590 --> 01:48:47,740
and pass to it whatever the current character is in s at location i.
并传递给它 s 中位置 i 的当前字符。

2209
01:48:47,740 --> 01:48:50,860
Otherwise, I still print out the unchanged character.
否则，我仍然打印出未更改的字符。

2210
01:48:50,860 --> 01:48:54,880
And let me go ahead and do make uppercase ./uppercase.
让我继续执行 make uppercase ./uppercase。

2211
01:48:54,880 --> 01:49:00,190
And now without any math, no subtracting 32, that, too, also works.
现在，没有任何数学运算，没有减去 32，它也工作了。

2212
01:49:00,190 --> 01:49:01,240
But it gets better.
但它变得更好了。

2213
01:49:01,240 --> 01:49:03,430
If you read the documentation for toupper,
如果你阅读 toupper 的文档，

2214
01:49:03,430 --> 01:49:07,570
it turns out its documentation tells you, if C is already uppercase,
事实证明，它的文档告诉您，如果 C 已经是大写，

2215
01:49:07,570 --> 01:49:09,950
it just passes it through for you.
它只是为你直接传递它。

2216
01:49:09,950 --> 01:49:12,550
So you don't even need to ask this conditional question.
所以你甚至不需要问这个条件问题。

2217
01:49:12,550 --> 01:49:17,710
I can actually cut this to my clipboard, get rid of all of this,
我实际上可以剪切它到我的剪贴板，删除所有这些，

2218
01:49:17,710 --> 01:49:21,430
and just replace that one line only and just
只替换那一行，然后

2219
01:49:21,430 --> 01:49:25,600
let toupper handle the situation for me because again, its documentation
让 toupper 为我处理这种情况，因为再次，它的文档

2220
01:49:25,600 --> 01:49:28,120
has assured me that if it's already uppercase,
向我保证，如果它已经是大写，

2221
01:49:28,120 --> 01:49:30,890
it's just going to return the original value.
它只会返回原始值。

2222
01:49:30,890 --> 01:49:33,670
So if I make uppercase, this time, ./uppercase,
所以如果我执行 make uppercase，这次是 ./uppercase，

2223
01:49:33,670 --> 01:49:36,640
now it works and now things are getting kind of fun.
现在它工作了，现在事情变得有点有趣了。

2224
01:49:36,640 --> 01:49:38,740
I mean, these are mundane tasks, admittedly,
我的意思是，这些都是平凡的任务，不可否认，

2225
01:49:38,740 --> 01:49:41,410
but at least I'm standing on the shoulders of smart people
但至少我站在了之前那些聪明人的肩膀上

2226
01:49:41,410 --> 01:49:45,040
who came before me who implemented the string library, the ctype library--
他们在我之前实现字符串库、ctype 库——

2227
01:49:45,040 --> 01:49:51,760
heck, even the CS50 Library so I don't need to reinvent any of those wheels.
哎呀，甚至 CS50 库，所以我不需要重新发明这些轮子。

2228
01:49:51,760 --> 01:49:57,750
Questions on any of these library techniques?
关于这些库技术的任何问题？

2229
01:49:57,750 --> 01:50:00,240
It's all still arrays, it's all still strings and chars,
它们仍然都是数组，它们仍然都是字符串和字符，

2230
01:50:00,240 --> 01:50:05,110
but now we're leveraging libraries to solve some of our problems for us.
但现在我们正在利用库来为我们解决一些问题。

2231
01:50:05,110 --> 01:50:05,610
All right.
好的。

2232
01:50:05,610 --> 01:50:07,890
So let's come full circle to where we began,
所以让我们回到起点，

2233
01:50:07,890 --> 01:50:10,950
where and I mentioned that some programs include
我在那里提到一些程序包括

2234
01:50:10,950 --> 01:50:12,630
support for command line arguments.
对命令行参数的支持。

2235
01:50:12,630 --> 01:50:18,210
Like Clang takes command line arguments words after the word clang.
比如 Clang 会接受命令行参数，这些参数是 clang 之后的所有词。

2236
01:50:18,210 --> 01:50:21,270
CD, which you've used in Linux, takes command line arguments.
CD 命令，你在 Linux 中用过，它接受命令行参数。

2237
01:50:21,270 --> 01:50:24,510
If you type cd, space, pset1 or cd, space,
如果你输入 cd，空格，pset1 或者 cd，空格，

2238
01:50:24,510 --> 01:50:28,200
mario in order to change directories into another folder.
mario 来改变目录到另一个文件夹。

2239
01:50:28,200 --> 01:50:31,140
If you do rm like I did earlier, you can remove a file
如果你像我之前一样使用 rm，你可以删除文件

2240
01:50:31,140 --> 01:50:33,510
by using a command line argument, a second word that
通过使用命令行参数，也就是第二个词，它

2241
01:50:33,510 --> 01:50:35,730
tells the computer what to remove.
告诉计算机要删除什么。

2242
01:50:35,730 --> 01:50:38,520
Well, it turns out that you, too, can write
实际上，你也可以编写

2243
01:50:38,520 --> 01:50:43,230
code that takes words at the command prompt and uses them as input.
接受命令提示符中的词语并将其作为输入的代码。

2244
01:50:43,230 --> 01:50:47,040
Up until now, you and I have only gotten user input via get_string, get_int,
到目前为止，我们只通过 get_string、get_int、

2245
01:50:47,040 --> 01:50:48,810
get_float, and functions like that.
get_float 和类似的函数获取用户输入。

2246
01:50:48,810 --> 01:50:52,230
You, too, can write code that take command line arguments which,
你也可以编写接受命令行参数的代码，这些参数实际上，

2247
01:50:52,230 --> 01:50:54,240
frankly, just save the human time.
节省了人类的时间。

2248
01:50:54,240 --> 01:50:57,790
They can type their entire thought at the command line, hit Enter, and boom,
他们在命令行输入完整的想法，按下回车，然后，

2249
01:50:57,790 --> 01:51:01,240
the program can complete without prompting them and re-prompting them
程序可以在没有提示他们的情况下完成，并且不会再次提示他们

2250
01:51:01,240 --> 01:51:02,020
again.
。

2251
01:51:02,020 --> 01:51:05,680
So here's where we can now start to take off some more training wheels.
所以现在我们可以开始去掉一些辅助轮了。

2252
01:51:05,680 --> 01:51:10,000
Up until now, we've just put void inside of the parentheses here any time
到目前为止，我们每次在实现 main 时，都只是在括号里写 void

2253
01:51:10,000 --> 01:51:11,620
we implement main.
。

2254
01:51:11,620 --> 01:51:15,130
It turns out that you can put something else in parentheses
事实证明，在使用 C 语言时，你可以在括号中写其他内容

2255
01:51:15,130 --> 01:51:18,820
when using C. It's a mouthful, but you can replace void
。这个表达有点长，但是你可以用它来替换 void

2256
01:51:18,820 --> 01:51:23,800
with this bigger expression.
。

2257
01:51:23,800 --> 01:51:25,240
But it's two things.
但这包含两部分。

2258
01:51:25,240 --> 01:51:28,960
int, called argc by convention, and a string,
int，按照惯例称为 argc，以及一个字符串，

2259
01:51:28,960 --> 01:51:32,920
but not a string, actually an array of strings called argv.
但实际上不是字符串，而是一个称为 argv 的字符串数组。

2260
01:51:32,920 --> 01:51:35,320
And these terms are a little arcane, but argc means
这些术语有点晦涩，但 argc 代表

2261
01:51:35,320 --> 01:51:38,770
argument count-- how many words did the human type at the prompt?
参数数量——用户在提示符中输入了多少个词？

2262
01:51:38,770 --> 01:51:41,410
Argv stands for argument vector, which is generally
Argv 代表参数向量，它通常

2263
01:51:41,410 --> 01:51:42,762
another term for an array--
是数组的另一个术语——

2264
01:51:42,762 --> 01:51:44,470
you've heard it perhaps from mathematics.
你可能在数学中听说过。

2265
01:51:44,470 --> 01:51:48,440
It's like a list of values, or in this case, a list of command line arguments.
它就像一个值列表，或者在本例中，是一个命令行参数列表。

2266
01:51:48,440 --> 01:51:49,790
So C is special.
所以 C 语言很特殊。

2267
01:51:49,790 --> 01:51:54,370
If you declare main as not taking void inside of parentheses, but rather,
如果你声明 main 在括号中不接受 void，而是

2268
01:51:54,370 --> 01:51:58,270
an int and an array of strings, C will figure out
一个 int 和一个字符串数组，C 语言会弄清楚

2269
01:51:58,270 --> 01:52:00,880
whatever the human typed at the prompt and hand it to you
用户在提示符中输入的内容，并将它传递给你

2270
01:52:00,880 --> 01:52:03,620
as an array and the length thereof.
作为数组以及它的长度。

2271
01:52:03,620 --> 01:52:05,830
So if I want to leverage this, I can start
所以如果我想利用这一点，我可以开始

2272
01:52:05,830 --> 01:52:10,940
to implement some programs of my own that actually incorporate command line
实现一些我自己的程序，这些程序实际上包含命令行

2273
01:52:10,940 --> 01:52:11,440
arguments.
参数。

2274
01:52:11,440 --> 01:52:14,980
For instance, let me go back in a moment here to VS Code.
例如，让我回到 VS Code 这里。

2275
01:52:14,980 --> 01:52:19,090
Let me create a program, for instance, called greet.c
让我创建一个程序，例如，名为 greet.c

2276
01:52:19,090 --> 01:52:21,590
that's just going to greet the user in a few different ways.
它将以几种不同的方式向用户问候。

2277
01:52:21,590 --> 01:52:24,580
So let me first do it the old way. cs50.h.
所以我先用旧方法来做。cs50.h。

2278
01:52:24,580 --> 01:52:27,430
Let me include stdio.h.
让我包含 stdio.h。

2279
01:52:27,430 --> 01:52:29,740
Let me do int main void still.
让我仍然使用 int main void。

2280
01:52:29,740 --> 01:52:30,950
So the old way.
所以这是旧方法。

2281
01:52:30,950 --> 01:52:34,420
And if I want to greet myself or Carter or Yulie or anyone else,
如果我想向我自己、Carter、Yulie 或其他任何人问候，

2282
01:52:34,420 --> 01:52:39,850
I could do, old fashioned now, get the answer from the user, get_string.
我可以像现在这样，用老方法从用户那里获得答案，使用 get_string。

2283
01:52:39,850 --> 01:52:42,670
Let's prompt for "What's your name?" question mark,
让我们提示“你的名字是什么？”问号，

2284
01:52:42,670 --> 01:52:44,200
just like we did in Scratch.
就像我们在Scratch中所做的那样。

2285
01:52:44,200 --> 01:52:49,940
And then do printf, "Hello," comma, %s backslash n, answer.
然后执行printf，“你好，”逗号，％s反斜杠n，答案。

2286
01:52:49,940 --> 01:52:53,320
So we've done this many times now this week and last.
所以我们这周和上周已经做了很多次了。

2287
01:52:53,320 --> 01:52:56,290
This is the old school way now of getting command line--
现在这是从命令行获取用户输入的传统方式——

2288
01:52:56,290 --> 01:52:59,360
of getting user input by prompting them for it.
通过提示用户来获取用户输入。

2289
01:52:59,360 --> 01:53:04,570
So if I do make greet /greet, there's no command line arguments at the prompt,
所以如果我执行make greet /greet，提示符处没有命令行参数，

2290
01:53:04,570 --> 01:53:06,610
I'm literally just running the program's name.
我只是在运行程序的名字。

2291
01:53:06,610 --> 01:53:10,690
If I hit Enter, though, now get_string kicks in, asks me for my name,
但是，如果我按回车键，get_string就会启动，询问我的名字，

2292
01:53:10,690 --> 01:53:12,370
and the program then greets me.
然后程序向我问好。

2293
01:53:12,370 --> 01:53:13,510
But I can do--
但我可以——

2294
01:53:13,510 --> 01:53:17,530
otherwise, I could do something like this instead.
否则，我可以尝试执行类似的操作。

2295
01:53:17,530 --> 01:53:20,290
First, answer's a little generic, so let's first change
首先，答案有点泛泛，所以让我们先更改

2296
01:53:20,290 --> 01:53:23,980
this back to name and back to name, but that's a minor improvement there
将其改回name并改回name，但这只是那里的小幅改进

2297
01:53:23,980 --> 01:53:25,480
just stylistically.
仅从样式上来说。

2298
01:53:25,480 --> 01:53:28,760
Let's, though, introduce now a command line argument
但是，让我们现在引入一个命令行参数

2299
01:53:28,760 --> 01:53:31,750
so that I can just greet myself by running the program, hitting Enter,
这样我就可以通过运行程序、按下回车键来向自己问好，

2300
01:53:31,750 --> 01:53:33,820
and being done, no more get_string.
并且完成操作，不再需要get_string。

2301
01:53:33,820 --> 01:53:39,520
So I'm going to go ahead and change void to int argc, string
所以我会继续将void更改为int argc，string

2302
01:53:39,520 --> 01:53:42,070
argv with square brackets.
带方括号的argv。

2303
01:53:42,070 --> 01:53:45,520
string means-- the square brackets means it's an array;
string表示——方括号表示它是一个数组；

2304
01:53:45,520 --> 01:53:49,010
string means it's an array of strings; and argc, again,
string表示它是一个字符串数组；并且argc再次，

2305
01:53:49,010 --> 01:53:51,898
is just an integer of the number of words typed.
只是一个输入单词数量的整数。

2306
01:53:51,898 --> 01:53:54,190
Now I'm going to somewhat dangerously going to do this.
我现在要进行一些危险的操作。

2307
01:53:54,190 --> 01:53:56,770
I'm going to get rid of my use of get_string altogether,
我将完全删除get_string的用法，

2308
01:53:56,770 --> 01:54:01,060
and I'm going to change this line to be not name, which no longer exists,
并且我将把这行代码更改为不再存在的name，

2309
01:54:01,060 --> 01:54:03,820
but I'm going to go into this array called argv
但是我会进入这个叫做argv的数组

2310
01:54:03,820 --> 01:54:08,050
and I'm going to go into location 1.
并且我会进入位置1。

2311
01:54:08,050 --> 01:54:10,180
So I'm doing this on faith.
所以我相信这一点。

2312
01:54:10,180 --> 01:54:15,070
I haven't explained what I'm doing yet, but I'm going to do make greet ./greet,
我还没有解释我要做什么，但我将执行make greet ./greet，

2313
01:54:15,070 --> 01:54:19,310
and now I'm going to type my name at the command line just like with rm,
现在我要在命令行中输入我的名字，就像使用rm一样，

2314
01:54:19,310 --> 01:54:20,740
with clang, with cd.
使用clang，使用cd。

2315
01:54:20,740 --> 01:54:23,440
With any of the commands you've written with multiple words,
对于你用多个单词编写的任何命令，

2316
01:54:23,440 --> 01:54:25,090
I'm going to greet literally David.
我会向David问好。

2317
01:54:25,090 --> 01:54:29,110
So I hit Enter, and voila, I've somehow gotten access
所以，我按回车键，瞧，我不知何故获得了访问

2318
01:54:29,110 --> 01:54:34,930
to what I typed at the prompt by accessing this special parameter called
通过访问这个名为

2319
01:54:34,930 --> 01:54:35,590
argv.
argv的特殊参数。

2320
01:54:35,590 --> 01:54:38,507
Technically you could call it anything you want, but the convention is
从技术上讲，你可以随意称呼它，但惯例是

2321
01:54:38,507 --> 01:54:41,020
argv and argc from right to left here.
从这里向右到左依次为argv和argc。

2322
01:54:41,020 --> 01:54:42,280
Just a guess, then.
仅仅猜测一下。

2323
01:54:42,280 --> 01:54:47,230
What if I change this to print out bracket 0 and recompile the code?
如果我将它更改为打印出方括号0并重新编译代码呢？

2324
01:54:47,230 --> 01:54:49,570
And I run ./greet David?
然后我运行./greet David？

2325
01:54:49,570 --> 01:54:51,790
What might it say instinctively?
它可能会本能地说些什么？

2326
01:54:54,490 --> 01:54:56,710
Any hunches?
有什么预感吗？

2327
01:54:56,710 --> 01:54:57,250
Yeah.
是的。

2328
01:54:57,250 --> 01:54:59,860
So it's going to say hello, ./greet.
所以它会说你好，./greet。

2329
01:54:59,860 --> 01:55:01,880
So it turns out, you get one for free.
所以，你免费得到一个。

2330
01:55:01,880 --> 01:55:04,450
Whatever the name of your program is always
无论你程序的名字是什么，它总是

2331
01:55:04,450 --> 01:55:07,420
accessible in argv at location 0.
可以在argv的位置0访问。

2332
01:55:07,420 --> 01:55:08,380
That's just because.
这只是因为。

2333
01:55:08,380 --> 01:55:09,340
It's a handy feature.
这是一个方便的功能。

2334
01:55:09,340 --> 01:55:12,548
In case there's an error or you need to tell the user how to use the program,
如果出现错误或需要告诉用户如何使用程序，

2335
01:55:12,548 --> 01:55:15,970
you know what the command is that they ran, but at location 1,
你知道他们运行的是什么命令，但在位置 1，

2336
01:55:15,970 --> 01:55:18,610
maybe 2, maybe 3 are the additional words
可能还有 2、3 个额外的单词

2337
01:55:18,610 --> 01:55:20,590
that the human might have typed in.
是用户可能输入的。

2338
01:55:20,590 --> 01:55:23,140
Well, let's do something a little smarter than this.
好吧，让我们做点比这更聪明的事。

2339
01:55:23,140 --> 01:55:25,420
Let me go back to version 1.
让我回到版本 1。

2340
01:55:25,420 --> 01:55:27,610
Let me recompile it, make greet.
让我重新编译它，生成 greet。

2341
01:55:27,610 --> 01:55:31,930
Let me rerun ./greet David, and this seems to work fine.
让我重新运行 ./greet David，这似乎工作正常。

2342
01:55:31,930 --> 01:55:35,080
What if I get a little curious and print out location 2?
如果我有点好奇，并打印出位置 2 呢？

2343
01:55:35,080 --> 01:55:41,530
Let me recompile the code, make greet ./greet David, Enter, OK, there's null.
让我重新编译代码，生成 greet，./greet David，Enter，OK，出现了 null。

2344
01:55:41,530 --> 01:55:45,580
And I mentioned we'd see N-U-L-L, and here's one incarnation thereof,
我提到我们会看到 N-U-L-L，这里就是其中一个体现，

2345
01:55:45,580 --> 01:55:47,270
but this is clearly wrong.
但这显然是错误的。

2346
01:55:47,270 --> 01:55:49,990
So I probably don't want to even let the user do this because I
所以，我可能甚至不想让用户这样做，因为我

2347
01:55:49,990 --> 01:55:51,490
don't want them to see bogus output.
不想让他们看到错误的输出。

2348
01:55:51,490 --> 01:55:53,680
Like this is arguably the a bug in the code
就像这可以说是代码中的一个 bug

2349
01:55:53,680 --> 01:55:58,420
that it even bothered to show this by default. So what could I do instead?
它甚至默认显示了这一点。那么我该怎么办呢？

2350
01:55:58,420 --> 01:55:59,420
Well, what if I do this?
好吧，如果我这样做呢？

2351
01:55:59,420 --> 01:56:07,490
If argc equals equals 2, then go ahead and comfortably
如果 argc 等于 2，那么继续并轻松地

2352
01:56:07,490 --> 01:56:11,120
say printf "hello," argv, bracket, 1.
说 printf "hello," argv，方括号，1。

2353
01:56:11,120 --> 01:56:15,620
Else, if the human did not give exactly two arguments at the prompt,
否则，如果用户在提示符处没有给出恰好两个参数，

2354
01:56:15,620 --> 01:56:18,590
let's just print out some default value like "hello, world"
让我们只打印出一些默认值，例如 "hello, world"

2355
01:56:18,590 --> 01:56:20,040
like from last week.
就像上周一样。

2356
01:56:20,040 --> 01:56:23,540
In other words now I'm doing this error checking with a conditional,
换句话说，我现在正在用条件语句进行错误检查，

2357
01:56:23,540 --> 01:56:25,790
making sure with this Boolean expression only
确保只有使用这个布尔表达式

2358
01:56:25,790 --> 01:56:29,990
if argc equals equals 2, and therefore has two words in argv
如果 argc 等于 2，因此 argv 中有两个单词

2359
01:56:29,990 --> 01:56:31,410
do you want to proceed.
你想继续吗？

2360
01:56:31,410 --> 01:56:35,700
And so now if I do make greet again, ./greet David, this now works.
所以，如果我再次生成 greet，./greet David，它现在可以工作了。

2361
01:56:35,700 --> 01:56:40,460
But if I don't cooperate and I just run greet, what should it say?
但如果我不配合，只运行 greet，它应该说什么呢？

2362
01:56:40,460 --> 01:56:41,690
Just hello, world.
就说 hello, world。

2363
01:56:41,690 --> 01:56:46,280
If I run David Malan as two words, what should it say?
如果我将 David Malan 作为两个单词运行，它应该说什么呢？

2364
01:56:46,280 --> 01:56:49,880
hello, world, because that's not exactly equal to 2.
hello, world，因为这并不完全等于 2。

2365
01:56:49,880 --> 01:56:52,910
Again, the first word in argv is always the program's name.
再说一次，argv 中的第一个词总是程序名。

2366
01:56:52,910 --> 01:56:56,480
The second word is whatever the human, then, has typed.
第二个词就是用户当时输入的任何内容。

2367
01:56:56,480 --> 01:56:59,750
Now if we don't even know in advance how many words they're going to be,
现在，如果我们事先甚至不知道会有多少个单词，

2368
01:56:59,750 --> 01:57:01,190
we can combine today's ideas.
我们可以将今天的想法结合起来。

2369
01:57:01,190 --> 01:57:04,190
This is going to look a little weird, but it's the same thing as before.
这看起来会有点奇怪，但它和以前是一样的。

2370
01:57:04,190 --> 01:57:09,920
for int i gets 0, i is less than--
对于 int i 获取 0，i 小于--

2371
01:57:09,920 --> 01:57:13,010
how about argc i++?
argc i++ 怎么样？

2372
01:57:13,010 --> 01:57:19,430
And then inside of this loop, I can print out %s, maybe backslash n, comma,
然后在这个循环内部，我可以打印出 %s，可能是反斜杠 n，逗号，

2373
01:57:19,430 --> 01:57:23,660
and then print out argv, bracket, i.
然后打印出 argv，方括号，i。

2374
01:57:23,660 --> 01:57:27,840
So I can have a loop that iterates argc number of times,
所以，我可以创建一个循环，循环 argc 次，

2375
01:57:27,840 --> 01:57:29,660
once for every word at the prompt.
每次循环都对应一个提示符处的单词。

2376
01:57:29,660 --> 01:57:34,700
I can print out argv, bracket, i, which is the i-th word in that array
我可以打印出 argv，方括号，i，它是该数组中的第 i 个词

2377
01:57:34,700 --> 01:57:35,730
from left to right.
从左到右。

2378
01:57:35,730 --> 01:57:40,700
And so if I now run make greet and I do ./greet alone,
所以，如果我现在运行 make greet，并且我单独运行 ./greet，

2379
01:57:40,700 --> 01:57:42,080
I just see the program's name.
我只是看到了程序的名字。

2380
01:57:42,080 --> 01:57:47,010
If I do ./greet David, I see, those two, one after the other.
如果我运行 `./greet David`，你会看到这两个词，一个接一个地显示。

2381
01:57:47,010 --> 01:57:50,350
If I do David Malan, I get those three words.
如果我运行 `David Malan`，我会得到这三个单词。

2382
01:57:50,350 --> 01:57:52,540
If I keep going, I'll get more and more words.
如果我继续下去，我会得到越来越多的单词。

2383
01:57:52,540 --> 01:57:56,040
So using just the length of the array and the name of the array,
所以，仅使用数组的长度和数组的名称，

2384
01:57:56,040 --> 01:57:58,493
I can actually do quite a bit there.
我实际上可以做很多事情。

2385
01:57:58,493 --> 01:58:00,910
Now there's actually some fun things you can do with this,
现在，你实际上可以用这个做一些有趣的事情，

2386
01:58:00,910 --> 01:58:02,340
and this is sort of beside the point, but there's
这有点偏题，但它存在于

2387
01:58:02,340 --> 01:58:04,298
this thing in the world called ASCII art, which
世界上一个叫做 ASCII 艺术的东西，它

2388
01:58:04,298 --> 01:58:07,290
is making pictures and beautiful things just using ASCII or maybe
是用 ASCII 或现在的 Unicode 字符来制作图片和美丽的事物，但它不使用表情符号。

2389
01:58:07,290 --> 01:58:09,990
nowadays Unicode characters, but without using emoji.
现在 Unicode 字符，但没有使用 emoji。

2390
01:58:09,990 --> 01:58:12,300
Like emoji kind of make this a little too easy.
就像表情符号让这个变得太容易了。

2391
01:58:12,300 --> 01:58:15,480
But if all you have are traditional largely English letters
但是，如果你只有传统的英语字母

2392
01:58:15,480 --> 01:58:18,540
and punctuation, you can actually do some interesting things.
和标点符号，你实际上可以做一些有趣的事情。

2393
01:58:18,540 --> 01:58:21,910
On Linux systems-- for instance, if I go back to VS Code here,
在 Linux 系统上——例如，如果我回到 VS Code 这里，

2394
01:58:21,910 --> 01:58:25,835
let me increase the size of my terminal window here.
让我增加一下终端窗口的大小。

2395
01:58:25,835 --> 01:58:27,960
And it turns out that we've pre-installed-- really,
事实证明，我们已经预安装了——确实，

2396
01:58:27,960 --> 01:58:32,010
for no compelling reason, but just for fun, a program called cowsay,
出于没有强有力的理由，只是为了好玩，一个叫做 `cowsay` 的程序，

2397
01:58:32,010 --> 01:58:34,000
which has a cow say something.
它让一头牛说一些话。

2398
01:58:34,000 --> 01:58:37,920
So if I want to have a cow say "moo" in ASCII art, I can do this,
所以，如果我想让一头牛用 ASCII 艺术说 “moo”，我可以这样做，

2399
01:58:37,920 --> 01:58:41,310
and you get an adorable cow saying something like "moo" on the screen.
你会看到一头可爱的牛在屏幕上说着像 “moo” 之类的话。

2400
01:58:41,310 --> 01:58:43,680
But moo is a command line argument that is clearly
但是 `moo` 是一个命令行参数，很明显

2401
01:58:43,680 --> 01:58:46,590
modifying the output of this program because I could also
修改了这个程序的输出，因为我也可以

2402
01:58:46,590 --> 01:58:49,350
change it to say hello, comma, world, and now the cow
把它改成说 “hello, world”，现在这头牛

2403
01:58:49,350 --> 01:58:50,980
is going to say that instead.
会说这句话了。

2404
01:58:50,980 --> 01:58:53,460
So it takes multiple command line arguments, if you will.
所以，它接受多个命令行参数，如果你愿意的话。

2405
01:58:53,460 --> 01:58:58,350
But it also takes what are called flags or switches whereby any command line
但它也接受所谓的标志或开关，任何以短横线开头的命令行

2406
01:58:58,350 --> 01:59:01,740
argument that starts with a dash is usually like a special configuration
参数通常就像一个特殊的配置

2407
01:59:01,740 --> 01:59:04,860
option that you would only know exists by reading the documentation
选项，你只有通过阅读文档才能知道它的存在

2408
01:59:04,860 --> 01:59:06,300
or seeing a demonstration.
或观看演示。

2409
01:59:06,300 --> 01:59:12,780
And if I have my syntax right, if I do cowsay -f, and maybe I'll do--
如果我的语法正确，如果我运行 `cowsay -f`，也许我会做——

2410
01:59:12,780 --> 01:59:13,620
let's see.
让我们看看。

2411
01:59:13,620 --> 01:59:18,660
Instead of this cow say, how about I'll do -f for file,
而不是这只牛，我试试用 `-f` 代表文件，

2412
01:59:18,660 --> 01:59:20,460
and I'm going to change it into duck mode.
我要把它改成鸭子模式。

2413
01:59:20,460 --> 01:59:23,730
And I'm going to have this version of the ASCII art say quack.
我让这个版本的 ASCII 艺术说 "quack"。

2414
01:59:23,730 --> 01:59:26,255
So it's a tiny little duck there, but it's saying quack.
这是一个小小的鸭子，但它在说 "quack"。

2415
01:59:26,255 --> 01:59:28,380
And you can kind of waste a lot of time doing this.
你可以花很多时间做这个。

2416
01:59:28,380 --> 01:59:33,690
I can do cowsay -f dragon and say something like, RAWR,
我可以运行 `cowsay -f dragon` 并说一些像 “RAWR” 之类的话，

2417
01:59:33,690 --> 01:59:36,420
and this is just amazing.
这太棒了。

2418
01:59:36,420 --> 01:59:38,440
Again, not really academically compelling,
再次强调，这在学术上并不引人注目，

2419
01:59:38,440 --> 01:59:41,880
but it does demonstrate, again, command line arguments, which are everywhere,
但它再次证明了命令行参数，它们无处不在，

2420
01:59:41,880 --> 01:59:44,220
and you've indeed been using them already.
而你确实已经在使用它们了。

2421
01:59:44,220 --> 01:59:46,830
But there's one other feature we wanted to introduce you
但我们想向你介绍另一个功能，

2422
01:59:46,830 --> 01:59:50,610
to today, which will be a useful building block, which will also
在今天，它将是一个有用的构建块，它也将

2423
01:59:50,610 --> 01:59:54,090
reveal one other thing about the code that we've been writing.
揭示关于我们一直在编写的代码的另一件事。

2424
01:59:54,090 --> 01:59:58,110
It turns out that all of the programs we've been writing thus far, eventually
事实证明，到目前为止，我们编写的所有程序最终

2425
01:59:58,110 --> 02:00:00,210
obviously exit because you see your prompt again
都会退出，因为您会再次看到您的提示

2426
02:00:00,210 --> 02:00:02,680
unless you have an infinite loop such that it never ends.
除非您有一个无限循环，这样它永远不会结束。

2427
02:00:02,680 --> 02:00:03,870
But eventually they exit.
但最终它们都会退出。

2428
02:00:03,870 --> 02:00:07,560
And secretly, every program we've written thus far actually
而且实际上，到目前为止，我们编写的每个程序

2429
02:00:07,560 --> 02:00:09,240
has what's called an exit status.
都有一个所谓的退出状态。

2430
02:00:09,240 --> 02:00:11,730
It's like a special return value from the program
它就像程序的一个特殊返回值

2431
02:00:11,730 --> 02:00:14,310
itself that by default is always 0.
本身，默认情况下始终为 0。

2432
02:00:14,310 --> 02:00:17,590
0 as a number in the world generally means everything's OK.
在世界上，0 作为一个数字通常意味着一切正常。

2433
02:00:17,590 --> 02:00:21,240
The flip side of that is because the world tends to use integers
另一方面，这是因为世界倾向于使用整数

2434
02:00:21,240 --> 02:00:23,460
and you've got four billion possibilities,
而你有 40 亿种可能性，

2435
02:00:23,460 --> 02:00:27,000
like every other number in the world when it comes to our program's exit
就像世界上所有其他数字一样，当谈到我们程序的退出时

2436
02:00:27,000 --> 02:00:29,070
status is bad.
状态就不好。

2437
02:00:29,070 --> 02:00:30,750
If it's 1, it's probably bad.
如果它是 1，它可能就不好了。

2438
02:00:30,750 --> 02:00:32,095
If it's negative 1, it's bad.
如果它是负 1，它就不好。

2439
02:00:32,095 --> 02:00:34,470
And in fact, you've probably seen this in the real world.
事实上，您可能在现实世界中见过这种情况。

2440
02:00:34,470 --> 02:00:37,580
If you've ever had like a random error message on the screen--
如果您曾经在屏幕上看到过随机错误消息——

2441
02:00:37,580 --> 02:00:39,330
here's a screenshot of Zoom, for instance.
例如，这里是一张 Zoom 的截图。

2442
02:00:39,330 --> 02:00:43,920
And that screenshot, somewhat confusingly or unknowingly,
而且那张截图，有点令人困惑或不知情，

2443
02:00:43,920 --> 02:00:47,730
has an error code like 1132, that probably
有一个错误代码，比如 1132，这可能

2444
02:00:47,730 --> 02:00:52,500
means that the Zoom software that some other humans wrote incorrectly somehow
意味着 Zoom 软件，其他一些人类错误地编写了它，以某种方式

2445
02:00:52,500 --> 02:00:58,410
had an error and it did not exit with status 0, it exited with status 1132.
出现了错误，它没有以状态 0 退出，而是以状态 1132 退出。

2446
02:00:58,410 --> 02:01:00,480
And somewhere at Zoom, there's probably a file
在 Zoom 的某个地方，可能有一个文件

2447
02:01:00,480 --> 02:01:04,283
or a book that tells the programmers what this error code actually means.
或一本书告诉程序员这个错误代码的实际含义。

2448
02:01:04,283 --> 02:01:05,700
This is not useful for you and me.
这对您和我来说没有用。

2449
02:01:05,700 --> 02:01:08,158
There's some programmer at Zoom who would probably be like,
Zoom 的某个程序员可能会说，

2450
02:01:08,158 --> 02:01:10,950
oh, I know what I did or my colleague did wrong in this case.
哦，我知道我或我的同事在这种情况下做错了什么。

2451
02:01:10,950 --> 02:01:13,950
You've seen this elsewhere even though this is not quite the same thing,
您在其他地方见过这种情况，即使它并不完全相同，

2452
02:01:13,950 --> 02:01:15,658
but we'll talk about this in a few weeks.
但我们将在几周后讨论这个问题。

2453
02:01:15,658 --> 02:01:19,380
If you've ever seen 404, like numbers are everywhere, and on the web,
如果您曾经见过 404，就像数字无处不在，在网上，

2454
02:01:19,380 --> 02:01:23,070
404 means like file not found.
404 代表文件未找到。

2455
02:01:23,070 --> 02:01:26,830
It means you made a typo, the web server deleted a file, or something like that,
这意味着您输入错误，Web 服务器删除了文件，或者类似的事情，

2456
02:01:26,830 --> 02:01:30,850
but this is just to say numbers are so often used to signify or represent
但这只是为了说数字经常被用来表示或代表

2457
02:01:30,850 --> 02:01:31,350
errors.
错误。

2458
02:01:31,350 --> 02:01:33,600
Even though that's not an exit status, per se,
即使它本身不是退出状态，

2459
02:01:33,600 --> 02:01:36,750
that's an HTTP status code, which we'll soon see.
那是 HTTP 状态码，我们很快就会看到。

2460
02:01:36,750 --> 02:01:40,590
But you have access to exit statuses as it relates
但您已经可以访问退出状态，因为它与

2461
02:01:40,590 --> 02:01:42,630
to command line software already.
命令行软件相关。

2462
02:01:42,630 --> 02:01:46,250
Up until now, this is how we've been writing main, now
到目前为止，这就是我们一直编写 main 的方式，现在

2463
02:01:46,250 --> 02:01:48,740
with command line arguments, but we've also
使用命令行参数，但我们也

2464
02:01:48,740 --> 02:01:51,770
been writing main with an int return value.
一直在使用 int 返回值编写 main。

2465
02:01:51,770 --> 02:01:54,620
And you've never used this-- we didn't talk about this last week.
而且您从未使用过它——我们上周没有谈论过这个。

2466
02:01:54,620 --> 02:01:57,740
I just ask that you trust me and just keep copying and pasting this.
我只是要求您相信我，并继续复制和粘贴这个。

2467
02:01:57,740 --> 02:02:00,590
But that int means that even your programs
但是 int 意味着即使您的程序

2468
02:02:00,590 --> 02:02:05,660
can return values which can be useful even if you don't use command line
可以返回值，即使您不使用命令行，这些返回值也很有用

2469
02:02:05,660 --> 02:02:08,870
arguments and we just go back to the original version like void.
参数，我们只是回到原始版本，比如 void。

2470
02:02:08,870 --> 02:02:15,320
So for instance, if I go ahead and open up, for instance, VS Code again,
例如，如果我继续打开 VS Code，

2471
02:02:15,320 --> 02:02:16,670
I'll get rid of the dragon.
我会去掉这条龙。

2472
02:02:16,670 --> 02:02:19,460
And let's do one other program here called status just
让我们在这里做另一个程序，叫做 status，

2473
02:02:19,460 --> 02:02:23,450
to play around with the idea of these so-called exit statuses.
来试着玩玩这些所谓的退出状态。

2474
02:02:23,450 --> 02:02:28,370
Let me just demonstrate the idea with an include cs50.h, include
让我用 include cs50.h 来演示这个概念，

2475
02:02:28,370 --> 02:02:36,440
stdio.h, int main, and here I'll do int argc, string argv.
stdio.h，int main，在这里我会写 int argc，string argv。

2476
02:02:36,440 --> 02:02:39,080
And then inside of main, let's do a similar program
然后在 main 内部，让我们做一个类似的程序，

2477
02:02:39,080 --> 02:02:40,430
to before like the hello, world.
和之前的 hello world 一样。

2478
02:02:40,430 --> 02:02:44,540
So printf "hello," comma, %s backslash n.
所以 printf "hello," 逗号，%s 反斜杠 n。

2479
02:02:44,540 --> 02:02:47,010
Then let's print out argv 1.
然后让我们打印出 argv 1。

2480
02:02:47,010 --> 02:02:52,300
But I only want to execute that line if the human gave me a command line
但我只想在用户给了我一个命令行的时候执行那行代码。

2481
02:02:52,300 --> 02:02:52,800
argument.
参数。

2482
02:02:52,800 --> 02:02:55,550
Otherwise I don't want to even say some default like hello, world.
否则，我甚至不想说一些默认值，比如 hello world。

2483
02:02:55,550 --> 02:03:00,250
I just want to abort early and just exit the program, no output whatsoever.
我只想尽早终止并退出程序，没有任何输出。

2484
02:03:00,250 --> 02:03:01,350
So I could do this.
所以我可以这样做。

2485
02:03:01,350 --> 02:03:05,523
If argc does not equal 2--
如果 argc 不等于 2 - -

2486
02:03:05,523 --> 02:03:08,190
and it's a single equals, but it's a bang, an exclamation point,
它是一个单一的等于号，但它是一个感叹号，

2487
02:03:08,190 --> 02:03:09,370
means not equal.
表示不等于。

2488
02:03:09,370 --> 02:03:11,580
So this is the opposite of equals equals.
所以这是等于等于的反面。

2489
02:03:11,580 --> 02:03:14,730
Then previously I would have just printed hello, world,
然后我之前会直接打印 hello world，

2490
02:03:14,730 --> 02:03:16,830
but now I want to print out an error message
但现在我想打印一个错误信息，

2491
02:03:16,830 --> 02:03:21,210
like, "Missing command-line argument" just to explain to the user
比如 "缺少命令行参数"，只是为了向用户解释

2492
02:03:21,210 --> 02:03:26,520
why the program is about to terminate, and then I can return 1.
为什么程序要终止，然后我可以返回 1。

2493
02:03:26,520 --> 02:03:27,750
It's kind of arbitrary.
这有点随意。

2494
02:03:27,750 --> 02:03:30,700
I could also return 1132, but why start there?
我也可以返回 1132，但为什么要从那里开始？

2495
02:03:30,700 --> 02:03:34,180
This is the only possible error that could go wrong in my program.
这是我的程序中唯一可能出错的地方。

2496
02:03:34,180 --> 02:03:35,490
So I'm going to start at 1.
所以我将从 1 开始。

2497
02:03:35,490 --> 02:03:39,150
Zoom clearly has 1,000-plus possible things that can go wrong
Zoom 显然有 1000 多种可能出错的地方

2498
02:03:39,150 --> 02:03:42,660
in their source code, which is why the number got as big as 1132,
在他们的源代码中，这就是数字为什么变得如此大的原因，

2499
02:03:42,660 --> 02:03:45,990
but I'm just going to arbitrarily, but conventionally return 1.
但我只是随意地，但传统上返回 1。

2500
02:03:45,990 --> 02:03:52,110
But if everything is OK and I do-- it is not the case that argc does not equal 2
但如果一切正常，而且我确实 - - argc 不等于 2 并非如此

2501
02:03:52,110 --> 02:03:57,360
and I actually get to line 11, I'm going to return 0 because 0, again, I claim,
而我实际上到了第 11 行，我会返回 0，因为 0，我再说一次，

2502
02:03:57,360 --> 02:03:59,190
signifies success.
表示成功。

2503
02:03:59,190 --> 02:04:03,120
And all of this time, every program we've written-- you've written
而且一直以来，我们编写的每个程序 - - 你编写的每个程序

2504
02:04:03,120 --> 02:04:07,558
has secretly exited with 0 by default. But now
默认情况下，它都悄悄地退出了，返回 0。但现在

2505
02:04:07,558 --> 02:04:09,600
that our programs are getting more sophisticated,
我们的程序越来越复杂了，

2506
02:04:09,600 --> 02:04:11,700
when something goes wrong, it turns out it's
当发生错误时，事实证明，

2507
02:04:11,700 --> 02:04:15,085
useful to have the power to just return some other value even
能够返回其他值是有用的，即使

2508
02:04:15,085 --> 02:04:16,710
though the user is not going to see it.
用户不会看到它。

2509
02:04:16,710 --> 02:04:19,620
Even though the Zoom user shouldn't see it, it's still there.
即使 Zoom 用户不应该看到它，它仍然在那里。

2510
02:04:19,620 --> 02:04:22,380
It's diagnostically useful to you, or in the case of a class,
这对你有诊断意义，或者在课堂上，

2511
02:04:22,380 --> 02:04:24,660
to your TF or TA or CA.
对你指导老师、助教或助教来说。

2512
02:04:24,660 --> 02:04:30,930
So if I do make status now to compile this program and run ./status and type
所以如果我现在用 make status 来编译这个程序，然后运行 ./status 并且输入

2513
02:04:30,930 --> 02:04:33,340
my first name I think this is a success.
我的名字，我认为这是成功的。

2514
02:04:33,340 --> 02:04:37,290
It should say hello, David and secretly exit with 0.
它应该说 hello，David，并秘密地退出，返回 0。

2515
02:04:37,290 --> 02:04:41,820
If you really want to see the 0, there's this arcane command you can type.
如果你真的想看到 0，有一个神秘的命令你可以输入。

2516
02:04:41,820 --> 02:04:45,780
You can literally type at your prompt echo $?.
你可以直接在你的提示符中输入 echo $?。

2517
02:04:45,780 --> 02:04:48,810
It's weird symbology, but it's what the humans chose decades ago.
这是一个奇怪的符号，但这是人类几十年前选择使用的。

2518
02:04:48,810 --> 02:04:53,460
This will just show you what did the most recently-run program secretly exit
这只会显示最近运行的程序秘密退出的状态。

2519
02:04:53,460 --> 02:04:54,010
with.
状态。

2520
02:04:54,010 --> 02:04:58,560
So if I do this in VS Code, I can do exit $?, Enter,
所以如果我在 VS Code 中这样做，我可以输入 exit $?，然后回车，

2521
02:04:58,560 --> 02:04:59,982
and there's that secret 0.
就会显示那个秘密的 0。

2522
02:04:59,982 --> 02:05:02,190
I could have been doing this week and last week, it's
我可能这周和上周都在这样做，这

2523
02:05:02,190 --> 02:05:03,330
just not that interesting.
没什么意思。

2524
02:05:03,330 --> 02:05:08,340
But it is interesting, or at least marginally so, if I rerun status
但如果我重新运行 status，这很有趣，或者至少有点意思，

2525
02:05:08,340 --> 02:05:12,060
and maybe I don't provide a command line argument or I provide too many.
并且也许我没有提供命令行参数，或者我提供了太多。

2526
02:05:12,060 --> 02:05:14,340
So argc does not equal 2.
所以 argc 不等于 2。

2527
02:05:14,340 --> 02:05:17,520
And I hit Enter, I get yelled at with the error message,
然后我按回车，我收到了错误消息，

2528
02:05:17,520 --> 02:05:21,300
but I can see the secret status code, which is, indeed, 1.
但我可以看到秘密的状态码，它确实是 1。

2529
02:05:21,300 --> 02:05:24,340
And so now if you're ever in the habit in either a class like this
所以现在如果你在像这样的课程中，或者在现实世界中，你自动测试你的代码，

2530
02:05:24,340 --> 02:05:27,090
or in the real world where you're automatically testing your code,
在现实世界中你自动测试你的代码，

2531
02:05:27,090 --> 02:05:29,340
be it with check50 or in the real world, things called
无论是用 check50 还是在现实世界中，称为

2532
02:05:29,340 --> 02:05:31,590
unit tests and other third-party software,
单元测试和其他第三方软件，

2533
02:05:31,590 --> 02:05:36,150
those tests can actually detect these status code-- exit statuses
这些测试实际上可以检测这些状态码 - 退出状态

2534
02:05:36,150 --> 02:05:39,943
and know that your code succeed or fail, 0 or 1.
并且知道你的代码成功还是失败，0 或 1。

2535
02:05:39,943 --> 02:05:42,360
And if there's different types of failures it can detect--
如果存在不同类型的错误，它可以检测到 -

2536
02:05:42,360 --> 02:05:48,630
status 2, status 3, status 1132, it's just one other tool in your toolkit.
状态 2，状态 3，状态 1132，它只是你的工具包中的另一个工具。

2537
02:05:48,630 --> 02:05:51,240
But all of that is terribly low level, and really,
但所有这些都非常底层，实际上，

2538
02:05:51,240 --> 02:05:54,900
the goal of this week-- and really, today, and really, code more generally,
本周的目标 - 实际上，今天，以及更广泛地来说，代码

2539
02:05:54,900 --> 02:05:55,990
is to solve problems.
是为了解决问题。

2540
02:05:55,990 --> 02:05:58,380
So let's consider an increasingly important one, which
所以让我们考虑一个越来越重要的问题，即

2541
02:05:58,380 --> 02:06:01,650
is the ability to send information securely,
安全发送信息的能力，

2542
02:06:01,650 --> 02:06:04,980
whether it is in file format, wirelessly, or any other.
无论是文件格式、无线还是其他方式。

2543
02:06:04,980 --> 02:06:08,640
Cryptography is the art and the science of encrypting.
密码学是加密的艺术和科学。

2544
02:06:08,640 --> 02:06:09,930
Scrambling information.
对信息进行混淆。

2545
02:06:09,930 --> 02:06:12,510
So that even if I write a secret message to you
所以即使我写了一封秘密信息给你

2546
02:06:12,510 --> 02:06:16,350
and I send it through this open audience with so many nosey eyes
并且我通过这个开放的公众发送它，那里有那么多窥探的眼睛

2547
02:06:16,350 --> 02:06:19,890
who could look at the message, if I've encrypted this message, none of them
谁都可能看到这条消息，如果我对这条消息进行了加密，他们中的任何人都

2548
02:06:19,890 --> 02:06:22,800
should be able to read it, only you, whoever you are,
无法阅读它，只有你，无论你是谁，

2549
02:06:22,800 --> 02:06:24,900
to whom I intended that message.
我打算把这条信息发给你。

2550
02:06:24,900 --> 02:06:27,030
In the world of cryptography, then encryption
在密码学领域，加密

2551
02:06:27,030 --> 02:06:30,210
means scrambling the information so that only you and the recipient
意味着对信息进行混淆，这样只有你和接收者

2552
02:06:30,210 --> 02:06:31,060
can receive it.
可以接收它。

2553
02:06:31,060 --> 02:06:34,380
So if we consider our black box like in week 0 and 1,
所以如果我们考虑像第 0 周和第 1 周的黑盒一样，

2554
02:06:34,380 --> 02:06:36,030
here is the problem to be solved.
这里就是需要解决的问题。

2555
02:06:36,030 --> 02:06:38,910
And let me propose a couple of pieces of vocabulary.
让我提几个词汇。

2556
02:06:38,910 --> 02:06:42,420
Plaintext is any message written in English or any human language
明文是任何用英语或任何人类语言写成的

2557
02:06:42,420 --> 02:06:45,090
that you want to send and write yourself.
你想发送并自己写的消息。

2558
02:06:45,090 --> 02:06:47,150
Ciphertext is what you want to convert it
密文是你想要转换它的内容

2559
02:06:47,150 --> 02:06:49,850
to before you just hand it off to a bunch of random strangers
在你把它交给一群随机的陌生人之前

2560
02:06:49,850 --> 02:06:52,220
in the audience or a bunch of servers on the internet,
在观众席上，或者互联网上的服务器，

2561
02:06:52,220 --> 02:06:54,432
any one of whom could look at your message.
他们中的任何一个人都可能看到你的消息。

2562
02:06:54,432 --> 02:06:56,390
So in the black box is what we're going to call
所以在这个黑盒子里，我们将称之为

2563
02:06:56,390 --> 02:07:02,000
a cipher, an algorithm for encrypting or scrambling information
一种密码，一种用于加密或混淆信息的算法

2564
02:07:02,000 --> 02:07:03,268
in a reversible way.
以可逆的方式。

2565
02:07:03,268 --> 02:07:05,810
It doesn't suffice to just scramble the information randomly,
仅仅随机地混淆信息是不够的，

2566
02:07:05,810 --> 02:07:07,980
otherwise the recipient can't do anything with it.
否则接收者就无法对其进行任何操作。

2567
02:07:07,980 --> 02:07:11,660
It's an algorithm, a cipher that encrypts it in such a way
它是一种算法，一种以这样一种方式对其进行加密的密码

2568
02:07:11,660 --> 02:07:13,280
that someone else can decrypt it.
其他人可以对其进行解密。

2569
02:07:13,280 --> 02:07:14,750
And here's a common way.
这里有一个常见的方法。

2570
02:07:14,750 --> 02:07:20,540
Most ciphers take as input not only the plaintext message in English
大多数密码不仅以英文形式的明文消息作为输入

2571
02:07:20,540 --> 02:07:22,700
or whatever else, but also a key.
或者其他任何东西，而且还需要一个密钥。

2572
02:07:22,700 --> 02:07:25,400
And it's metaphorically like a key to open a lock,
从比喻意义上来说，它就像一把打开锁的钥匙，

2573
02:07:25,400 --> 02:07:29,300
but it's technically generally a number, like a really big number made up
但在技术上，它通常是一个数字，就像一个由

2574
02:07:29,300 --> 02:07:30,170
of lots of bits.
许多位组成的非常大的数字。

2575
02:07:30,170 --> 02:07:35,330
And not even 32, not even 64, sometimes 1,024 bits, which is crazy
甚至不是32位，甚至不是64位，有时是1024位，这太疯狂了

2576
02:07:35,330 --> 02:07:37,610
unpronounceable large, but the probability
难以发音的巨大，但可能性

2577
02:07:37,610 --> 02:07:40,880
that someone is going to guess your key is just so, so small
有人猜到你的密钥的可能性非常、非常小

2578
02:07:40,880 --> 02:07:43,850
that for all intents and purposes, you are, in fact, secure.
因此，从所有意图和目的来看，你实际上是安全的。

2579
02:07:43,850 --> 02:07:46,020
So what's an example of this, for instance?
那么，举个例子，这是什么？

2580
02:07:46,020 --> 02:07:50,165
Suppose the secret message I want to send is innocuously just "HI!"
假设我想要发送的秘密消息只是无害的“HI！”。

2581
02:07:50,165 --> 02:07:52,790
Well, it'd be pretty stupid to write "HI!" on a piece of paper,
嗯，在纸上写下“HI！”是很愚蠢的，

2582
02:07:52,790 --> 02:07:54,707
hand it to someone in the audience, and expect
把它递给观众中的某个人，并期望

2583
02:07:54,707 --> 02:07:57,770
it to get all the way to the back without someone like glancing at it
它能一路传到后面，而不被人看到

2584
02:07:57,770 --> 02:08:00,510
and obviously seeing and reading the plaintext.
并显然看到并读出明文。

2585
02:08:00,510 --> 02:08:03,650
So what if I, though, agree with someone in back, for instance,
所以如果我和后面的人达成一致，例如，

2586
02:08:03,650 --> 02:08:05,570
that our secret is going to be 1?
我们的秘密将是1？

2587
02:08:05,570 --> 02:08:07,790
And we have to agree upon that secret in advance,
我们必须提前商定好这个秘密，

2588
02:08:07,790 --> 02:08:10,160
but 1 just means that is my key.
但1只是意味着这是我的密钥。

2589
02:08:10,160 --> 02:08:13,340
And let me propose that according to one popular cipher,
让我提议，根据一种流行的密码，

2590
02:08:13,340 --> 02:08:19,730
if I want to send "HI!", change the H to an I and the I to a J-- that is,
如果我想发送“HI！”，将H改为I，将I改为J，也就是说，

2591
02:08:19,730 --> 02:08:22,740
increment effectively every letter of the alphabet by one,
将字母表中的每个字母都增加1，

2592
02:08:22,740 --> 02:08:25,830
and if you get to a Z, wrap back around to A, for instance.
如果你到了Z，就绕回到A，例如。

2593
02:08:25,830 --> 02:08:28,790
So shift the alphabet by one place in this case
所以在这个例子中将字母表向后移一位

2594
02:08:28,790 --> 02:08:31,200
and send this message now instead.
然后现在发送这条消息。

2595
02:08:31,200 --> 02:08:32,510
So is that secure?
那么这样安全吗？

2596
02:08:32,510 --> 02:08:35,240
Well, if one of you kind of nosily looks at this sheet of paper,
嗯，如果你有人好奇地看看这张纸，

2597
02:08:35,240 --> 02:08:36,440
you won't see "HI!"
你不会看到“HI！”

2598
02:08:36,440 --> 02:08:39,240
You will see some information leak in this algorithm.
你将会看到这个算法中泄露了一些信息。

2599
02:08:39,240 --> 02:08:42,500
You'll see an exclamation point, so I'm enthusiastically saying something,
你会看到一个感叹号，所以我热情地说了一些东西，

2600
02:08:42,500 --> 02:08:46,710
but you won't know what the message is unless you decrypt it.
但你不会知道这条消息是什么，除非你进行解密。

2601
02:08:46,710 --> 02:08:50,720
Now that said, is this very secure, really, in practice?
也就是说，这在实践中真的非常安全吗？

2602
02:08:50,720 --> 02:08:51,950
I mean, not really.
我的意思是，不全是。

2603
02:08:51,950 --> 02:08:55,520
Like, if you know I'm just using a key and I'm using the English alphabet,
比如，如果你知道我只是在用一个密钥，并且在用英语字母表，

2604
02:08:55,520 --> 02:08:58,220
you could probably brute force your way to a solution
你可能会强行找出解决方法

2605
02:08:58,220 --> 02:09:01,520
by just trying 1, trying 2, trying 3, trying 25,
通过尝试1，尝试2，尝试3，尝试25，

2606
02:09:01,520 --> 02:09:03,740
go through all the possibilities tediously,
枯燥地尝试所有可能性，

2607
02:09:03,740 --> 02:09:05,660
but eventually it's probably going to pop out.
但最终它可能会被找到。

2608
02:09:05,660 --> 02:09:08,090
This is actually known, though, as the Caesar cipher.
不过，这实际上被称为凯撒密码。

2609
02:09:08,090 --> 02:09:12,080
And back in the day, before anyone else knew about or had invented encryption,
在很久以前，在其他人知道或发明加密之前，

2610
02:09:12,080 --> 02:09:15,260
Caesar, Julius Caesar, was known to use a cipher like this
凯撒大帝，也就是尤利乌斯·凯撒，以使用这种密码而闻名。

2611
02:09:15,260 --> 02:09:17,360
using a key of three, literally.
他使用了一个密钥，一个数字3。

2612
02:09:17,360 --> 02:09:20,780
And I guess it works OK if you're literally the first human in the world
我想，如果你真的是世界上第一个想到这个主意的人，那它应该还可以。

2613
02:09:20,780 --> 02:09:25,370
by lore to have thought of this idea, but of course, anyone who intercepts it
根据传说，但当然，任何截获它的人

2614
02:09:25,370 --> 02:09:29,330
could attack it nonetheless and figure things out a bit mathematically.
都可以破解它，并用数学方法进行解密。

2615
02:09:29,330 --> 02:09:31,140
13 is more common.
13 比较常见。

2616
02:09:31,140 --> 02:09:35,180
This is called ROT13 on the internet for rotate the letters of the alphabet 13.
这在网络上被称为 ROT13，代表将字母表中的字母旋转 13 位。

2617
02:09:35,180 --> 02:09:38,240
That changes "HI!" to "UV!"
它会将 "HI！" 变成 "UV！"

2618
02:09:38,240 --> 02:09:39,937
You might think what's better than 13?
你可能会想，什么比 13 更好呢？

2619
02:09:39,937 --> 02:09:41,270
Well, let's double the security.
嗯，让我们将安全性翻倍。

2620
02:09:41,270 --> 02:09:42,590
ROT26.
ROT26。

2621
02:09:42,590 --> 02:09:45,140
Why is this stupid?
为什么这是愚蠢的？

2622
02:09:45,140 --> 02:09:48,140
I mean, there's like 26 letters in the alphabet, so like A becomes A. So
我的意思是，字母表里有 26 个字母，所以 A 就变成了 A。因此，

2623
02:09:48,140 --> 02:09:49,730
that doesn't really help-- oh, wait.
这实际上没什么用处——哦，等等。

2624
02:09:49,730 --> 02:09:53,090
Oh, I'm pointing at something that's not on the screen, dammit.
哦，我在指向屏幕上没有的东西，该死。

2625
02:09:53,090 --> 02:09:58,190
Suppose the message is more lovingly, "I LOVE YOU," instead of just "HI!"
假设这条消息更甜蜜，是 "I LOVE YOU"，而不是仅仅 "HI！"

2626
02:09:58,190 --> 02:10:01,490
Same exact approach, whether or not there's punctuation, "I LOVE YOU,"
同样的方法，无论是否有标点符号，"I LOVE YOU"，

2627
02:10:01,490 --> 02:10:03,980
with an input of 13 might now become this.
输入 13 后，它可能会变成这样。

2628
02:10:03,980 --> 02:10:07,130
And now it's getting a little less obvious what the ciphertext actually
现在，密文实际上代表什么就不那么明显了。

2629
02:10:07,130 --> 02:10:07,970
represents.
代表什么。

2630
02:10:07,970 --> 02:10:10,550
And now, what's twice as secure is 13?
现在，什么比 13 安全两倍呢？

2631
02:10:10,550 --> 02:10:15,260
Well, 26 is surely better, but of course, if you rotate 26 places,
嗯，26 肯定更好，但当然，如果你旋转 26 个位置，

2632
02:10:15,260 --> 02:10:17,460
that, of course, just gives you the same thing.
那当然，你得到的还是相同的东西。

2633
02:10:17,460 --> 02:10:19,460
So there's a limit to this, but again, that just
所以，这有一定的局限性，但再次强调，这只是

2634
02:10:19,460 --> 02:10:22,770
speaks to the cipher being used, which is very simple.
说明所使用的密码非常简单。

2635
02:10:22,770 --> 02:10:26,417
There is much, much better, more sophisticated mathematical ciphers
有许多更好、更复杂的数学密码

2636
02:10:26,417 --> 02:10:27,000
that are used.
被使用。

2637
02:10:27,000 --> 02:10:29,660
We're just starting with something simple here.
我们只是从一个简单的例子开始。

2638
02:10:29,660 --> 02:10:34,910
As for decryption, if I'm using a key of 1, how do I reverse the process?
至于解密，如果我使用密钥 1，我如何逆转这个过程？

2639
02:10:34,910 --> 02:10:36,290
Yeah, so I just minus 1.
是的，我只需要减去 1。

2640
02:10:36,290 --> 02:10:41,510
So B becomes A, C becomes B, A becomes Z. And if it's 13,
所以 B 变成 A，C 变成 B，A 变成 Z。如果密钥是 13，

2641
02:10:41,510 --> 02:10:45,390
I subtract 13 instead or whatever the key is, so long as sender
我则减去 13，或者减去任何密钥的值，只要发送者

2642
02:10:45,390 --> 02:10:46,780
and receiver actually know it.
和接收者知道它就行了。

2643
02:10:46,780 --> 02:10:50,280
So in this case here, this is actually the message with which we began class.
因此，在这种情况下，这实际上是我们开始上课时所使用的消息。

2644
02:10:50,280 --> 02:10:53,730
If we have this message here and I used a key of 1 to encrypt it,
如果我们有这条消息，我用密钥 1 对它进行加密，

2645
02:10:53,730 --> 02:10:57,220
well, decrypting, it might involve doing something like this.
那么，解密可能需要做这样的事情。

2646
02:10:57,220 --> 02:11:00,278
Here's those same letters on the screen, and I think in a moment
这些相同的字母在屏幕上，我想过一会儿

2647
02:11:00,278 --> 02:11:02,070
before we adjourn, I'll mention too that we
在我们结束之前，我还想提一下，我们

2648
02:11:02,070 --> 02:11:04,230
might have encrypted a message in eight characters
可能用八个字符加密了一条消息。

2649
02:11:04,230 --> 02:11:06,360
this whole day, so if any of you took the time
在今天一整天，所以如果你有人花时间

2650
02:11:06,360 --> 02:11:08,660
and procrastinated and figured out what the light bulb spelled
拖延时间，并弄清楚灯泡拼写的是什么，

2651
02:11:08,660 --> 02:11:10,743
and they didn't seem to spell anything in English,
而且它们似乎没有拼出任何英语单词，

2652
02:11:10,743 --> 02:11:13,530
well, here now is the solution for cracking it.
那么，现在是破解它的方法。

2653
02:11:13,530 --> 02:11:16,500
This, if I subtract 1, becomes what?
如果我减去 1，它会变成什么？

2654
02:11:16,500 --> 02:11:22,007
U becomes T. And this is obviously-- see where we're going with this?
U 变成 T。很明显——你们明白我要说什么了吧？

2655
02:11:22,007 --> 02:11:25,090
And if we keep going, subtracting 1-- so indeed, we're at the end of class
如果我们继续减1，我们确实已经到了课程的结尾

2656
02:11:25,090 --> 02:11:26,930
now because this was CS50.
因为这是CS50

2657
02:11:26,930 --> 02:11:30,180
And the last thing we have to say is we have hundreds of ducks waiting for you
最后我们要说的是，我们有数百只鸭子在外面等着你

2658
02:11:30,180 --> 02:11:30,790
outside.
在外面

2659
02:11:30,790 --> 02:11:33,120
So on the way out, grab your own rubber duck.
所以出去的时候，抓一只你自己的橡皮鸭

2660
02:11:33,120 --> 02:11:34,320
[APPLAUSE]
[鼓掌]

2661
02:11:34,320 --> 02:11:37,970
[MUSIC PLAYING]
[音乐播放]
